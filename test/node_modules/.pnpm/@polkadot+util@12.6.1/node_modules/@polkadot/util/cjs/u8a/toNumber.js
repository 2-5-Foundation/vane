"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.u8aToNumber = void 0;
/**
 * @name u8aToNumber
 * @summary Creates a number from a Uint8Array object.
 */
function u8aToNumber(value, { isLe = true, isNegative = false } = {}) {
    // slice + reverse is expensive, however SCALE is LE by default so this is the path
    // we are most interested in (the BE is added for the sake of being comprehensive)
    if (!isLe) {
        value = value.slice().reverse();
    }
    const count = value.length;
    // When the value is a i{8, 16, 24, 32, 40, 40} values and the top-most bit
    // indicates a signed value, we use a two's complement conversion. If one of these
    // flags are not set, we just do a normal unsigned conversion (the same shortcut
    // applies in both the u8aTo{BigInt, Bn} conversions as well)
    if (isNegative && count && (value[count - 1] & 0x80)) {
        switch (count) {
            case 0:
                return 0;
            case 1:
                return (((value[0] ^ 255) * -1) - 1);
            case 2:
                return ((((value[0] + (value[1] << 8)) ^ 65535) * -1) - 1);
            case 3:
                return ((((value[0] + (value[1] << 8) + (value[2] << 16)) ^ 16777215) * -1) - 1);
            case 4:
                // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
                // 32-bit, in the case where the top-most bit is set this yields a negative value
                return ((((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) * -1) - 1);
            case 5:
                return (((((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + ((value[4] ^ 0xff) * 4294967296)) * -1) - 1);
            case 6:
                return (((((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + (((value[4] + (value[5] << 8)) ^ 65535) * 4294967296)) * -1) - 1);
            default:
                throw new Error('Value more than 48-bits cannot be reliably converted');
        }
    }
    switch (count) {
        case 0:
            return 0;
        case 1:
            return value[0];
        case 2:
            return value[0] + (value[1] << 8);
        case 3:
            return value[0] + (value[1] << 8) + (value[2] << 16);
        case 4:
            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
            // 32-bit, in the case where the top-most bit is set this yields a negative value
            return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216);
        case 5:
            return value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8)) * 16777216);
        case 6:
            return value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216);
        default:
            throw new Error('Value more than 48-bits cannot be reliably converted');
    }
}
exports.u8aToNumber = u8aToNumber;
