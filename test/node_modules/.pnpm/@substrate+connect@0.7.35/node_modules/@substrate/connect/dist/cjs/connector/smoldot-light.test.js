"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line import/no-extraneous-dependencies
const vitest_1 = require("vitest");
const WellKnownChain_1 = require("../WellKnownChain");
class SdAlreadyDestroyedError extends Error {
    constructor() {
        super();
        this.name = "AlreadyDestroyedError";
    }
}
class SdCrashError extends Error {
    constructor(message) {
        super(message);
        this.name = "CrashError";
    }
}
class SdJsonRpcDisabledError extends Error {
    constructor() {
        super();
        this.name = "JsonRpcDisabledError";
    }
}
class SdMalformedJsonRpcError extends Error {
    constructor() {
        super();
        this.name = "MalformedJsonRpcError";
    }
}
class SdQueueFullError extends Error {
    constructor() {
        super();
        this.name = "QueueFullError";
    }
}
const mockSmoldotLightFactory = () => {
    const start = (options) => {
        const addChain = (addChainOptions, isClientTerminated) => {
            let _remove = vitest_1.vi.fn();
            let _sendJsonRpc = vitest_1.vi.fn();
            return {
                _addChainOptions: addChainOptions,
                remove() {
                    if (isClientTerminated())
                        throw new SdAlreadyDestroyedError();
                    _remove();
                },
                _setRemove(nextRemove) {
                    _remove = nextRemove;
                },
                _getSendRemove: () => _remove,
                sendJsonRpc(rpc) {
                    if (isClientTerminated())
                        throw new SdAlreadyDestroyedError();
                    _sendJsonRpc(rpc);
                },
                _setSendJsonRpc(nextSendJsonRpc) {
                    _sendJsonRpc = nextSendJsonRpc;
                },
                _getSendJsonRpc: () => _sendJsonRpc,
            };
        };
        const chains = [];
        const terminate = vitest_1.vi.fn();
        return {
            _options: options,
            _getChains: () => chains,
            _getLatestChain: () => chains === null || chains === void 0 ? void 0 : chains[chains.length - 1],
            terminate,
            addChain: (addChainOptions) => {
                const chain = addChain(addChainOptions, () => terminate.mock.calls.length > 0);
                chains.push(chain);
                return Promise.resolve(chain);
            },
        };
    };
    let latestClient;
    const mock = {
        AlreadyDestroyedError: SdAlreadyDestroyedError,
        CrashError: SdCrashError,
        JsonRpcDisabledError: SdJsonRpcDisabledError,
        MalformedJsonRpcError: SdMalformedJsonRpcError,
        QueueFullError: SdQueueFullError,
        start: (options) => {
            return (latestClient = start(options));
        },
        getLatestClient: () => latestClient,
    };
    return mock;
};
vitest_1.vi.doMock("smoldot", mockSmoldotLightFactory);
vitest_1.vi.doMock("./specs/index.js", () => ({
    getSpec: (wellKnownChain) => `fake-${wellKnownChain}-spec`,
}));
let mockedSmoldotLight;
(0, vitest_1.beforeAll)(() => __awaiter(void 0, void 0, void 0, function* () {
    mockedSmoldotLight = mockSmoldotLightFactory;
}));
(0, vitest_1.beforeEach)(() => {
    vitest_1.vi.resetModules();
});
(0, vitest_1.describe)("SmoldotConnect::smoldot", () => {
    (0, vitest_1.describe)("client", () => {
        (0, vitest_1.it)("does not eagerly instantiate the client", () => {
            Promise.resolve().then(() => __importStar(require("./smoldot-light"))).then((smoldot) => {
                smoldot.createScClient();
                mockedSmoldotLight =
                    mockSmoldotLightFactory;
                (0, vitest_1.expect)(mockedSmoldotLight.start).toBeUndefined();
            });
        });
        (0, vitest_1.it)("terminates the internal client when all the chains, from all clients, have been removed", () => {
            Promise.resolve().then(() => __importStar(require("./smoldot-light"))).then((smoldot) => __awaiter(void 0, void 0, void 0, function* () {
                const { addWellKnownChain, addChain } = smoldot.createScClient();
                let chain1 = yield addWellKnownChain("");
                const client = mockedSmoldotLight === null || mockedSmoldotLight === void 0 ? void 0 : mockedSmoldotLight.getLatestClient();
                let chain2 = yield addChain("");
                (0, vitest_1.expect)(client).toBe(mockedSmoldotLight.getLatestClient());
                chain1.remove();
                (0, vitest_1.expect)(client.terminate).not.toHaveBeenCalled();
                chain2.remove();
                (0, vitest_1.expect)(client.terminate).toHaveBeenCalled();
                let chain3 = yield addWellKnownChain("");
                (0, vitest_1.expect)(mockedSmoldotLight.getLatestClient()).not.toBe(client);
                (0, vitest_1.expect)(mockedSmoldotLight.getLatestClient().terminate).not.toHaveBeenCalled();
                chain3.remove();
                (0, vitest_1.expect)(mockedSmoldotLight.getLatestClient().terminate).toHaveBeenCalled();
            }));
        });
        (0, vitest_1.it)("handles race conditions on the client when adding/removing chains", () => {
            Promise.resolve().then(() => __importStar(require("./smoldot-light"))).then((smoldot) => __awaiter(void 0, void 0, void 0, function* () {
                const { addChain } = smoldot.createScClient();
                const { addChain: addChain2 } = smoldot.createScClient();
                let chain1 = yield addChain("");
                const client = mockedSmoldotLight.getLatestClient();
                const chain2Promise = addChain2("");
                chain1.remove();
                (0, vitest_1.expect)(client.terminate).not.toHaveBeenCalled();
                let chain2 = yield chain2Promise;
                chain2.remove();
                (0, vitest_1.expect)(client.terminate).toHaveBeenCalled();
            }));
        });
    });
    (0, vitest_1.describe)("chain", () => {
        (0, vitest_1.it)("propagates the correct chainSpec to smoldot", () => {
            Promise.resolve().then(() => __importStar(require("./smoldot-light"))).then((smoldot) => __awaiter(void 0, void 0, void 0, function* () {
                const { addChain, addWellKnownChain } = smoldot.createScClient();
                const chainSpec = "testChainSpec";
                yield addChain(chainSpec);
                let mockedChain = mockedSmoldotLight
                    .getLatestClient()
                    ._getLatestChain();
                (0, vitest_1.expect)(mockedChain._addChainOptions.chainSpec).toEqual(chainSpec);
                yield addWellKnownChain(WellKnownChain_1.WellKnownChain.polkadot);
                mockedChain = mockedSmoldotLight.getLatestClient()._getLatestChain();
                (0, vitest_1.expect)(mockedChain._addChainOptions.chainSpec).toEqual("fake-polkadot-spec");
                yield addWellKnownChain(WellKnownChain_1.WellKnownChain.ksmcc3);
                mockedChain = mockedSmoldotLight.getLatestClient()._getLatestChain();
                (0, vitest_1.expect)(mockedChain._addChainOptions.chainSpec).toEqual("fake-ksmcc3-spec");
                yield addWellKnownChain(WellKnownChain_1.WellKnownChain.rococo_v2_2);
                mockedChain = mockedSmoldotLight.getLatestClient()._getLatestChain();
                (0, vitest_1.expect)(mockedChain._addChainOptions.chainSpec).toEqual("fake-rococo_v2_2-spec");
            }));
        });
        (0, vitest_1.it)("propagates the correct potentialRelayChainIds to smoldot", () => {
            Promise.resolve().then(() => __importStar(require("./smoldot-light"))).then((smoldot) => __awaiter(void 0, void 0, void 0, function* () {
                const { addChain } = smoldot.createScClient();
                let prevChains = yield Promise.all(Array(3)
                    .fill(null)
                    .map(() => addChain("")));
                prevChains[0].remove();
                yield addChain("");
                const mockedChains = mockedSmoldotLight
                    .getLatestClient()
                    ._getChains()
                    .slice(-4);
                const lastMockedChain = mockedChains[3];
                (0, vitest_1.expect)(lastMockedChain._addChainOptions.potentialRelayChains).toEqual([
                    mockedChains[1],
                    mockedChains[2],
                ]);
            }));
        });
    });
});
