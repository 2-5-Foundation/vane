// eslint-disable-next-line import/no-extraneous-dependencies
import { beforeEach, beforeAll, it, describe, expect, vi } from "vitest";
import { WellKnownChain } from "../WellKnownChain";
class SdAlreadyDestroyedError extends Error {
    constructor() {
        super();
        this.name = "AlreadyDestroyedError";
    }
}
class SdCrashError extends Error {
    constructor(message) {
        super(message);
        this.name = "CrashError";
    }
}
class SdJsonRpcDisabledError extends Error {
    constructor() {
        super();
        this.name = "JsonRpcDisabledError";
    }
}
class SdMalformedJsonRpcError extends Error {
    constructor() {
        super();
        this.name = "MalformedJsonRpcError";
    }
}
class SdQueueFullError extends Error {
    constructor() {
        super();
        this.name = "QueueFullError";
    }
}
const mockSmoldotLightFactory = () => {
    const start = (options) => {
        const addChain = (addChainOptions, isClientTerminated) => {
            let _remove = vi.fn();
            let _sendJsonRpc = vi.fn();
            return {
                _addChainOptions: addChainOptions,
                remove() {
                    if (isClientTerminated())
                        throw new SdAlreadyDestroyedError();
                    _remove();
                },
                _setRemove(nextRemove) {
                    _remove = nextRemove;
                },
                _getSendRemove: () => _remove,
                sendJsonRpc(rpc) {
                    if (isClientTerminated())
                        throw new SdAlreadyDestroyedError();
                    _sendJsonRpc(rpc);
                },
                _setSendJsonRpc(nextSendJsonRpc) {
                    _sendJsonRpc = nextSendJsonRpc;
                },
                _getSendJsonRpc: () => _sendJsonRpc,
            };
        };
        const chains = [];
        const terminate = vi.fn();
        return {
            _options: options,
            _getChains: () => chains,
            _getLatestChain: () => chains === null || chains === void 0 ? void 0 : chains[chains.length - 1],
            terminate,
            addChain: (addChainOptions) => {
                const chain = addChain(addChainOptions, () => terminate.mock.calls.length > 0);
                chains.push(chain);
                return Promise.resolve(chain);
            },
        };
    };
    let latestClient;
    const mock = {
        AlreadyDestroyedError: SdAlreadyDestroyedError,
        CrashError: SdCrashError,
        JsonRpcDisabledError: SdJsonRpcDisabledError,
        MalformedJsonRpcError: SdMalformedJsonRpcError,
        QueueFullError: SdQueueFullError,
        start: (options) => {
            return (latestClient = start(options));
        },
        getLatestClient: () => latestClient,
    };
    return mock;
};
vi.doMock("smoldot", mockSmoldotLightFactory);
vi.doMock("./specs/index.js", () => ({
    getSpec: (wellKnownChain) => `fake-${wellKnownChain}-spec`,
}));
let mockedSmoldotLight;
beforeAll(async () => {
    mockedSmoldotLight = mockSmoldotLightFactory;
});
beforeEach(() => {
    vi.resetModules();
});
describe("SmoldotConnect::smoldot", () => {
    describe("client", () => {
        it("does not eagerly instantiate the client", () => {
            import("./smoldot-light").then((smoldot) => {
                smoldot.createScClient();
                mockedSmoldotLight =
                    mockSmoldotLightFactory;
                expect(mockedSmoldotLight.start).toBeUndefined();
            });
        });
        it("terminates the internal client when all the chains, from all clients, have been removed", () => {
            import("./smoldot-light").then(async (smoldot) => {
                const { addWellKnownChain, addChain } = smoldot.createScClient();
                let chain1 = await addWellKnownChain("");
                const client = mockedSmoldotLight === null || mockedSmoldotLight === void 0 ? void 0 : mockedSmoldotLight.getLatestClient();
                let chain2 = await addChain("");
                expect(client).toBe(mockedSmoldotLight.getLatestClient());
                chain1.remove();
                expect(client.terminate).not.toHaveBeenCalled();
                chain2.remove();
                expect(client.terminate).toHaveBeenCalled();
                let chain3 = await addWellKnownChain("");
                expect(mockedSmoldotLight.getLatestClient()).not.toBe(client);
                expect(mockedSmoldotLight.getLatestClient().terminate).not.toHaveBeenCalled();
                chain3.remove();
                expect(mockedSmoldotLight.getLatestClient().terminate).toHaveBeenCalled();
            });
        });
        it("handles race conditions on the client when adding/removing chains", () => {
            import("./smoldot-light").then(async (smoldot) => {
                const { addChain } = smoldot.createScClient();
                const { addChain: addChain2 } = smoldot.createScClient();
                let chain1 = await addChain("");
                const client = mockedSmoldotLight.getLatestClient();
                const chain2Promise = addChain2("");
                chain1.remove();
                expect(client.terminate).not.toHaveBeenCalled();
                let chain2 = await chain2Promise;
                chain2.remove();
                expect(client.terminate).toHaveBeenCalled();
            });
        });
    });
    describe("chain", () => {
        it("propagates the correct chainSpec to smoldot", () => {
            import("./smoldot-light").then(async (smoldot) => {
                const { addChain, addWellKnownChain } = smoldot.createScClient();
                const chainSpec = "testChainSpec";
                await addChain(chainSpec);
                let mockedChain = mockedSmoldotLight
                    .getLatestClient()
                    ._getLatestChain();
                expect(mockedChain._addChainOptions.chainSpec).toEqual(chainSpec);
                await addWellKnownChain(WellKnownChain.polkadot);
                mockedChain = mockedSmoldotLight.getLatestClient()._getLatestChain();
                expect(mockedChain._addChainOptions.chainSpec).toEqual("fake-polkadot-spec");
                await addWellKnownChain(WellKnownChain.ksmcc3);
                mockedChain = mockedSmoldotLight.getLatestClient()._getLatestChain();
                expect(mockedChain._addChainOptions.chainSpec).toEqual("fake-ksmcc3-spec");
                await addWellKnownChain(WellKnownChain.rococo_v2_2);
                mockedChain = mockedSmoldotLight.getLatestClient()._getLatestChain();
                expect(mockedChain._addChainOptions.chainSpec).toEqual("fake-rococo_v2_2-spec");
            });
        });
        it("propagates the correct potentialRelayChainIds to smoldot", () => {
            import("./smoldot-light").then(async (smoldot) => {
                const { addChain } = smoldot.createScClient();
                let prevChains = await Promise.all(Array(3)
                    .fill(null)
                    .map(() => addChain("")));
                prevChains[0].remove();
                await addChain("");
                const mockedChains = mockedSmoldotLight
                    .getLatestClient()
                    ._getChains()
                    .slice(-4);
                const lastMockedChain = mockedChains[3];
                expect(lastMockedChain._addChainOptions.potentialRelayChains).toEqual([
                    mockedChains[1],
                    mockedChains[2],
                ]);
            });
        });
    });
});
