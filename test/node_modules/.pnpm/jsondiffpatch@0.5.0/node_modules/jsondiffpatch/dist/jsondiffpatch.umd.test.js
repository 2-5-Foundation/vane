(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('chalk')) :
	typeof define === 'function' && define.amd ? define(['chalk'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.chalk));
})(this, (function (chalk) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
	  if (n.__esModule) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
	        return Reflect.construct(f, arguments, this.constructor);
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var diffMatchPatch = {exports: {}};

	/**
	 * Diff Match and Patch
	 * Copyright 2018 The diff-match-patch Authors.
	 * https://github.com/google/diff-match-patch
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	(function (module) {
		/**
		 * @fileoverview Computes the difference between two texts to create a patch.
		 * Applies the patch onto another text, allowing for errors.
		 * @author fraser@google.com (Neil Fraser)
		 */

		/**
		 * Class containing the diff, match and patch methods.
		 * @constructor
		 */
		var diff_match_patch = function() {

		  // Defaults.
		  // Redefine these in your program to override the defaults.

		  // Number of seconds to map a diff before giving up (0 for infinity).
		  this.Diff_Timeout = 1.0;
		  // Cost of an empty edit operation in terms of edit characters.
		  this.Diff_EditCost = 4;
		  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
		  this.Match_Threshold = 0.5;
		  // How far to search for a match (0 = exact location, 1000+ = broad match).
		  // A match this many characters away from the expected location will add
		  // 1.0 to the score (0.0 is a perfect match).
		  this.Match_Distance = 1000;
		  // When deleting a large block of text (over ~64 characters), how close do
		  // the contents have to be to match the expected contents. (0.0 = perfection,
		  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
		  // end points of a delete need to match.
		  this.Patch_DeleteThreshold = 0.5;
		  // Chunk size for context length.
		  this.Patch_Margin = 4;

		  // The number of bits in an int.
		  this.Match_MaxBits = 32;
		};


		//  DIFF FUNCTIONS


		/**
		 * The data structure representing a diff is an array of tuples:
		 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
		 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
		 */
		var DIFF_DELETE = -1;
		var DIFF_INSERT = 1;
		var DIFF_EQUAL = 0;

		/**
		 * Class representing one diff tuple.
		 * ~Attempts to look like a two-element array (which is what this used to be).~
		 * Constructor returns an actual two-element array, to allow destructing @JackuB
		 * See https://github.com/JackuB/diff-match-patch/issues/14 for details
		 * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
		 * @param {string} text Text to be deleted, inserted, or retained.
		 * @constructor
		 */
		diff_match_patch.Diff = function(op, text) {
		  return [op, text];
		};

		/**
		 * Find the differences between two texts.  Simplifies the problem by stripping
		 * any common prefix or suffix off the texts before diffing.
		 * @param {string} text1 Old string to be diffed.
		 * @param {string} text2 New string to be diffed.
		 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
		 *     then don't run a line-level diff first to identify the changed areas.
		 *     Defaults to true, which does a faster, slightly less optimal diff.
		 * @param {number=} opt_deadline Optional time when the diff should be complete
		 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
		 *     instead.
		 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
		 */
		diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
		    opt_deadline) {
		  // Set a deadline by which time the diff must be complete.
		  if (typeof opt_deadline == 'undefined') {
		    if (this.Diff_Timeout <= 0) {
		      opt_deadline = Number.MAX_VALUE;
		    } else {
		      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
		    }
		  }
		  var deadline = opt_deadline;

		  // Check for null inputs.
		  if (text1 == null || text2 == null) {
		    throw new Error('Null input. (diff_main)');
		  }

		  // Check for equality (speedup).
		  if (text1 == text2) {
		    if (text1) {
		      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
		    }
		    return [];
		  }

		  if (typeof opt_checklines == 'undefined') {
		    opt_checklines = true;
		  }
		  var checklines = opt_checklines;

		  // Trim off common prefix (speedup).
		  var commonlength = this.diff_commonPrefix(text1, text2);
		  var commonprefix = text1.substring(0, commonlength);
		  text1 = text1.substring(commonlength);
		  text2 = text2.substring(commonlength);

		  // Trim off common suffix (speedup).
		  commonlength = this.diff_commonSuffix(text1, text2);
		  var commonsuffix = text1.substring(text1.length - commonlength);
		  text1 = text1.substring(0, text1.length - commonlength);
		  text2 = text2.substring(0, text2.length - commonlength);

		  // Compute the diff on the middle block.
		  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

		  // Restore the prefix and suffix.
		  if (commonprefix) {
		    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
		  }
		  if (commonsuffix) {
		    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
		  }
		  this.diff_cleanupMerge(diffs);
		  return diffs;
		};


		/**
		 * Find the differences between two texts.  Assumes that the texts do not
		 * have any common prefix or suffix.
		 * @param {string} text1 Old string to be diffed.
		 * @param {string} text2 New string to be diffed.
		 * @param {boolean} checklines Speedup flag.  If false, then don't run a
		 *     line-level diff first to identify the changed areas.
		 *     If true, then run a faster, slightly less optimal diff.
		 * @param {number} deadline Time when the diff should be complete by.
		 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
		 * @private
		 */
		diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
		    deadline) {
		  var diffs;

		  if (!text1) {
		    // Just add some text (speedup).
		    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
		  }

		  if (!text2) {
		    // Just delete some text (speedup).
		    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
		  }

		  var longtext = text1.length > text2.length ? text1 : text2;
		  var shorttext = text1.length > text2.length ? text2 : text1;
		  var i = longtext.indexOf(shorttext);
		  if (i != -1) {
		    // Shorter text is inside the longer text (speedup).
		    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
		             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
		             new diff_match_patch.Diff(DIFF_INSERT,
		                 longtext.substring(i + shorttext.length))];
		    // Swap insertions for deletions if diff is reversed.
		    if (text1.length > text2.length) {
		      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
		    }
		    return diffs;
		  }

		  if (shorttext.length == 1) {
		    // Single character string.
		    // After the previous speedup, the character can't be an equality.
		    return [new diff_match_patch.Diff(DIFF_DELETE, text1),
		            new diff_match_patch.Diff(DIFF_INSERT, text2)];
		  }

		  // Check to see if the problem can be split in two.
		  var hm = this.diff_halfMatch_(text1, text2);
		  if (hm) {
		    // A half-match was found, sort out the return data.
		    var text1_a = hm[0];
		    var text1_b = hm[1];
		    var text2_a = hm[2];
		    var text2_b = hm[3];
		    var mid_common = hm[4];
		    // Send both pairs off for separate processing.
		    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
		    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
		    // Merge the results.
		    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
		                          diffs_b);
		  }

		  if (checklines && text1.length > 100 && text2.length > 100) {
		    return this.diff_lineMode_(text1, text2, deadline);
		  }

		  return this.diff_bisect_(text1, text2, deadline);
		};


		/**
		 * Do a quick line-level diff on both strings, then rediff the parts for
		 * greater accuracy.
		 * This speedup can produce non-minimal diffs.
		 * @param {string} text1 Old string to be diffed.
		 * @param {string} text2 New string to be diffed.
		 * @param {number} deadline Time when the diff should be complete by.
		 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
		 * @private
		 */
		diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
		  // Scan the text on a line-by-line basis first.
		  var a = this.diff_linesToChars_(text1, text2);
		  text1 = a.chars1;
		  text2 = a.chars2;
		  var linearray = a.lineArray;

		  var diffs = this.diff_main(text1, text2, false, deadline);

		  // Convert the diff back to original text.
		  this.diff_charsToLines_(diffs, linearray);
		  // Eliminate freak matches (e.g. blank lines)
		  this.diff_cleanupSemantic(diffs);

		  // Rediff any replacement blocks, this time character-by-character.
		  // Add a dummy entry at the end.
		  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
		  var pointer = 0;
		  var count_delete = 0;
		  var count_insert = 0;
		  var text_delete = '';
		  var text_insert = '';
		  while (pointer < diffs.length) {
		    switch (diffs[pointer][0]) {
		      case DIFF_INSERT:
		        count_insert++;
		        text_insert += diffs[pointer][1];
		        break;
		      case DIFF_DELETE:
		        count_delete++;
		        text_delete += diffs[pointer][1];
		        break;
		      case DIFF_EQUAL:
		        // Upon reaching an equality, check for prior redundancies.
		        if (count_delete >= 1 && count_insert >= 1) {
		          // Delete the offending records and add the merged ones.
		          diffs.splice(pointer - count_delete - count_insert,
		                       count_delete + count_insert);
		          pointer = pointer - count_delete - count_insert;
		          var subDiff =
		              this.diff_main(text_delete, text_insert, false, deadline);
		          for (var j = subDiff.length - 1; j >= 0; j--) {
		            diffs.splice(pointer, 0, subDiff[j]);
		          }
		          pointer = pointer + subDiff.length;
		        }
		        count_insert = 0;
		        count_delete = 0;
		        text_delete = '';
		        text_insert = '';
		        break;
		    }
		    pointer++;
		  }
		  diffs.pop();  // Remove the dummy entry at the end.

		  return diffs;
		};


		/**
		 * Find the 'middle snake' of a diff, split the problem in two
		 * and return the recursively constructed diff.
		 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
		 * @param {string} text1 Old string to be diffed.
		 * @param {string} text2 New string to be diffed.
		 * @param {number} deadline Time at which to bail if not yet complete.
		 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
		 * @private
		 */
		diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
		  // Cache the text lengths to prevent multiple calls.
		  var text1_length = text1.length;
		  var text2_length = text2.length;
		  var max_d = Math.ceil((text1_length + text2_length) / 2);
		  var v_offset = max_d;
		  var v_length = 2 * max_d;
		  var v1 = new Array(v_length);
		  var v2 = new Array(v_length);
		  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
		  // integers and undefined.
		  for (var x = 0; x < v_length; x++) {
		    v1[x] = -1;
		    v2[x] = -1;
		  }
		  v1[v_offset + 1] = 0;
		  v2[v_offset + 1] = 0;
		  var delta = text1_length - text2_length;
		  // If the total number of characters is odd, then the front path will collide
		  // with the reverse path.
		  var front = (delta % 2 != 0);
		  // Offsets for start and end of k loop.
		  // Prevents mapping of space beyond the grid.
		  var k1start = 0;
		  var k1end = 0;
		  var k2start = 0;
		  var k2end = 0;
		  for (var d = 0; d < max_d; d++) {
		    // Bail out if deadline is reached.
		    if ((new Date()).getTime() > deadline) {
		      break;
		    }

		    // Walk the front path one step.
		    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
		      var k1_offset = v_offset + k1;
		      var x1;
		      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
		        x1 = v1[k1_offset + 1];
		      } else {
		        x1 = v1[k1_offset - 1] + 1;
		      }
		      var y1 = x1 - k1;
		      while (x1 < text1_length && y1 < text2_length &&
		             text1.charAt(x1) == text2.charAt(y1)) {
		        x1++;
		        y1++;
		      }
		      v1[k1_offset] = x1;
		      if (x1 > text1_length) {
		        // Ran off the right of the graph.
		        k1end += 2;
		      } else if (y1 > text2_length) {
		        // Ran off the bottom of the graph.
		        k1start += 2;
		      } else if (front) {
		        var k2_offset = v_offset + delta - k1;
		        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
		          // Mirror x2 onto top-left coordinate system.
		          var x2 = text1_length - v2[k2_offset];
		          if (x1 >= x2) {
		            // Overlap detected.
		            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
		          }
		        }
		      }
		    }

		    // Walk the reverse path one step.
		    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
		      var k2_offset = v_offset + k2;
		      var x2;
		      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
		        x2 = v2[k2_offset + 1];
		      } else {
		        x2 = v2[k2_offset - 1] + 1;
		      }
		      var y2 = x2 - k2;
		      while (x2 < text1_length && y2 < text2_length &&
		             text1.charAt(text1_length - x2 - 1) ==
		             text2.charAt(text2_length - y2 - 1)) {
		        x2++;
		        y2++;
		      }
		      v2[k2_offset] = x2;
		      if (x2 > text1_length) {
		        // Ran off the left of the graph.
		        k2end += 2;
		      } else if (y2 > text2_length) {
		        // Ran off the top of the graph.
		        k2start += 2;
		      } else if (!front) {
		        var k1_offset = v_offset + delta - k2;
		        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
		          var x1 = v1[k1_offset];
		          var y1 = v_offset + x1 - k1_offset;
		          // Mirror x2 onto top-left coordinate system.
		          x2 = text1_length - x2;
		          if (x1 >= x2) {
		            // Overlap detected.
		            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
		          }
		        }
		      }
		    }
		  }
		  // Diff took too long and hit the deadline or
		  // number of diffs equals number of characters, no commonality at all.
		  return [new diff_match_patch.Diff(DIFF_DELETE, text1),
		          new diff_match_patch.Diff(DIFF_INSERT, text2)];
		};


		/**
		 * Given the location of the 'middle snake', split the diff in two parts
		 * and recurse.
		 * @param {string} text1 Old string to be diffed.
		 * @param {string} text2 New string to be diffed.
		 * @param {number} x Index of split point in text1.
		 * @param {number} y Index of split point in text2.
		 * @param {number} deadline Time at which to bail if not yet complete.
		 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
		 * @private
		 */
		diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
		    deadline) {
		  var text1a = text1.substring(0, x);
		  var text2a = text2.substring(0, y);
		  var text1b = text1.substring(x);
		  var text2b = text2.substring(y);

		  // Compute both diffs serially.
		  var diffs = this.diff_main(text1a, text2a, false, deadline);
		  var diffsb = this.diff_main(text1b, text2b, false, deadline);

		  return diffs.concat(diffsb);
		};


		/**
		 * Split two texts into an array of strings.  Reduce the texts to a string of
		 * hashes where each Unicode character represents one line.
		 * @param {string} text1 First string.
		 * @param {string} text2 Second string.
		 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
		 *     An object containing the encoded text1, the encoded text2 and
		 *     the array of unique strings.
		 *     The zeroth element of the array of unique strings is intentionally blank.
		 * @private
		 */
		diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
		  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
		  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

		  // '\x00' is a valid character, but various debuggers don't like it.
		  // So we'll insert a junk entry to avoid generating a null character.
		  lineArray[0] = '';

		  /**
		   * Split a text into an array of strings.  Reduce the texts to a string of
		   * hashes where each Unicode character represents one line.
		   * Modifies linearray and linehash through being a closure.
		   * @param {string} text String to encode.
		   * @return {string} Encoded string.
		   * @private
		   */
		  function diff_linesToCharsMunge_(text) {
		    var chars = '';
		    // Walk the text, pulling out a substring for each line.
		    // text.split('\n') would would temporarily double our memory footprint.
		    // Modifying text would create many large strings to garbage collect.
		    var lineStart = 0;
		    var lineEnd = -1;
		    // Keeping our own length variable is faster than looking it up.
		    var lineArrayLength = lineArray.length;
		    while (lineEnd < text.length - 1) {
		      lineEnd = text.indexOf('\n', lineStart);
		      if (lineEnd == -1) {
		        lineEnd = text.length - 1;
		      }
		      var line = text.substring(lineStart, lineEnd + 1);

		      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
		          (lineHash[line] !== undefined)) {
		        chars += String.fromCharCode(lineHash[line]);
		      } else {
		        if (lineArrayLength == maxLines) {
		          // Bail out at 65535 because
		          // String.fromCharCode(65536) == String.fromCharCode(0)
		          line = text.substring(lineStart);
		          lineEnd = text.length;
		        }
		        chars += String.fromCharCode(lineArrayLength);
		        lineHash[line] = lineArrayLength;
		        lineArray[lineArrayLength++] = line;
		      }
		      lineStart = lineEnd + 1;
		    }
		    return chars;
		  }
		  // Allocate 2/3rds of the space for text1, the rest for text2.
		  var maxLines = 40000;
		  var chars1 = diff_linesToCharsMunge_(text1);
		  maxLines = 65535;
		  var chars2 = diff_linesToCharsMunge_(text2);
		  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
		};


		/**
		 * Rehydrate the text in a diff from a string of line hashes to real lines of
		 * text.
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 * @param {!Array.<string>} lineArray Array of unique strings.
		 * @private
		 */
		diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
		  for (var i = 0; i < diffs.length; i++) {
		    var chars = diffs[i][1];
		    var text = [];
		    for (var j = 0; j < chars.length; j++) {
		      text[j] = lineArray[chars.charCodeAt(j)];
		    }
		    diffs[i][1] = text.join('');
		  }
		};


		/**
		 * Determine the common prefix of two strings.
		 * @param {string} text1 First string.
		 * @param {string} text2 Second string.
		 * @return {number} The number of characters common to the start of each
		 *     string.
		 */
		diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
		  // Quick check for common null cases.
		  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
		    return 0;
		  }
		  // Binary search.
		  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
		  var pointermin = 0;
		  var pointermax = Math.min(text1.length, text2.length);
		  var pointermid = pointermax;
		  var pointerstart = 0;
		  while (pointermin < pointermid) {
		    if (text1.substring(pointerstart, pointermid) ==
		        text2.substring(pointerstart, pointermid)) {
		      pointermin = pointermid;
		      pointerstart = pointermin;
		    } else {
		      pointermax = pointermid;
		    }
		    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
		  }
		  return pointermid;
		};


		/**
		 * Determine the common suffix of two strings.
		 * @param {string} text1 First string.
		 * @param {string} text2 Second string.
		 * @return {number} The number of characters common to the end of each string.
		 */
		diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
		  // Quick check for common null cases.
		  if (!text1 || !text2 ||
		      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
		    return 0;
		  }
		  // Binary search.
		  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
		  var pointermin = 0;
		  var pointermax = Math.min(text1.length, text2.length);
		  var pointermid = pointermax;
		  var pointerend = 0;
		  while (pointermin < pointermid) {
		    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
		        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
		      pointermin = pointermid;
		      pointerend = pointermin;
		    } else {
		      pointermax = pointermid;
		    }
		    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
		  }
		  return pointermid;
		};


		/**
		 * Determine if the suffix of one string is the prefix of another.
		 * @param {string} text1 First string.
		 * @param {string} text2 Second string.
		 * @return {number} The number of characters common to the end of the first
		 *     string and the start of the second string.
		 * @private
		 */
		diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
		  // Cache the text lengths to prevent multiple calls.
		  var text1_length = text1.length;
		  var text2_length = text2.length;
		  // Eliminate the null case.
		  if (text1_length == 0 || text2_length == 0) {
		    return 0;
		  }
		  // Truncate the longer string.
		  if (text1_length > text2_length) {
		    text1 = text1.substring(text1_length - text2_length);
		  } else if (text1_length < text2_length) {
		    text2 = text2.substring(0, text1_length);
		  }
		  var text_length = Math.min(text1_length, text2_length);
		  // Quick check for the worst case.
		  if (text1 == text2) {
		    return text_length;
		  }

		  // Start by looking for a single character match
		  // and increase length until no match is found.
		  // Performance analysis: https://neil.fraser.name/news/2010/11/04/
		  var best = 0;
		  var length = 1;
		  while (true) {
		    var pattern = text1.substring(text_length - length);
		    var found = text2.indexOf(pattern);
		    if (found == -1) {
		      return best;
		    }
		    length += found;
		    if (found == 0 || text1.substring(text_length - length) ==
		        text2.substring(0, length)) {
		      best = length;
		      length++;
		    }
		  }
		};


		/**
		 * Do the two texts share a substring which is at least half the length of the
		 * longer text?
		 * This speedup can produce non-minimal diffs.
		 * @param {string} text1 First string.
		 * @param {string} text2 Second string.
		 * @return {Array.<string>} Five element Array, containing the prefix of
		 *     text1, the suffix of text1, the prefix of text2, the suffix of
		 *     text2 and the common middle.  Or null if there was no match.
		 * @private
		 */
		diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
		  if (this.Diff_Timeout <= 0) {
		    // Don't risk returning a non-optimal diff if we have unlimited time.
		    return null;
		  }
		  var longtext = text1.length > text2.length ? text1 : text2;
		  var shorttext = text1.length > text2.length ? text2 : text1;
		  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
		    return null;  // Pointless.
		  }
		  var dmp = this;  // 'this' becomes 'window' in a closure.

		  /**
		   * Does a substring of shorttext exist within longtext such that the substring
		   * is at least half the length of longtext?
		   * Closure, but does not reference any external variables.
		   * @param {string} longtext Longer string.
		   * @param {string} shorttext Shorter string.
		   * @param {number} i Start index of quarter length substring within longtext.
		   * @return {Array.<string>} Five element Array, containing the prefix of
		   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
		   *     of shorttext and the common middle.  Or null if there was no match.
		   * @private
		   */
		  function diff_halfMatchI_(longtext, shorttext, i) {
		    // Start with a 1/4 length substring at position i as a seed.
		    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
		    var j = -1;
		    var best_common = '';
		    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
		    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
		      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
		                                               shorttext.substring(j));
		      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
		                                               shorttext.substring(0, j));
		      if (best_common.length < suffixLength + prefixLength) {
		        best_common = shorttext.substring(j - suffixLength, j) +
		            shorttext.substring(j, j + prefixLength);
		        best_longtext_a = longtext.substring(0, i - suffixLength);
		        best_longtext_b = longtext.substring(i + prefixLength);
		        best_shorttext_a = shorttext.substring(0, j - suffixLength);
		        best_shorttext_b = shorttext.substring(j + prefixLength);
		      }
		    }
		    if (best_common.length * 2 >= longtext.length) {
		      return [best_longtext_a, best_longtext_b,
		              best_shorttext_a, best_shorttext_b, best_common];
		    } else {
		      return null;
		    }
		  }

		  // First check if the second quarter is the seed for a half-match.
		  var hm1 = diff_halfMatchI_(longtext, shorttext,
		                             Math.ceil(longtext.length / 4));
		  // Check again based on the third quarter.
		  var hm2 = diff_halfMatchI_(longtext, shorttext,
		                             Math.ceil(longtext.length / 2));
		  var hm;
		  if (!hm1 && !hm2) {
		    return null;
		  } else if (!hm2) {
		    hm = hm1;
		  } else if (!hm1) {
		    hm = hm2;
		  } else {
		    // Both matched.  Select the longest.
		    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
		  }

		  // A half-match was found, sort out the return data.
		  var text1_a, text1_b, text2_a, text2_b;
		  if (text1.length > text2.length) {
		    text1_a = hm[0];
		    text1_b = hm[1];
		    text2_a = hm[2];
		    text2_b = hm[3];
		  } else {
		    text2_a = hm[0];
		    text2_b = hm[1];
		    text1_a = hm[2];
		    text1_b = hm[3];
		  }
		  var mid_common = hm[4];
		  return [text1_a, text1_b, text2_a, text2_b, mid_common];
		};


		/**
		 * Reduce the number of edits by eliminating semantically trivial equalities.
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 */
		diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
		  var changes = false;
		  var equalities = [];  // Stack of indices where equalities are found.
		  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
		  /** @type {?string} */
		  var lastEquality = null;
		  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
		  var pointer = 0;  // Index of current position.
		  // Number of characters that changed prior to the equality.
		  var length_insertions1 = 0;
		  var length_deletions1 = 0;
		  // Number of characters that changed after the equality.
		  var length_insertions2 = 0;
		  var length_deletions2 = 0;
		  while (pointer < diffs.length) {
		    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
		      equalities[equalitiesLength++] = pointer;
		      length_insertions1 = length_insertions2;
		      length_deletions1 = length_deletions2;
		      length_insertions2 = 0;
		      length_deletions2 = 0;
		      lastEquality = diffs[pointer][1];
		    } else {  // An insertion or deletion.
		      if (diffs[pointer][0] == DIFF_INSERT) {
		        length_insertions2 += diffs[pointer][1].length;
		      } else {
		        length_deletions2 += diffs[pointer][1].length;
		      }
		      // Eliminate an equality that is smaller or equal to the edits on both
		      // sides of it.
		      if (lastEquality && (lastEquality.length <=
		          Math.max(length_insertions1, length_deletions1)) &&
		          (lastEquality.length <= Math.max(length_insertions2,
		                                           length_deletions2))) {
		        // Duplicate record.
		        diffs.splice(equalities[equalitiesLength - 1], 0,
		                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
		        // Change second copy to insert.
		        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
		        // Throw away the equality we just deleted.
		        equalitiesLength--;
		        // Throw away the previous equality (it needs to be reevaluated).
		        equalitiesLength--;
		        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
		        length_insertions1 = 0;  // Reset the counters.
		        length_deletions1 = 0;
		        length_insertions2 = 0;
		        length_deletions2 = 0;
		        lastEquality = null;
		        changes = true;
		      }
		    }
		    pointer++;
		  }

		  // Normalize the diff.
		  if (changes) {
		    this.diff_cleanupMerge(diffs);
		  }
		  this.diff_cleanupSemanticLossless(diffs);

		  // Find any overlaps between deletions and insertions.
		  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
		  //   -> <del>abc</del>xxx<ins>def</ins>
		  // e.g: <del>xxxabc</del><ins>defxxx</ins>
		  //   -> <ins>def</ins>xxx<del>abc</del>
		  // Only extract an overlap if it is as big as the edit ahead or behind it.
		  pointer = 1;
		  while (pointer < diffs.length) {
		    if (diffs[pointer - 1][0] == DIFF_DELETE &&
		        diffs[pointer][0] == DIFF_INSERT) {
		      var deletion = diffs[pointer - 1][1];
		      var insertion = diffs[pointer][1];
		      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
		      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
		      if (overlap_length1 >= overlap_length2) {
		        if (overlap_length1 >= deletion.length / 2 ||
		            overlap_length1 >= insertion.length / 2) {
		          // Overlap found.  Insert an equality and trim the surrounding edits.
		          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
		              insertion.substring(0, overlap_length1)));
		          diffs[pointer - 1][1] =
		              deletion.substring(0, deletion.length - overlap_length1);
		          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
		          pointer++;
		        }
		      } else {
		        if (overlap_length2 >= deletion.length / 2 ||
		            overlap_length2 >= insertion.length / 2) {
		          // Reverse overlap found.
		          // Insert an equality and swap and trim the surrounding edits.
		          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
		              deletion.substring(0, overlap_length2)));
		          diffs[pointer - 1][0] = DIFF_INSERT;
		          diffs[pointer - 1][1] =
		              insertion.substring(0, insertion.length - overlap_length2);
		          diffs[pointer + 1][0] = DIFF_DELETE;
		          diffs[pointer + 1][1] =
		              deletion.substring(overlap_length2);
		          pointer++;
		        }
		      }
		      pointer++;
		    }
		    pointer++;
		  }
		};


		/**
		 * Look for single edits surrounded on both sides by equalities
		 * which can be shifted sideways to align the edit to a word boundary.
		 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 */
		diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
		  /**
		   * Given two strings, compute a score representing whether the internal
		   * boundary falls on logical boundaries.
		   * Scores range from 6 (best) to 0 (worst).
		   * Closure, but does not reference any external variables.
		   * @param {string} one First string.
		   * @param {string} two Second string.
		   * @return {number} The score.
		   * @private
		   */
		  function diff_cleanupSemanticScore_(one, two) {
		    if (!one || !two) {
		      // Edges are the best.
		      return 6;
		    }

		    // Each port of this function behaves slightly differently due to
		    // subtle differences in each language's definition of things like
		    // 'whitespace'.  Since this function's purpose is largely cosmetic,
		    // the choice has been made to use each language's native features
		    // rather than force total conformity.
		    var char1 = one.charAt(one.length - 1);
		    var char2 = two.charAt(0);
		    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
		    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
		    var whitespace1 = nonAlphaNumeric1 &&
		        char1.match(diff_match_patch.whitespaceRegex_);
		    var whitespace2 = nonAlphaNumeric2 &&
		        char2.match(diff_match_patch.whitespaceRegex_);
		    var lineBreak1 = whitespace1 &&
		        char1.match(diff_match_patch.linebreakRegex_);
		    var lineBreak2 = whitespace2 &&
		        char2.match(diff_match_patch.linebreakRegex_);
		    var blankLine1 = lineBreak1 &&
		        one.match(diff_match_patch.blanklineEndRegex_);
		    var blankLine2 = lineBreak2 &&
		        two.match(diff_match_patch.blanklineStartRegex_);

		    if (blankLine1 || blankLine2) {
		      // Five points for blank lines.
		      return 5;
		    } else if (lineBreak1 || lineBreak2) {
		      // Four points for line breaks.
		      return 4;
		    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
		      // Three points for end of sentences.
		      return 3;
		    } else if (whitespace1 || whitespace2) {
		      // Two points for whitespace.
		      return 2;
		    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
		      // One point for non-alphanumeric.
		      return 1;
		    }
		    return 0;
		  }

		  var pointer = 1;
		  // Intentionally ignore the first and last element (don't need checking).
		  while (pointer < diffs.length - 1) {
		    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
		        diffs[pointer + 1][0] == DIFF_EQUAL) {
		      // This is a single edit surrounded by equalities.
		      var equality1 = diffs[pointer - 1][1];
		      var edit = diffs[pointer][1];
		      var equality2 = diffs[pointer + 1][1];

		      // First, shift the edit as far left as possible.
		      var commonOffset = this.diff_commonSuffix(equality1, edit);
		      if (commonOffset) {
		        var commonString = edit.substring(edit.length - commonOffset);
		        equality1 = equality1.substring(0, equality1.length - commonOffset);
		        edit = commonString + edit.substring(0, edit.length - commonOffset);
		        equality2 = commonString + equality2;
		      }

		      // Second, step character by character right, looking for the best fit.
		      var bestEquality1 = equality1;
		      var bestEdit = edit;
		      var bestEquality2 = equality2;
		      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
		          diff_cleanupSemanticScore_(edit, equality2);
		      while (edit.charAt(0) === equality2.charAt(0)) {
		        equality1 += edit.charAt(0);
		        edit = edit.substring(1) + equality2.charAt(0);
		        equality2 = equality2.substring(1);
		        var score = diff_cleanupSemanticScore_(equality1, edit) +
		            diff_cleanupSemanticScore_(edit, equality2);
		        // The >= encourages trailing rather than leading whitespace on edits.
		        if (score >= bestScore) {
		          bestScore = score;
		          bestEquality1 = equality1;
		          bestEdit = edit;
		          bestEquality2 = equality2;
		        }
		      }

		      if (diffs[pointer - 1][1] != bestEquality1) {
		        // We have an improvement, save it back to the diff.
		        if (bestEquality1) {
		          diffs[pointer - 1][1] = bestEquality1;
		        } else {
		          diffs.splice(pointer - 1, 1);
		          pointer--;
		        }
		        diffs[pointer][1] = bestEdit;
		        if (bestEquality2) {
		          diffs[pointer + 1][1] = bestEquality2;
		        } else {
		          diffs.splice(pointer + 1, 1);
		          pointer--;
		        }
		      }
		    }
		    pointer++;
		  }
		};

		// Define some regex patterns for matching boundaries.
		diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
		diff_match_patch.whitespaceRegex_ = /\s/;
		diff_match_patch.linebreakRegex_ = /[\r\n]/;
		diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
		diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

		/**
		 * Reduce the number of edits by eliminating operationally trivial equalities.
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 */
		diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
		  var changes = false;
		  var equalities = [];  // Stack of indices where equalities are found.
		  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
		  /** @type {?string} */
		  var lastEquality = null;
		  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
		  var pointer = 0;  // Index of current position.
		  // Is there an insertion operation before the last equality.
		  var pre_ins = false;
		  // Is there a deletion operation before the last equality.
		  var pre_del = false;
		  // Is there an insertion operation after the last equality.
		  var post_ins = false;
		  // Is there a deletion operation after the last equality.
		  var post_del = false;
		  while (pointer < diffs.length) {
		    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
		      if (diffs[pointer][1].length < this.Diff_EditCost &&
		          (post_ins || post_del)) {
		        // Candidate found.
		        equalities[equalitiesLength++] = pointer;
		        pre_ins = post_ins;
		        pre_del = post_del;
		        lastEquality = diffs[pointer][1];
		      } else {
		        // Not a candidate, and can never become one.
		        equalitiesLength = 0;
		        lastEquality = null;
		      }
		      post_ins = post_del = false;
		    } else {  // An insertion or deletion.
		      if (diffs[pointer][0] == DIFF_DELETE) {
		        post_del = true;
		      } else {
		        post_ins = true;
		      }
		      /*
		       * Five types to be split:
		       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
		       * <ins>A</ins>X<ins>C</ins><del>D</del>
		       * <ins>A</ins><del>B</del>X<ins>C</ins>
		       * <ins>A</del>X<ins>C</ins><del>D</del>
		       * <ins>A</ins><del>B</del>X<del>C</del>
		       */
		      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||
		                           ((lastEquality.length < this.Diff_EditCost / 2) &&
		                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
		        // Duplicate record.
		        diffs.splice(equalities[equalitiesLength - 1], 0,
		                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
		        // Change second copy to insert.
		        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
		        equalitiesLength--;  // Throw away the equality we just deleted;
		        lastEquality = null;
		        if (pre_ins && pre_del) {
		          // No changes made which could affect previous entry, keep going.
		          post_ins = post_del = true;
		          equalitiesLength = 0;
		        } else {
		          equalitiesLength--;  // Throw away the previous equality.
		          pointer = equalitiesLength > 0 ?
		              equalities[equalitiesLength - 1] : -1;
		          post_ins = post_del = false;
		        }
		        changes = true;
		      }
		    }
		    pointer++;
		  }

		  if (changes) {
		    this.diff_cleanupMerge(diffs);
		  }
		};


		/**
		 * Reorder and merge like edit sections.  Merge equalities.
		 * Any edit section can move as long as it doesn't cross an equality.
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 */
		diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
		  // Add a dummy entry at the end.
		  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
		  var pointer = 0;
		  var count_delete = 0;
		  var count_insert = 0;
		  var text_delete = '';
		  var text_insert = '';
		  var commonlength;
		  while (pointer < diffs.length) {
		    switch (diffs[pointer][0]) {
		      case DIFF_INSERT:
		        count_insert++;
		        text_insert += diffs[pointer][1];
		        pointer++;
		        break;
		      case DIFF_DELETE:
		        count_delete++;
		        text_delete += diffs[pointer][1];
		        pointer++;
		        break;
		      case DIFF_EQUAL:
		        // Upon reaching an equality, check for prior redundancies.
		        if (count_delete + count_insert > 1) {
		          if (count_delete !== 0 && count_insert !== 0) {
		            // Factor out any common prefixies.
		            commonlength = this.diff_commonPrefix(text_insert, text_delete);
		            if (commonlength !== 0) {
		              if ((pointer - count_delete - count_insert) > 0 &&
		                  diffs[pointer - count_delete - count_insert - 1][0] ==
		                  DIFF_EQUAL) {
		                diffs[pointer - count_delete - count_insert - 1][1] +=
		                    text_insert.substring(0, commonlength);
		              } else {
		                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,
		                    text_insert.substring(0, commonlength)));
		                pointer++;
		              }
		              text_insert = text_insert.substring(commonlength);
		              text_delete = text_delete.substring(commonlength);
		            }
		            // Factor out any common suffixies.
		            commonlength = this.diff_commonSuffix(text_insert, text_delete);
		            if (commonlength !== 0) {
		              diffs[pointer][1] = text_insert.substring(text_insert.length -
		                  commonlength) + diffs[pointer][1];
		              text_insert = text_insert.substring(0, text_insert.length -
		                  commonlength);
		              text_delete = text_delete.substring(0, text_delete.length -
		                  commonlength);
		            }
		          }
		          // Delete the offending records and add the merged ones.
		          pointer -= count_delete + count_insert;
		          diffs.splice(pointer, count_delete + count_insert);
		          if (text_delete.length) {
		            diffs.splice(pointer, 0,
		                new diff_match_patch.Diff(DIFF_DELETE, text_delete));
		            pointer++;
		          }
		          if (text_insert.length) {
		            diffs.splice(pointer, 0,
		                new diff_match_patch.Diff(DIFF_INSERT, text_insert));
		            pointer++;
		          }
		          pointer++;
		        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
		          // Merge this equality with the previous one.
		          diffs[pointer - 1][1] += diffs[pointer][1];
		          diffs.splice(pointer, 1);
		        } else {
		          pointer++;
		        }
		        count_insert = 0;
		        count_delete = 0;
		        text_delete = '';
		        text_insert = '';
		        break;
		    }
		  }
		  if (diffs[diffs.length - 1][1] === '') {
		    diffs.pop();  // Remove the dummy entry at the end.
		  }

		  // Second pass: look for single edits surrounded on both sides by equalities
		  // which can be shifted sideways to eliminate an equality.
		  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
		  var changes = false;
		  pointer = 1;
		  // Intentionally ignore the first and last element (don't need checking).
		  while (pointer < diffs.length - 1) {
		    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
		        diffs[pointer + 1][0] == DIFF_EQUAL) {
		      // This is a single edit surrounded by equalities.
		      if (diffs[pointer][1].substring(diffs[pointer][1].length -
		          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
		        // Shift the edit over the previous equality.
		        diffs[pointer][1] = diffs[pointer - 1][1] +
		            diffs[pointer][1].substring(0, diffs[pointer][1].length -
		                                        diffs[pointer - 1][1].length);
		        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
		        diffs.splice(pointer - 1, 1);
		        changes = true;
		      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
		          diffs[pointer + 1][1]) {
		        // Shift the edit over the next equality.
		        diffs[pointer - 1][1] += diffs[pointer + 1][1];
		        diffs[pointer][1] =
		            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
		            diffs[pointer + 1][1];
		        diffs.splice(pointer + 1, 1);
		        changes = true;
		      }
		    }
		    pointer++;
		  }
		  // If shifts were made, the diff needs reordering and another shift sweep.
		  if (changes) {
		    this.diff_cleanupMerge(diffs);
		  }
		};


		/**
		 * loc is a location in text1, compute and return the equivalent location in
		 * text2.
		 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 * @param {number} loc Location within text1.
		 * @return {number} Location within text2.
		 */
		diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
		  var chars1 = 0;
		  var chars2 = 0;
		  var last_chars1 = 0;
		  var last_chars2 = 0;
		  var x;
		  for (x = 0; x < diffs.length; x++) {
		    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
		      chars1 += diffs[x][1].length;
		    }
		    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
		      chars2 += diffs[x][1].length;
		    }
		    if (chars1 > loc) {  // Overshot the location.
		      break;
		    }
		    last_chars1 = chars1;
		    last_chars2 = chars2;
		  }
		  // Was the location was deleted?
		  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
		    return last_chars2;
		  }
		  // Add the remaining character length.
		  return last_chars2 + (loc - last_chars1);
		};


		/**
		 * Convert a diff array into a pretty HTML report.
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 * @return {string} HTML representation.
		 */
		diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
		  var html = [];
		  var pattern_amp = /&/g;
		  var pattern_lt = /</g;
		  var pattern_gt = />/g;
		  var pattern_para = /\n/g;
		  for (var x = 0; x < diffs.length; x++) {
		    var op = diffs[x][0];    // Operation (insert, delete, equal)
		    var data = diffs[x][1];  // Text of change.
		    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
		        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
		    switch (op) {
		      case DIFF_INSERT:
		        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
		        break;
		      case DIFF_DELETE:
		        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
		        break;
		      case DIFF_EQUAL:
		        html[x] = '<span>' + text + '</span>';
		        break;
		    }
		  }
		  return html.join('');
		};


		/**
		 * Compute and return the source text (all equalities and deletions).
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 * @return {string} Source text.
		 */
		diff_match_patch.prototype.diff_text1 = function(diffs) {
		  var text = [];
		  for (var x = 0; x < diffs.length; x++) {
		    if (diffs[x][0] !== DIFF_INSERT) {
		      text[x] = diffs[x][1];
		    }
		  }
		  return text.join('');
		};


		/**
		 * Compute and return the destination text (all equalities and insertions).
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 * @return {string} Destination text.
		 */
		diff_match_patch.prototype.diff_text2 = function(diffs) {
		  var text = [];
		  for (var x = 0; x < diffs.length; x++) {
		    if (diffs[x][0] !== DIFF_DELETE) {
		      text[x] = diffs[x][1];
		    }
		  }
		  return text.join('');
		};


		/**
		 * Compute the Levenshtein distance; the number of inserted, deleted or
		 * substituted characters.
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 * @return {number} Number of changes.
		 */
		diff_match_patch.prototype.diff_levenshtein = function(diffs) {
		  var levenshtein = 0;
		  var insertions = 0;
		  var deletions = 0;
		  for (var x = 0; x < diffs.length; x++) {
		    var op = diffs[x][0];
		    var data = diffs[x][1];
		    switch (op) {
		      case DIFF_INSERT:
		        insertions += data.length;
		        break;
		      case DIFF_DELETE:
		        deletions += data.length;
		        break;
		      case DIFF_EQUAL:
		        // A deletion and an insertion is one substitution.
		        levenshtein += Math.max(insertions, deletions);
		        insertions = 0;
		        deletions = 0;
		        break;
		    }
		  }
		  levenshtein += Math.max(insertions, deletions);
		  return levenshtein;
		};


		/**
		 * Crush the diff into an encoded string which describes the operations
		 * required to transform text1 into text2.
		 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
		 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
		 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
		 * @return {string} Delta text.
		 */
		diff_match_patch.prototype.diff_toDelta = function(diffs) {
		  var text = [];
		  for (var x = 0; x < diffs.length; x++) {
		    switch (diffs[x][0]) {
		      case DIFF_INSERT:
		        text[x] = '+' + encodeURI(diffs[x][1]);
		        break;
		      case DIFF_DELETE:
		        text[x] = '-' + diffs[x][1].length;
		        break;
		      case DIFF_EQUAL:
		        text[x] = '=' + diffs[x][1].length;
		        break;
		    }
		  }
		  return text.join('\t').replace(/%20/g, ' ');
		};


		/**
		 * Given the original text1, and an encoded string which describes the
		 * operations required to transform text1 into text2, compute the full diff.
		 * @param {string} text1 Source string for the diff.
		 * @param {string} delta Delta text.
		 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
		 * @throws {!Error} If invalid input.
		 */
		diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
		  var diffs = [];
		  var diffsLength = 0;  // Keeping our own length var is faster in JS.
		  var pointer = 0;  // Cursor in text1
		  var tokens = delta.split(/\t/g);
		  for (var x = 0; x < tokens.length; x++) {
		    // Each token begins with a one character parameter which specifies the
		    // operation of this token (delete, insert, equality).
		    var param = tokens[x].substring(1);
		    switch (tokens[x].charAt(0)) {
		      case '+':
		        try {
		          diffs[diffsLength++] =
		              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
		        } catch (ex) {
		          // Malformed URI sequence.
		          throw new Error('Illegal escape in diff_fromDelta: ' + param);
		        }
		        break;
		      case '-':
		        // Fall through.
		      case '=':
		        var n = parseInt(param, 10);
		        if (isNaN(n) || n < 0) {
		          throw new Error('Invalid number in diff_fromDelta: ' + param);
		        }
		        var text = text1.substring(pointer, pointer += n);
		        if (tokens[x].charAt(0) == '=') {
		          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
		        } else {
		          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
		        }
		        break;
		      default:
		        // Blank tokens are ok (from a trailing \t).
		        // Anything else is an error.
		        if (tokens[x]) {
		          throw new Error('Invalid diff operation in diff_fromDelta: ' +
		                          tokens[x]);
		        }
		    }
		  }
		  if (pointer != text1.length) {
		    throw new Error('Delta length (' + pointer +
		        ') does not equal source text length (' + text1.length + ').');
		  }
		  return diffs;
		};


		//  MATCH FUNCTIONS


		/**
		 * Locate the best instance of 'pattern' in 'text' near 'loc'.
		 * @param {string} text The text to search.
		 * @param {string} pattern The pattern to search for.
		 * @param {number} loc The location to search around.
		 * @return {number} Best match index or -1.
		 */
		diff_match_patch.prototype.match_main = function(text, pattern, loc) {
		  // Check for null inputs.
		  if (text == null || pattern == null || loc == null) {
		    throw new Error('Null input. (match_main)');
		  }

		  loc = Math.max(0, Math.min(loc, text.length));
		  if (text == pattern) {
		    // Shortcut (potentially not guaranteed by the algorithm)
		    return 0;
		  } else if (!text.length) {
		    // Nothing to match.
		    return -1;
		  } else if (text.substring(loc, loc + pattern.length) == pattern) {
		    // Perfect match at the perfect spot!  (Includes case of null pattern)
		    return loc;
		  } else {
		    // Do a fuzzy compare.
		    return this.match_bitap_(text, pattern, loc);
		  }
		};


		/**
		 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
		 * Bitap algorithm.
		 * @param {string} text The text to search.
		 * @param {string} pattern The pattern to search for.
		 * @param {number} loc The location to search around.
		 * @return {number} Best match index or -1.
		 * @private
		 */
		diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
		  if (pattern.length > this.Match_MaxBits) {
		    throw new Error('Pattern too long for this browser.');
		  }

		  // Initialise the alphabet.
		  var s = this.match_alphabet_(pattern);

		  var dmp = this;  // 'this' becomes 'window' in a closure.

		  /**
		   * Compute and return the score for a match with e errors and x location.
		   * Accesses loc and pattern through being a closure.
		   * @param {number} e Number of errors in match.
		   * @param {number} x Location of match.
		   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
		   * @private
		   */
		  function match_bitapScore_(e, x) {
		    var accuracy = e / pattern.length;
		    var proximity = Math.abs(loc - x);
		    if (!dmp.Match_Distance) {
		      // Dodge divide by zero error.
		      return proximity ? 1.0 : accuracy;
		    }
		    return accuracy + (proximity / dmp.Match_Distance);
		  }

		  // Highest score beyond which we give up.
		  var score_threshold = this.Match_Threshold;
		  // Is there a nearby exact match? (speedup)
		  var best_loc = text.indexOf(pattern, loc);
		  if (best_loc != -1) {
		    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
		    // What about in the other direction? (speedup)
		    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
		    if (best_loc != -1) {
		      score_threshold =
		          Math.min(match_bitapScore_(0, best_loc), score_threshold);
		    }
		  }

		  // Initialise the bit arrays.
		  var matchmask = 1 << (pattern.length - 1);
		  best_loc = -1;

		  var bin_min, bin_mid;
		  var bin_max = pattern.length + text.length;
		  var last_rd;
		  for (var d = 0; d < pattern.length; d++) {
		    // Scan for the best match; each iteration allows for one more error.
		    // Run a binary search to determine how far from 'loc' we can stray at this
		    // error level.
		    bin_min = 0;
		    bin_mid = bin_max;
		    while (bin_min < bin_mid) {
		      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
		        bin_min = bin_mid;
		      } else {
		        bin_max = bin_mid;
		      }
		      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
		    }
		    // Use the result from this iteration as the maximum for the next.
		    bin_max = bin_mid;
		    var start = Math.max(1, loc - bin_mid + 1);
		    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

		    var rd = Array(finish + 2);
		    rd[finish + 1] = (1 << d) - 1;
		    for (var j = finish; j >= start; j--) {
		      // The alphabet (s) is a sparse hash, so the following line generates
		      // warnings.
		      var charMatch = s[text.charAt(j - 1)];
		      if (d === 0) {  // First pass: exact match.
		        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
		      } else {  // Subsequent passes: fuzzy match.
		        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
		                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
		                last_rd[j + 1];
		      }
		      if (rd[j] & matchmask) {
		        var score = match_bitapScore_(d, j - 1);
		        // This match will almost certainly be better than any existing match.
		        // But check anyway.
		        if (score <= score_threshold) {
		          // Told you so.
		          score_threshold = score;
		          best_loc = j - 1;
		          if (best_loc > loc) {
		            // When passing loc, don't exceed our current distance from loc.
		            start = Math.max(1, 2 * loc - best_loc);
		          } else {
		            // Already passed loc, downhill from here on in.
		            break;
		          }
		        }
		      }
		    }
		    // No hope for a (better) match at greater error levels.
		    if (match_bitapScore_(d + 1, loc) > score_threshold) {
		      break;
		    }
		    last_rd = rd;
		  }
		  return best_loc;
		};


		/**
		 * Initialise the alphabet for the Bitap algorithm.
		 * @param {string} pattern The text to encode.
		 * @return {!Object} Hash of character locations.
		 * @private
		 */
		diff_match_patch.prototype.match_alphabet_ = function(pattern) {
		  var s = {};
		  for (var i = 0; i < pattern.length; i++) {
		    s[pattern.charAt(i)] = 0;
		  }
		  for (var i = 0; i < pattern.length; i++) {
		    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
		  }
		  return s;
		};


		//  PATCH FUNCTIONS


		/**
		 * Increase the context until it is unique,
		 * but don't let the pattern expand beyond Match_MaxBits.
		 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
		 * @param {string} text Source text.
		 * @private
		 */
		diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
		  if (text.length == 0) {
		    return;
		  }
		  if (patch.start2 === null) {
		    throw Error('patch not initialized');
		  }
		  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
		  var padding = 0;

		  // Look for the first and last matches of pattern in text.  If two different
		  // matches are found, increase the pattern length.
		  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
		         pattern.length < this.Match_MaxBits - this.Patch_Margin -
		         this.Patch_Margin) {
		    padding += this.Patch_Margin;
		    pattern = text.substring(patch.start2 - padding,
		                             patch.start2 + patch.length1 + padding);
		  }
		  // Add one chunk for good luck.
		  padding += this.Patch_Margin;

		  // Add the prefix.
		  var prefix = text.substring(patch.start2 - padding, patch.start2);
		  if (prefix) {
		    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
		  }
		  // Add the suffix.
		  var suffix = text.substring(patch.start2 + patch.length1,
		                              patch.start2 + patch.length1 + padding);
		  if (suffix) {
		    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
		  }

		  // Roll back the start points.
		  patch.start1 -= prefix.length;
		  patch.start2 -= prefix.length;
		  // Extend the lengths.
		  patch.length1 += prefix.length + suffix.length;
		  patch.length2 += prefix.length + suffix.length;
		};


		/**
		 * Compute a list of patches to turn text1 into text2.
		 * Use diffs if provided, otherwise compute it ourselves.
		 * There are four ways to call this function, depending on what data is
		 * available to the caller:
		 * Method 1:
		 * a = text1, b = text2
		 * Method 2:
		 * a = diffs
		 * Method 3 (optimal):
		 * a = text1, b = diffs
		 * Method 4 (deprecated, use method 3):
		 * a = text1, b = text2, c = diffs
		 *
		 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
		 * Array of diff tuples for text1 to text2 (method 2).
		 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or
		 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
		 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples
		 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
		 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
		 */
		diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
		  var text1, diffs;
		  if (typeof a == 'string' && typeof opt_b == 'string' &&
		      typeof opt_c == 'undefined') {
		    // Method 1: text1, text2
		    // Compute diffs from text1 and text2.
		    text1 = /** @type {string} */(a);
		    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
		    if (diffs.length > 2) {
		      this.diff_cleanupSemantic(diffs);
		      this.diff_cleanupEfficiency(diffs);
		    }
		  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
		      typeof opt_c == 'undefined') {
		    // Method 2: diffs
		    // Compute text1 from diffs.
		    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
		    text1 = this.diff_text1(diffs);
		  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
		      typeof opt_c == 'undefined') {
		    // Method 3: text1, diffs
		    text1 = /** @type {string} */(a);
		    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
		  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
		      opt_c && typeof opt_c == 'object') {
		    // Method 4: text1, text2, diffs
		    // text2 is not used.
		    text1 = /** @type {string} */(a);
		    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
		  } else {
		    throw new Error('Unknown call format to patch_make.');
		  }

		  if (diffs.length === 0) {
		    return [];  // Get rid of the null case.
		  }
		  var patches = [];
		  var patch = new diff_match_patch.patch_obj();
		  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
		  var char_count1 = 0;  // Number of characters into the text1 string.
		  var char_count2 = 0;  // Number of characters into the text2 string.
		  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
		  // text2 (postpatch_text).  We recreate the patches one by one to determine
		  // context info.
		  var prepatch_text = text1;
		  var postpatch_text = text1;
		  for (var x = 0; x < diffs.length; x++) {
		    var diff_type = diffs[x][0];
		    var diff_text = diffs[x][1];

		    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
		      // A new patch starts here.
		      patch.start1 = char_count1;
		      patch.start2 = char_count2;
		    }

		    switch (diff_type) {
		      case DIFF_INSERT:
		        patch.diffs[patchDiffLength++] = diffs[x];
		        patch.length2 += diff_text.length;
		        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
		                         postpatch_text.substring(char_count2);
		        break;
		      case DIFF_DELETE:
		        patch.length1 += diff_text.length;
		        patch.diffs[patchDiffLength++] = diffs[x];
		        postpatch_text = postpatch_text.substring(0, char_count2) +
		                         postpatch_text.substring(char_count2 +
		                             diff_text.length);
		        break;
		      case DIFF_EQUAL:
		        if (diff_text.length <= 2 * this.Patch_Margin &&
		            patchDiffLength && diffs.length != x + 1) {
		          // Small equality inside a patch.
		          patch.diffs[patchDiffLength++] = diffs[x];
		          patch.length1 += diff_text.length;
		          patch.length2 += diff_text.length;
		        } else if (diff_text.length >= 2 * this.Patch_Margin) {
		          // Time for a new patch.
		          if (patchDiffLength) {
		            this.patch_addContext_(patch, prepatch_text);
		            patches.push(patch);
		            patch = new diff_match_patch.patch_obj();
		            patchDiffLength = 0;
		            // Unlike Unidiff, our patch lists have a rolling context.
		            // https://github.com/google/diff-match-patch/wiki/Unidiff
		            // Update prepatch text & pos to reflect the application of the
		            // just completed patch.
		            prepatch_text = postpatch_text;
		            char_count1 = char_count2;
		          }
		        }
		        break;
		    }

		    // Update the current character count.
		    if (diff_type !== DIFF_INSERT) {
		      char_count1 += diff_text.length;
		    }
		    if (diff_type !== DIFF_DELETE) {
		      char_count2 += diff_text.length;
		    }
		  }
		  // Pick up the leftover patch if not empty.
		  if (patchDiffLength) {
		    this.patch_addContext_(patch, prepatch_text);
		    patches.push(patch);
		  }

		  return patches;
		};


		/**
		 * Given an array of patches, return another array that is identical.
		 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
		 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
		 */
		diff_match_patch.prototype.patch_deepCopy = function(patches) {
		  // Making deep copies is hard in JavaScript.
		  var patchesCopy = [];
		  for (var x = 0; x < patches.length; x++) {
		    var patch = patches[x];
		    var patchCopy = new diff_match_patch.patch_obj();
		    patchCopy.diffs = [];
		    for (var y = 0; y < patch.diffs.length; y++) {
		      patchCopy.diffs[y] =
		          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
		    }
		    patchCopy.start1 = patch.start1;
		    patchCopy.start2 = patch.start2;
		    patchCopy.length1 = patch.length1;
		    patchCopy.length2 = patch.length2;
		    patchesCopy[x] = patchCopy;
		  }
		  return patchesCopy;
		};


		/**
		 * Merge a set of patches onto the text.  Return a patched text, as well
		 * as a list of true/false values indicating which patches were applied.
		 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
		 * @param {string} text Old text.
		 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
		 *      new text and an array of boolean values.
		 */
		diff_match_patch.prototype.patch_apply = function(patches, text) {
		  if (patches.length == 0) {
		    return [text, []];
		  }

		  // Deep copy the patches so that no changes are made to originals.
		  patches = this.patch_deepCopy(patches);

		  var nullPadding = this.patch_addPadding(patches);
		  text = nullPadding + text + nullPadding;

		  this.patch_splitMax(patches);
		  // delta keeps track of the offset between the expected and actual location
		  // of the previous patch.  If there are patches expected at positions 10 and
		  // 20, but the first patch was found at 12, delta is 2 and the second patch
		  // has an effective expected position of 22.
		  var delta = 0;
		  var results = [];
		  for (var x = 0; x < patches.length; x++) {
		    var expected_loc = patches[x].start2 + delta;
		    var text1 = this.diff_text1(patches[x].diffs);
		    var start_loc;
		    var end_loc = -1;
		    if (text1.length > this.Match_MaxBits) {
		      // patch_splitMax will only provide an oversized pattern in the case of
		      // a monster delete.
		      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
		                                  expected_loc);
		      if (start_loc != -1) {
		        end_loc = this.match_main(text,
		            text1.substring(text1.length - this.Match_MaxBits),
		            expected_loc + text1.length - this.Match_MaxBits);
		        if (end_loc == -1 || start_loc >= end_loc) {
		          // Can't find valid trailing context.  Drop this patch.
		          start_loc = -1;
		        }
		      }
		    } else {
		      start_loc = this.match_main(text, text1, expected_loc);
		    }
		    if (start_loc == -1) {
		      // No match found.  :(
		      results[x] = false;
		      // Subtract the delta for this failed patch from subsequent patches.
		      delta -= patches[x].length2 - patches[x].length1;
		    } else {
		      // Found a match.  :)
		      results[x] = true;
		      delta = start_loc - expected_loc;
		      var text2;
		      if (end_loc == -1) {
		        text2 = text.substring(start_loc, start_loc + text1.length);
		      } else {
		        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
		      }
		      if (text1 == text2) {
		        // Perfect match, just shove the replacement text in.
		        text = text.substring(0, start_loc) +
		               this.diff_text2(patches[x].diffs) +
		               text.substring(start_loc + text1.length);
		      } else {
		        // Imperfect match.  Run a diff to get a framework of equivalent
		        // indices.
		        var diffs = this.diff_main(text1, text2, false);
		        if (text1.length > this.Match_MaxBits &&
		            this.diff_levenshtein(diffs) / text1.length >
		            this.Patch_DeleteThreshold) {
		          // The end points match, but the content is unacceptably bad.
		          results[x] = false;
		        } else {
		          this.diff_cleanupSemanticLossless(diffs);
		          var index1 = 0;
		          var index2;
		          for (var y = 0; y < patches[x].diffs.length; y++) {
		            var mod = patches[x].diffs[y];
		            if (mod[0] !== DIFF_EQUAL) {
		              index2 = this.diff_xIndex(diffs, index1);
		            }
		            if (mod[0] === DIFF_INSERT) {  // Insertion
		              text = text.substring(0, start_loc + index2) + mod[1] +
		                     text.substring(start_loc + index2);
		            } else if (mod[0] === DIFF_DELETE) {  // Deletion
		              text = text.substring(0, start_loc + index2) +
		                     text.substring(start_loc + this.diff_xIndex(diffs,
		                         index1 + mod[1].length));
		            }
		            if (mod[0] !== DIFF_DELETE) {
		              index1 += mod[1].length;
		            }
		          }
		        }
		      }
		    }
		  }
		  // Strip the padding off.
		  text = text.substring(nullPadding.length, text.length - nullPadding.length);
		  return [text, results];
		};


		/**
		 * Add some padding on text start and end so that edges can match something.
		 * Intended to be called only from within patch_apply.
		 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
		 * @return {string} The padding string added to each side.
		 */
		diff_match_patch.prototype.patch_addPadding = function(patches) {
		  var paddingLength = this.Patch_Margin;
		  var nullPadding = '';
		  for (var x = 1; x <= paddingLength; x++) {
		    nullPadding += String.fromCharCode(x);
		  }

		  // Bump all the patches forward.
		  for (var x = 0; x < patches.length; x++) {
		    patches[x].start1 += paddingLength;
		    patches[x].start2 += paddingLength;
		  }

		  // Add some padding on start of first diff.
		  var patch = patches[0];
		  var diffs = patch.diffs;
		  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
		    // Add nullPadding equality.
		    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
		    patch.start1 -= paddingLength;  // Should be 0.
		    patch.start2 -= paddingLength;  // Should be 0.
		    patch.length1 += paddingLength;
		    patch.length2 += paddingLength;
		  } else if (paddingLength > diffs[0][1].length) {
		    // Grow first equality.
		    var extraLength = paddingLength - diffs[0][1].length;
		    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
		    patch.start1 -= extraLength;
		    patch.start2 -= extraLength;
		    patch.length1 += extraLength;
		    patch.length2 += extraLength;
		  }

		  // Add some padding on end of last diff.
		  patch = patches[patches.length - 1];
		  diffs = patch.diffs;
		  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
		    // Add nullPadding equality.
		    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
		    patch.length1 += paddingLength;
		    patch.length2 += paddingLength;
		  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
		    // Grow last equality.
		    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
		    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
		    patch.length1 += extraLength;
		    patch.length2 += extraLength;
		  }

		  return nullPadding;
		};


		/**
		 * Look through the patches and break up any which are longer than the maximum
		 * limit of the match algorithm.
		 * Intended to be called only from within patch_apply.
		 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
		 */
		diff_match_patch.prototype.patch_splitMax = function(patches) {
		  var patch_size = this.Match_MaxBits;
		  for (var x = 0; x < patches.length; x++) {
		    if (patches[x].length1 <= patch_size) {
		      continue;
		    }
		    var bigpatch = patches[x];
		    // Remove the big old patch.
		    patches.splice(x--, 1);
		    var start1 = bigpatch.start1;
		    var start2 = bigpatch.start2;
		    var precontext = '';
		    while (bigpatch.diffs.length !== 0) {
		      // Create one of several smaller patches.
		      var patch = new diff_match_patch.patch_obj();
		      var empty = true;
		      patch.start1 = start1 - precontext.length;
		      patch.start2 = start2 - precontext.length;
		      if (precontext !== '') {
		        patch.length1 = patch.length2 = precontext.length;
		        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
		      }
		      while (bigpatch.diffs.length !== 0 &&
		             patch.length1 < patch_size - this.Patch_Margin) {
		        var diff_type = bigpatch.diffs[0][0];
		        var diff_text = bigpatch.diffs[0][1];
		        if (diff_type === DIFF_INSERT) {
		          // Insertions are harmless.
		          patch.length2 += diff_text.length;
		          start2 += diff_text.length;
		          patch.diffs.push(bigpatch.diffs.shift());
		          empty = false;
		        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
		                   patch.diffs[0][0] == DIFF_EQUAL &&
		                   diff_text.length > 2 * patch_size) {
		          // This is a large deletion.  Let it pass in one chunk.
		          patch.length1 += diff_text.length;
		          start1 += diff_text.length;
		          empty = false;
		          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
		          bigpatch.diffs.shift();
		        } else {
		          // Deletion or equality.  Only take as much as we can stomach.
		          diff_text = diff_text.substring(0,
		              patch_size - patch.length1 - this.Patch_Margin);
		          patch.length1 += diff_text.length;
		          start1 += diff_text.length;
		          if (diff_type === DIFF_EQUAL) {
		            patch.length2 += diff_text.length;
		            start2 += diff_text.length;
		          } else {
		            empty = false;
		          }
		          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
		          if (diff_text == bigpatch.diffs[0][1]) {
		            bigpatch.diffs.shift();
		          } else {
		            bigpatch.diffs[0][1] =
		                bigpatch.diffs[0][1].substring(diff_text.length);
		          }
		        }
		      }
		      // Compute the head context for the next patch.
		      precontext = this.diff_text2(patch.diffs);
		      precontext =
		          precontext.substring(precontext.length - this.Patch_Margin);
		      // Append the end context for this patch.
		      var postcontext = this.diff_text1(bigpatch.diffs)
		                            .substring(0, this.Patch_Margin);
		      if (postcontext !== '') {
		        patch.length1 += postcontext.length;
		        patch.length2 += postcontext.length;
		        if (patch.diffs.length !== 0 &&
		            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
		          patch.diffs[patch.diffs.length - 1][1] += postcontext;
		        } else {
		          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
		        }
		      }
		      if (!empty) {
		        patches.splice(++x, 0, patch);
		      }
		    }
		  }
		};


		/**
		 * Take a list of patches and return a textual representation.
		 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
		 * @return {string} Text representation of patches.
		 */
		diff_match_patch.prototype.patch_toText = function(patches) {
		  var text = [];
		  for (var x = 0; x < patches.length; x++) {
		    text[x] = patches[x];
		  }
		  return text.join('');
		};


		/**
		 * Parse a textual representation of patches and return a list of Patch objects.
		 * @param {string} textline Text representation of patches.
		 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
		 * @throws {!Error} If invalid input.
		 */
		diff_match_patch.prototype.patch_fromText = function(textline) {
		  var patches = [];
		  if (!textline) {
		    return patches;
		  }
		  var text = textline.split('\n');
		  var textPointer = 0;
		  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
		  while (textPointer < text.length) {
		    var m = text[textPointer].match(patchHeader);
		    if (!m) {
		      throw new Error('Invalid patch string: ' + text[textPointer]);
		    }
		    var patch = new diff_match_patch.patch_obj();
		    patches.push(patch);
		    patch.start1 = parseInt(m[1], 10);
		    if (m[2] === '') {
		      patch.start1--;
		      patch.length1 = 1;
		    } else if (m[2] == '0') {
		      patch.length1 = 0;
		    } else {
		      patch.start1--;
		      patch.length1 = parseInt(m[2], 10);
		    }

		    patch.start2 = parseInt(m[3], 10);
		    if (m[4] === '') {
		      patch.start2--;
		      patch.length2 = 1;
		    } else if (m[4] == '0') {
		      patch.length2 = 0;
		    } else {
		      patch.start2--;
		      patch.length2 = parseInt(m[4], 10);
		    }
		    textPointer++;

		    while (textPointer < text.length) {
		      var sign = text[textPointer].charAt(0);
		      try {
		        var line = decodeURI(text[textPointer].substring(1));
		      } catch (ex) {
		        // Malformed URI sequence.
		        throw new Error('Illegal escape in patch_fromText: ' + line);
		      }
		      if (sign == '-') {
		        // Deletion.
		        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
		      } else if (sign == '+') {
		        // Insertion.
		        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
		      } else if (sign == ' ') {
		        // Minor equality.
		        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
		      } else if (sign == '@') {
		        // Start of next patch.
		        break;
		      } else if (sign === '') ; else {
		        // WTF?
		        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
		      }
		      textPointer++;
		    }
		  }
		  return patches;
		};


		/**
		 * Class representing one patch operation.
		 * @constructor
		 */
		diff_match_patch.patch_obj = function() {
		  /** @type {!Array.<!diff_match_patch.Diff>} */
		  this.diffs = [];
		  /** @type {?number} */
		  this.start1 = null;
		  /** @type {?number} */
		  this.start2 = null;
		  /** @type {number} */
		  this.length1 = 0;
		  /** @type {number} */
		  this.length2 = 0;
		};


		/**
		 * Emulate GNU diff's format.
		 * Header: @@ -382,8 +481,9 @@
		 * Indices are printed as 1-based, not 0-based.
		 * @return {string} The GNU diff string.
		 */
		diff_match_patch.patch_obj.prototype.toString = function() {
		  var coords1, coords2;
		  if (this.length1 === 0) {
		    coords1 = this.start1 + ',0';
		  } else if (this.length1 == 1) {
		    coords1 = this.start1 + 1;
		  } else {
		    coords1 = (this.start1 + 1) + ',' + this.length1;
		  }
		  if (this.length2 === 0) {
		    coords2 = this.start2 + ',0';
		  } else if (this.length2 == 1) {
		    coords2 = this.start2 + 1;
		  } else {
		    coords2 = (this.start2 + 1) + ',' + this.length2;
		  }
		  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
		  var op;
		  // Escape the body of the patch with %xx notation.
		  for (var x = 0; x < this.diffs.length; x++) {
		    switch (this.diffs[x][0]) {
		      case DIFF_INSERT:
		        op = '+';
		        break;
		      case DIFF_DELETE:
		        op = '-';
		        break;
		      case DIFF_EQUAL:
		        op = ' ';
		        break;
		    }
		    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
		  }
		  return text.join('').replace(/%20/g, ' ');
		};


		// The following export code was added by @ForbesLindesay
		module.exports = diff_match_patch;
		module.exports['diff_match_patch'] = diff_match_patch;
		module.exports['DIFF_DELETE'] = DIFF_DELETE;
		module.exports['DIFF_INSERT'] = DIFF_INSERT;
		module.exports['DIFF_EQUAL'] = DIFF_EQUAL; 
	} (diffMatchPatch));

	var diffMatchPatchExports = diffMatchPatch.exports;
	var dmp = /*@__PURE__*/getDefaultExportFromCjs(diffMatchPatchExports);

	function cov_2pegzbuun3() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/processor.js";
	  var hash = "1cfb0b0a1af54659c6dadd028374589eb84a9867";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/processor.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 3,
	          column: 4
	        },
	        end: {
	          line: 3,
	          column: 37
	        }
	      },
	      "1": {
	        start: {
	          line: 4,
	          column: 4
	        },
	        end: {
	          line: 4,
	          column: 20
	        }
	      },
	      "2": {
	        start: {
	          line: 7,
	          column: 4
	        },
	        end: {
	          line: 9,
	          column: 5
	        }
	      },
	      "3": {
	        start: {
	          line: 8,
	          column: 6
	        },
	        end: {
	          line: 8,
	          column: 33
	        }
	      },
	      "4": {
	        start: {
	          line: 10,
	          column: 4
	        },
	        end: {
	          line: 10,
	          column: 28
	        }
	      },
	      "5": {
	        start: {
	          line: 13,
	          column: 15
	        },
	        end: {
	          line: 13,
	          column: 22
	        }
	      },
	      "6": {
	        start: {
	          line: 14,
	          column: 4
	        },
	        end: {
	          line: 20,
	          column: 5
	        }
	      },
	      "7": {
	        start: {
	          line: 15,
	          column: 6
	        },
	        end: {
	          line: 19,
	          column: 7
	        }
	      },
	      "8": {
	        start: {
	          line: 16,
	          column: 8
	        },
	        end: {
	          line: 16,
	          column: 32
	        }
	      },
	      "9": {
	        start: {
	          line: 18,
	          column: 8
	        },
	        end: {
	          line: 18,
	          column: 32
	        }
	      },
	      "10": {
	        start: {
	          line: 21,
	          column: 4
	        },
	        end: {
	          line: 27,
	          column: 5
	        }
	      },
	      "11": {
	        start: {
	          line: 22,
	          column: 6
	        },
	        end: {
	          line: 22,
	          column: 18
	        }
	      },
	      "12": {
	        start: {
	          line: 23,
	          column: 6
	        },
	        end: {
	          line: 25,
	          column: 7
	        }
	      },
	      "13": {
	        start: {
	          line: 24,
	          column: 8
	        },
	        end: {
	          line: 24,
	          column: 20
	        }
	      },
	      "14": {
	        start: {
	          line: 26,
	          column: 6
	        },
	        end: {
	          line: 26,
	          column: 35
	        }
	      },
	      "15": {
	        start: {
	          line: 28,
	          column: 4
	        },
	        end: {
	          line: 28,
	          column: 26
	        }
	      },
	      "16": {
	        start: {
	          line: 29,
	          column: 4
	        },
	        end: {
	          line: 29,
	          column: 16
	        }
	      },
	      "17": {
	        start: {
	          line: 32,
	          column: 18
	        },
	        end: {
	          line: 32,
	          column: 23
	        }
	      },
	      "18": {
	        start: {
	          line: 33,
	          column: 4
	        },
	        end: {
	          line: 33,
	          column: 37
	        }
	      },
	      "19": {
	        start: {
	          line: 34,
	          column: 19
	        },
	        end: {
	          line: 34,
	          column: 50
	        }
	      },
	      "20": {
	        start: {
	          line: 37,
	          column: 4
	        },
	        end: {
	          line: 56,
	          column: 5
	        }
	      },
	      "21": {
	        start: {
	          line: 38,
	          column: 6
	        },
	        end: {
	          line: 42,
	          column: 7
	        }
	      },
	      "22": {
	        start: {
	          line: 40,
	          column: 8
	        },
	        end: {
	          line: 40,
	          column: 49
	        }
	      },
	      "23": {
	        start: {
	          line: 41,
	          column: 8
	        },
	        end: {
	          line: 41,
	          column: 41
	        }
	      },
	      "24": {
	        start: {
	          line: 43,
	          column: 6
	        },
	        end: {
	          line: 45,
	          column: 7
	        }
	      },
	      "25": {
	        start: {
	          line: 44,
	          column: 8
	        },
	        end: {
	          line: 44,
	          column: 39
	        }
	      },
	      "26": {
	        start: {
	          line: 46,
	          column: 6
	        },
	        end: {
	          line: 46,
	          column: 32
	        }
	      },
	      "27": {
	        start: {
	          line: 47,
	          column: 6
	        },
	        end: {
	          line: 47,
	          column: 28
	        }
	      },
	      "28": {
	        start: {
	          line: 48,
	          column: 6
	        },
	        end: {
	          line: 48,
	          column: 26
	        }
	      },
	      "29": {
	        start: {
	          line: 49,
	          column: 6
	        },
	        end: {
	          line: 49,
	          column: 22
	        }
	      },
	      "30": {
	        start: {
	          line: 50,
	          column: 6
	        },
	        end: {
	          line: 55,
	          column: 7
	        }
	      },
	      "31": {
	        start: {
	          line: 51,
	          column: 8
	        },
	        end: {
	          line: 54,
	          column: 9
	        }
	      },
	      "32": {
	        start: {
	          line: 52,
	          column: 10
	        },
	        end: {
	          line: 52,
	          column: 33
	        }
	      },
	      "33": {
	        start: {
	          line: 53,
	          column: 10
	        },
	        end: {
	          line: 53,
	          column: 70
	        }
	      },
	      "34": {
	        start: {
	          line: 57,
	          column: 4
	        },
	        end: {
	          line: 57,
	          column: 58
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 2,
	            column: 2
	          },
	          end: {
	            line: 2,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 2,
	            column: 23
	          },
	          end: {
	            line: 5,
	            column: 3
	          }
	        },
	        line: 2
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 6,
	            column: 2
	          },
	          end: {
	            line: 6,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 6,
	            column: 19
	          },
	          end: {
	            line: 11,
	            column: 3
	          }
	        },
	        line: 6
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 12,
	            column: 2
	          },
	          end: {
	            line: 12,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 12,
	            column: 22
	          },
	          end: {
	            line: 30,
	            column: 3
	          }
	        },
	        line: 12
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 31,
	            column: 2
	          },
	          end: {
	            line: 31,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 31,
	            column: 23
	          },
	          end: {
	            line: 58,
	            column: 3
	          }
	        },
	        line: 31
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 3,
	            column: 23
	          },
	          end: {
	            line: 3,
	            column: 36
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 3,
	            column: 23
	          },
	          end: {
	            line: 3,
	            column: 30
	          }
	        }, {
	          start: {
	            line: 3,
	            column: 34
	          },
	          end: {
	            line: 3,
	            column: 36
	          }
	        }],
	        line: 3
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 7,
	            column: 4
	          },
	          end: {
	            line: 9,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 7,
	            column: 4
	          },
	          end: {
	            line: 9,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 7
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 14,
	            column: 4
	          },
	          end: {
	            line: 20,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 14,
	            column: 4
	          },
	          end: {
	            line: 20,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 14
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 15,
	            column: 6
	          },
	          end: {
	            line: 19,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 15,
	            column: 6
	          },
	          end: {
	            line: 19,
	            column: 7
	          }
	        }, {
	          start: {
	            line: 17,
	            column: 13
	          },
	          end: {
	            line: 19,
	            column: 7
	          }
	        }],
	        line: 15
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 21,
	            column: 4
	          },
	          end: {
	            line: 27,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 21,
	            column: 4
	          },
	          end: {
	            line: 27,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 21
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 21,
	            column: 8
	          },
	          end: {
	            line: 21,
	            column: 25
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 21,
	            column: 8
	          },
	          end: {
	            line: 21,
	            column: 12
	          }
	        }, {
	          start: {
	            line: 21,
	            column: 16
	          },
	          end: {
	            line: 21,
	            column: 25
	          }
	        }],
	        line: 21
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 23,
	            column: 6
	          },
	          end: {
	            line: 25,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 23,
	            column: 6
	          },
	          end: {
	            line: 25,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 23
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 34,
	            column: 19
	          },
	          end: {
	            line: 34,
	            column: 50
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 34,
	            column: 19
	          },
	          end: {
	            line: 34,
	            column: 23
	          }
	        }, {
	          start: {
	            line: 34,
	            column: 27
	          },
	          end: {
	            line: 34,
	            column: 37
	          }
	        }, {
	          start: {
	            line: 34,
	            column: 41
	          },
	          end: {
	            line: 34,
	            column: 50
	          }
	        }],
	        line: 34
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 38,
	            column: 6
	          },
	          end: {
	            line: 42,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 38,
	            column: 6
	          },
	          end: {
	            line: 42,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 38
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 43,
	            column: 6
	          },
	          end: {
	            line: 45,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 43,
	            column: 6
	          },
	          end: {
	            line: 45,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 43
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 50,
	            column: 6
	          },
	          end: {
	            line: 55,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 50,
	            column: 6
	          },
	          end: {
	            line: 55,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 50
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 51,
	            column: 8
	          },
	          end: {
	            line: 54,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 51,
	            column: 8
	          },
	          end: {
	            line: 54,
	            column: 9
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 51
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 53,
	            column: 21
	          },
	          end: {
	            line: 53,
	            column: 69
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 53,
	            column: 21
	          },
	          end: {
	            line: 53,
	            column: 41
	          }
	        }, {
	          start: {
	            line: 53,
	            column: 45
	          },
	          end: {
	            line: 53,
	            column: 57
	          }
	        }, {
	          start: {
	            line: 53,
	            column: 61
	          },
	          end: {
	            line: 53,
	            column: 69
	          }
	        }],
	        line: 53
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 57,
	            column: 11
	          },
	          end: {
	            line: 57,
	            column: 57
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 57,
	            column: 31
	          },
	          end: {
	            line: 57,
	            column: 45
	          }
	        }, {
	          start: {
	            line: 57,
	            column: 48
	          },
	          end: {
	            line: 57,
	            column: 57
	          }
	        }],
	        line: 57
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0, 0],
	      "8": [0, 0],
	      "9": [0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0, 0],
	      "13": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/processor.js"],
	      sourcesContent: ["class Processor {\n  constructor(options) {\n    this.selfOptions = options || {};\n    this.pipes = {};\n  }\n\n  options(options) {\n    if (options) {\n      this.selfOptions = options;\n    }\n    return this.selfOptions;\n  }\n\n  pipe(name, pipeArg) {\n    let pipe = pipeArg;\n    if (typeof name === 'string') {\n      if (typeof pipe === 'undefined') {\n        return this.pipes[name];\n      } else {\n        this.pipes[name] = pipe;\n      }\n    }\n    if (name && name.name) {\n      pipe = name;\n      if (pipe.processor === this) {\n        return pipe;\n      }\n      this.pipes[pipe.name] = pipe;\n    }\n    pipe.processor = this;\n    return pipe;\n  }\n\n  process(input, pipe) {\n    let context = input;\n    context.options = this.options();\n    let nextPipe = pipe || input.pipe || 'default';\n    let lastPipe;\n    let lastContext;\n    while (nextPipe) {\n      if (typeof context.nextAfterChildren !== 'undefined') {\n        // children processed and coming back to parent\n        context.next = context.nextAfterChildren;\n        context.nextAfterChildren = null;\n      }\n\n      if (typeof nextPipe === 'string') {\n        nextPipe = this.pipe(nextPipe);\n      }\n      nextPipe.process(context);\n      lastContext = context;\n      lastPipe = nextPipe;\n      nextPipe = null;\n      if (context) {\n        if (context.next) {\n          context = context.next;\n          nextPipe = lastContext.nextPipe || context.pipe || lastPipe;\n        }\n      }\n    }\n    return context.hasResult ? context.result : undefined;\n  }\n}\n\nexport default Processor;\n"],
	      names: ["Processor", "constructor", "options", "selfOptions", "pipes", "pipe", "name", "pipeArg", "processor", "process", "input", "context", "nextPipe", "lastPipe", "lastContext", "nextAfterChildren", "next", "hasResult", "result", "undefined"],
	      mappings: "AAAA,MAAMA,SAAS,CAAC;EACdC,WAAWA,CAACC,OAAO,EAAE;IACnB,IAAI,CAACC,WAAW,GAAGD,OAAO,IAAI,CAAC,CAAC;IAChC,IAAI,CAACE,KAAK,GAAG,CAAC,CAAC;EACjB;EAEAF,OAAOA,CAACA,OAAO,EAAE;IACf,IAAIA,OAAO,EAAE;MACX,IAAI,CAACC,WAAW,GAAGD,OAAO;IAC5B;IACA,OAAO,IAAI,CAACC,WAAW;EACzB;EAEAE,IAAIA,CAACC,IAAI,EAAEC,OAAO,EAAE;IAClB,IAAIF,IAAI,GAAGE,OAAO;IAClB,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;MAC5B,IAAI,OAAOD,IAAI,KAAK,WAAW,EAAE;QAC/B,OAAO,IAAI,CAACD,KAAK,CAACE,IAAI,CAAC;MACzB,CAAC,MAAM;QACL,IAAI,CAACF,KAAK,CAACE,IAAI,CAAC,GAAGD,IAAI;MACzB;IACF;IACA,IAAIC,IAAI,IAAIA,IAAI,CAACA,IAAI,EAAE;MACrBD,IAAI,GAAGC,IAAI;MACX,IAAID,IAAI,CAACG,SAAS,KAAK,IAAI,EAAE;QAC3B,OAAOH,IAAI;MACb;MACA,IAAI,CAACD,KAAK,CAACC,IAAI,CAACC,IAAI,CAAC,GAAGD,IAAI;IAC9B;IACAA,IAAI,CAACG,SAAS,GAAG,IAAI;IACrB,OAAOH,IAAI;EACb;EAEAI,OAAOA,CAACC,KAAK,EAAEL,IAAI,EAAE;IACnB,IAAIM,OAAO,GAAGD,KAAK;IACnBC,OAAO,CAACT,OAAO,GAAG,IAAI,CAACA,OAAO,CAAC,CAAC;IAChC,IAAIU,QAAQ,GAAGP,IAAI,IAAIK,KAAK,CAACL,IAAI,IAAI,SAAS;IAC9C,IAAIQ,QAAQ;IACZ,IAAIC,WAAW;IACf,OAAOF,QAAQ,EAAE;MACf,IAAI,OAAOD,OAAO,CAACI,iBAAiB,KAAK,WAAW,EAAE;QACpD;QACAJ,OAAO,CAACK,IAAI,GAAGL,OAAO,CAACI,iBAAiB;QACxCJ,OAAO,CAACI,iBAAiB,GAAG,IAAI;MAClC;MAEA,IAAI,OAAOH,QAAQ,KAAK,QAAQ,EAAE;QAChCA,QAAQ,GAAG,IAAI,CAACP,IAAI,CAACO,QAAQ,CAAC;MAChC;MACAA,QAAQ,CAACH,OAAO,CAACE,OAAO,CAAC;MACzBG,WAAW,GAAGH,OAAO;MACrBE,QAAQ,GAAGD,QAAQ;MACnBA,QAAQ,GAAG,IAAI;MACf,IAAID,OAAO,EAAE;QACX,IAAIA,OAAO,CAACK,IAAI,EAAE;UAChBL,OAAO,GAAGA,OAAO,CAACK,IAAI;UACtBJ,QAAQ,GAAGE,WAAW,CAACF,QAAQ,IAAID,OAAO,CAACN,IAAI,IAAIQ,QAAQ;QAC7D;MACF;IACF;IACA,OAAOF,OAAO,CAACM,SAAS,GAAGN,OAAO,CAACO,MAAM,GAAGC,SAAS;EACvD;AACF;AAEA,eAAenB,SAAS",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "1cfb0b0a1af54659c6dadd028374589eb84a9867"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_2pegzbuun3 = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_2pegzbuun3();
	class Processor {
	  constructor(options) {
	    cov_2pegzbuun3().f[0]++;
	    cov_2pegzbuun3().s[0]++;
	    this.selfOptions = (cov_2pegzbuun3().b[0][0]++, options) || (cov_2pegzbuun3().b[0][1]++, {});
	    cov_2pegzbuun3().s[1]++;
	    this.pipes = {};
	  }
	  options(options) {
	    cov_2pegzbuun3().f[1]++;
	    cov_2pegzbuun3().s[2]++;
	    if (options) {
	      cov_2pegzbuun3().b[1][0]++;
	      cov_2pegzbuun3().s[3]++;
	      this.selfOptions = options;
	    } else {
	      cov_2pegzbuun3().b[1][1]++;
	    }
	    cov_2pegzbuun3().s[4]++;
	    return this.selfOptions;
	  }
	  pipe(name, pipeArg) {
	    cov_2pegzbuun3().f[2]++;
	    let pipe = (cov_2pegzbuun3().s[5]++, pipeArg);
	    cov_2pegzbuun3().s[6]++;
	    if (typeof name === 'string') {
	      cov_2pegzbuun3().b[2][0]++;
	      cov_2pegzbuun3().s[7]++;
	      if (typeof pipe === 'undefined') {
	        cov_2pegzbuun3().b[3][0]++;
	        cov_2pegzbuun3().s[8]++;
	        return this.pipes[name];
	      } else {
	        cov_2pegzbuun3().b[3][1]++;
	        cov_2pegzbuun3().s[9]++;
	        this.pipes[name] = pipe;
	      }
	    } else {
	      cov_2pegzbuun3().b[2][1]++;
	    }
	    cov_2pegzbuun3().s[10]++;
	    if ((cov_2pegzbuun3().b[5][0]++, name) && (cov_2pegzbuun3().b[5][1]++, name.name)) {
	      cov_2pegzbuun3().b[4][0]++;
	      cov_2pegzbuun3().s[11]++;
	      pipe = name;
	      cov_2pegzbuun3().s[12]++;
	      if (pipe.processor === this) {
	        cov_2pegzbuun3().b[6][0]++;
	        cov_2pegzbuun3().s[13]++;
	        return pipe;
	      } else {
	        cov_2pegzbuun3().b[6][1]++;
	      }
	      cov_2pegzbuun3().s[14]++;
	      this.pipes[pipe.name] = pipe;
	    } else {
	      cov_2pegzbuun3().b[4][1]++;
	    }
	    cov_2pegzbuun3().s[15]++;
	    pipe.processor = this;
	    cov_2pegzbuun3().s[16]++;
	    return pipe;
	  }
	  process(input, pipe) {
	    cov_2pegzbuun3().f[3]++;
	    let context = (cov_2pegzbuun3().s[17]++, input);
	    cov_2pegzbuun3().s[18]++;
	    context.options = this.options();
	    let nextPipe = (cov_2pegzbuun3().s[19]++, (cov_2pegzbuun3().b[7][0]++, pipe) || (cov_2pegzbuun3().b[7][1]++, input.pipe) || (cov_2pegzbuun3().b[7][2]++, 'default'));
	    let lastPipe;
	    let lastContext;
	    cov_2pegzbuun3().s[20]++;
	    while (nextPipe) {
	      cov_2pegzbuun3().s[21]++;
	      if (typeof context.nextAfterChildren !== 'undefined') {
	        cov_2pegzbuun3().b[8][0]++;
	        cov_2pegzbuun3().s[22]++; // children processed and coming back to parent
	        context.next = context.nextAfterChildren;
	        cov_2pegzbuun3().s[23]++;
	        context.nextAfterChildren = null;
	      } else {
	        cov_2pegzbuun3().b[8][1]++;
	      }
	      cov_2pegzbuun3().s[24]++;
	      if (typeof nextPipe === 'string') {
	        cov_2pegzbuun3().b[9][0]++;
	        cov_2pegzbuun3().s[25]++;
	        nextPipe = this.pipe(nextPipe);
	      } else {
	        cov_2pegzbuun3().b[9][1]++;
	      }
	      cov_2pegzbuun3().s[26]++;
	      nextPipe.process(context);
	      cov_2pegzbuun3().s[27]++;
	      lastContext = context;
	      cov_2pegzbuun3().s[28]++;
	      lastPipe = nextPipe;
	      cov_2pegzbuun3().s[29]++;
	      nextPipe = null;
	      cov_2pegzbuun3().s[30]++;
	      if (context) {
	        cov_2pegzbuun3().b[10][0]++;
	        cov_2pegzbuun3().s[31]++;
	        if (context.next) {
	          cov_2pegzbuun3().b[11][0]++;
	          cov_2pegzbuun3().s[32]++;
	          context = context.next;
	          cov_2pegzbuun3().s[33]++;
	          nextPipe = (cov_2pegzbuun3().b[12][0]++, lastContext.nextPipe) || (cov_2pegzbuun3().b[12][1]++, context.pipe) || (cov_2pegzbuun3().b[12][2]++, lastPipe);
	        } else {
	          cov_2pegzbuun3().b[11][1]++;
	        }
	      } else {
	        cov_2pegzbuun3().b[10][1]++;
	      }
	    }
	    cov_2pegzbuun3().s[34]++;
	    return context.hasResult ? (cov_2pegzbuun3().b[13][0]++, context.result) : (cov_2pegzbuun3().b[13][1]++, undefined);
	  }
	}
	function cov_2rrdnqfb4a() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/pipe.js";
	  var hash = "53a6154e5891f92143377ee62fc5794709013162";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/pipe.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 3,
	          column: 4
	        },
	        end: {
	          line: 3,
	          column: 21
	        }
	      },
	      "1": {
	        start: {
	          line: 4,
	          column: 4
	        },
	        end: {
	          line: 4,
	          column: 22
	        }
	      },
	      "2": {
	        start: {
	          line: 7,
	          column: 4
	        },
	        end: {
	          line: 9,
	          column: 5
	        }
	      },
	      "3": {
	        start: {
	          line: 8,
	          column: 6
	        },
	        end: {
	          line: 8,
	          column: 70
	        }
	      },
	      "4": {
	        start: {
	          line: 10,
	          column: 18
	        },
	        end: {
	          line: 10,
	          column: 28
	        }
	      },
	      "5": {
	        start: {
	          line: 11,
	          column: 19
	        },
	        end: {
	          line: 11,
	          column: 38
	        }
	      },
	      "6": {
	        start: {
	          line: 12,
	          column: 20
	        },
	        end: {
	          line: 12,
	          column: 25
	        }
	      },
	      "7": {
	        start: {
	          line: 13,
	          column: 4
	        },
	        end: {
	          line: 23,
	          column: 5
	        }
	      },
	      "8": {
	        start: {
	          line: 13,
	          column: 21
	        },
	        end: {
	          line: 13,
	          column: 22
	        }
	      },
	      "9": {
	        start: {
	          line: 14,
	          column: 21
	        },
	        end: {
	          line: 14,
	          column: 40
	        }
	      },
	      "10": {
	        start: {
	          line: 15,
	          column: 6
	        },
	        end: {
	          line: 17,
	          column: 7
	        }
	      },
	      "11": {
	        start: {
	          line: 16,
	          column: 8
	        },
	        end: {
	          line: 16,
	          column: 49
	        }
	      },
	      "12": {
	        start: {
	          line: 18,
	          column: 6
	        },
	        end: {
	          line: 18,
	          column: 22
	        }
	      },
	      "13": {
	        start: {
	          line: 19,
	          column: 6
	        },
	        end: {
	          line: 22,
	          column: 7
	        }
	      },
	      "14": {
	        start: {
	          line: 20,
	          column: 8
	        },
	        end: {
	          line: 20,
	          column: 32
	        }
	      },
	      "15": {
	        start: {
	          line: 21,
	          column: 8
	        },
	        end: {
	          line: 21,
	          column: 14
	        }
	      },
	      "16": {
	        start: {
	          line: 24,
	          column: 4
	        },
	        end: {
	          line: 26,
	          column: 5
	        }
	      },
	      "17": {
	        start: {
	          line: 25,
	          column: 6
	        },
	        end: {
	          line: 25,
	          column: 32
	        }
	      },
	      "18": {
	        start: {
	          line: 29,
	          column: 4
	        },
	        end: {
	          line: 29,
	          column: 61
	        }
	      },
	      "19": {
	        start: {
	          line: 32,
	          column: 4
	        },
	        end: {
	          line: 32,
	          column: 36
	        }
	      },
	      "20": {
	        start: {
	          line: 33,
	          column: 4
	        },
	        end: {
	          line: 33,
	          column: 16
	        }
	      },
	      "21": {
	        start: {
	          line: 36,
	          column: 4
	        },
	        end: {
	          line: 36,
	          column: 39
	        }
	      },
	      "22": {
	        start: {
	          line: 37,
	          column: 4
	        },
	        end: {
	          line: 37,
	          column: 16
	        }
	      },
	      "23": {
	        start: {
	          line: 40,
	          column: 4
	        },
	        end: {
	          line: 42,
	          column: 5
	        }
	      },
	      "24": {
	        start: {
	          line: 41,
	          column: 6
	        },
	        end: {
	          line: 41,
	          column: 51
	        }
	      },
	      "25": {
	        start: {
	          line: 43,
	          column: 4
	        },
	        end: {
	          line: 48,
	          column: 5
	        }
	      },
	      "26": {
	        start: {
	          line: 43,
	          column: 21
	        },
	        end: {
	          line: 43,
	          column: 22
	        }
	      },
	      "27": {
	        start: {
	          line: 44,
	          column: 21
	        },
	        end: {
	          line: 44,
	          column: 40
	        }
	      },
	      "28": {
	        start: {
	          line: 45,
	          column: 6
	        },
	        end: {
	          line: 47,
	          column: 7
	        }
	      },
	      "29": {
	        start: {
	          line: 46,
	          column: 8
	        },
	        end: {
	          line: 46,
	          column: 21
	        }
	      },
	      "30": {
	        start: {
	          line: 49,
	          column: 4
	        },
	        end: {
	          line: 49,
	          column: 55
	        }
	      },
	      "31": {
	        start: {
	          line: 52,
	          column: 4
	        },
	        end: {
	          line: 52,
	          column: 47
	        }
	      },
	      "32": {
	        start: {
	          line: 52,
	          column: 33
	        },
	        end: {
	          line: 52,
	          column: 45
	        }
	      },
	      "33": {
	        start: {
	          line: 55,
	          column: 18
	        },
	        end: {
	          line: 55,
	          column: 42
	        }
	      },
	      "34": {
	        start: {
	          line: 56,
	          column: 19
	        },
	        end: {
	          line: 56,
	          column: 59
	        }
	      },
	      "35": {
	        start: {
	          line: 57,
	          column: 4
	        },
	        end: {
	          line: 59,
	          column: 5
	        }
	      },
	      "36": {
	        start: {
	          line: 58,
	          column: 6
	        },
	        end: {
	          line: 58,
	          column: 46
	        }
	      },
	      "37": {
	        start: {
	          line: 60,
	          column: 4
	        },
	        end: {
	          line: 60,
	          column: 33
	        }
	      },
	      "38": {
	        start: {
	          line: 61,
	          column: 4
	        },
	        end: {
	          line: 61,
	          column: 55
	        }
	      },
	      "39": {
	        start: {
	          line: 62,
	          column: 4
	        },
	        end: {
	          line: 62,
	          column: 16
	        }
	      },
	      "40": {
	        start: {
	          line: 65,
	          column: 18
	        },
	        end: {
	          line: 65,
	          column: 42
	        }
	      },
	      "41": {
	        start: {
	          line: 66,
	          column: 19
	        },
	        end: {
	          line: 66,
	          column: 59
	        }
	      },
	      "42": {
	        start: {
	          line: 67,
	          column: 4
	        },
	        end: {
	          line: 69,
	          column: 5
	        }
	      },
	      "43": {
	        start: {
	          line: 68,
	          column: 6
	        },
	        end: {
	          line: 68,
	          column: 46
	        }
	      },
	      "44": {
	        start: {
	          line: 70,
	          column: 4
	        },
	        end: {
	          line: 70,
	          column: 29
	        }
	      },
	      "45": {
	        start: {
	          line: 71,
	          column: 4
	        },
	        end: {
	          line: 71,
	          column: 55
	        }
	      },
	      "46": {
	        start: {
	          line: 72,
	          column: 4
	        },
	        end: {
	          line: 72,
	          column: 16
	        }
	      },
	      "47": {
	        start: {
	          line: 75,
	          column: 18
	        },
	        end: {
	          line: 75,
	          column: 42
	        }
	      },
	      "48": {
	        start: {
	          line: 76,
	          column: 19
	        },
	        end: {
	          line: 76,
	          column: 59
	        }
	      },
	      "49": {
	        start: {
	          line: 77,
	          column: 4
	        },
	        end: {
	          line: 79,
	          column: 5
	        }
	      },
	      "50": {
	        start: {
	          line: 78,
	          column: 6
	        },
	        end: {
	          line: 78,
	          column: 46
	        }
	      },
	      "51": {
	        start: {
	          line: 80,
	          column: 4
	        },
	        end: {
	          line: 80,
	          column: 29
	        }
	      },
	      "52": {
	        start: {
	          line: 81,
	          column: 4
	        },
	        end: {
	          line: 81,
	          column: 55
	        }
	      },
	      "53": {
	        start: {
	          line: 82,
	          column: 4
	        },
	        end: {
	          line: 82,
	          column: 16
	        }
	      },
	      "54": {
	        start: {
	          line: 85,
	          column: 18
	        },
	        end: {
	          line: 85,
	          column: 42
	        }
	      },
	      "55": {
	        start: {
	          line: 86,
	          column: 4
	        },
	        end: {
	          line: 86,
	          column: 34
	        }
	      },
	      "56": {
	        start: {
	          line: 87,
	          column: 4
	        },
	        end: {
	          line: 87,
	          column: 16
	        }
	      },
	      "57": {
	        start: {
	          line: 90,
	          column: 4
	        },
	        end: {
	          line: 90,
	          column: 28
	        }
	      },
	      "58": {
	        start: {
	          line: 91,
	          column: 4
	        },
	        end: {
	          line: 91,
	          column: 16
	        }
	      },
	      "59": {
	        start: {
	          line: 94,
	          column: 4
	        },
	        end: {
	          line: 97,
	          column: 5
	        }
	      },
	      "60": {
	        start: {
	          line: 95,
	          column: 6
	        },
	        end: {
	          line: 95,
	          column: 30
	        }
	      },
	      "61": {
	        start: {
	          line: 96,
	          column: 6
	        },
	        end: {
	          line: 96,
	          column: 13
	        }
	      },
	      "62": {
	        start: {
	          line: 98,
	          column: 4
	        },
	        end: {
	          line: 100,
	          column: 5
	        }
	      },
	      "63": {
	        start: {
	          line: 99,
	          column: 6
	        },
	        end: {
	          line: 99,
	          column: 13
	        }
	      },
	      "64": {
	        start: {
	          line: 101,
	          column: 17
	        },
	        end: {
	          line: 101,
	          column: 21
	        }
	      },
	      "65": {
	        start: {
	          line: 102,
	          column: 4
	        },
	        end: {
	          line: 109,
	          column: 6
	        }
	      },
	      "66": {
	        start: {
	          line: 103,
	          column: 6
	        },
	        end: {
	          line: 108,
	          column: 7
	        }
	      },
	      "67": {
	        start: {
	          line: 104,
	          column: 8
	        },
	        end: {
	          line: 104,
	          column: 29
	        }
	      },
	      "68": {
	        start: {
	          line: 105,
	          column: 22
	        },
	        end: {
	          line: 105,
	          column: 54
	        }
	      },
	      "69": {
	        start: {
	          line: 106,
	          column: 8
	        },
	        end: {
	          line: 106,
	          column: 30
	        }
	      },
	      "70": {
	        start: {
	          line: 107,
	          column: 8
	        },
	        end: {
	          line: 107,
	          column: 20
	        }
	      },
	      "71": {
	        start: {
	          line: 110,
	          column: 4
	        },
	        end: {
	          line: 110,
	          column: 16
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 2,
	            column: 2
	          },
	          end: {
	            line: 2,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 2,
	            column: 20
	          },
	          end: {
	            line: 5,
	            column: 3
	          }
	        },
	        line: 2
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 6,
	            column: 2
	          },
	          end: {
	            line: 6,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 6,
	            column: 17
	          },
	          end: {
	            line: 27,
	            column: 3
	          }
	        },
	        line: 6
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 28,
	            column: 2
	          },
	          end: {
	            line: 28,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 28,
	            column: 11
	          },
	          end: {
	            line: 30,
	            column: 3
	          }
	        },
	        line: 28
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 31,
	            column: 2
	          },
	          end: {
	            line: 31,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 31,
	            column: 11
	          },
	          end: {
	            line: 34,
	            column: 3
	          }
	        },
	        line: 31
	      },
	      "4": {
	        name: "(anonymous_4)",
	        decl: {
	          start: {
	            line: 35,
	            column: 2
	          },
	          end: {
	            line: 35,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 35,
	            column: 12
	          },
	          end: {
	            line: 38,
	            column: 3
	          }
	        },
	        line: 35
	      },
	      "5": {
	        name: "(anonymous_5)",
	        decl: {
	          start: {
	            line: 39,
	            column: 2
	          },
	          end: {
	            line: 39,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 39,
	            column: 22
	          },
	          end: {
	            line: 50,
	            column: 3
	          }
	        },
	        line: 39
	      },
	      "6": {
	        name: "(anonymous_6)",
	        decl: {
	          start: {
	            line: 51,
	            column: 2
	          },
	          end: {
	            line: 51,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 51,
	            column: 9
	          },
	          end: {
	            line: 53,
	            column: 3
	          }
	        },
	        line: 51
	      },
	      "7": {
	        name: "(anonymous_7)",
	        decl: {
	          start: {
	            line: 52,
	            column: 28
	          },
	          end: {
	            line: 52,
	            column: 29
	          }
	        },
	        loc: {
	          start: {
	            line: 52,
	            column: 33
	          },
	          end: {
	            line: 52,
	            column: 45
	          }
	        },
	        line: 52
	      },
	      "8": {
	        name: "(anonymous_8)",
	        decl: {
	          start: {
	            line: 54,
	            column: 2
	          },
	          end: {
	            line: 54,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 54,
	            column: 20
	          },
	          end: {
	            line: 63,
	            column: 3
	          }
	        },
	        line: 54
	      },
	      "9": {
	        name: "(anonymous_9)",
	        decl: {
	          start: {
	            line: 64,
	            column: 2
	          },
	          end: {
	            line: 64,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 64,
	            column: 21
	          },
	          end: {
	            line: 73,
	            column: 3
	          }
	        },
	        line: 64
	      },
	      "10": {
	        name: "(anonymous_10)",
	        decl: {
	          start: {
	            line: 74,
	            column: 2
	          },
	          end: {
	            line: 74,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 74,
	            column: 22
	          },
	          end: {
	            line: 83,
	            column: 3
	          }
	        },
	        line: 74
	      },
	      "11": {
	        name: "(anonymous_11)",
	        decl: {
	          start: {
	            line: 84,
	            column: 2
	          },
	          end: {
	            line: 84,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 84,
	            column: 21
	          },
	          end: {
	            line: 88,
	            column: 3
	          }
	        },
	        line: 84
	      },
	      "12": {
	        name: "(anonymous_12)",
	        decl: {
	          start: {
	            line: 89,
	            column: 2
	          },
	          end: {
	            line: 89,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 89,
	            column: 10
	          },
	          end: {
	            line: 92,
	            column: 3
	          }
	        },
	        line: 89
	      },
	      "13": {
	        name: "(anonymous_13)",
	        decl: {
	          start: {
	            line: 93,
	            column: 2
	          },
	          end: {
	            line: 93,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 93,
	            column: 27
	          },
	          end: {
	            line: 111,
	            column: 3
	          }
	        },
	        line: 93
	      },
	      "14": {
	        name: "(anonymous_14)",
	        decl: {
	          start: {
	            line: 102,
	            column: 23
	          },
	          end: {
	            line: 102,
	            column: 24
	          }
	        },
	        loc: {
	          start: {
	            line: 102,
	            column: 34
	          },
	          end: {
	            line: 109,
	            column: 5
	          }
	        },
	        line: 102
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 7,
	            column: 4
	          },
	          end: {
	            line: 9,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 7,
	            column: 4
	          },
	          end: {
	            line: 9,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 7
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 15,
	            column: 6
	          },
	          end: {
	            line: 17,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 15,
	            column: 6
	          },
	          end: {
	            line: 17,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 15
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 19,
	            column: 6
	          },
	          end: {
	            line: 22,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 19,
	            column: 6
	          },
	          end: {
	            line: 22,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 19
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 19,
	            column: 10
	          },
	          end: {
	            line: 19,
	            column: 56
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 19,
	            column: 10
	          },
	          end: {
	            line: 19,
	            column: 37
	          }
	        }, {
	          start: {
	            line: 19,
	            column: 41
	          },
	          end: {
	            line: 19,
	            column: 56
	          }
	        }],
	        line: 19
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 24,
	            column: 4
	          },
	          end: {
	            line: 26,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 24,
	            column: 4
	          },
	          end: {
	            line: 26,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 24
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 24,
	            column: 8
	          },
	          end: {
	            line: 24,
	            column: 41
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 24,
	            column: 8
	          },
	          end: {
	            line: 24,
	            column: 21
	          }
	        }, {
	          start: {
	            line: 24,
	            column: 25
	          },
	          end: {
	            line: 24,
	            column: 41
	          }
	        }],
	        line: 24
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 40,
	            column: 4
	          },
	          end: {
	            line: 42,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 40,
	            column: 4
	          },
	          end: {
	            line: 42,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 40
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 45,
	            column: 6
	          },
	          end: {
	            line: 47,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 45,
	            column: 6
	          },
	          end: {
	            line: 47,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 45
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 57,
	            column: 4
	          },
	          end: {
	            line: 59,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 57,
	            column: 4
	          },
	          end: {
	            line: 59,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 57
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 67,
	            column: 4
	          },
	          end: {
	            line: 69,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 67,
	            column: 4
	          },
	          end: {
	            line: 69,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 67
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 77,
	            column: 4
	          },
	          end: {
	            line: 79,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 77,
	            column: 4
	          },
	          end: {
	            line: 79,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 77
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 94,
	            column: 4
	          },
	          end: {
	            line: 97,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 94,
	            column: 4
	          },
	          end: {
	            line: 97,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 94
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 98,
	            column: 4
	          },
	          end: {
	            line: 100,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 98,
	            column: 4
	          },
	          end: {
	            line: 100,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 98
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 103,
	            column: 6
	          },
	          end: {
	            line: 108,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 103,
	            column: 6
	          },
	          end: {
	            line: 108,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 103
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0],
	      "8": [0, 0],
	      "9": [0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0],
	      "13": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/pipe.js"],
	      sourcesContent: ["class Pipe {\n  constructor(name) {\n    this.name = name;\n    this.filters = [];\n  }\n\n  process(input) {\n    if (!this.processor) {\n      throw new Error('add this pipe to a processor before using it');\n    }\n    const debug = this.debug;\n    const length = this.filters.length;\n    const context = input;\n    for (let index = 0; index < length; index++) {\n      const filter = this.filters[index];\n      if (debug) {\n        this.log(`filter: ${filter.filterName}`);\n      }\n      filter(context);\n      if (typeof context === 'object' && context.exiting) {\n        context.exiting = false;\n        break;\n      }\n    }\n    if (!context.next && this.resultCheck) {\n      this.resultCheck(context);\n    }\n  }\n\n  log(msg) {\n    console.log(`[jsondiffpatch] ${this.name} pipe, ${msg}`);\n  }\n\n  append(...args) {\n    this.filters.push(...args);\n    return this;\n  }\n\n  prepend(...args) {\n    this.filters.unshift(...args);\n    return this;\n  }\n\n  indexOf(filterName) {\n    if (!filterName) {\n      throw new Error('a filter name is required');\n    }\n    for (let index = 0; index < this.filters.length; index++) {\n      const filter = this.filters[index];\n      if (filter.filterName === filterName) {\n        return index;\n      }\n    }\n    throw new Error(`filter not found: ${filterName}`);\n  }\n\n  list() {\n    return this.filters.map(f => f.filterName);\n  }\n\n  after(filterName) {\n    const index = this.indexOf(filterName);\n    const params = Array.prototype.slice.call(arguments, 1);\n    if (!params.length) {\n      throw new Error('a filter is required');\n    }\n    params.unshift(index + 1, 0);\n    Array.prototype.splice.apply(this.filters, params);\n    return this;\n  }\n\n  before(filterName) {\n    const index = this.indexOf(filterName);\n    const params = Array.prototype.slice.call(arguments, 1);\n    if (!params.length) {\n      throw new Error('a filter is required');\n    }\n    params.unshift(index, 0);\n    Array.prototype.splice.apply(this.filters, params);\n    return this;\n  }\n\n  replace(filterName) {\n    const index = this.indexOf(filterName);\n    const params = Array.prototype.slice.call(arguments, 1);\n    if (!params.length) {\n      throw new Error('a filter is required');\n    }\n    params.unshift(index, 1);\n    Array.prototype.splice.apply(this.filters, params);\n    return this;\n  }\n\n  remove(filterName) {\n    const index = this.indexOf(filterName);\n    this.filters.splice(index, 1);\n    return this;\n  }\n\n  clear() {\n    this.filters.length = 0;\n    return this;\n  }\n\n  shouldHaveResult(should) {\n    if (should === false) {\n      this.resultCheck = null;\n      return;\n    }\n    if (this.resultCheck) {\n      return;\n    }\n    const pipe = this;\n    this.resultCheck = context => {\n      if (!context.hasResult) {\n        console.log(context);\n        const error = new Error(`${pipe.name} failed`);\n        error.noResult = true;\n        throw error;\n      }\n    };\n    return this;\n  }\n}\n\nexport default Pipe;\n"],
	      names: ["Pipe", "constructor", "name", "filters", "process", "input", "processor", "Error", "debug", "length", "context", "index", "filter", "log", "filterName", "exiting", "next", "resultCheck", "msg", "console", "append", "push", "arguments", "prepend", "unshift", "indexOf", "list", "map", "f", "after", "params", "Array", "prototype", "slice", "call", "splice", "apply", "before", "replace", "remove", "clear", "shouldHaveResult", "should", "pipe", "hasResult", "error", "noResult"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "53a6154e5891f92143377ee62fc5794709013162"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_2rrdnqfb4a = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_2rrdnqfb4a();
	class Pipe {
	  constructor(name) {
	    cov_2rrdnqfb4a().f[0]++;
	    cov_2rrdnqfb4a().s[0]++;
	    this.name = name;
	    cov_2rrdnqfb4a().s[1]++;
	    this.filters = [];
	  }
	  process(input) {
	    cov_2rrdnqfb4a().f[1]++;
	    cov_2rrdnqfb4a().s[2]++;
	    if (!this.processor) {
	      cov_2rrdnqfb4a().b[0][0]++;
	      cov_2rrdnqfb4a().s[3]++;
	      throw new Error('add this pipe to a processor before using it');
	    } else {
	      cov_2rrdnqfb4a().b[0][1]++;
	    }
	    const debug = (cov_2rrdnqfb4a().s[4]++, this.debug);
	    const length = (cov_2rrdnqfb4a().s[5]++, this.filters.length);
	    const context = (cov_2rrdnqfb4a().s[6]++, input);
	    cov_2rrdnqfb4a().s[7]++;
	    for (let index = (cov_2rrdnqfb4a().s[8]++, 0); index < length; index++) {
	      const filter = (cov_2rrdnqfb4a().s[9]++, this.filters[index]);
	      cov_2rrdnqfb4a().s[10]++;
	      if (debug) {
	        cov_2rrdnqfb4a().b[1][0]++;
	        cov_2rrdnqfb4a().s[11]++;
	        this.log(`filter: ${filter.filterName}`);
	      } else {
	        cov_2rrdnqfb4a().b[1][1]++;
	      }
	      cov_2rrdnqfb4a().s[12]++;
	      filter(context);
	      cov_2rrdnqfb4a().s[13]++;
	      if ((cov_2rrdnqfb4a().b[3][0]++, typeof context === 'object') && (cov_2rrdnqfb4a().b[3][1]++, context.exiting)) {
	        cov_2rrdnqfb4a().b[2][0]++;
	        cov_2rrdnqfb4a().s[14]++;
	        context.exiting = false;
	        cov_2rrdnqfb4a().s[15]++;
	        break;
	      } else {
	        cov_2rrdnqfb4a().b[2][1]++;
	      }
	    }
	    cov_2rrdnqfb4a().s[16]++;
	    if ((cov_2rrdnqfb4a().b[5][0]++, !context.next) && (cov_2rrdnqfb4a().b[5][1]++, this.resultCheck)) {
	      cov_2rrdnqfb4a().b[4][0]++;
	      cov_2rrdnqfb4a().s[17]++;
	      this.resultCheck(context);
	    } else {
	      cov_2rrdnqfb4a().b[4][1]++;
	    }
	  }
	  log(msg) {
	    cov_2rrdnqfb4a().f[2]++;
	    cov_2rrdnqfb4a().s[18]++;
	    console.log(`[jsondiffpatch] ${this.name} pipe, ${msg}`);
	  }
	  append() {
	    cov_2rrdnqfb4a().f[3]++;
	    cov_2rrdnqfb4a().s[19]++;
	    this.filters.push(...arguments);
	    cov_2rrdnqfb4a().s[20]++;
	    return this;
	  }
	  prepend() {
	    cov_2rrdnqfb4a().f[4]++;
	    cov_2rrdnqfb4a().s[21]++;
	    this.filters.unshift(...arguments);
	    cov_2rrdnqfb4a().s[22]++;
	    return this;
	  }
	  indexOf(filterName) {
	    cov_2rrdnqfb4a().f[5]++;
	    cov_2rrdnqfb4a().s[23]++;
	    if (!filterName) {
	      cov_2rrdnqfb4a().b[6][0]++;
	      cov_2rrdnqfb4a().s[24]++;
	      throw new Error('a filter name is required');
	    } else {
	      cov_2rrdnqfb4a().b[6][1]++;
	    }
	    cov_2rrdnqfb4a().s[25]++;
	    for (let index = (cov_2rrdnqfb4a().s[26]++, 0); index < this.filters.length; index++) {
	      const filter = (cov_2rrdnqfb4a().s[27]++, this.filters[index]);
	      cov_2rrdnqfb4a().s[28]++;
	      if (filter.filterName === filterName) {
	        cov_2rrdnqfb4a().b[7][0]++;
	        cov_2rrdnqfb4a().s[29]++;
	        return index;
	      } else {
	        cov_2rrdnqfb4a().b[7][1]++;
	      }
	    }
	    cov_2rrdnqfb4a().s[30]++;
	    throw new Error(`filter not found: ${filterName}`);
	  }
	  list() {
	    cov_2rrdnqfb4a().f[6]++;
	    cov_2rrdnqfb4a().s[31]++;
	    return this.filters.map(f => {
	      cov_2rrdnqfb4a().f[7]++;
	      cov_2rrdnqfb4a().s[32]++;
	      return f.filterName;
	    });
	  }
	  after(filterName) {
	    cov_2rrdnqfb4a().f[8]++;
	    const index = (cov_2rrdnqfb4a().s[33]++, this.indexOf(filterName));
	    const params = (cov_2rrdnqfb4a().s[34]++, Array.prototype.slice.call(arguments, 1));
	    cov_2rrdnqfb4a().s[35]++;
	    if (!params.length) {
	      cov_2rrdnqfb4a().b[8][0]++;
	      cov_2rrdnqfb4a().s[36]++;
	      throw new Error('a filter is required');
	    } else {
	      cov_2rrdnqfb4a().b[8][1]++;
	    }
	    cov_2rrdnqfb4a().s[37]++;
	    params.unshift(index + 1, 0);
	    cov_2rrdnqfb4a().s[38]++;
	    Array.prototype.splice.apply(this.filters, params);
	    cov_2rrdnqfb4a().s[39]++;
	    return this;
	  }
	  before(filterName) {
	    cov_2rrdnqfb4a().f[9]++;
	    const index = (cov_2rrdnqfb4a().s[40]++, this.indexOf(filterName));
	    const params = (cov_2rrdnqfb4a().s[41]++, Array.prototype.slice.call(arguments, 1));
	    cov_2rrdnqfb4a().s[42]++;
	    if (!params.length) {
	      cov_2rrdnqfb4a().b[9][0]++;
	      cov_2rrdnqfb4a().s[43]++;
	      throw new Error('a filter is required');
	    } else {
	      cov_2rrdnqfb4a().b[9][1]++;
	    }
	    cov_2rrdnqfb4a().s[44]++;
	    params.unshift(index, 0);
	    cov_2rrdnqfb4a().s[45]++;
	    Array.prototype.splice.apply(this.filters, params);
	    cov_2rrdnqfb4a().s[46]++;
	    return this;
	  }
	  replace(filterName) {
	    cov_2rrdnqfb4a().f[10]++;
	    const index = (cov_2rrdnqfb4a().s[47]++, this.indexOf(filterName));
	    const params = (cov_2rrdnqfb4a().s[48]++, Array.prototype.slice.call(arguments, 1));
	    cov_2rrdnqfb4a().s[49]++;
	    if (!params.length) {
	      cov_2rrdnqfb4a().b[10][0]++;
	      cov_2rrdnqfb4a().s[50]++;
	      throw new Error('a filter is required');
	    } else {
	      cov_2rrdnqfb4a().b[10][1]++;
	    }
	    cov_2rrdnqfb4a().s[51]++;
	    params.unshift(index, 1);
	    cov_2rrdnqfb4a().s[52]++;
	    Array.prototype.splice.apply(this.filters, params);
	    cov_2rrdnqfb4a().s[53]++;
	    return this;
	  }
	  remove(filterName) {
	    cov_2rrdnqfb4a().f[11]++;
	    const index = (cov_2rrdnqfb4a().s[54]++, this.indexOf(filterName));
	    cov_2rrdnqfb4a().s[55]++;
	    this.filters.splice(index, 1);
	    cov_2rrdnqfb4a().s[56]++;
	    return this;
	  }
	  clear() {
	    cov_2rrdnqfb4a().f[12]++;
	    cov_2rrdnqfb4a().s[57]++;
	    this.filters.length = 0;
	    cov_2rrdnqfb4a().s[58]++;
	    return this;
	  }
	  shouldHaveResult(should) {
	    cov_2rrdnqfb4a().f[13]++;
	    cov_2rrdnqfb4a().s[59]++;
	    if (should === false) {
	      cov_2rrdnqfb4a().b[11][0]++;
	      cov_2rrdnqfb4a().s[60]++;
	      this.resultCheck = null;
	      cov_2rrdnqfb4a().s[61]++;
	      return;
	    } else {
	      cov_2rrdnqfb4a().b[11][1]++;
	    }
	    cov_2rrdnqfb4a().s[62]++;
	    if (this.resultCheck) {
	      cov_2rrdnqfb4a().b[12][0]++;
	      cov_2rrdnqfb4a().s[63]++;
	      return;
	    } else {
	      cov_2rrdnqfb4a().b[12][1]++;
	    }
	    const pipe = (cov_2rrdnqfb4a().s[64]++, this);
	    cov_2rrdnqfb4a().s[65]++;
	    this.resultCheck = context => {
	      cov_2rrdnqfb4a().f[14]++;
	      cov_2rrdnqfb4a().s[66]++;
	      if (!context.hasResult) {
	        cov_2rrdnqfb4a().b[13][0]++;
	        cov_2rrdnqfb4a().s[67]++;
	        console.log(context);
	        const error = (cov_2rrdnqfb4a().s[68]++, new Error(`${pipe.name} failed`));
	        cov_2rrdnqfb4a().s[69]++;
	        error.noResult = true;
	        cov_2rrdnqfb4a().s[70]++;
	        throw error;
	      } else {
	        cov_2rrdnqfb4a().b[13][1]++;
	      }
	    };
	    cov_2rrdnqfb4a().s[71]++;
	    return this;
	  }
	}
	function cov_156ww8luqd() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/context.js";
	  var hash = "0905dcdccddf41cb8f8d91ce66a88c11881cd5d2";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/context.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 4,
	          column: 4
	        },
	        end: {
	          line: 4,
	          column: 25
	        }
	      },
	      "1": {
	        start: {
	          line: 5,
	          column: 4
	        },
	        end: {
	          line: 5,
	          column: 26
	        }
	      },
	      "2": {
	        start: {
	          line: 6,
	          column: 4
	        },
	        end: {
	          line: 6,
	          column: 16
	        }
	      },
	      "3": {
	        start: {
	          line: 9,
	          column: 4
	        },
	        end: {
	          line: 9,
	          column: 24
	        }
	      },
	      "4": {
	        start: {
	          line: 10,
	          column: 4
	        },
	        end: {
	          line: 10,
	          column: 16
	        }
	      },
	      "5": {
	        start: {
	          line: 13,
	          column: 4
	        },
	        end: {
	          line: 20,
	          column: 5
	        }
	      },
	      "6": {
	        start: {
	          line: 14,
	          column: 6
	        },
	        end: {
	          line: 14,
	          column: 27
	        }
	      },
	      "7": {
	        start: {
	          line: 16,
	          column: 6
	        },
	        end: {
	          line: 16,
	          column: 23
	        }
	      },
	      "8": {
	        start: {
	          line: 17,
	          column: 6
	        },
	        end: {
	          line: 19,
	          column: 7
	        }
	      },
	      "9": {
	        start: {
	          line: 18,
	          column: 8
	        },
	        end: {
	          line: 18,
	          column: 29
	        }
	      },
	      "10": {
	        start: {
	          line: 21,
	          column: 4
	        },
	        end: {
	          line: 21,
	          column: 16
	        }
	      },
	      "11": {
	        start: {
	          line: 24,
	          column: 4
	        },
	        end: {
	          line: 24,
	          column: 24
	        }
	      },
	      "12": {
	        start: {
	          line: 25,
	          column: 4
	        },
	        end: {
	          line: 27,
	          column: 5
	        }
	      },
	      "13": {
	        start: {
	          line: 26,
	          column: 6
	        },
	        end: {
	          line: 26,
	          column: 29
	        }
	      },
	      "14": {
	        start: {
	          line: 28,
	          column: 4
	        },
	        end: {
	          line: 28,
	          column: 35
	        }
	      },
	      "15": {
	        start: {
	          line: 29,
	          column: 4
	        },
	        end: {
	          line: 29,
	          column: 50
	        }
	      },
	      "16": {
	        start: {
	          line: 30,
	          column: 4
	        },
	        end: {
	          line: 37,
	          column: 5
	        }
	      },
	      "17": {
	        start: {
	          line: 31,
	          column: 6
	        },
	        end: {
	          line: 31,
	          column: 30
	        }
	      },
	      "18": {
	        start: {
	          line: 32,
	          column: 6
	        },
	        end: {
	          line: 32,
	          column: 49
	        }
	      },
	      "19": {
	        start: {
	          line: 33,
	          column: 6
	        },
	        end: {
	          line: 33,
	          column: 24
	        }
	      },
	      "20": {
	        start: {
	          line: 35,
	          column: 6
	        },
	        end: {
	          line: 35,
	          column: 59
	        }
	      },
	      "21": {
	        start: {
	          line: 36,
	          column: 6
	        },
	        end: {
	          line: 36,
	          column: 32
	        }
	      },
	      "22": {
	        start: {
	          line: 38,
	          column: 4
	        },
	        end: {
	          line: 38,
	          column: 22
	        }
	      },
	      "23": {
	        start: {
	          line: 39,
	          column: 4
	        },
	        end: {
	          line: 39,
	          column: 16
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 3,
	            column: 2
	          },
	          end: {
	            line: 3,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 3,
	            column: 20
	          },
	          end: {
	            line: 7,
	            column: 3
	          }
	        },
	        line: 3
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 8,
	            column: 2
	          },
	          end: {
	            line: 8,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 8,
	            column: 9
	          },
	          end: {
	            line: 11,
	            column: 3
	          }
	        },
	        line: 8
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 12,
	            column: 2
	          },
	          end: {
	            line: 12,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 12,
	            column: 23
	          },
	          end: {
	            line: 22,
	            column: 3
	          }
	        },
	        line: 12
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 23,
	            column: 2
	          },
	          end: {
	            line: 23,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 23,
	            column: 20
	          },
	          end: {
	            line: 40,
	            column: 3
	          }
	        },
	        line: 23
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 13,
	            column: 4
	          },
	          end: {
	            line: 20,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 13,
	            column: 4
	          },
	          end: {
	            line: 20,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 15,
	            column: 11
	          },
	          end: {
	            line: 20,
	            column: 5
	          }
	        }],
	        line: 13
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 13,
	            column: 8
	          },
	          end: {
	            line: 13,
	            column: 56
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 13,
	            column: 8
	          },
	          end: {
	            line: 13,
	            column: 32
	          }
	        }, {
	          start: {
	            line: 13,
	            column: 36
	          },
	          end: {
	            line: 13,
	            column: 56
	          }
	        }],
	        line: 13
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 17,
	            column: 6
	          },
	          end: {
	            line: 19,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 17,
	            column: 6
	          },
	          end: {
	            line: 19,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 17
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 25,
	            column: 4
	          },
	          end: {
	            line: 27,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 25,
	            column: 4
	          },
	          end: {
	            line: 27,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 25
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 28,
	            column: 17
	          },
	          end: {
	            line: 28,
	            column: 34
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 28,
	            column: 17
	          },
	          end: {
	            line: 28,
	            column: 26
	          }
	        }, {
	          start: {
	            line: 28,
	            column: 30
	          },
	          end: {
	            line: 28,
	            column: 34
	          }
	        }],
	        line: 28
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 29,
	            column: 20
	          },
	          end: {
	            line: 29,
	            column: 49
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 29,
	            column: 20
	          },
	          end: {
	            line: 29,
	            column: 33
	          }
	        }, {
	          start: {
	            line: 29,
	            column: 37
	          },
	          end: {
	            line: 29,
	            column: 49
	          }
	        }],
	        line: 29
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 30,
	            column: 4
	          },
	          end: {
	            line: 37,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 30,
	            column: 4
	          },
	          end: {
	            line: 37,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 34,
	            column: 11
	          },
	          end: {
	            line: 37,
	            column: 5
	          }
	        }],
	        line: 30
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 32,
	            column: 31
	          },
	          end: {
	            line: 32,
	            column: 48
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 32,
	            column: 31
	          },
	          end: {
	            line: 32,
	            column: 40
	          }
	        }, {
	          start: {
	            line: 32,
	            column: 44
	          },
	          end: {
	            line: 32,
	            column: 48
	          }
	        }],
	        line: 32
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/context.js"],
	      sourcesContent: ["import Pipe from '../pipe';\n\nexport default class Context {\n  setResult(result) {\n    this.result = result;\n    this.hasResult = true;\n    return this;\n  }\n\n  exit() {\n    this.exiting = true;\n    return this;\n  }\n\n  switchTo(next, pipe) {\n    if (typeof next === 'string' || next instanceof Pipe) {\n      this.nextPipe = next;\n    } else {\n      this.next = next;\n      if (pipe) {\n        this.nextPipe = pipe;\n      }\n    }\n    return this;\n  }\n\n  push(child, name) {\n    child.parent = this;\n    if (typeof name !== 'undefined') {\n      child.childName = name;\n    }\n    child.root = this.root || this;\n    child.options = child.options || this.options;\n    if (!this.children) {\n      this.children = [child];\n      this.nextAfterChildren = this.next || null;\n      this.next = child;\n    } else {\n      this.children[this.children.length - 1].next = child;\n      this.children.push(child);\n    }\n    child.next = this;\n    return this;\n  }\n}\n"],
	      names: ["Pipe", "Context", "setResult", "result", "hasResult", "exit", "exiting", "switchTo", "next", "pipe", "nextPipe", "push", "child", "name", "parent", "childName", "root", "options", "children", "nextAfterChildren", "length"],
	      mappings: "AAAA,OAAOA,IAAI,MAAM,SAAS;AAE1B,eAAe,MAAMC,OAAO,CAAC;EAC3BC,SAASA,CAACC,MAAM,EAAE;IAChB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,OAAO,IAAI;EACb;EAEAC,IAAIA,CAAA,EAAG;IACL,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,OAAO,IAAI;EACb;EAEAC,QAAQA,CAACC,IAAI,EAAEC,IAAI,EAAE;IACnB,IAAI,OAAOD,IAAI,KAAK,QAAQ,IAAIA,IAAI,YAAYR,IAAI,EAAE;MACpD,IAAI,CAACU,QAAQ,GAAGF,IAAI;IACtB,CAAC,MAAM;MACL,IAAI,CAACA,IAAI,GAAGA,IAAI;MAChB,IAAIC,IAAI,EAAE;QACR,IAAI,CAACC,QAAQ,GAAGD,IAAI;MACtB;IACF;IACA,OAAO,IAAI;EACb;EAEAE,IAAIA,CAACC,KAAK,EAAEC,IAAI,EAAE;IAChBD,KAAK,CAACE,MAAM,GAAG,IAAI;IACnB,IAAI,OAAOD,IAAI,KAAK,WAAW,EAAE;MAC/BD,KAAK,CAACG,SAAS,GAAGF,IAAI;IACxB;IACAD,KAAK,CAACI,IAAI,GAAG,IAAI,CAACA,IAAI,IAAI,IAAI;IAC9BJ,KAAK,CAACK,OAAO,GAAGL,KAAK,CAACK,OAAO,IAAI,IAAI,CAACA,OAAO;IAC7C,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MAClB,IAAI,CAACA,QAAQ,GAAG,CAACN,KAAK,CAAC;MACvB,IAAI,CAACO,iBAAiB,GAAG,IAAI,CAACX,IAAI,IAAI,IAAI;MAC1C,IAAI,CAACA,IAAI,GAAGI,KAAK;IACnB,CAAC,MAAM;MACL,IAAI,CAACM,QAAQ,CAAC,IAAI,CAACA,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC,CAACZ,IAAI,GAAGI,KAAK;MACpD,IAAI,CAACM,QAAQ,CAACP,IAAI,CAACC,KAAK,CAAC;IAC3B;IACAA,KAAK,CAACJ,IAAI,GAAG,IAAI;IACjB,OAAO,IAAI;EACb;AACF",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "0905dcdccddf41cb8f8d91ce66a88c11881cd5d2"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_156ww8luqd = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_156ww8luqd();
	class Context {
	  setResult(result) {
	    cov_156ww8luqd().f[0]++;
	    cov_156ww8luqd().s[0]++;
	    this.result = result;
	    cov_156ww8luqd().s[1]++;
	    this.hasResult = true;
	    cov_156ww8luqd().s[2]++;
	    return this;
	  }
	  exit() {
	    cov_156ww8luqd().f[1]++;
	    cov_156ww8luqd().s[3]++;
	    this.exiting = true;
	    cov_156ww8luqd().s[4]++;
	    return this;
	  }
	  switchTo(next, pipe) {
	    cov_156ww8luqd().f[2]++;
	    cov_156ww8luqd().s[5]++;
	    if ((cov_156ww8luqd().b[1][0]++, typeof next === 'string') || (cov_156ww8luqd().b[1][1]++, next instanceof Pipe)) {
	      cov_156ww8luqd().b[0][0]++;
	      cov_156ww8luqd().s[6]++;
	      this.nextPipe = next;
	    } else {
	      cov_156ww8luqd().b[0][1]++;
	      cov_156ww8luqd().s[7]++;
	      this.next = next;
	      cov_156ww8luqd().s[8]++;
	      if (pipe) {
	        cov_156ww8luqd().b[2][0]++;
	        cov_156ww8luqd().s[9]++;
	        this.nextPipe = pipe;
	      } else {
	        cov_156ww8luqd().b[2][1]++;
	      }
	    }
	    cov_156ww8luqd().s[10]++;
	    return this;
	  }
	  push(child, name) {
	    cov_156ww8luqd().f[3]++;
	    cov_156ww8luqd().s[11]++;
	    child.parent = this;
	    cov_156ww8luqd().s[12]++;
	    if (typeof name !== 'undefined') {
	      cov_156ww8luqd().b[3][0]++;
	      cov_156ww8luqd().s[13]++;
	      child.childName = name;
	    } else {
	      cov_156ww8luqd().b[3][1]++;
	    }
	    cov_156ww8luqd().s[14]++;
	    child.root = (cov_156ww8luqd().b[4][0]++, this.root) || (cov_156ww8luqd().b[4][1]++, this);
	    cov_156ww8luqd().s[15]++;
	    child.options = (cov_156ww8luqd().b[5][0]++, child.options) || (cov_156ww8luqd().b[5][1]++, this.options);
	    cov_156ww8luqd().s[16]++;
	    if (!this.children) {
	      cov_156ww8luqd().b[6][0]++;
	      cov_156ww8luqd().s[17]++;
	      this.children = [child];
	      cov_156ww8luqd().s[18]++;
	      this.nextAfterChildren = (cov_156ww8luqd().b[7][0]++, this.next) || (cov_156ww8luqd().b[7][1]++, null);
	      cov_156ww8luqd().s[19]++;
	      this.next = child;
	    } else {
	      cov_156ww8luqd().b[6][1]++;
	      cov_156ww8luqd().s[20]++;
	      this.children[this.children.length - 1].next = child;
	      cov_156ww8luqd().s[21]++;
	      this.children.push(child);
	    }
	    cov_156ww8luqd().s[22]++;
	    child.next = this;
	    cov_156ww8luqd().s[23]++;
	    return this;
	  }
	}
	function cov_189th3r4ax() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/clone.js";
	  var hash = "a0b84328ddce498f5c08b90e00a345e5116cc3d1";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/clone.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 1,
	          column: 16
	        },
	        end: {
	          line: 1,
	          column: 93
	        }
	      },
	      "1": {
	        start: {
	          line: 1,
	          column: 75
	        },
	        end: {
	          line: 1,
	          column: 93
	        }
	      },
	      "2": {
	        start: {
	          line: 3,
	          column: 21
	        },
	        end: {
	          line: 3,
	          column: 63
	        }
	      },
	      "3": {
	        start: {
	          line: 4,
	          column: 2
	        },
	        end: {
	          line: 4,
	          column: 50
	        }
	      },
	      "4": {
	        start: {
	          line: 7,
	          column: 2
	        },
	        end: {
	          line: 9,
	          column: 3
	        }
	      },
	      "5": {
	        start: {
	          line: 8,
	          column: 4
	        },
	        end: {
	          line: 8,
	          column: 15
	        }
	      },
	      "6": {
	        start: {
	          line: 10,
	          column: 2
	        },
	        end: {
	          line: 12,
	          column: 3
	        }
	      },
	      "7": {
	        start: {
	          line: 11,
	          column: 4
	        },
	        end: {
	          line: 11,
	          column: 16
	        }
	      },
	      "8": {
	        start: {
	          line: 13,
	          column: 2
	        },
	        end: {
	          line: 15,
	          column: 3
	        }
	      },
	      "9": {
	        start: {
	          line: 14,
	          column: 4
	        },
	        end: {
	          line: 14,
	          column: 26
	        }
	      },
	      "10": {
	        start: {
	          line: 16,
	          column: 2
	        },
	        end: {
	          line: 18,
	          column: 3
	        }
	      },
	      "11": {
	        start: {
	          line: 17,
	          column: 4
	        },
	        end: {
	          line: 17,
	          column: 35
	        }
	      },
	      "12": {
	        start: {
	          line: 19,
	          column: 2
	        },
	        end: {
	          line: 21,
	          column: 3
	        }
	      },
	      "13": {
	        start: {
	          line: 20,
	          column: 4
	        },
	        end: {
	          line: 20,
	          column: 28
	        }
	      },
	      "14": {
	        start: {
	          line: 22,
	          column: 17
	        },
	        end: {
	          line: 22,
	          column: 19
	        }
	      },
	      "15": {
	        start: {
	          line: 23,
	          column: 2
	        },
	        end: {
	          line: 27,
	          column: 3
	        }
	      },
	      "16": {
	        start: {
	          line: 24,
	          column: 4
	        },
	        end: {
	          line: 26,
	          column: 5
	        }
	      },
	      "17": {
	        start: {
	          line: 25,
	          column: 6
	        },
	        end: {
	          line: 25,
	          column: 38
	        }
	      },
	      "18": {
	        start: {
	          line: 28,
	          column: 2
	        },
	        end: {
	          line: 28,
	          column: 16
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 1,
	            column: 70
	          },
	          end: {
	            line: 1,
	            column: 71
	          }
	        },
	        loc: {
	          start: {
	            line: 1,
	            column: 75
	          },
	          end: {
	            line: 1,
	            column: 93
	          }
	        },
	        line: 1
	      },
	      "1": {
	        name: "cloneRegExp",
	        decl: {
	          start: {
	            line: 2,
	            column: 9
	          },
	          end: {
	            line: 2,
	            column: 20
	          }
	        },
	        loc: {
	          start: {
	            line: 2,
	            column: 25
	          },
	          end: {
	            line: 5,
	            column: 1
	          }
	        },
	        line: 2
	      },
	      "2": {
	        name: "clone",
	        decl: {
	          start: {
	            line: 6,
	            column: 24
	          },
	          end: {
	            line: 6,
	            column: 29
	          }
	        },
	        loc: {
	          start: {
	            line: 6,
	            column: 35
	          },
	          end: {
	            line: 29,
	            column: 1
	          }
	        },
	        line: 6
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 1,
	            column: 16
	          },
	          end: {
	            line: 1,
	            column: 93
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 1,
	            column: 54
	          },
	          end: {
	            line: 1,
	            column: 67
	          }
	        }, {
	          start: {
	            line: 1,
	            column: 70
	          },
	          end: {
	            line: 1,
	            column: 93
	          }
	        }],
	        line: 1
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 7,
	            column: 2
	          },
	          end: {
	            line: 9,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 7,
	            column: 2
	          },
	          end: {
	            line: 9,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 7
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 10,
	            column: 2
	          },
	          end: {
	            line: 12,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 10,
	            column: 2
	          },
	          end: {
	            line: 12,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 10
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 13,
	            column: 2
	          },
	          end: {
	            line: 15,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 13,
	            column: 2
	          },
	          end: {
	            line: 15,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 13
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 16,
	            column: 2
	          },
	          end: {
	            line: 18,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 16,
	            column: 2
	          },
	          end: {
	            line: 18,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 16
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 19,
	            column: 2
	          },
	          end: {
	            line: 21,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 19,
	            column: 2
	          },
	          end: {
	            line: 21,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 19
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 24,
	            column: 4
	          },
	          end: {
	            line: 26,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 24,
	            column: 4
	          },
	          end: {
	            line: 26,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 24
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/clone.js"],
	      sourcesContent: ["const isArray =\n  typeof Array.isArray === 'function' ? Array.isArray : a => a instanceof Array;\n\nfunction cloneRegExp(re) {\n  const regexMatch = /^\\/(.*)\\/([gimyu]*)$/.exec(re.toString());\n  return new RegExp(regexMatch[1], regexMatch[2]);\n}\n\nexport default function clone(arg) {\n  if (typeof arg !== 'object') {\n    return arg;\n  }\n  if (arg === null) {\n    return null;\n  }\n  if (isArray(arg)) {\n    return arg.map(clone);\n  }\n  if (arg instanceof Date) {\n    return new Date(arg.getTime());\n  }\n  if (arg instanceof RegExp) {\n    return cloneRegExp(arg);\n  }\n  const cloned = {};\n  for (const name in arg) {\n    if (Object.prototype.hasOwnProperty.call(arg, name)) {\n      cloned[name] = clone(arg[name]);\n    }\n  }\n  return cloned;\n}\n"],
	      names: ["isArray", "Array", "a", "cloneRegExp", "re", "regexMatch", "exec", "toString", "RegExp", "clone", "arg", "map", "Date", "getTime", "cloned", "name", "Object", "prototype", "hasOwnProperty", "call"],
	      mappings: "AAAA,MAAMA,OAAO,GACX,OAAOC,KAAK,CAACD,OAAO,KAAK,UAAU,GAAGC,KAAK,CAACD,OAAO,GAAGE,CAAC,IAAIA,CAAC,YAAYD,KAAK;AAE/E,SAASE,WAAWA,CAACC,EAAE,EAAE;EACvB,MAAMC,UAAU,GAAG,sBAAsB,CAACC,IAAI,CAACF,EAAE,CAACG,QAAQ,CAAC,CAAC,CAAC;EAC7D,OAAO,IAAIC,MAAM,CAACH,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAAC;AACjD;AAEA,eAAe,SAASI,KAAKA,CAACC,GAAG,EAAE;EACjC,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC3B,OAAOA,GAAG;EACZ;EACA,IAAIA,GAAG,KAAK,IAAI,EAAE;IAChB,OAAO,IAAI;EACb;EACA,IAAIV,OAAO,CAACU,GAAG,CAAC,EAAE;IAChB,OAAOA,GAAG,CAACC,GAAG,CAACF,KAAK,CAAC;EACvB;EACA,IAAIC,GAAG,YAAYE,IAAI,EAAE;IACvB,OAAO,IAAIA,IAAI,CAACF,GAAG,CAACG,OAAO,CAAC,CAAC,CAAC;EAChC;EACA,IAAIH,GAAG,YAAYF,MAAM,EAAE;IACzB,OAAOL,WAAW,CAACO,GAAG,CAAC;EACzB;EACA,MAAMI,MAAM,GAAG,CAAC,CAAC;EACjB,KAAK,MAAMC,IAAI,IAAIL,GAAG,EAAE;IACtB,IAAIM,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACT,GAAG,EAAEK,IAAI,CAAC,EAAE;MACnDD,MAAM,CAACC,IAAI,CAAC,GAAGN,KAAK,CAACC,GAAG,CAACK,IAAI,CAAC,CAAC;IACjC;EACF;EACA,OAAOD,MAAM;AACf",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "a0b84328ddce498f5c08b90e00a345e5116cc3d1"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_189th3r4ax = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_189th3r4ax();
	const isArray$3 = (cov_189th3r4ax().s[0]++, typeof Array.isArray === 'function' ? (cov_189th3r4ax().b[0][0]++, Array.isArray) : (cov_189th3r4ax().b[0][1]++, a => {
	  cov_189th3r4ax().f[0]++;
	  cov_189th3r4ax().s[1]++;
	  return a instanceof Array;
	}));
	function cloneRegExp(re) {
	  cov_189th3r4ax().f[1]++;
	  const regexMatch = (cov_189th3r4ax().s[2]++, /^\/(.*)\/([gimyu]*)$/.exec(re.toString()));
	  cov_189th3r4ax().s[3]++;
	  return new RegExp(regexMatch[1], regexMatch[2]);
	}
	function clone$1(arg) {
	  cov_189th3r4ax().f[2]++;
	  cov_189th3r4ax().s[4]++;
	  if (typeof arg !== 'object') {
	    cov_189th3r4ax().b[1][0]++;
	    cov_189th3r4ax().s[5]++;
	    return arg;
	  } else {
	    cov_189th3r4ax().b[1][1]++;
	  }
	  cov_189th3r4ax().s[6]++;
	  if (arg === null) {
	    cov_189th3r4ax().b[2][0]++;
	    cov_189th3r4ax().s[7]++;
	    return null;
	  } else {
	    cov_189th3r4ax().b[2][1]++;
	  }
	  cov_189th3r4ax().s[8]++;
	  if (isArray$3(arg)) {
	    cov_189th3r4ax().b[3][0]++;
	    cov_189th3r4ax().s[9]++;
	    return arg.map(clone$1);
	  } else {
	    cov_189th3r4ax().b[3][1]++;
	  }
	  cov_189th3r4ax().s[10]++;
	  if (arg instanceof Date) {
	    cov_189th3r4ax().b[4][0]++;
	    cov_189th3r4ax().s[11]++;
	    return new Date(arg.getTime());
	  } else {
	    cov_189th3r4ax().b[4][1]++;
	  }
	  cov_189th3r4ax().s[12]++;
	  if (arg instanceof RegExp) {
	    cov_189th3r4ax().b[5][0]++;
	    cov_189th3r4ax().s[13]++;
	    return cloneRegExp(arg);
	  } else {
	    cov_189th3r4ax().b[5][1]++;
	  }
	  const cloned = (cov_189th3r4ax().s[14]++, {});
	  cov_189th3r4ax().s[15]++;
	  for (const name in arg) {
	    cov_189th3r4ax().s[16]++;
	    if (Object.prototype.hasOwnProperty.call(arg, name)) {
	      cov_189th3r4ax().b[6][0]++;
	      cov_189th3r4ax().s[17]++;
	      cloned[name] = clone$1(arg[name]);
	    } else {
	      cov_189th3r4ax().b[6][1]++;
	    }
	  }
	  cov_189th3r4ax().s[18]++;
	  return cloned;
	}
	function cov_1yfcxjce8g() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/diff.js";
	  var hash = "ae3c5ca2fe29a1e69de0bd8372ef9d67946b72c4";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/diff.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 5,
	          column: 4
	        },
	        end: {
	          line: 5,
	          column: 12
	        }
	      },
	      "1": {
	        start: {
	          line: 6,
	          column: 4
	        },
	        end: {
	          line: 6,
	          column: 21
	        }
	      },
	      "2": {
	        start: {
	          line: 7,
	          column: 4
	        },
	        end: {
	          line: 7,
	          column: 23
	        }
	      },
	      "3": {
	        start: {
	          line: 8,
	          column: 4
	        },
	        end: {
	          line: 8,
	          column: 23
	        }
	      },
	      "4": {
	        start: {
	          line: 11,
	          column: 4
	        },
	        end: {
	          line: 19,
	          column: 5
	        }
	      },
	      "5": {
	        start: {
	          line: 12,
	          column: 20
	        },
	        end: {
	          line: 12,
	          column: 116
	        }
	      },
	      "6": {
	        start: {
	          line: 13,
	          column: 6
	        },
	        end: {
	          line: 15,
	          column: 7
	        }
	      },
	      "7": {
	        start: {
	          line: 14,
	          column: 8
	        },
	        end: {
	          line: 14,
	          column: 37
	        }
	      },
	      "8": {
	        start: {
	          line: 16,
	          column: 6
	        },
	        end: {
	          line: 18,
	          column: 7
	        }
	      },
	      "9": {
	        start: {
	          line: 17,
	          column: 8
	        },
	        end: {
	          line: 17,
	          column: 37
	        }
	      },
	      "10": {
	        start: {
	          line: 20,
	          column: 4
	        },
	        end: {
	          line: 20,
	          column: 62
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 4,
	            column: 2
	          },
	          end: {
	            line: 4,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 4,
	            column: 27
	          },
	          end: {
	            line: 9,
	            column: 3
	          }
	        },
	        line: 4
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 10,
	            column: 2
	          },
	          end: {
	            line: 10,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 10,
	            column: 20
	          },
	          end: {
	            line: 21,
	            column: 3
	          }
	        },
	        line: 10
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 11,
	            column: 4
	          },
	          end: {
	            line: 19,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 11,
	            column: 4
	          },
	          end: {
	            line: 19,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 11
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 11,
	            column: 8
	          },
	          end: {
	            line: 11,
	            column: 66
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 11,
	            column: 8
	          },
	          end: {
	            line: 11,
	            column: 36
	          }
	        }, {
	          start: {
	            line: 11,
	            column: 40
	          },
	          end: {
	            line: 11,
	            column: 66
	          }
	        }],
	        line: 11
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 12,
	            column: 20
	          },
	          end: {
	            line: 12,
	            column: 116
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 12,
	            column: 73
	          },
	          end: {
	            line: 12,
	            column: 101
	          }
	        }, {
	          start: {
	            line: 12,
	            column: 104
	          },
	          end: {
	            line: 12,
	            column: 116
	          }
	        }],
	        line: 12
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 13,
	            column: 6
	          },
	          end: {
	            line: 15,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 13,
	            column: 6
	          },
	          end: {
	            line: 15,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 13
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 16,
	            column: 6
	          },
	          end: {
	            line: 18,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 16,
	            column: 6
	          },
	          end: {
	            line: 18,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 16
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/diff.js"],
	      sourcesContent: ["import Context from './context';\nimport defaultClone from '../clone';\n\nclass DiffContext extends Context {\n  constructor(left, right) {\n    super();\n    this.left = left;\n    this.right = right;\n    this.pipe = 'diff';\n  }\n\n  setResult(result) {\n    if (this.options.cloneDiffValues && typeof result === 'object') {\n      const clone =\n        typeof this.options.cloneDiffValues === 'function'\n          ? this.options.cloneDiffValues\n          : defaultClone;\n      if (typeof result[0] === 'object') {\n        result[0] = clone(result[0]);\n      }\n      if (typeof result[1] === 'object') {\n        result[1] = clone(result[1]);\n      }\n    }\n    return Context.prototype.setResult.apply(this, arguments);\n  }\n}\n\nexport default DiffContext;\n"],
	      names: ["Context", "defaultClone", "DiffContext", "constructor", "left", "right", "pipe", "setResult", "result", "options", "cloneDiffValues", "clone", "prototype", "apply", "arguments"],
	      mappings: "AAAA,OAAOA,OAAO,MAAM,WAAW;AAC/B,OAAOC,YAAY,MAAM,UAAU;AAEnC,MAAMC,WAAW,SAASF,OAAO,CAAC;EAChCG,WAAWA,CAACC,IAAI,EAAEC,KAAK,EAAE;IACvB,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,IAAI,GAAG,MAAM;EACpB;EAEAC,SAASA,CAACC,MAAM,EAAE;IAChB,IAAI,IAAI,CAACC,OAAO,CAACC,eAAe,IAAI,OAAOF,MAAM,KAAK,QAAQ,EAAE;MAC9D,MAAMG,KAAK,GACT,OAAO,IAAI,CAACF,OAAO,CAACC,eAAe,KAAK,UAAU,GAC9C,IAAI,CAACD,OAAO,CAACC,eAAe,GAC5BT,YAAY;MAClB,IAAI,OAAOO,MAAM,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;QACjCA,MAAM,CAAC,CAAC,CAAC,GAAGG,KAAK,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC;MAC9B;MACA,IAAI,OAAOA,MAAM,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;QACjCA,MAAM,CAAC,CAAC,CAAC,GAAGG,KAAK,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC;MAC9B;IACF;IACA,OAAOR,OAAO,CAACY,SAAS,CAACL,SAAS,CAACM,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EAC3D;AACF;AAEA,eAAeZ,WAAW",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "ae3c5ca2fe29a1e69de0bd8372ef9d67946b72c4"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_1yfcxjce8g = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_1yfcxjce8g();
	class DiffContext extends Context {
	  constructor(left, right) {
	    cov_1yfcxjce8g().f[0]++;
	    cov_1yfcxjce8g().s[0]++;
	    super();
	    cov_1yfcxjce8g().s[1]++;
	    this.left = left;
	    cov_1yfcxjce8g().s[2]++;
	    this.right = right;
	    cov_1yfcxjce8g().s[3]++;
	    this.pipe = 'diff';
	  }
	  setResult(result) {
	    cov_1yfcxjce8g().f[1]++;
	    cov_1yfcxjce8g().s[4]++;
	    if ((cov_1yfcxjce8g().b[1][0]++, this.options.cloneDiffValues) && (cov_1yfcxjce8g().b[1][1]++, typeof result === 'object')) {
	      cov_1yfcxjce8g().b[0][0]++;
	      const clone = (cov_1yfcxjce8g().s[5]++, typeof this.options.cloneDiffValues === 'function' ? (cov_1yfcxjce8g().b[2][0]++, this.options.cloneDiffValues) : (cov_1yfcxjce8g().b[2][1]++, clone$1));
	      cov_1yfcxjce8g().s[6]++;
	      if (typeof result[0] === 'object') {
	        cov_1yfcxjce8g().b[3][0]++;
	        cov_1yfcxjce8g().s[7]++;
	        result[0] = clone(result[0]);
	      } else {
	        cov_1yfcxjce8g().b[3][1]++;
	      }
	      cov_1yfcxjce8g().s[8]++;
	      if (typeof result[1] === 'object') {
	        cov_1yfcxjce8g().b[4][0]++;
	        cov_1yfcxjce8g().s[9]++;
	        result[1] = clone(result[1]);
	      } else {
	        cov_1yfcxjce8g().b[4][1]++;
	      }
	    } else {
	      cov_1yfcxjce8g().b[0][1]++;
	    }
	    cov_1yfcxjce8g().s[10]++;
	    return Context.prototype.setResult.apply(this, arguments);
	  }
	}
	function cov_21s8mmx0sc() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/patch.js";
	  var hash = "d5ff66111bf4679c0f2e3308a67f1c935df69237";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/patch.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 4,
	          column: 4
	        },
	        end: {
	          line: 4,
	          column: 12
	        }
	      },
	      "1": {
	        start: {
	          line: 5,
	          column: 4
	        },
	        end: {
	          line: 5,
	          column: 21
	        }
	      },
	      "2": {
	        start: {
	          line: 6,
	          column: 4
	        },
	        end: {
	          line: 6,
	          column: 23
	        }
	      },
	      "3": {
	        start: {
	          line: 7,
	          column: 4
	        },
	        end: {
	          line: 7,
	          column: 24
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 3,
	            column: 2
	          },
	          end: {
	            line: 3,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 3,
	            column: 27
	          },
	          end: {
	            line: 8,
	            column: 3
	          }
	        },
	        line: 3
	      }
	    },
	    branchMap: {},
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0
	    },
	    f: {
	      "0": 0
	    },
	    b: {},
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/patch.js"],
	      sourcesContent: ["import Context from './context';\n\nclass PatchContext extends Context {\n  constructor(left, delta) {\n    super();\n    this.left = left;\n    this.delta = delta;\n    this.pipe = 'patch';\n  }\n}\n\nexport default PatchContext;\n"],
	      names: ["Context", "PatchContext", "constructor", "left", "delta", "pipe"],
	      mappings: "AAAA,OAAOA,OAAO,MAAM,WAAW;AAE/B,MAAMC,YAAY,SAASD,OAAO,CAAC;EACjCE,WAAWA,CAACC,IAAI,EAAEC,KAAK,EAAE;IACvB,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,IAAI,GAAG,OAAO;EACrB;AACF;AAEA,eAAeJ,YAAY",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "d5ff66111bf4679c0f2e3308a67f1c935df69237"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_21s8mmx0sc = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_21s8mmx0sc();
	class PatchContext extends Context {
	  constructor(left, delta) {
	    cov_21s8mmx0sc().f[0]++;
	    cov_21s8mmx0sc().s[0]++;
	    super();
	    cov_21s8mmx0sc().s[1]++;
	    this.left = left;
	    cov_21s8mmx0sc().s[2]++;
	    this.delta = delta;
	    cov_21s8mmx0sc().s[3]++;
	    this.pipe = 'patch';
	  }
	}
	function cov_1uy77krwmd() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/reverse.js";
	  var hash = "490b8fb22fd9b8408971e7901f14d3f4328715f0";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/reverse.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 4,
	          column: 4
	        },
	        end: {
	          line: 4,
	          column: 12
	        }
	      },
	      "1": {
	        start: {
	          line: 5,
	          column: 4
	        },
	        end: {
	          line: 5,
	          column: 23
	        }
	      },
	      "2": {
	        start: {
	          line: 6,
	          column: 4
	        },
	        end: {
	          line: 6,
	          column: 26
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 3,
	            column: 2
	          },
	          end: {
	            line: 3,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 3,
	            column: 21
	          },
	          end: {
	            line: 7,
	            column: 3
	          }
	        },
	        line: 3
	      }
	    },
	    branchMap: {},
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0
	    },
	    f: {
	      "0": 0
	    },
	    b: {},
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/contexts/reverse.js"],
	      sourcesContent: ["import Context from './context';\n\nclass ReverseContext extends Context {\n  constructor(delta) {\n    super();\n    this.delta = delta;\n    this.pipe = 'reverse';\n  }\n}\n\nexport default ReverseContext;\n"],
	      names: ["Context", "ReverseContext", "constructor", "delta", "pipe"],
	      mappings: "AAAA,OAAOA,OAAO,MAAM,WAAW;AAE/B,MAAMC,cAAc,SAASD,OAAO,CAAC;EACnCE,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,IAAI,GAAG,SAAS;EACvB;AACF;AAEA,eAAeH,cAAc",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "490b8fb22fd9b8408971e7901f14d3f4328715f0"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_1uy77krwmd = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_1uy77krwmd();
	class ReverseContext extends Context {
	  constructor(delta) {
	    cov_1uy77krwmd().f[0]++;
	    cov_1uy77krwmd().s[0]++;
	    super();
	    cov_1uy77krwmd().s[1]++;
	    this.delta = delta;
	    cov_1uy77krwmd().s[2]++;
	    this.pipe = 'reverse';
	  }
	}
	function cov_3qxlmdaon() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/trivial.js";
	  var hash = "06243e451936ecfc1374873ce358c0641e232932";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/trivial.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 1,
	          column: 16
	        },
	        end: {
	          line: 3,
	          column: 1
	        }
	      },
	      "1": {
	        start: {
	          line: 2,
	          column: 2
	        },
	        end: {
	          line: 2,
	          column: 28
	        }
	      },
	      "2": {
	        start: {
	          line: 4,
	          column: 26
	        },
	        end: {
	          line: 50,
	          column: 1
	        }
	      },
	      "3": {
	        start: {
	          line: 5,
	          column: 2
	        },
	        end: {
	          line: 8,
	          column: 3
	        }
	      },
	      "4": {
	        start: {
	          line: 6,
	          column: 4
	        },
	        end: {
	          line: 6,
	          column: 40
	        }
	      },
	      "5": {
	        start: {
	          line: 7,
	          column: 4
	        },
	        end: {
	          line: 7,
	          column: 11
	        }
	      },
	      "6": {
	        start: {
	          line: 9,
	          column: 2
	        },
	        end: {
	          line: 15,
	          column: 3
	        }
	      },
	      "7": {
	        start: {
	          line: 10,
	          column: 4
	        },
	        end: {
	          line: 12,
	          column: 5
	        }
	      },
	      "8": {
	        start: {
	          line: 11,
	          column: 6
	        },
	        end: {
	          line: 11,
	          column: 53
	        }
	      },
	      "9": {
	        start: {
	          line: 13,
	          column: 4
	        },
	        end: {
	          line: 13,
	          column: 46
	        }
	      },
	      "10": {
	        start: {
	          line: 14,
	          column: 4
	        },
	        end: {
	          line: 14,
	          column: 11
	        }
	      },
	      "11": {
	        start: {
	          line: 16,
	          column: 2
	        },
	        end: {
	          line: 19,
	          column: 3
	        }
	      },
	      "12": {
	        start: {
	          line: 17,
	          column: 4
	        },
	        end: {
	          line: 17,
	          column: 51
	        }
	      },
	      "13": {
	        start: {
	          line: 18,
	          column: 4
	        },
	        end: {
	          line: 18,
	          column: 11
	        }
	      },
	      "14": {
	        start: {
	          line: 20,
	          column: 2
	        },
	        end: {
	          line: 22,
	          column: 3
	        }
	      },
	      "15": {
	        start: {
	          line: 21,
	          column: 4
	        },
	        end: {
	          line: 21,
	          column: 51
	        }
	      },
	      "16": {
	        start: {
	          line: 23,
	          column: 2
	        },
	        end: {
	          line: 23,
	          column: 74
	        }
	      },
	      "17": {
	        start: {
	          line: 24,
	          column: 2
	        },
	        end: {
	          line: 24,
	          column: 77
	        }
	      },
	      "18": {
	        start: {
	          line: 25,
	          column: 2
	        },
	        end: {
	          line: 28,
	          column: 3
	        }
	      },
	      "19": {
	        start: {
	          line: 26,
	          column: 4
	        },
	        end: {
	          line: 26,
	          column: 60
	        }
	      },
	      "20": {
	        start: {
	          line: 27,
	          column: 4
	        },
	        end: {
	          line: 27,
	          column: 11
	        }
	      },
	      "21": {
	        start: {
	          line: 29,
	          column: 2
	        },
	        end: {
	          line: 32,
	          column: 3
	        }
	      },
	      "22": {
	        start: {
	          line: 30,
	          column: 4
	        },
	        end: {
	          line: 30,
	          column: 60
	        }
	      },
	      "23": {
	        start: {
	          line: 31,
	          column: 4
	        },
	        end: {
	          line: 31,
	          column: 11
	        }
	      },
	      "24": {
	        start: {
	          line: 33,
	          column: 2
	        },
	        end: {
	          line: 35,
	          column: 3
	        }
	      },
	      "25": {
	        start: {
	          line: 34,
	          column: 4
	        },
	        end: {
	          line: 34,
	          column: 48
	        }
	      },
	      "26": {
	        start: {
	          line: 36,
	          column: 2
	        },
	        end: {
	          line: 38,
	          column: 3
	        }
	      },
	      "27": {
	        start: {
	          line: 37,
	          column: 4
	        },
	        end: {
	          line: 37,
	          column: 50
	        }
	      },
	      "28": {
	        start: {
	          line: 39,
	          column: 2
	        },
	        end: {
	          line: 42,
	          column: 3
	        }
	      },
	      "29": {
	        start: {
	          line: 40,
	          column: 4
	        },
	        end: {
	          line: 40,
	          column: 60
	        }
	      },
	      "30": {
	        start: {
	          line: 41,
	          column: 4
	        },
	        end: {
	          line: 41,
	          column: 11
	        }
	      },
	      "31": {
	        start: {
	          line: 43,
	          column: 2
	        },
	        end: {
	          line: 49,
	          column: 3
	        }
	      },
	      "32": {
	        start: {
	          line: 44,
	          column: 4
	        },
	        end: {
	          line: 48,
	          column: 5
	        }
	      },
	      "33": {
	        start: {
	          line: 45,
	          column: 6
	        },
	        end: {
	          line: 45,
	          column: 84
	        }
	      },
	      "34": {
	        start: {
	          line: 47,
	          column: 6
	        },
	        end: {
	          line: 47,
	          column: 62
	        }
	      },
	      "35": {
	        start: {
	          line: 51,
	          column: 0
	        },
	        end: {
	          line: 51,
	          column: 34
	        }
	      },
	      "36": {
	        start: {
	          line: 52,
	          column: 27
	        },
	        end: {
	          line: 79,
	          column: 1
	        }
	      },
	      "37": {
	        start: {
	          line: 53,
	          column: 2
	        },
	        end: {
	          line: 56,
	          column: 3
	        }
	      },
	      "38": {
	        start: {
	          line: 54,
	          column: 4
	        },
	        end: {
	          line: 54,
	          column: 43
	        }
	      },
	      "39": {
	        start: {
	          line: 55,
	          column: 4
	        },
	        end: {
	          line: 55,
	          column: 11
	        }
	      },
	      "40": {
	        start: {
	          line: 57,
	          column: 2
	        },
	        end: {
	          line: 57,
	          column: 43
	        }
	      },
	      "41": {
	        start: {
	          line: 58,
	          column: 2
	        },
	        end: {
	          line: 60,
	          column: 3
	        }
	      },
	      "42": {
	        start: {
	          line: 59,
	          column: 4
	        },
	        end: {
	          line: 59,
	          column: 11
	        }
	      },
	      "43": {
	        start: {
	          line: 61,
	          column: 2
	        },
	        end: {
	          line: 64,
	          column: 3
	        }
	      },
	      "44": {
	        start: {
	          line: 62,
	          column: 4
	        },
	        end: {
	          line: 62,
	          column: 47
	        }
	      },
	      "45": {
	        start: {
	          line: 63,
	          column: 4
	        },
	        end: {
	          line: 63,
	          column: 11
	        }
	      },
	      "46": {
	        start: {
	          line: 65,
	          column: 2
	        },
	        end: {
	          line: 75,
	          column: 3
	        }
	      },
	      "47": {
	        start: {
	          line: 66,
	          column: 4
	        },
	        end: {
	          line: 72,
	          column: 5
	        }
	      },
	      "48": {
	        start: {
	          line: 67,
	          column: 24
	        },
	        end: {
	          line: 67,
	          column: 69
	        }
	      },
	      "49": {
	        start: {
	          line: 68,
	          column: 6
	        },
	        end: {
	          line: 71,
	          column: 7
	        }
	      },
	      "50": {
	        start: {
	          line: 69,
	          column: 8
	        },
	        end: {
	          line: 69,
	          column: 73
	        }
	      },
	      "51": {
	        start: {
	          line: 70,
	          column: 8
	        },
	        end: {
	          line: 70,
	          column: 15
	        }
	      },
	      "52": {
	        start: {
	          line: 73,
	          column: 4
	        },
	        end: {
	          line: 73,
	          column: 47
	        }
	      },
	      "53": {
	        start: {
	          line: 74,
	          column: 4
	        },
	        end: {
	          line: 74,
	          column: 11
	        }
	      },
	      "54": {
	        start: {
	          line: 76,
	          column: 2
	        },
	        end: {
	          line: 78,
	          column: 3
	        }
	      },
	      "55": {
	        start: {
	          line: 77,
	          column: 4
	        },
	        end: {
	          line: 77,
	          column: 40
	        }
	      },
	      "56": {
	        start: {
	          line: 80,
	          column: 0
	        },
	        end: {
	          line: 80,
	          column: 35
	        }
	      },
	      "57": {
	        start: {
	          line: 81,
	          column: 29
	        },
	        end: {
	          line: 101,
	          column: 1
	        }
	      },
	      "58": {
	        start: {
	          line: 82,
	          column: 2
	        },
	        end: {
	          line: 85,
	          column: 3
	        }
	      },
	      "59": {
	        start: {
	          line: 83,
	          column: 4
	        },
	        end: {
	          line: 83,
	          column: 44
	        }
	      },
	      "60": {
	        start: {
	          line: 84,
	          column: 4
	        },
	        end: {
	          line: 84,
	          column: 11
	        }
	      },
	      "61": {
	        start: {
	          line: 86,
	          column: 2
	        },
	        end: {
	          line: 86,
	          column: 43
	        }
	      },
	      "62": {
	        start: {
	          line: 87,
	          column: 2
	        },
	        end: {
	          line: 89,
	          column: 3
	        }
	      },
	      "63": {
	        start: {
	          line: 88,
	          column: 4
	        },
	        end: {
	          line: 88,
	          column: 11
	        }
	      },
	      "64": {
	        start: {
	          line: 90,
	          column: 2
	        },
	        end: {
	          line: 93,
	          column: 3
	        }
	      },
	      "65": {
	        start: {
	          line: 91,
	          column: 4
	        },
	        end: {
	          line: 91,
	          column: 55
	        }
	      },
	      "66": {
	        start: {
	          line: 92,
	          column: 4
	        },
	        end: {
	          line: 92,
	          column: 11
	        }
	      },
	      "67": {
	        start: {
	          line: 94,
	          column: 2
	        },
	        end: {
	          line: 97,
	          column: 3
	        }
	      },
	      "68": {
	        start: {
	          line: 95,
	          column: 4
	        },
	        end: {
	          line: 95,
	          column: 67
	        }
	      },
	      "69": {
	        start: {
	          line: 96,
	          column: 4
	        },
	        end: {
	          line: 96,
	          column: 11
	        }
	      },
	      "70": {
	        start: {
	          line: 98,
	          column: 2
	        },
	        end: {
	          line: 100,
	          column: 3
	        }
	      },
	      "71": {
	        start: {
	          line: 99,
	          column: 4
	        },
	        end: {
	          line: 99,
	          column: 49
	        }
	      },
	      "72": {
	        start: {
	          line: 102,
	          column: 0
	        },
	        end: {
	          line: 102,
	          column: 37
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 1,
	            column: 70
	          },
	          end: {
	            line: 1,
	            column: 71
	          }
	        },
	        loc: {
	          start: {
	            line: 1,
	            column: 83
	          },
	          end: {
	            line: 3,
	            column: 1
	          }
	        },
	        line: 1
	      },
	      "1": {
	        name: "trivialMatchesDiffFilter",
	        decl: {
	          start: {
	            line: 4,
	            column: 35
	          },
	          end: {
	            line: 4,
	            column: 59
	          }
	        },
	        loc: {
	          start: {
	            line: 4,
	            column: 69
	          },
	          end: {
	            line: 50,
	            column: 1
	          }
	        },
	        line: 4
	      },
	      "2": {
	        name: "trivialMatchesPatchFilter",
	        decl: {
	          start: {
	            line: 52,
	            column: 36
	          },
	          end: {
	            line: 52,
	            column: 61
	          }
	        },
	        loc: {
	          start: {
	            line: 52,
	            column: 71
	          },
	          end: {
	            line: 79,
	            column: 1
	          }
	        },
	        line: 52
	      },
	      "3": {
	        name: "trivialReferseFilter",
	        decl: {
	          start: {
	            line: 81,
	            column: 38
	          },
	          end: {
	            line: 81,
	            column: 58
	          }
	        },
	        loc: {
	          start: {
	            line: 81,
	            column: 68
	          },
	          end: {
	            line: 101,
	            column: 1
	          }
	        },
	        line: 81
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 1,
	            column: 16
	          },
	          end: {
	            line: 3,
	            column: 1
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 1,
	            column: 54
	          },
	          end: {
	            line: 1,
	            column: 67
	          }
	        }, {
	          start: {
	            line: 1,
	            column: 70
	          },
	          end: {
	            line: 3,
	            column: 1
	          }
	        }],
	        line: 1
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 5,
	            column: 2
	          },
	          end: {
	            line: 8,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 5,
	            column: 2
	          },
	          end: {
	            line: 8,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 5
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 9,
	            column: 2
	          },
	          end: {
	            line: 15,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 9,
	            column: 2
	          },
	          end: {
	            line: 15,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 9
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 10,
	            column: 4
	          },
	          end: {
	            line: 12,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 10,
	            column: 4
	          },
	          end: {
	            line: 12,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 10
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 16,
	            column: 2
	          },
	          end: {
	            line: 19,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 16,
	            column: 2
	          },
	          end: {
	            line: 19,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 16
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 20,
	            column: 2
	          },
	          end: {
	            line: 22,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 20,
	            column: 2
	          },
	          end: {
	            line: 22,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 20
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 20,
	            column: 6
	          },
	          end: {
	            line: 20,
	            column: 79
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 20,
	            column: 6
	          },
	          end: {
	            line: 20,
	            column: 40
	          }
	        }, {
	          start: {
	            line: 20,
	            column: 44
	          },
	          end: {
	            line: 20,
	            column: 79
	          }
	        }],
	        line: 20
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 23,
	            column: 21
	          },
	          end: {
	            line: 23,
	            column: 73
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 23,
	            column: 45
	          },
	          end: {
	            line: 23,
	            column: 51
	          }
	        }, {
	          start: {
	            line: 23,
	            column: 54
	          },
	          end: {
	            line: 23,
	            column: 73
	          }
	        }],
	        line: 23
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 24,
	            column: 22
	          },
	          end: {
	            line: 24,
	            column: 76
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 24,
	            column: 47
	          },
	          end: {
	            line: 24,
	            column: 53
	          }
	        }, {
	          start: {
	            line: 24,
	            column: 56
	          },
	          end: {
	            line: 24,
	            column: 76
	          }
	        }],
	        line: 24
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 25,
	            column: 2
	          },
	          end: {
	            line: 28,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 25,
	            column: 2
	          },
	          end: {
	            line: 28,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 25
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 29,
	            column: 2
	          },
	          end: {
	            line: 32,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 29,
	            column: 2
	          },
	          end: {
	            line: 32,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 29
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 29,
	            column: 6
	          },
	          end: {
	            line: 29,
	            column: 69
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 29,
	            column: 6
	          },
	          end: {
	            line: 29,
	            column: 36
	          }
	        }, {
	          start: {
	            line: 29,
	            column: 40
	          },
	          end: {
	            line: 29,
	            column: 69
	          }
	        }],
	        line: 29
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 33,
	            column: 2
	          },
	          end: {
	            line: 35,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 33,
	            column: 2
	          },
	          end: {
	            line: 35,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 33
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 36,
	            column: 2
	          },
	          end: {
	            line: 38,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 36,
	            column: 2
	          },
	          end: {
	            line: 38,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 36
	      },
	      "14": {
	        loc: {
	          start: {
	            line: 39,
	            column: 2
	          },
	          end: {
	            line: 42,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 39,
	            column: 2
	          },
	          end: {
	            line: 42,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 39
	      },
	      "15": {
	        loc: {
	          start: {
	            line: 43,
	            column: 2
	          },
	          end: {
	            line: 49,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 43,
	            column: 2
	          },
	          end: {
	            line: 49,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 43
	      },
	      "16": {
	        loc: {
	          start: {
	            line: 44,
	            column: 4
	          },
	          end: {
	            line: 48,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 44,
	            column: 4
	          },
	          end: {
	            line: 48,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 46,
	            column: 11
	          },
	          end: {
	            line: 48,
	            column: 5
	          }
	        }],
	        line: 44
	      },
	      "17": {
	        loc: {
	          start: {
	            line: 53,
	            column: 2
	          },
	          end: {
	            line: 56,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 53,
	            column: 2
	          },
	          end: {
	            line: 56,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 53
	      },
	      "18": {
	        loc: {
	          start: {
	            line: 58,
	            column: 2
	          },
	          end: {
	            line: 60,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 58,
	            column: 2
	          },
	          end: {
	            line: 60,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 58
	      },
	      "19": {
	        loc: {
	          start: {
	            line: 61,
	            column: 2
	          },
	          end: {
	            line: 64,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 61,
	            column: 2
	          },
	          end: {
	            line: 64,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 61
	      },
	      "20": {
	        loc: {
	          start: {
	            line: 65,
	            column: 2
	          },
	          end: {
	            line: 75,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 65,
	            column: 2
	          },
	          end: {
	            line: 75,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 65
	      },
	      "21": {
	        loc: {
	          start: {
	            line: 66,
	            column: 4
	          },
	          end: {
	            line: 72,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 66,
	            column: 4
	          },
	          end: {
	            line: 72,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 66
	      },
	      "22": {
	        loc: {
	          start: {
	            line: 68,
	            column: 6
	          },
	          end: {
	            line: 71,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 68,
	            column: 6
	          },
	          end: {
	            line: 71,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 68
	      },
	      "23": {
	        loc: {
	          start: {
	            line: 76,
	            column: 2
	          },
	          end: {
	            line: 78,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 76,
	            column: 2
	          },
	          end: {
	            line: 78,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 76
	      },
	      "24": {
	        loc: {
	          start: {
	            line: 76,
	            column: 6
	          },
	          end: {
	            line: 76,
	            column: 58
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 76,
	            column: 6
	          },
	          end: {
	            line: 76,
	            column: 32
	          }
	        }, {
	          start: {
	            line: 76,
	            column: 36
	          },
	          end: {
	            line: 76,
	            column: 58
	          }
	        }],
	        line: 76
	      },
	      "25": {
	        loc: {
	          start: {
	            line: 82,
	            column: 2
	          },
	          end: {
	            line: 85,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 82,
	            column: 2
	          },
	          end: {
	            line: 85,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 82
	      },
	      "26": {
	        loc: {
	          start: {
	            line: 87,
	            column: 2
	          },
	          end: {
	            line: 89,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 87,
	            column: 2
	          },
	          end: {
	            line: 89,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 87
	      },
	      "27": {
	        loc: {
	          start: {
	            line: 90,
	            column: 2
	          },
	          end: {
	            line: 93,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 90,
	            column: 2
	          },
	          end: {
	            line: 93,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 90
	      },
	      "28": {
	        loc: {
	          start: {
	            line: 94,
	            column: 2
	          },
	          end: {
	            line: 97,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 94,
	            column: 2
	          },
	          end: {
	            line: 97,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 94
	      },
	      "29": {
	        loc: {
	          start: {
	            line: 98,
	            column: 2
	          },
	          end: {
	            line: 100,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 98,
	            column: 2
	          },
	          end: {
	            line: 100,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 98
	      },
	      "30": {
	        loc: {
	          start: {
	            line: 98,
	            column: 6
	          },
	          end: {
	            line: 98,
	            column: 58
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 98,
	            column: 6
	          },
	          end: {
	            line: 98,
	            column: 32
	          }
	        }, {
	          start: {
	            line: 98,
	            column: 36
	          },
	          end: {
	            line: 98,
	            column: 58
	          }
	        }],
	        line: 98
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0,
	      "72": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0],
	      "8": [0, 0],
	      "9": [0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0],
	      "13": [0, 0],
	      "14": [0, 0],
	      "15": [0, 0],
	      "16": [0, 0],
	      "17": [0, 0],
	      "18": [0, 0],
	      "19": [0, 0],
	      "20": [0, 0],
	      "21": [0, 0],
	      "22": [0, 0],
	      "23": [0, 0],
	      "24": [0, 0],
	      "25": [0, 0],
	      "26": [0, 0],
	      "27": [0, 0],
	      "28": [0, 0],
	      "29": [0, 0],
	      "30": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/trivial.js"],
	      sourcesContent: ["const isArray =\n  typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function(a) {\n      return a instanceof Array;\n    };\n\nexport const diffFilter = function trivialMatchesDiffFilter(context) {\n  if (context.left === context.right) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  if (typeof context.left === 'undefined') {\n    if (typeof context.right === 'function') {\n      throw new Error('functions are not supported');\n    }\n    context.setResult([context.right]).exit();\n    return;\n  }\n  if (typeof context.right === 'undefined') {\n    context.setResult([context.left, 0, 0]).exit();\n    return;\n  }\n  if (\n    typeof context.left === 'function' ||\n    typeof context.right === 'function'\n  ) {\n    throw new Error('functions are not supported');\n  }\n  context.leftType = context.left === null ? 'null' : typeof context.left;\n  context.rightType = context.right === null ? 'null' : typeof context.right;\n  if (context.leftType !== context.rightType) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'boolean' || context.leftType === 'number') {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'object') {\n    context.leftIsArray = isArray(context.left);\n  }\n  if (context.rightType === 'object') {\n    context.rightIsArray = isArray(context.right);\n  }\n  if (context.leftIsArray !== context.rightIsArray) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n\n  if (context.left instanceof RegExp) {\n    if (context.right instanceof RegExp) {\n      context\n        .setResult([context.left.toString(), context.right.toString()])\n        .exit();\n    } else {\n      context.setResult([context.left, context.right]).exit();\n    }\n  }\n};\ndiffFilter.filterName = 'trivial';\n\nexport const patchFilter = function trivialMatchesPatchFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.nested = !isArray(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult(context.delta[0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    if (context.left instanceof RegExp) {\n      const regexArgs = /^\\/(.*)\\/([gimyu]+)$/.exec(context.delta[1]);\n      if (regexArgs) {\n        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();\n        return;\n      }\n    }\n    context.setResult(context.delta[1]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult(undefined).exit();\n  }\n};\npatchFilter.filterName = 'trivial';\n\nexport const reverseFilter = function trivialReferseFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.delta).exit();\n    return;\n  }\n  context.nested = !isArray(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult([context.delta[0], 0, 0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    context.setResult([context.delta[1], context.delta[0]]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult([context.delta[0]]).exit();\n  }\n};\nreverseFilter.filterName = 'trivial';\n"],
	      names: ["isArray", "Array", "a", "diffFilter", "trivialMatchesDiffFilter", "context", "left", "right", "setResult", "undefined", "exit", "Error", "leftType", "rightType", "leftIsArray", "rightIsArray", "RegExp", "toString", "filterName", "patchFilter", "trivialMatchesPatchFilter", "delta", "nested", "length", "regexArgs", "exec", "reverseFilter", "trivialReferseFilter"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "06243e451936ecfc1374873ce358c0641e232932"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_3qxlmdaon = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_3qxlmdaon();
	const isArray$2 = (cov_3qxlmdaon().s[0]++, typeof Array.isArray === 'function' ? (cov_3qxlmdaon().b[0][0]++, Array.isArray) : (cov_3qxlmdaon().b[0][1]++, function (a) {
	  cov_3qxlmdaon().f[0]++;
	  cov_3qxlmdaon().s[1]++;
	  return a instanceof Array;
	}));
	cov_3qxlmdaon().s[2]++;
	const diffFilter$3 = function trivialMatchesDiffFilter(context) {
	  cov_3qxlmdaon().f[1]++;
	  cov_3qxlmdaon().s[3]++;
	  if (context.left === context.right) {
	    cov_3qxlmdaon().b[1][0]++;
	    cov_3qxlmdaon().s[4]++;
	    context.setResult(undefined).exit();
	    cov_3qxlmdaon().s[5]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[1][1]++;
	  }
	  cov_3qxlmdaon().s[6]++;
	  if (typeof context.left === 'undefined') {
	    cov_3qxlmdaon().b[2][0]++;
	    cov_3qxlmdaon().s[7]++;
	    if (typeof context.right === 'function') {
	      cov_3qxlmdaon().b[3][0]++;
	      cov_3qxlmdaon().s[8]++;
	      throw new Error('functions are not supported');
	    } else {
	      cov_3qxlmdaon().b[3][1]++;
	    }
	    cov_3qxlmdaon().s[9]++;
	    context.setResult([context.right]).exit();
	    cov_3qxlmdaon().s[10]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[2][1]++;
	  }
	  cov_3qxlmdaon().s[11]++;
	  if (typeof context.right === 'undefined') {
	    cov_3qxlmdaon().b[4][0]++;
	    cov_3qxlmdaon().s[12]++;
	    context.setResult([context.left, 0, 0]).exit();
	    cov_3qxlmdaon().s[13]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[4][1]++;
	  }
	  cov_3qxlmdaon().s[14]++;
	  if ((cov_3qxlmdaon().b[6][0]++, typeof context.left === 'function') || (cov_3qxlmdaon().b[6][1]++, typeof context.right === 'function')) {
	    cov_3qxlmdaon().b[5][0]++;
	    cov_3qxlmdaon().s[15]++;
	    throw new Error('functions are not supported');
	  } else {
	    cov_3qxlmdaon().b[5][1]++;
	  }
	  cov_3qxlmdaon().s[16]++;
	  context.leftType = context.left === null ? (cov_3qxlmdaon().b[7][0]++, 'null') : (cov_3qxlmdaon().b[7][1]++, typeof context.left);
	  cov_3qxlmdaon().s[17]++;
	  context.rightType = context.right === null ? (cov_3qxlmdaon().b[8][0]++, 'null') : (cov_3qxlmdaon().b[8][1]++, typeof context.right);
	  cov_3qxlmdaon().s[18]++;
	  if (context.leftType !== context.rightType) {
	    cov_3qxlmdaon().b[9][0]++;
	    cov_3qxlmdaon().s[19]++;
	    context.setResult([context.left, context.right]).exit();
	    cov_3qxlmdaon().s[20]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[9][1]++;
	  }
	  cov_3qxlmdaon().s[21]++;
	  if ((cov_3qxlmdaon().b[11][0]++, context.leftType === 'boolean') || (cov_3qxlmdaon().b[11][1]++, context.leftType === 'number')) {
	    cov_3qxlmdaon().b[10][0]++;
	    cov_3qxlmdaon().s[22]++;
	    context.setResult([context.left, context.right]).exit();
	    cov_3qxlmdaon().s[23]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[10][1]++;
	  }
	  cov_3qxlmdaon().s[24]++;
	  if (context.leftType === 'object') {
	    cov_3qxlmdaon().b[12][0]++;
	    cov_3qxlmdaon().s[25]++;
	    context.leftIsArray = isArray$2(context.left);
	  } else {
	    cov_3qxlmdaon().b[12][1]++;
	  }
	  cov_3qxlmdaon().s[26]++;
	  if (context.rightType === 'object') {
	    cov_3qxlmdaon().b[13][0]++;
	    cov_3qxlmdaon().s[27]++;
	    context.rightIsArray = isArray$2(context.right);
	  } else {
	    cov_3qxlmdaon().b[13][1]++;
	  }
	  cov_3qxlmdaon().s[28]++;
	  if (context.leftIsArray !== context.rightIsArray) {
	    cov_3qxlmdaon().b[14][0]++;
	    cov_3qxlmdaon().s[29]++;
	    context.setResult([context.left, context.right]).exit();
	    cov_3qxlmdaon().s[30]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[14][1]++;
	  }
	  cov_3qxlmdaon().s[31]++;
	  if (context.left instanceof RegExp) {
	    cov_3qxlmdaon().b[15][0]++;
	    cov_3qxlmdaon().s[32]++;
	    if (context.right instanceof RegExp) {
	      cov_3qxlmdaon().b[16][0]++;
	      cov_3qxlmdaon().s[33]++;
	      context.setResult([context.left.toString(), context.right.toString()]).exit();
	    } else {
	      cov_3qxlmdaon().b[16][1]++;
	      cov_3qxlmdaon().s[34]++;
	      context.setResult([context.left, context.right]).exit();
	    }
	  } else {
	    cov_3qxlmdaon().b[15][1]++;
	  }
	};
	cov_3qxlmdaon().s[35]++;
	diffFilter$3.filterName = 'trivial';
	cov_3qxlmdaon().s[36]++;
	const patchFilter$3 = function trivialMatchesPatchFilter(context) {
	  cov_3qxlmdaon().f[2]++;
	  cov_3qxlmdaon().s[37]++;
	  if (typeof context.delta === 'undefined') {
	    cov_3qxlmdaon().b[17][0]++;
	    cov_3qxlmdaon().s[38]++;
	    context.setResult(context.left).exit();
	    cov_3qxlmdaon().s[39]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[17][1]++;
	  }
	  cov_3qxlmdaon().s[40]++;
	  context.nested = !isArray$2(context.delta);
	  cov_3qxlmdaon().s[41]++;
	  if (context.nested) {
	    cov_3qxlmdaon().b[18][0]++;
	    cov_3qxlmdaon().s[42]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[18][1]++;
	  }
	  cov_3qxlmdaon().s[43]++;
	  if (context.delta.length === 1) {
	    cov_3qxlmdaon().b[19][0]++;
	    cov_3qxlmdaon().s[44]++;
	    context.setResult(context.delta[0]).exit();
	    cov_3qxlmdaon().s[45]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[19][1]++;
	  }
	  cov_3qxlmdaon().s[46]++;
	  if (context.delta.length === 2) {
	    cov_3qxlmdaon().b[20][0]++;
	    cov_3qxlmdaon().s[47]++;
	    if (context.left instanceof RegExp) {
	      cov_3qxlmdaon().b[21][0]++;
	      const regexArgs = (cov_3qxlmdaon().s[48]++, /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1]));
	      cov_3qxlmdaon().s[49]++;
	      if (regexArgs) {
	        cov_3qxlmdaon().b[22][0]++;
	        cov_3qxlmdaon().s[50]++;
	        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
	        cov_3qxlmdaon().s[51]++;
	        return;
	      } else {
	        cov_3qxlmdaon().b[22][1]++;
	      }
	    } else {
	      cov_3qxlmdaon().b[21][1]++;
	    }
	    cov_3qxlmdaon().s[52]++;
	    context.setResult(context.delta[1]).exit();
	    cov_3qxlmdaon().s[53]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[20][1]++;
	  }
	  cov_3qxlmdaon().s[54]++;
	  if ((cov_3qxlmdaon().b[24][0]++, context.delta.length === 3) && (cov_3qxlmdaon().b[24][1]++, context.delta[2] === 0)) {
	    cov_3qxlmdaon().b[23][0]++;
	    cov_3qxlmdaon().s[55]++;
	    context.setResult(undefined).exit();
	  } else {
	    cov_3qxlmdaon().b[23][1]++;
	  }
	};
	cov_3qxlmdaon().s[56]++;
	patchFilter$3.filterName = 'trivial';
	cov_3qxlmdaon().s[57]++;
	const reverseFilter$3 = function trivialReferseFilter(context) {
	  cov_3qxlmdaon().f[3]++;
	  cov_3qxlmdaon().s[58]++;
	  if (typeof context.delta === 'undefined') {
	    cov_3qxlmdaon().b[25][0]++;
	    cov_3qxlmdaon().s[59]++;
	    context.setResult(context.delta).exit();
	    cov_3qxlmdaon().s[60]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[25][1]++;
	  }
	  cov_3qxlmdaon().s[61]++;
	  context.nested = !isArray$2(context.delta);
	  cov_3qxlmdaon().s[62]++;
	  if (context.nested) {
	    cov_3qxlmdaon().b[26][0]++;
	    cov_3qxlmdaon().s[63]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[26][1]++;
	  }
	  cov_3qxlmdaon().s[64]++;
	  if (context.delta.length === 1) {
	    cov_3qxlmdaon().b[27][0]++;
	    cov_3qxlmdaon().s[65]++;
	    context.setResult([context.delta[0], 0, 0]).exit();
	    cov_3qxlmdaon().s[66]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[27][1]++;
	  }
	  cov_3qxlmdaon().s[67]++;
	  if (context.delta.length === 2) {
	    cov_3qxlmdaon().b[28][0]++;
	    cov_3qxlmdaon().s[68]++;
	    context.setResult([context.delta[1], context.delta[0]]).exit();
	    cov_3qxlmdaon().s[69]++;
	    return;
	  } else {
	    cov_3qxlmdaon().b[28][1]++;
	  }
	  cov_3qxlmdaon().s[70]++;
	  if ((cov_3qxlmdaon().b[30][0]++, context.delta.length === 3) && (cov_3qxlmdaon().b[30][1]++, context.delta[2] === 0)) {
	    cov_3qxlmdaon().b[29][0]++;
	    cov_3qxlmdaon().s[71]++;
	    context.setResult([context.delta[0]]).exit();
	  } else {
	    cov_3qxlmdaon().b[29][1]++;
	  }
	};
	cov_3qxlmdaon().s[72]++;
	reverseFilter$3.filterName = 'trivial';
	function cov_460jccrw6() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/nested.js";
	  var hash = "fa85cf0de5d7debaf112c931e0e2a5ad70e85941";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/nested.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 5,
	          column: 2
	        },
	        end: {
	          line: 7,
	          column: 3
	        }
	      },
	      "1": {
	        start: {
	          line: 6,
	          column: 4
	        },
	        end: {
	          line: 6,
	          column: 11
	        }
	      },
	      "2": {
	        start: {
	          line: 8,
	          column: 17
	        },
	        end: {
	          line: 8,
	          column: 40
	        }
	      },
	      "3": {
	        start: {
	          line: 10,
	          column: 15
	        },
	        end: {
	          line: 10,
	          column: 29
	        }
	      },
	      "4": {
	        start: {
	          line: 11,
	          column: 2
	        },
	        end: {
	          line: 18,
	          column: 3
	        }
	      },
	      "5": {
	        start: {
	          line: 11,
	          column: 19
	        },
	        end: {
	          line: 11,
	          column: 20
	        }
	      },
	      "6": {
	        start: {
	          line: 12,
	          column: 4
	        },
	        end: {
	          line: 12,
	          column: 36
	        }
	      },
	      "7": {
	        start: {
	          line: 13,
	          column: 4
	        },
	        end: {
	          line: 15,
	          column: 5
	        }
	      },
	      "8": {
	        start: {
	          line: 14,
	          column: 6
	        },
	        end: {
	          line: 14,
	          column: 15
	        }
	      },
	      "9": {
	        start: {
	          line: 16,
	          column: 4
	        },
	        end: {
	          line: 16,
	          column: 26
	        }
	      },
	      "10": {
	        start: {
	          line: 17,
	          column: 4
	        },
	        end: {
	          line: 17,
	          column: 43
	        }
	      },
	      "11": {
	        start: {
	          line: 19,
	          column: 2
	        },
	        end: {
	          line: 21,
	          column: 3
	        }
	      },
	      "12": {
	        start: {
	          line: 20,
	          column: 4
	        },
	        end: {
	          line: 20,
	          column: 20
	        }
	      },
	      "13": {
	        start: {
	          line: 22,
	          column: 2
	        },
	        end: {
	          line: 22,
	          column: 35
	        }
	      },
	      "14": {
	        start: {
	          line: 24,
	          column: 0
	        },
	        end: {
	          line: 24,
	          column: 57
	        }
	      },
	      "15": {
	        start: {
	          line: 26,
	          column: 2
	        },
	        end: {
	          line: 28,
	          column: 3
	        }
	      },
	      "16": {
	        start: {
	          line: 27,
	          column: 4
	        },
	        end: {
	          line: 27,
	          column: 11
	        }
	      },
	      "17": {
	        start: {
	          line: 31,
	          column: 25
	        },
	        end: {
	          line: 31,
	          column: 55
	        }
	      },
	      "18": {
	        start: {
	          line: 32,
	          column: 2
	        },
	        end: {
	          line: 41,
	          column: 3
	        }
	      },
	      "19": {
	        start: {
	          line: 33,
	          column: 4
	        },
	        end: {
	          line: 35,
	          column: 5
	        }
	      },
	      "20": {
	        start: {
	          line: 34,
	          column: 6
	        },
	        end: {
	          line: 34,
	          column: 15
	        }
	      },
	      "21": {
	        start: {
	          line: 36,
	          column: 4
	        },
	        end: {
	          line: 38,
	          column: 5
	        }
	      },
	      "22": {
	        start: {
	          line: 37,
	          column: 6
	        },
	        end: {
	          line: 37,
	          column: 15
	        }
	      },
	      "23": {
	        start: {
	          line: 39,
	          column: 4
	        },
	        end: {
	          line: 39,
	          column: 69
	        }
	      },
	      "24": {
	        start: {
	          line: 40,
	          column: 4
	        },
	        end: {
	          line: 40,
	          column: 30
	        }
	      },
	      "25": {
	        start: {
	          line: 42,
	          column: 2
	        },
	        end: {
	          line: 53,
	          column: 3
	        }
	      },
	      "26": {
	        start: {
	          line: 43,
	          column: 4
	        },
	        end: {
	          line: 45,
	          column: 5
	        }
	      },
	      "27": {
	        start: {
	          line: 44,
	          column: 6
	        },
	        end: {
	          line: 44,
	          column: 15
	        }
	      },
	      "28": {
	        start: {
	          line: 46,
	          column: 4
	        },
	        end: {
	          line: 48,
	          column: 5
	        }
	      },
	      "29": {
	        start: {
	          line: 47,
	          column: 6
	        },
	        end: {
	          line: 47,
	          column: 15
	        }
	      },
	      "30": {
	        start: {
	          line: 49,
	          column: 4
	        },
	        end: {
	          line: 52,
	          column: 5
	        }
	      },
	      "31": {
	        start: {
	          line: 50,
	          column: 6
	        },
	        end: {
	          line: 50,
	          column: 62
	        }
	      },
	      "32": {
	        start: {
	          line: 51,
	          column: 6
	        },
	        end: {
	          line: 51,
	          column: 32
	        }
	      },
	      "33": {
	        start: {
	          line: 54,
	          column: 2
	        },
	        end: {
	          line: 57,
	          column: 3
	        }
	      },
	      "34": {
	        start: {
	          line: 55,
	          column: 4
	        },
	        end: {
	          line: 55,
	          column: 40
	        }
	      },
	      "35": {
	        start: {
	          line: 56,
	          column: 4
	        },
	        end: {
	          line: 56,
	          column: 11
	        }
	      },
	      "36": {
	        start: {
	          line: 58,
	          column: 2
	        },
	        end: {
	          line: 58,
	          column: 17
	        }
	      },
	      "37": {
	        start: {
	          line: 60,
	          column: 0
	        },
	        end: {
	          line: 60,
	          column: 41
	        }
	      },
	      "38": {
	        start: {
	          line: 61,
	          column: 27
	        },
	        end: {
	          line: 75,
	          column: 1
	        }
	      },
	      "39": {
	        start: {
	          line: 62,
	          column: 2
	        },
	        end: {
	          line: 64,
	          column: 3
	        }
	      },
	      "40": {
	        start: {
	          line: 63,
	          column: 4
	        },
	        end: {
	          line: 63,
	          column: 11
	        }
	      },
	      "41": {
	        start: {
	          line: 65,
	          column: 2
	        },
	        end: {
	          line: 67,
	          column: 3
	        }
	      },
	      "42": {
	        start: {
	          line: 66,
	          column: 4
	        },
	        end: {
	          line: 66,
	          column: 11
	        }
	      },
	      "43": {
	        start: {
	          line: 70,
	          column: 2
	        },
	        end: {
	          line: 73,
	          column: 3
	        }
	      },
	      "44": {
	        start: {
	          line: 71,
	          column: 4
	        },
	        end: {
	          line: 71,
	          column: 70
	        }
	      },
	      "45": {
	        start: {
	          line: 72,
	          column: 4
	        },
	        end: {
	          line: 72,
	          column: 30
	        }
	      },
	      "46": {
	        start: {
	          line: 74,
	          column: 2
	        },
	        end: {
	          line: 74,
	          column: 17
	        }
	      },
	      "47": {
	        start: {
	          line: 76,
	          column: 0
	        },
	        end: {
	          line: 76,
	          column: 35
	        }
	      },
	      "48": {
	        start: {
	          line: 77,
	          column: 42
	        },
	        end: {
	          line: 95,
	          column: 1
	        }
	      },
	      "49": {
	        start: {
	          line: 78,
	          column: 2
	        },
	        end: {
	          line: 80,
	          column: 3
	        }
	      },
	      "50": {
	        start: {
	          line: 79,
	          column: 4
	        },
	        end: {
	          line: 79,
	          column: 11
	        }
	      },
	      "51": {
	        start: {
	          line: 81,
	          column: 2
	        },
	        end: {
	          line: 83,
	          column: 3
	        }
	      },
	      "52": {
	        start: {
	          line: 82,
	          column: 4
	        },
	        end: {
	          line: 82,
	          column: 11
	        }
	      },
	      "53": {
	        start: {
	          line: 84,
	          column: 17
	        },
	        end: {
	          line: 84,
	          column: 40
	        }
	      },
	      "54": {
	        start: {
	          line: 86,
	          column: 2
	        },
	        end: {
	          line: 93,
	          column: 3
	        }
	      },
	      "55": {
	        start: {
	          line: 86,
	          column: 19
	        },
	        end: {
	          line: 86,
	          column: 20
	        }
	      },
	      "56": {
	        start: {
	          line: 87,
	          column: 4
	        },
	        end: {
	          line: 87,
	          column: 36
	        }
	      },
	      "57": {
	        start: {
	          line: 88,
	          column: 4
	        },
	        end: {
	          line: 92,
	          column: 5
	        }
	      },
	      "58": {
	        start: {
	          line: 89,
	          column: 6
	        },
	        end: {
	          line: 89,
	          column: 43
	        }
	      },
	      "59": {
	        start: {
	          line: 90,
	          column: 11
	        },
	        end: {
	          line: 92,
	          column: 5
	        }
	      },
	      "60": {
	        start: {
	          line: 91,
	          column: 6
	        },
	        end: {
	          line: 91,
	          column: 51
	        }
	      },
	      "61": {
	        start: {
	          line: 94,
	          column: 2
	        },
	        end: {
	          line: 94,
	          column: 41
	        }
	      },
	      "62": {
	        start: {
	          line: 96,
	          column: 0
	        },
	        end: {
	          line: 96,
	          column: 58
	        }
	      },
	      "63": {
	        start: {
	          line: 97,
	          column: 29
	        },
	        end: {
	          line: 111,
	          column: 1
	        }
	      },
	      "64": {
	        start: {
	          line: 98,
	          column: 2
	        },
	        end: {
	          line: 100,
	          column: 3
	        }
	      },
	      "65": {
	        start: {
	          line: 99,
	          column: 4
	        },
	        end: {
	          line: 99,
	          column: 11
	        }
	      },
	      "66": {
	        start: {
	          line: 101,
	          column: 2
	        },
	        end: {
	          line: 103,
	          column: 3
	        }
	      },
	      "67": {
	        start: {
	          line: 102,
	          column: 4
	        },
	        end: {
	          line: 102,
	          column: 11
	        }
	      },
	      "68": {
	        start: {
	          line: 106,
	          column: 2
	        },
	        end: {
	          line: 109,
	          column: 3
	        }
	      },
	      "69": {
	        start: {
	          line: 107,
	          column: 4
	        },
	        end: {
	          line: 107,
	          column: 52
	        }
	      },
	      "70": {
	        start: {
	          line: 108,
	          column: 4
	        },
	        end: {
	          line: 108,
	          column: 30
	        }
	      },
	      "71": {
	        start: {
	          line: 110,
	          column: 2
	        },
	        end: {
	          line: 110,
	          column: 17
	        }
	      },
	      "72": {
	        start: {
	          line: 112,
	          column: 0
	        },
	        end: {
	          line: 112,
	          column: 37
	        }
	      },
	      "73": {
	        start: {
	          line: 114,
	          column: 2
	        },
	        end: {
	          line: 116,
	          column: 3
	        }
	      },
	      "74": {
	        start: {
	          line: 115,
	          column: 4
	        },
	        end: {
	          line: 115,
	          column: 11
	        }
	      },
	      "75": {
	        start: {
	          line: 117,
	          column: 2
	        },
	        end: {
	          line: 119,
	          column: 3
	        }
	      },
	      "76": {
	        start: {
	          line: 118,
	          column: 4
	        },
	        end: {
	          line: 118,
	          column: 11
	        }
	      },
	      "77": {
	        start: {
	          line: 120,
	          column: 17
	        },
	        end: {
	          line: 120,
	          column: 40
	        }
	      },
	      "78": {
	        start: {
	          line: 122,
	          column: 16
	        },
	        end: {
	          line: 122,
	          column: 18
	        }
	      },
	      "79": {
	        start: {
	          line: 123,
	          column: 2
	        },
	        end: {
	          line: 128,
	          column: 3
	        }
	      },
	      "80": {
	        start: {
	          line: 123,
	          column: 19
	        },
	        end: {
	          line: 123,
	          column: 20
	        }
	      },
	      "81": {
	        start: {
	          line: 124,
	          column: 4
	        },
	        end: {
	          line: 124,
	          column: 36
	        }
	      },
	      "82": {
	        start: {
	          line: 125,
	          column: 4
	        },
	        end: {
	          line: 127,
	          column: 5
	        }
	      },
	      "83": {
	        start: {
	          line: 126,
	          column: 6
	        },
	        end: {
	          line: 126,
	          column: 44
	        }
	      },
	      "84": {
	        start: {
	          line: 129,
	          column: 2
	        },
	        end: {
	          line: 129,
	          column: 34
	        }
	      },
	      "85": {
	        start: {
	          line: 131,
	          column: 0
	        },
	        end: {
	          line: 131,
	          column: 60
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "collectChildrenDiffFilter",
	        decl: {
	          start: {
	            line: 4,
	            column: 16
	          },
	          end: {
	            line: 4,
	            column: 41
	          }
	        },
	        loc: {
	          start: {
	            line: 4,
	            column: 51
	          },
	          end: {
	            line: 23,
	            column: 1
	          }
	        },
	        line: 4
	      },
	      "1": {
	        name: "objectsDiffFilter",
	        decl: {
	          start: {
	            line: 25,
	            column: 16
	          },
	          end: {
	            line: 25,
	            column: 33
	          }
	        },
	        loc: {
	          start: {
	            line: 25,
	            column: 43
	          },
	          end: {
	            line: 59,
	            column: 1
	          }
	        },
	        line: 25
	      },
	      "2": {
	        name: "nestedPatchFilter",
	        decl: {
	          start: {
	            line: 61,
	            column: 36
	          },
	          end: {
	            line: 61,
	            column: 53
	          }
	        },
	        loc: {
	          start: {
	            line: 61,
	            column: 63
	          },
	          end: {
	            line: 75,
	            column: 1
	          }
	        },
	        line: 61
	      },
	      "3": {
	        name: "collectChildrenPatchFilter",
	        decl: {
	          start: {
	            line: 77,
	            column: 51
	          },
	          end: {
	            line: 77,
	            column: 77
	          }
	        },
	        loc: {
	          start: {
	            line: 77,
	            column: 87
	          },
	          end: {
	            line: 95,
	            column: 1
	          }
	        },
	        line: 77
	      },
	      "4": {
	        name: "nestedReverseFilter",
	        decl: {
	          start: {
	            line: 97,
	            column: 38
	          },
	          end: {
	            line: 97,
	            column: 57
	          }
	        },
	        loc: {
	          start: {
	            line: 97,
	            column: 67
	          },
	          end: {
	            line: 111,
	            column: 1
	          }
	        },
	        line: 97
	      },
	      "5": {
	        name: "collectChildrenReverseFilter",
	        decl: {
	          start: {
	            line: 113,
	            column: 16
	          },
	          end: {
	            line: 113,
	            column: 44
	          }
	        },
	        loc: {
	          start: {
	            line: 113,
	            column: 54
	          },
	          end: {
	            line: 130,
	            column: 1
	          }
	        },
	        line: 113
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 5,
	            column: 2
	          },
	          end: {
	            line: 7,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 5,
	            column: 2
	          },
	          end: {
	            line: 7,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 5
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 5,
	            column: 6
	          },
	          end: {
	            line: 5,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 5,
	            column: 6
	          },
	          end: {
	            line: 5,
	            column: 14
	          }
	        }, {
	          start: {
	            line: 5,
	            column: 18
	          },
	          end: {
	            line: 5,
	            column: 35
	          }
	        }],
	        line: 5
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 13,
	            column: 4
	          },
	          end: {
	            line: 15,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 13,
	            column: 4
	          },
	          end: {
	            line: 15,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 13
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 16,
	            column: 13
	          },
	          end: {
	            line: 16,
	            column: 25
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 16,
	            column: 13
	          },
	          end: {
	            line: 16,
	            column: 19
	          }
	        }, {
	          start: {
	            line: 16,
	            column: 23
	          },
	          end: {
	            line: 16,
	            column: 25
	          }
	        }],
	        line: 16
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 19,
	            column: 2
	          },
	          end: {
	            line: 21,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 19,
	            column: 2
	          },
	          end: {
	            line: 21,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 19
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 19,
	            column: 6
	          },
	          end: {
	            line: 19,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 19,
	            column: 6
	          },
	          end: {
	            line: 19,
	            column: 12
	          }
	        }, {
	          start: {
	            line: 19,
	            column: 16
	          },
	          end: {
	            line: 19,
	            column: 35
	          }
	        }],
	        line: 19
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 26,
	            column: 2
	          },
	          end: {
	            line: 28,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 26,
	            column: 2
	          },
	          end: {
	            line: 28,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 26
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 26,
	            column: 6
	          },
	          end: {
	            line: 26,
	            column: 58
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 26,
	            column: 6
	          },
	          end: {
	            line: 26,
	            column: 25
	          }
	        }, {
	          start: {
	            line: 26,
	            column: 29
	          },
	          end: {
	            line: 26,
	            column: 58
	          }
	        }],
	        line: 26
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 33,
	            column: 4
	          },
	          end: {
	            line: 35,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 33,
	            column: 4
	          },
	          end: {
	            line: 35,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 33
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 36,
	            column: 4
	          },
	          end: {
	            line: 38,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 36,
	            column: 4
	          },
	          end: {
	            line: 38,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 36
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 36,
	            column: 8
	          },
	          end: {
	            line: 36,
	            column: 56
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 36,
	            column: 8
	          },
	          end: {
	            line: 36,
	            column: 22
	          }
	        }, {
	          start: {
	            line: 36,
	            column: 26
	          },
	          end: {
	            line: 36,
	            column: 56
	          }
	        }],
	        line: 36
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 43,
	            column: 4
	          },
	          end: {
	            line: 45,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 43,
	            column: 4
	          },
	          end: {
	            line: 45,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 43
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 46,
	            column: 4
	          },
	          end: {
	            line: 48,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 46,
	            column: 4
	          },
	          end: {
	            line: 48,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 46
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 46,
	            column: 8
	          },
	          end: {
	            line: 46,
	            column: 56
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 46,
	            column: 8
	          },
	          end: {
	            line: 46,
	            column: 22
	          }
	        }, {
	          start: {
	            line: 46,
	            column: 26
	          },
	          end: {
	            line: 46,
	            column: 56
	          }
	        }],
	        line: 46
	      },
	      "14": {
	        loc: {
	          start: {
	            line: 49,
	            column: 4
	          },
	          end: {
	            line: 52,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 49,
	            column: 4
	          },
	          end: {
	            line: 52,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 49
	      },
	      "15": {
	        loc: {
	          start: {
	            line: 54,
	            column: 2
	          },
	          end: {
	            line: 57,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 54,
	            column: 2
	          },
	          end: {
	            line: 57,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 54
	      },
	      "16": {
	        loc: {
	          start: {
	            line: 54,
	            column: 6
	          },
	          end: {
	            line: 54,
	            column: 56
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 54,
	            column: 6
	          },
	          end: {
	            line: 54,
	            column: 23
	          }
	        }, {
	          start: {
	            line: 54,
	            column: 27
	          },
	          end: {
	            line: 54,
	            column: 56
	          }
	        }],
	        line: 54
	      },
	      "17": {
	        loc: {
	          start: {
	            line: 62,
	            column: 2
	          },
	          end: {
	            line: 64,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 62,
	            column: 2
	          },
	          end: {
	            line: 64,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 62
	      },
	      "18": {
	        loc: {
	          start: {
	            line: 65,
	            column: 2
	          },
	          end: {
	            line: 67,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 65,
	            column: 2
	          },
	          end: {
	            line: 67,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 65
	      },
	      "19": {
	        loc: {
	          start: {
	            line: 78,
	            column: 2
	          },
	          end: {
	            line: 80,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 78,
	            column: 2
	          },
	          end: {
	            line: 80,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 78
	      },
	      "20": {
	        loc: {
	          start: {
	            line: 78,
	            column: 6
	          },
	          end: {
	            line: 78,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 78,
	            column: 6
	          },
	          end: {
	            line: 78,
	            column: 14
	          }
	        }, {
	          start: {
	            line: 78,
	            column: 18
	          },
	          end: {
	            line: 78,
	            column: 35
	          }
	        }],
	        line: 78
	      },
	      "21": {
	        loc: {
	          start: {
	            line: 81,
	            column: 2
	          },
	          end: {
	            line: 83,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 81,
	            column: 2
	          },
	          end: {
	            line: 83,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 81
	      },
	      "22": {
	        loc: {
	          start: {
	            line: 88,
	            column: 4
	          },
	          end: {
	            line: 92,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 88,
	            column: 4
	          },
	          end: {
	            line: 92,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 90,
	            column: 11
	          },
	          end: {
	            line: 92,
	            column: 5
	          }
	        }],
	        line: 88
	      },
	      "23": {
	        loc: {
	          start: {
	            line: 88,
	            column: 8
	          },
	          end: {
	            line: 88,
	            column: 105
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 88,
	            column: 8
	          },
	          end: {
	            line: 88,
	            column: 75
	          }
	        }, {
	          start: {
	            line: 88,
	            column: 79
	          },
	          end: {
	            line: 88,
	            column: 105
	          }
	        }],
	        line: 88
	      },
	      "24": {
	        loc: {
	          start: {
	            line: 90,
	            column: 11
	          },
	          end: {
	            line: 92,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 90,
	            column: 11
	          },
	          end: {
	            line: 92,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 90
	      },
	      "25": {
	        loc: {
	          start: {
	            line: 98,
	            column: 2
	          },
	          end: {
	            line: 100,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 98,
	            column: 2
	          },
	          end: {
	            line: 100,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 98
	      },
	      "26": {
	        loc: {
	          start: {
	            line: 101,
	            column: 2
	          },
	          end: {
	            line: 103,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 101,
	            column: 2
	          },
	          end: {
	            line: 103,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 101
	      },
	      "27": {
	        loc: {
	          start: {
	            line: 114,
	            column: 2
	          },
	          end: {
	            line: 116,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 114,
	            column: 2
	          },
	          end: {
	            line: 116,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 114
	      },
	      "28": {
	        loc: {
	          start: {
	            line: 114,
	            column: 6
	          },
	          end: {
	            line: 114,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 114,
	            column: 6
	          },
	          end: {
	            line: 114,
	            column: 14
	          }
	        }, {
	          start: {
	            line: 114,
	            column: 18
	          },
	          end: {
	            line: 114,
	            column: 35
	          }
	        }],
	        line: 114
	      },
	      "29": {
	        loc: {
	          start: {
	            line: 117,
	            column: 2
	          },
	          end: {
	            line: 119,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 117,
	            column: 2
	          },
	          end: {
	            line: 119,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 117
	      },
	      "30": {
	        loc: {
	          start: {
	            line: 125,
	            column: 4
	          },
	          end: {
	            line: 127,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 125,
	            column: 4
	          },
	          end: {
	            line: 127,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 125
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0,
	      "72": 0,
	      "73": 0,
	      "74": 0,
	      "75": 0,
	      "76": 0,
	      "77": 0,
	      "78": 0,
	      "79": 0,
	      "80": 0,
	      "81": 0,
	      "82": 0,
	      "83": 0,
	      "84": 0,
	      "85": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0],
	      "8": [0, 0],
	      "9": [0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0],
	      "13": [0, 0],
	      "14": [0, 0],
	      "15": [0, 0],
	      "16": [0, 0],
	      "17": [0, 0],
	      "18": [0, 0],
	      "19": [0, 0],
	      "20": [0, 0],
	      "21": [0, 0],
	      "22": [0, 0],
	      "23": [0, 0],
	      "24": [0, 0],
	      "25": [0, 0],
	      "26": [0, 0],
	      "27": [0, 0],
	      "28": [0, 0],
	      "29": [0, 0],
	      "30": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/nested.js"],
	      sourcesContent: ["import DiffContext from '../contexts/diff';\nimport PatchContext from '../contexts/patch';\nimport ReverseContext from '../contexts/reverse';\n\nexport function collectChildrenDiffFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  const length = context.children.length;\n  let child;\n  let result = context.result;\n  for (let index = 0; index < length; index++) {\n    child = context.children[index];\n    if (typeof child.result === 'undefined') {\n      continue;\n    }\n    result = result || {};\n    result[child.childName] = child.result;\n  }\n  if (result && context.leftIsArray) {\n    result._t = 'a';\n  }\n  context.setResult(result).exit();\n}\ncollectChildrenDiffFilter.filterName = 'collectChildren';\n\nexport function objectsDiffFilter(context) {\n  if (context.leftIsArray || context.leftType !== 'object') {\n    return;\n  }\n\n  let name;\n  let child;\n  const propertyFilter = context.options.propertyFilter;\n  for (name in context.left) {\n    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    child = new DiffContext(context.left[name], context.right[name]);\n    context.push(child, name);\n  }\n  for (name in context.right) {\n    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    if (typeof context.left[name] === 'undefined') {\n      child = new DiffContext(undefined, context.right[name]);\n      context.push(child, name);\n    }\n  }\n\n  if (!context.children || context.children.length === 0) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  context.exit();\n}\nobjectsDiffFilter.filterName = 'objects';\n\nexport const patchFilter = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  let name;\n  let child;\n  for (name in context.delta) {\n    child = new PatchContext(context.left[name], context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\npatchFilter.filterName = 'objects';\n\nexport const collectChildrenPatchFilter = function collectChildrenPatchFilter(\n  context,\n) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  const length = context.children.length;\n  let child;\n  for (let index = 0; index < length; index++) {\n    child = context.children[index];\n    if (\n      Object.prototype.hasOwnProperty.call(context.left, child.childName) &&\n      child.result === undefined\n    ) {\n      delete context.left[child.childName];\n    } else if (context.left[child.childName] !== child.result) {\n      context.left[child.childName] = child.result;\n    }\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter.filterName = 'collectChildren';\n\nexport const reverseFilter = function nestedReverseFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  let name;\n  let child;\n  for (name in context.delta) {\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter.filterName = 'objects';\n\nexport function collectChildrenReverseFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  const length = context.children.length;\n  let child;\n  const delta = {};\n  for (let index = 0; index < length; index++) {\n    child = context.children[index];\n    if (delta[child.childName] !== child.result) {\n      delta[child.childName] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n}\ncollectChildrenReverseFilter.filterName = 'collectChildren';\n"],
	      names: ["DiffContext", "PatchContext", "ReverseContext", "collectChildrenDiffFilter", "context", "children", "length", "child", "result", "index", "childName", "leftIsArray", "_t", "setResult", "exit", "filterName", "objectsDiffFilter", "leftType", "name", "propertyFilter", "options", "left", "Object", "prototype", "hasOwnProperty", "call", "right", "push", "undefined", "patchFilter", "nestedPatchFilter", "nested", "delta", "collectChildrenPatchFilter", "reverseFilter", "nestedReverseFilter", "collectChildrenReverseFilter"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "fa85cf0de5d7debaf112c931e0e2a5ad70e85941"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_460jccrw6 = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_460jccrw6();
	function collectChildrenDiffFilter(context) {
	  cov_460jccrw6().f[0]++;
	  cov_460jccrw6().s[0]++;
	  if ((cov_460jccrw6().b[1][0]++, !context) || (cov_460jccrw6().b[1][1]++, !context.children)) {
	    cov_460jccrw6().b[0][0]++;
	    cov_460jccrw6().s[1]++;
	    return;
	  } else {
	    cov_460jccrw6().b[0][1]++;
	  }
	  const length = (cov_460jccrw6().s[2]++, context.children.length);
	  let child;
	  let result = (cov_460jccrw6().s[3]++, context.result);
	  cov_460jccrw6().s[4]++;
	  for (let index = (cov_460jccrw6().s[5]++, 0); index < length; index++) {
	    cov_460jccrw6().s[6]++;
	    child = context.children[index];
	    cov_460jccrw6().s[7]++;
	    if (typeof child.result === 'undefined') {
	      cov_460jccrw6().b[2][0]++;
	      cov_460jccrw6().s[8]++;
	      continue;
	    } else {
	      cov_460jccrw6().b[2][1]++;
	    }
	    cov_460jccrw6().s[9]++;
	    result = (cov_460jccrw6().b[3][0]++, result) || (cov_460jccrw6().b[3][1]++, {});
	    cov_460jccrw6().s[10]++;
	    result[child.childName] = child.result;
	  }
	  cov_460jccrw6().s[11]++;
	  if ((cov_460jccrw6().b[5][0]++, result) && (cov_460jccrw6().b[5][1]++, context.leftIsArray)) {
	    cov_460jccrw6().b[4][0]++;
	    cov_460jccrw6().s[12]++;
	    result._t = 'a';
	  } else {
	    cov_460jccrw6().b[4][1]++;
	  }
	  cov_460jccrw6().s[13]++;
	  context.setResult(result).exit();
	}
	cov_460jccrw6().s[14]++;
	collectChildrenDiffFilter.filterName = 'collectChildren';
	function objectsDiffFilter(context) {
	  cov_460jccrw6().f[1]++;
	  cov_460jccrw6().s[15]++;
	  if ((cov_460jccrw6().b[7][0]++, context.leftIsArray) || (cov_460jccrw6().b[7][1]++, context.leftType !== 'object')) {
	    cov_460jccrw6().b[6][0]++;
	    cov_460jccrw6().s[16]++;
	    return;
	  } else {
	    cov_460jccrw6().b[6][1]++;
	  }
	  let name;
	  let child;
	  const propertyFilter = (cov_460jccrw6().s[17]++, context.options.propertyFilter);
	  cov_460jccrw6().s[18]++;
	  for (name in context.left) {
	    cov_460jccrw6().s[19]++;
	    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
	      cov_460jccrw6().b[8][0]++;
	      cov_460jccrw6().s[20]++;
	      continue;
	    } else {
	      cov_460jccrw6().b[8][1]++;
	    }
	    cov_460jccrw6().s[21]++;
	    if ((cov_460jccrw6().b[10][0]++, propertyFilter) && (cov_460jccrw6().b[10][1]++, !propertyFilter(name, context))) {
	      cov_460jccrw6().b[9][0]++;
	      cov_460jccrw6().s[22]++;
	      continue;
	    } else {
	      cov_460jccrw6().b[9][1]++;
	    }
	    cov_460jccrw6().s[23]++;
	    child = new DiffContext(context.left[name], context.right[name]);
	    cov_460jccrw6().s[24]++;
	    context.push(child, name);
	  }
	  cov_460jccrw6().s[25]++;
	  for (name in context.right) {
	    cov_460jccrw6().s[26]++;
	    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
	      cov_460jccrw6().b[11][0]++;
	      cov_460jccrw6().s[27]++;
	      continue;
	    } else {
	      cov_460jccrw6().b[11][1]++;
	    }
	    cov_460jccrw6().s[28]++;
	    if ((cov_460jccrw6().b[13][0]++, propertyFilter) && (cov_460jccrw6().b[13][1]++, !propertyFilter(name, context))) {
	      cov_460jccrw6().b[12][0]++;
	      cov_460jccrw6().s[29]++;
	      continue;
	    } else {
	      cov_460jccrw6().b[12][1]++;
	    }
	    cov_460jccrw6().s[30]++;
	    if (typeof context.left[name] === 'undefined') {
	      cov_460jccrw6().b[14][0]++;
	      cov_460jccrw6().s[31]++;
	      child = new DiffContext(undefined, context.right[name]);
	      cov_460jccrw6().s[32]++;
	      context.push(child, name);
	    } else {
	      cov_460jccrw6().b[14][1]++;
	    }
	  }
	  cov_460jccrw6().s[33]++;
	  if ((cov_460jccrw6().b[16][0]++, !context.children) || (cov_460jccrw6().b[16][1]++, context.children.length === 0)) {
	    cov_460jccrw6().b[15][0]++;
	    cov_460jccrw6().s[34]++;
	    context.setResult(undefined).exit();
	    cov_460jccrw6().s[35]++;
	    return;
	  } else {
	    cov_460jccrw6().b[15][1]++;
	  }
	  cov_460jccrw6().s[36]++;
	  context.exit();
	}
	cov_460jccrw6().s[37]++;
	objectsDiffFilter.filterName = 'objects';
	cov_460jccrw6().s[38]++;
	const patchFilter$2 = function nestedPatchFilter(context) {
	  cov_460jccrw6().f[2]++;
	  cov_460jccrw6().s[39]++;
	  if (!context.nested) {
	    cov_460jccrw6().b[17][0]++;
	    cov_460jccrw6().s[40]++;
	    return;
	  } else {
	    cov_460jccrw6().b[17][1]++;
	  }
	  cov_460jccrw6().s[41]++;
	  if (context.delta._t) {
	    cov_460jccrw6().b[18][0]++;
	    cov_460jccrw6().s[42]++;
	    return;
	  } else {
	    cov_460jccrw6().b[18][1]++;
	  }
	  let name;
	  let child;
	  cov_460jccrw6().s[43]++;
	  for (name in context.delta) {
	    cov_460jccrw6().s[44]++;
	    child = new PatchContext(context.left[name], context.delta[name]);
	    cov_460jccrw6().s[45]++;
	    context.push(child, name);
	  }
	  cov_460jccrw6().s[46]++;
	  context.exit();
	};
	cov_460jccrw6().s[47]++;
	patchFilter$2.filterName = 'objects';
	cov_460jccrw6().s[48]++;
	const collectChildrenPatchFilter$1 = function collectChildrenPatchFilter(context) {
	  cov_460jccrw6().f[3]++;
	  cov_460jccrw6().s[49]++;
	  if ((cov_460jccrw6().b[20][0]++, !context) || (cov_460jccrw6().b[20][1]++, !context.children)) {
	    cov_460jccrw6().b[19][0]++;
	    cov_460jccrw6().s[50]++;
	    return;
	  } else {
	    cov_460jccrw6().b[19][1]++;
	  }
	  cov_460jccrw6().s[51]++;
	  if (context.delta._t) {
	    cov_460jccrw6().b[21][0]++;
	    cov_460jccrw6().s[52]++;
	    return;
	  } else {
	    cov_460jccrw6().b[21][1]++;
	  }
	  const length = (cov_460jccrw6().s[53]++, context.children.length);
	  let child;
	  cov_460jccrw6().s[54]++;
	  for (let index = (cov_460jccrw6().s[55]++, 0); index < length; index++) {
	    cov_460jccrw6().s[56]++;
	    child = context.children[index];
	    cov_460jccrw6().s[57]++;
	    if ((cov_460jccrw6().b[23][0]++, Object.prototype.hasOwnProperty.call(context.left, child.childName)) && (cov_460jccrw6().b[23][1]++, child.result === undefined)) {
	      cov_460jccrw6().b[22][0]++;
	      cov_460jccrw6().s[58]++;
	      delete context.left[child.childName];
	    } else {
	      cov_460jccrw6().b[22][1]++;
	      cov_460jccrw6().s[59]++;
	      if (context.left[child.childName] !== child.result) {
	        cov_460jccrw6().b[24][0]++;
	        cov_460jccrw6().s[60]++;
	        context.left[child.childName] = child.result;
	      } else {
	        cov_460jccrw6().b[24][1]++;
	      }
	    }
	  }
	  cov_460jccrw6().s[61]++;
	  context.setResult(context.left).exit();
	};
	cov_460jccrw6().s[62]++;
	collectChildrenPatchFilter$1.filterName = 'collectChildren';
	cov_460jccrw6().s[63]++;
	const reverseFilter$2 = function nestedReverseFilter(context) {
	  cov_460jccrw6().f[4]++;
	  cov_460jccrw6().s[64]++;
	  if (!context.nested) {
	    cov_460jccrw6().b[25][0]++;
	    cov_460jccrw6().s[65]++;
	    return;
	  } else {
	    cov_460jccrw6().b[25][1]++;
	  }
	  cov_460jccrw6().s[66]++;
	  if (context.delta._t) {
	    cov_460jccrw6().b[26][0]++;
	    cov_460jccrw6().s[67]++;
	    return;
	  } else {
	    cov_460jccrw6().b[26][1]++;
	  }
	  let name;
	  let child;
	  cov_460jccrw6().s[68]++;
	  for (name in context.delta) {
	    cov_460jccrw6().s[69]++;
	    child = new ReverseContext(context.delta[name]);
	    cov_460jccrw6().s[70]++;
	    context.push(child, name);
	  }
	  cov_460jccrw6().s[71]++;
	  context.exit();
	};
	cov_460jccrw6().s[72]++;
	reverseFilter$2.filterName = 'objects';
	function collectChildrenReverseFilter$1(context) {
	  cov_460jccrw6().f[5]++;
	  cov_460jccrw6().s[73]++;
	  if ((cov_460jccrw6().b[28][0]++, !context) || (cov_460jccrw6().b[28][1]++, !context.children)) {
	    cov_460jccrw6().b[27][0]++;
	    cov_460jccrw6().s[74]++;
	    return;
	  } else {
	    cov_460jccrw6().b[27][1]++;
	  }
	  cov_460jccrw6().s[75]++;
	  if (context.delta._t) {
	    cov_460jccrw6().b[29][0]++;
	    cov_460jccrw6().s[76]++;
	    return;
	  } else {
	    cov_460jccrw6().b[29][1]++;
	  }
	  const length = (cov_460jccrw6().s[77]++, context.children.length);
	  let child;
	  const delta = (cov_460jccrw6().s[78]++, {});
	  cov_460jccrw6().s[79]++;
	  for (let index = (cov_460jccrw6().s[80]++, 0); index < length; index++) {
	    cov_460jccrw6().s[81]++;
	    child = context.children[index];
	    cov_460jccrw6().s[82]++;
	    if (delta[child.childName] !== child.result) {
	      cov_460jccrw6().b[30][0]++;
	      cov_460jccrw6().s[83]++;
	      delta[child.childName] = child.result;
	    } else {
	      cov_460jccrw6().b[30][1]++;
	    }
	  }
	  cov_460jccrw6().s[84]++;
	  context.setResult(delta).exit();
	}
	cov_460jccrw6().s[85]++;
	collectChildrenReverseFilter$1.filterName = 'collectChildren';
	function cov_2ix4m2tnjk() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/lcs.js";
	  var hash = "bae65a0e206b42a5e2f3387ebe268c2372f098a6";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/lcs.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 9,
	          column: 21
	        },
	        end: {
	          line: 11,
	          column: 1
	        }
	      },
	      "1": {
	        start: {
	          line: 10,
	          column: 2
	        },
	        end: {
	          line: 10,
	          column: 43
	        }
	      },
	      "2": {
	        start: {
	          line: 12,
	          column: 21
	        },
	        end: {
	          line: 37,
	          column: 1
	        }
	      },
	      "3": {
	        start: {
	          line: 13,
	          column: 15
	        },
	        end: {
	          line: 13,
	          column: 28
	        }
	      },
	      "4": {
	        start: {
	          line: 14,
	          column: 15
	        },
	        end: {
	          line: 14,
	          column: 28
	        }
	      },
	      "5": {
	        start: {
	          line: 18,
	          column: 17
	        },
	        end: {
	          line: 18,
	          column: 27
	        }
	      },
	      "6": {
	        start: {
	          line: 19,
	          column: 2
	        },
	        end: {
	          line: 24,
	          column: 3
	        }
	      },
	      "7": {
	        start: {
	          line: 20,
	          column: 4
	        },
	        end: {
	          line: 20,
	          column: 27
	        }
	      },
	      "8": {
	        start: {
	          line: 21,
	          column: 4
	        },
	        end: {
	          line: 23,
	          column: 5
	        }
	      },
	      "9": {
	        start: {
	          line: 22,
	          column: 6
	        },
	        end: {
	          line: 22,
	          column: 23
	        }
	      },
	      "10": {
	        start: {
	          line: 25,
	          column: 2
	        },
	        end: {
	          line: 25,
	          column: 23
	        }
	      },
	      "11": {
	        start: {
	          line: 27,
	          column: 2
	        },
	        end: {
	          line: 35,
	          column: 3
	        }
	      },
	      "12": {
	        start: {
	          line: 28,
	          column: 4
	        },
	        end: {
	          line: 34,
	          column: 5
	        }
	      },
	      "13": {
	        start: {
	          line: 29,
	          column: 6
	        },
	        end: {
	          line: 33,
	          column: 7
	        }
	      },
	      "14": {
	        start: {
	          line: 30,
	          column: 8
	        },
	        end: {
	          line: 30,
	          column: 48
	        }
	      },
	      "15": {
	        start: {
	          line: 32,
	          column: 8
	        },
	        end: {
	          line: 32,
	          column: 68
	        }
	      },
	      "16": {
	        start: {
	          line: 36,
	          column: 2
	        },
	        end: {
	          line: 36,
	          column: 16
	        }
	      },
	      "17": {
	        start: {
	          line: 38,
	          column: 18
	        },
	        end: {
	          line: 65,
	          column: 1
	        }
	      },
	      "18": {
	        start: {
	          line: 39,
	          column: 15
	        },
	        end: {
	          line: 39,
	          column: 28
	        }
	      },
	      "19": {
	        start: {
	          line: 40,
	          column: 15
	        },
	        end: {
	          line: 40,
	          column: 28
	        }
	      },
	      "20": {
	        start: {
	          line: 41,
	          column: 22
	        },
	        end: {
	          line: 45,
	          column: 3
	        }
	      },
	      "21": {
	        start: {
	          line: 46,
	          column: 2
	        },
	        end: {
	          line: 63,
	          column: 3
	        }
	      },
	      "22": {
	        start: {
	          line: 47,
	          column: 23
	        },
	        end: {
	          line: 47,
	          column: 84
	        }
	      },
	      "23": {
	        start: {
	          line: 48,
	          column: 4
	        },
	        end: {
	          line: 62,
	          column: 5
	        }
	      },
	      "24": {
	        start: {
	          line: 49,
	          column: 6
	        },
	        end: {
	          line: 49,
	          column: 55
	        }
	      },
	      "25": {
	        start: {
	          line: 50,
	          column: 6
	        },
	        end: {
	          line: 50,
	          column: 47
	        }
	      },
	      "26": {
	        start: {
	          line: 51,
	          column: 6
	        },
	        end: {
	          line: 51,
	          column: 47
	        }
	      },
	      "27": {
	        start: {
	          line: 52,
	          column: 6
	        },
	        end: {
	          line: 52,
	          column: 15
	        }
	      },
	      "28": {
	        start: {
	          line: 53,
	          column: 6
	        },
	        end: {
	          line: 53,
	          column: 15
	        }
	      },
	      "29": {
	        start: {
	          line: 55,
	          column: 33
	        },
	        end: {
	          line: 55,
	          column: 59
	        }
	      },
	      "30": {
	        start: {
	          line: 56,
	          column: 32
	        },
	        end: {
	          line: 56,
	          column: 58
	        }
	      },
	      "31": {
	        start: {
	          line: 57,
	          column: 6
	        },
	        end: {
	          line: 61,
	          column: 7
	        }
	      },
	      "32": {
	        start: {
	          line: 58,
	          column: 8
	        },
	        end: {
	          line: 58,
	          column: 17
	        }
	      },
	      "33": {
	        start: {
	          line: 60,
	          column: 8
	        },
	        end: {
	          line: 60,
	          column: 17
	        }
	      },
	      "34": {
	        start: {
	          line: 64,
	          column: 2
	        },
	        end: {
	          line: 64,
	          column: 21
	        }
	      },
	      "35": {
	        start: {
	          line: 66,
	          column: 12
	        },
	        end: {
	          line: 74,
	          column: 1
	        }
	      },
	      "36": {
	        start: {
	          line: 67,
	          column: 23
	        },
	        end: {
	          line: 67,
	          column: 36
	        }
	      },
	      "37": {
	        start: {
	          line: 68,
	          column: 17
	        },
	        end: {
	          line: 68,
	          column: 82
	        }
	      },
	      "38": {
	        start: {
	          line: 69,
	          column: 17
	        },
	        end: {
	          line: 69,
	          column: 64
	        }
	      },
	      "39": {
	        start: {
	          line: 70,
	          column: 2
	        },
	        end: {
	          line: 72,
	          column: 3
	        }
	      },
	      "40": {
	        start: {
	          line: 71,
	          column: 4
	        },
	        end: {
	          line: 71,
	          column: 47
	        }
	      },
	      "41": {
	        start: {
	          line: 73,
	          column: 2
	        },
	        end: {
	          line: 73,
	          column: 16
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 9,
	            column: 21
	          },
	          end: {
	            line: 9,
	            column: 22
	          }
	        },
	        loc: {
	          start: {
	            line: 9,
	            column: 63
	          },
	          end: {
	            line: 11,
	            column: 1
	          }
	        },
	        line: 9
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 12,
	            column: 21
	          },
	          end: {
	            line: 12,
	            column: 22
	          }
	        },
	        loc: {
	          start: {
	            line: 12,
	            column: 63
	          },
	          end: {
	            line: 37,
	            column: 1
	          }
	        },
	        line: 12
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 38,
	            column: 18
	          },
	          end: {
	            line: 38,
	            column: 19
	          }
	        },
	        loc: {
	          start: {
	            line: 38,
	            column: 61
	          },
	          end: {
	            line: 65,
	            column: 1
	          }
	        },
	        line: 38
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 66,
	            column: 12
	          },
	          end: {
	            line: 66,
	            column: 13
	          }
	        },
	        loc: {
	          start: {
	            line: 66,
	            column: 54
	          },
	          end: {
	            line: 74,
	            column: 1
	          }
	        },
	        line: 66
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 29,
	            column: 6
	          },
	          end: {
	            line: 33,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 29,
	            column: 6
	          },
	          end: {
	            line: 33,
	            column: 7
	          }
	        }, {
	          start: {
	            line: 31,
	            column: 13
	          },
	          end: {
	            line: 33,
	            column: 7
	          }
	        }],
	        line: 29
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 46,
	            column: 9
	          },
	          end: {
	            line: 46,
	            column: 37
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 46,
	            column: 9
	          },
	          end: {
	            line: 46,
	            column: 21
	          }
	        }, {
	          start: {
	            line: 46,
	            column: 25
	          },
	          end: {
	            line: 46,
	            column: 37
	          }
	        }],
	        line: 46
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 48,
	            column: 4
	          },
	          end: {
	            line: 62,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 48,
	            column: 4
	          },
	          end: {
	            line: 62,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 54,
	            column: 11
	          },
	          end: {
	            line: 62,
	            column: 5
	          }
	        }],
	        line: 48
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 57,
	            column: 6
	          },
	          end: {
	            line: 61,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 57,
	            column: 6
	          },
	          end: {
	            line: 61,
	            column: 7
	          }
	        }, {
	          start: {
	            line: 59,
	            column: 13
	          },
	          end: {
	            line: 61,
	            column: 7
	          }
	        }],
	        line: 57
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 67,
	            column: 23
	          },
	          end: {
	            line: 67,
	            column: 36
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 67,
	            column: 23
	          },
	          end: {
	            line: 67,
	            column: 30
	          }
	        }, {
	          start: {
	            line: 67,
	            column: 34
	          },
	          end: {
	            line: 67,
	            column: 36
	          }
	        }],
	        line: 67
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 68,
	            column: 46
	          },
	          end: {
	            line: 68,
	            column: 67
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 68,
	            column: 46
	          },
	          end: {
	            line: 68,
	            column: 51
	          }
	        }, {
	          start: {
	            line: 68,
	            column: 55
	          },
	          end: {
	            line: 68,
	            column: 67
	          }
	        }],
	        line: 68
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 70,
	            column: 2
	          },
	          end: {
	            line: 72,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 70,
	            column: 2
	          },
	          end: {
	            line: 72,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 70
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 70,
	            column: 6
	          },
	          end: {
	            line: 70,
	            column: 62
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 70,
	            column: 6
	          },
	          end: {
	            line: 70,
	            column: 32
	          }
	        }, {
	          start: {
	            line: 70,
	            column: 36
	          },
	          end: {
	            line: 70,
	            column: 62
	          }
	        }],
	        line: 70
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/lcs.js"],
	      sourcesContent: ["/*\n\nLCS implementation that supports arrays or strings\n\nreference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n\n*/\n\nconst defaultMatch = function(array1, array2, index1, index2) {\n  return array1[index1] === array2[index2];\n};\n\nconst lengthMatrix = function(array1, array2, match, context) {\n  const len1 = array1.length;\n  const len2 = array2.length;\n  let x, y;\n\n  // initialize empty matrix of len1+1 x len2+1\n  const matrix = [len1 + 1];\n  for (x = 0; x < len1 + 1; x++) {\n    matrix[x] = [len2 + 1];\n    for (y = 0; y < len2 + 1; y++) {\n      matrix[x][y] = 0;\n    }\n  }\n  matrix.match = match;\n  // save sequence lengths for each coordinate\n  for (x = 1; x < len1 + 1; x++) {\n    for (y = 1; y < len2 + 1; y++) {\n      if (match(array1, array2, x - 1, y - 1, context)) {\n        matrix[x][y] = matrix[x - 1][y - 1] + 1;\n      } else {\n        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);\n      }\n    }\n  }\n  return matrix;\n};\n\nconst backtrack = function(matrix, array1, array2, context) {\n  let index1 = array1.length;\n  let index2 = array2.length;\n  const subsequence = {\n    sequence: [],\n    indices1: [],\n    indices2: [],\n  };\n\n  while (index1 !== 0 && index2 !== 0) {\n    const sameLetter =\n      matrix.match(array1, array2, index1 - 1, index2 - 1, context);\n    if (sameLetter) {\n      subsequence.sequence.unshift(array1[index1 - 1]);\n      subsequence.indices1.unshift(index1 - 1);\n      subsequence.indices2.unshift(index2 - 1);\n      --index1;\n      --index2;\n    } else {\n      const valueAtMatrixAbove = matrix[index1][index2 - 1];\n      const valueAtMatrixLeft = matrix[index1 - 1][index2];\n      if (valueAtMatrixAbove > valueAtMatrixLeft) {\n        --index2;\n      } else {\n        --index1;\n      }\n    }\n  }\n  return subsequence;\n};\n\nconst get = function(array1, array2, match, context) {\n  const innerContext = context || {};\n  const matrix = lengthMatrix(\n    array1,\n    array2,\n    match || defaultMatch,\n    innerContext,\n  );\n  const result = backtrack(\n    matrix,\n    array1,\n    array2,\n    innerContext,\n  );\n  if (typeof array1 === 'string' && typeof array2 === 'string') {\n    result.sequence = result.sequence.join('');\n  }\n  return result;\n};\n\nexport default {\n  get,\n};\n"],
	      names: ["defaultMatch", "array1", "array2", "index1", "index2", "lengthMatrix", "match", "context", "len1", "length", "len2", "x", "y", "matrix", "Math", "max", "backtrack", "subsequence", "sequence", "indices1", "indices2", "sameLetter", "unshift", "valueAtMatrixAbove", "valueAtMatrixLeft", "get", "innerContext", "result", "join"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "bae65a0e206b42a5e2f3387ebe268c2372f098a6"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_2ix4m2tnjk = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_2ix4m2tnjk();
	cov_2ix4m2tnjk().s[0]++; /*
	                         LCS implementation that supports arrays or strings
	                         reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
	                         */
	const defaultMatch$1 = function (array1, array2, index1, index2) {
	  cov_2ix4m2tnjk().f[0]++;
	  cov_2ix4m2tnjk().s[1]++;
	  return array1[index1] === array2[index2];
	};
	cov_2ix4m2tnjk().s[2]++;
	const lengthMatrix$1 = function (array1, array2, match, context) {
	  cov_2ix4m2tnjk().f[1]++;
	  const len1 = (cov_2ix4m2tnjk().s[3]++, array1.length);
	  const len2 = (cov_2ix4m2tnjk().s[4]++, array2.length);
	  let x, y; // initialize empty matrix of len1+1 x len2+1
	  const matrix = (cov_2ix4m2tnjk().s[5]++, [len1 + 1]);
	  cov_2ix4m2tnjk().s[6]++;
	  for (x = 0; x < len1 + 1; x++) {
	    cov_2ix4m2tnjk().s[7]++;
	    matrix[x] = [len2 + 1];
	    cov_2ix4m2tnjk().s[8]++;
	    for (y = 0; y < len2 + 1; y++) {
	      cov_2ix4m2tnjk().s[9]++;
	      matrix[x][y] = 0;
	    }
	  }
	  cov_2ix4m2tnjk().s[10]++;
	  matrix.match = match; // save sequence lengths for each coordinate
	  cov_2ix4m2tnjk().s[11]++;
	  for (x = 1; x < len1 + 1; x++) {
	    cov_2ix4m2tnjk().s[12]++;
	    for (y = 1; y < len2 + 1; y++) {
	      cov_2ix4m2tnjk().s[13]++;
	      if (match(array1, array2, x - 1, y - 1, context)) {
	        cov_2ix4m2tnjk().b[0][0]++;
	        cov_2ix4m2tnjk().s[14]++;
	        matrix[x][y] = matrix[x - 1][y - 1] + 1;
	      } else {
	        cov_2ix4m2tnjk().b[0][1]++;
	        cov_2ix4m2tnjk().s[15]++;
	        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
	      }
	    }
	  }
	  cov_2ix4m2tnjk().s[16]++;
	  return matrix;
	};
	cov_2ix4m2tnjk().s[17]++;
	const backtrack$1 = function (matrix, array1, array2, context) {
	  cov_2ix4m2tnjk().f[2]++;
	  let index1 = (cov_2ix4m2tnjk().s[18]++, array1.length);
	  let index2 = (cov_2ix4m2tnjk().s[19]++, array2.length);
	  const subsequence = (cov_2ix4m2tnjk().s[20]++, {
	    sequence: [],
	    indices1: [],
	    indices2: []
	  });
	  cov_2ix4m2tnjk().s[21]++;
	  while ((cov_2ix4m2tnjk().b[1][0]++, index1 !== 0) && (cov_2ix4m2tnjk().b[1][1]++, index2 !== 0)) {
	    const sameLetter = (cov_2ix4m2tnjk().s[22]++, matrix.match(array1, array2, index1 - 1, index2 - 1, context));
	    cov_2ix4m2tnjk().s[23]++;
	    if (sameLetter) {
	      cov_2ix4m2tnjk().b[2][0]++;
	      cov_2ix4m2tnjk().s[24]++;
	      subsequence.sequence.unshift(array1[index1 - 1]);
	      cov_2ix4m2tnjk().s[25]++;
	      subsequence.indices1.unshift(index1 - 1);
	      cov_2ix4m2tnjk().s[26]++;
	      subsequence.indices2.unshift(index2 - 1);
	      cov_2ix4m2tnjk().s[27]++;
	      --index1;
	      cov_2ix4m2tnjk().s[28]++;
	      --index2;
	    } else {
	      cov_2ix4m2tnjk().b[2][1]++;
	      const valueAtMatrixAbove = (cov_2ix4m2tnjk().s[29]++, matrix[index1][index2 - 1]);
	      const valueAtMatrixLeft = (cov_2ix4m2tnjk().s[30]++, matrix[index1 - 1][index2]);
	      cov_2ix4m2tnjk().s[31]++;
	      if (valueAtMatrixAbove > valueAtMatrixLeft) {
	        cov_2ix4m2tnjk().b[3][0]++;
	        cov_2ix4m2tnjk().s[32]++;
	        --index2;
	      } else {
	        cov_2ix4m2tnjk().b[3][1]++;
	        cov_2ix4m2tnjk().s[33]++;
	        --index1;
	      }
	    }
	  }
	  cov_2ix4m2tnjk().s[34]++;
	  return subsequence;
	};
	cov_2ix4m2tnjk().s[35]++;
	const get$1 = function (array1, array2, match, context) {
	  cov_2ix4m2tnjk().f[3]++;
	  const innerContext = (cov_2ix4m2tnjk().s[36]++, (cov_2ix4m2tnjk().b[4][0]++, context) || (cov_2ix4m2tnjk().b[4][1]++, {}));
	  const matrix = (cov_2ix4m2tnjk().s[37]++, lengthMatrix$1(array1, array2, (cov_2ix4m2tnjk().b[5][0]++, match) || (cov_2ix4m2tnjk().b[5][1]++, defaultMatch$1), innerContext));
	  const result = (cov_2ix4m2tnjk().s[38]++, backtrack$1(matrix, array1, array2, innerContext));
	  cov_2ix4m2tnjk().s[39]++;
	  if ((cov_2ix4m2tnjk().b[7][0]++, typeof array1 === 'string') && (cov_2ix4m2tnjk().b[7][1]++, typeof array2 === 'string')) {
	    cov_2ix4m2tnjk().b[6][0]++;
	    cov_2ix4m2tnjk().s[40]++;
	    result.sequence = result.sequence.join('');
	  } else {
	    cov_2ix4m2tnjk().b[6][1]++;
	  }
	  cov_2ix4m2tnjk().s[41]++;
	  return result;
	};
	var lcs$1 = {
	  get: get$1
	};
	function cov_5ijtfroyd() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/arrays.js";
	  var hash = "6c892b145d1d9d4115fa0472ca6ce15c2e1b8e40";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/arrays.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 5,
	          column: 19
	        },
	        end: {
	          line: 5,
	          column: 20
	        }
	      },
	      "1": {
	        start: {
	          line: 6,
	          column: 16
	        },
	        end: {
	          line: 6,
	          column: 93
	        }
	      },
	      "2": {
	        start: {
	          line: 6,
	          column: 75
	        },
	        end: {
	          line: 6,
	          column: 93
	        }
	      },
	      "3": {
	        start: {
	          line: 7,
	          column: 21
	        },
	        end: {
	          line: 15,
	          column: 1
	        }
	      },
	      "4": {
	        start: {
	          line: 7,
	          column: 86
	        },
	        end: {
	          line: 7,
	          column: 105
	        }
	      },
	      "5": {
	        start: {
	          line: 8,
	          column: 17
	        },
	        end: {
	          line: 8,
	          column: 29
	        }
	      },
	      "6": {
	        start: {
	          line: 9,
	          column: 2
	        },
	        end: {
	          line: 13,
	          column: 3
	        }
	      },
	      "7": {
	        start: {
	          line: 9,
	          column: 15
	        },
	        end: {
	          line: 9,
	          column: 16
	        }
	      },
	      "8": {
	        start: {
	          line: 10,
	          column: 4
	        },
	        end: {
	          line: 12,
	          column: 5
	        }
	      },
	      "9": {
	        start: {
	          line: 11,
	          column: 6
	        },
	        end: {
	          line: 11,
	          column: 15
	        }
	      },
	      "10": {
	        start: {
	          line: 14,
	          column: 2
	        },
	        end: {
	          line: 14,
	          column: 12
	        }
	      },
	      "11": {
	        start: {
	          line: 17,
	          column: 2
	        },
	        end: {
	          line: 25,
	          column: 3
	        }
	      },
	      "12": {
	        start: {
	          line: 17,
	          column: 20
	        },
	        end: {
	          line: 17,
	          column: 21
	        }
	      },
	      "13": {
	        start: {
	          line: 18,
	          column: 17
	        },
	        end: {
	          line: 18,
	          column: 31
	        }
	      },
	      "14": {
	        start: {
	          line: 19,
	          column: 4
	        },
	        end: {
	          line: 24,
	          column: 5
	        }
	      },
	      "15": {
	        start: {
	          line: 19,
	          column: 22
	        },
	        end: {
	          line: 19,
	          column: 23
	        }
	      },
	      "16": {
	        start: {
	          line: 20,
	          column: 19
	        },
	        end: {
	          line: 20,
	          column: 33
	        }
	      },
	      "17": {
	        start: {
	          line: 21,
	          column: 6
	        },
	        end: {
	          line: 23,
	          column: 7
	        }
	      },
	      "18": {
	        start: {
	          line: 22,
	          column: 8
	        },
	        end: {
	          line: 22,
	          column: 20
	        }
	      },
	      "19": {
	        start: {
	          line: 28,
	          column: 17
	        },
	        end: {
	          line: 28,
	          column: 31
	        }
	      },
	      "20": {
	        start: {
	          line: 29,
	          column: 17
	        },
	        end: {
	          line: 29,
	          column: 31
	        }
	      },
	      "21": {
	        start: {
	          line: 30,
	          column: 2
	        },
	        end: {
	          line: 32,
	          column: 3
	        }
	      },
	      "22": {
	        start: {
	          line: 31,
	          column: 4
	        },
	        end: {
	          line: 31,
	          column: 16
	        }
	      },
	      "23": {
	        start: {
	          line: 33,
	          column: 2
	        },
	        end: {
	          line: 35,
	          column: 3
	        }
	      },
	      "24": {
	        start: {
	          line: 34,
	          column: 4
	        },
	        end: {
	          line: 34,
	          column: 17
	        }
	      },
	      "25": {
	        start: {
	          line: 36,
	          column: 21
	        },
	        end: {
	          line: 36,
	          column: 39
	        }
	      },
	      "26": {
	        start: {
	          line: 37,
	          column: 2
	        },
	        end: {
	          line: 40,
	          column: 3
	        }
	      },
	      "27": {
	        start: {
	          line: 39,
	          column: 4
	        },
	        end: {
	          line: 39,
	          column: 56
	        }
	      },
	      "28": {
	        start: {
	          line: 43,
	          column: 2
	        },
	        end: {
	          line: 51,
	          column: 3
	        }
	      },
	      "29": {
	        start: {
	          line: 44,
	          column: 4
	        },
	        end: {
	          line: 44,
	          column: 50
	        }
	      },
	      "30": {
	        start: {
	          line: 45,
	          column: 4
	        },
	        end: {
	          line: 45,
	          column: 39
	        }
	      },
	      "31": {
	        start: {
	          line: 46,
	          column: 4
	        },
	        end: {
	          line: 48,
	          column: 5
	        }
	      },
	      "32": {
	        start: {
	          line: 47,
	          column: 6
	        },
	        end: {
	          line: 47,
	          column: 70
	        }
	      },
	      "33": {
	        start: {
	          line: 50,
	          column: 4
	        },
	        end: {
	          line: 50,
	          column: 31
	        }
	      },
	      "34": {
	        start: {
	          line: 52,
	          column: 2
	        },
	        end: {
	          line: 54,
	          column: 3
	        }
	      },
	      "35": {
	        start: {
	          line: 53,
	          column: 4
	        },
	        end: {
	          line: 53,
	          column: 17
	        }
	      },
	      "36": {
	        start: {
	          line: 55,
	          column: 2
	        },
	        end: {
	          line: 63,
	          column: 3
	        }
	      },
	      "37": {
	        start: {
	          line: 56,
	          column: 4
	        },
	        end: {
	          line: 56,
	          column: 50
	        }
	      },
	      "38": {
	        start: {
	          line: 57,
	          column: 4
	        },
	        end: {
	          line: 57,
	          column: 39
	        }
	      },
	      "39": {
	        start: {
	          line: 58,
	          column: 4
	        },
	        end: {
	          line: 60,
	          column: 5
	        }
	      },
	      "40": {
	        start: {
	          line: 59,
	          column: 6
	        },
	        end: {
	          line: 59,
	          column: 70
	        }
	      },
	      "41": {
	        start: {
	          line: 62,
	          column: 4
	        },
	        end: {
	          line: 62,
	          column: 31
	        }
	      },
	      "42": {
	        start: {
	          line: 64,
	          column: 2
	        },
	        end: {
	          line: 66,
	          column: 3
	        }
	      },
	      "43": {
	        start: {
	          line: 65,
	          column: 4
	        },
	        end: {
	          line: 65,
	          column: 17
	        }
	      },
	      "44": {
	        start: {
	          line: 67,
	          column: 2
	        },
	        end: {
	          line: 67,
	          column: 25
	        }
	      },
	      "45": {
	        start: {
	          line: 69,
	          column: 26
	        },
	        end: {
	          line: 199,
	          column: 1
	        }
	      },
	      "46": {
	        start: {
	          line: 70,
	          column: 2
	        },
	        end: {
	          line: 72,
	          column: 3
	        }
	      },
	      "47": {
	        start: {
	          line: 71,
	          column: 4
	        },
	        end: {
	          line: 71,
	          column: 11
	        }
	      },
	      "48": {
	        start: {
	          line: 73,
	          column: 23
	        },
	        end: {
	          line: 76,
	          column: 3
	        }
	      },
	      "49": {
	        start: {
	          line: 77,
	          column: 19
	        },
	        end: {
	          line: 77,
	          column: 20
	        }
	      },
	      "50": {
	        start: {
	          line: 78,
	          column: 19
	        },
	        end: {
	          line: 78,
	          column: 20
	        }
	      },
	      "51": {
	        start: {
	          line: 82,
	          column: 17
	        },
	        end: {
	          line: 82,
	          column: 29
	        }
	      },
	      "52": {
	        start: {
	          line: 83,
	          column: 17
	        },
	        end: {
	          line: 83,
	          column: 30
	        }
	      },
	      "53": {
	        start: {
	          line: 84,
	          column: 15
	        },
	        end: {
	          line: 84,
	          column: 28
	        }
	      },
	      "54": {
	        start: {
	          line: 85,
	          column: 15
	        },
	        end: {
	          line: 85,
	          column: 28
	        }
	      },
	      "55": {
	        start: {
	          line: 87,
	          column: 2
	        },
	        end: {
	          line: 89,
	          column: 3
	        }
	      },
	      "56": {
	        start: {
	          line: 88,
	          column: 4
	        },
	        end: {
	          line: 88,
	          column: 85
	        }
	      },
	      "57": {
	        start: {
	          line: 92,
	          column: 2
	        },
	        end: {
	          line: 97,
	          column: 3
	        }
	      },
	      "58": {
	        start: {
	          line: 93,
	          column: 4
	        },
	        end: {
	          line: 93,
	          column: 23
	        }
	      },
	      "59": {
	        start: {
	          line: 94,
	          column: 4
	        },
	        end: {
	          line: 94,
	          column: 71
	        }
	      },
	      "60": {
	        start: {
	          line: 95,
	          column: 4
	        },
	        end: {
	          line: 95,
	          column: 31
	        }
	      },
	      "61": {
	        start: {
	          line: 96,
	          column: 4
	        },
	        end: {
	          line: 96,
	          column: 17
	        }
	      },
	      "62": {
	        start: {
	          line: 99,
	          column: 2
	        },
	        end: {
	          line: 105,
	          column: 3
	        }
	      },
	      "63": {
	        start: {
	          line: 100,
	          column: 4
	        },
	        end: {
	          line: 100,
	          column: 35
	        }
	      },
	      "64": {
	        start: {
	          line: 101,
	          column: 4
	        },
	        end: {
	          line: 101,
	          column: 35
	        }
	      },
	      "65": {
	        start: {
	          line: 102,
	          column: 4
	        },
	        end: {
	          line: 102,
	          column: 73
	        }
	      },
	      "66": {
	        start: {
	          line: 103,
	          column: 4
	        },
	        end: {
	          line: 103,
	          column: 32
	        }
	      },
	      "67": {
	        start: {
	          line: 104,
	          column: 4
	        },
	        end: {
	          line: 104,
	          column: 17
	        }
	      },
	      "68": {
	        start: {
	          line: 107,
	          column: 2
	        },
	        end: {
	          line: 122,
	          column: 3
	        }
	      },
	      "69": {
	        start: {
	          line: 108,
	          column: 4
	        },
	        end: {
	          line: 112,
	          column: 5
	        }
	      },
	      "70": {
	        start: {
	          line: 110,
	          column: 6
	        },
	        end: {
	          line: 110,
	          column: 42
	        }
	      },
	      "71": {
	        start: {
	          line: 111,
	          column: 6
	        },
	        end: {
	          line: 111,
	          column: 13
	        }
	      },
	      "72": {
	        start: {
	          line: 114,
	          column: 4
	        },
	        end: {
	          line: 116,
	          column: 6
	        }
	      },
	      "73": {
	        start: {
	          line: 117,
	          column: 4
	        },
	        end: {
	          line: 119,
	          column: 5
	        }
	      },
	      "74": {
	        start: {
	          line: 118,
	          column: 6
	        },
	        end: {
	          line: 118,
	          column: 38
	        }
	      },
	      "75": {
	        start: {
	          line: 120,
	          column: 4
	        },
	        end: {
	          line: 120,
	          column: 37
	        }
	      },
	      "76": {
	        start: {
	          line: 121,
	          column: 4
	        },
	        end: {
	          line: 121,
	          column: 11
	        }
	      },
	      "77": {
	        start: {
	          line: 123,
	          column: 2
	        },
	        end: {
	          line: 133,
	          column: 3
	        }
	      },
	      "78": {
	        start: {
	          line: 125,
	          column: 4
	        },
	        end: {
	          line: 127,
	          column: 6
	        }
	      },
	      "79": {
	        start: {
	          line: 128,
	          column: 4
	        },
	        end: {
	          line: 130,
	          column: 5
	        }
	      },
	      "80": {
	        start: {
	          line: 129,
	          column: 6
	        },
	        end: {
	          line: 129,
	          column: 50
	        }
	      },
	      "81": {
	        start: {
	          line: 131,
	          column: 4
	        },
	        end: {
	          line: 131,
	          column: 37
	        }
	      },
	      "82": {
	        start: {
	          line: 132,
	          column: 4
	        },
	        end: {
	          line: 132,
	          column: 11
	        }
	      },
	      "83": {
	        start: {
	          line: 135,
	          column: 2
	        },
	        end: {
	          line: 135,
	          column: 33
	        }
	      },
	      "84": {
	        start: {
	          line: 136,
	          column: 2
	        },
	        end: {
	          line: 136,
	          column: 33
	        }
	      },
	      "85": {
	        start: {
	          line: 139,
	          column: 19
	        },
	        end: {
	          line: 139,
	          column: 62
	        }
	      },
	      "86": {
	        start: {
	          line: 140,
	          column: 19
	        },
	        end: {
	          line: 140,
	          column: 62
	        }
	      },
	      "87": {
	        start: {
	          line: 141,
	          column: 14
	        },
	        end: {
	          line: 141,
	          column: 67
	        }
	      },
	      "88": {
	        start: {
	          line: 142,
	          column: 23
	        },
	        end: {
	          line: 142,
	          column: 25
	        }
	      },
	      "89": {
	        start: {
	          line: 143,
	          column: 2
	        },
	        end: {
	          line: 145,
	          column: 4
	        }
	      },
	      "90": {
	        start: {
	          line: 146,
	          column: 2
	        },
	        end: {
	          line: 152,
	          column: 3
	        }
	      },
	      "91": {
	        start: {
	          line: 147,
	          column: 4
	        },
	        end: {
	          line: 151,
	          column: 5
	        }
	      },
	      "92": {
	        start: {
	          line: 149,
	          column: 6
	        },
	        end: {
	          line: 149,
	          column: 50
	        }
	      },
	      "93": {
	        start: {
	          line: 150,
	          column: 6
	        },
	        end: {
	          line: 150,
	          column: 31
	        }
	      },
	      "94": {
	        start: {
	          line: 153,
	          column: 19
	        },
	        end: {
	          line: 153,
	          column: 23
	        }
	      },
	      "95": {
	        start: {
	          line: 154,
	          column: 2
	        },
	        end: {
	          line: 156,
	          column: 3
	        }
	      },
	      "96": {
	        start: {
	          line: 155,
	          column: 4
	        },
	        end: {
	          line: 155,
	          column: 23
	        }
	      },
	      "97": {
	        start: {
	          line: 157,
	          column: 27
	        },
	        end: {
	          line: 157,
	          column: 32
	        }
	      },
	      "98": {
	        start: {
	          line: 158,
	          column: 2
	        },
	        end: {
	          line: 160,
	          column: 3
	        }
	      },
	      "99": {
	        start: {
	          line: 159,
	          column: 4
	        },
	        end: {
	          line: 159,
	          column: 30
	        }
	      },
	      "100": {
	        start: {
	          line: 161,
	          column: 29
	        },
	        end: {
	          line: 161,
	          column: 48
	        }
	      },
	      "101": {
	        start: {
	          line: 162,
	          column: 2
	        },
	        end: {
	          line: 197,
	          column: 3
	        }
	      },
	      "102": {
	        start: {
	          line: 163,
	          column: 26
	        },
	        end: {
	          line: 163,
	          column: 72
	        }
	      },
	      "103": {
	        start: {
	          line: 164,
	          column: 4
	        },
	        end: {
	          line: 196,
	          column: 5
	        }
	      },
	      "104": {
	        start: {
	          line: 166,
	          column: 19
	        },
	        end: {
	          line: 166,
	          column: 24
	        }
	      },
	      "105": {
	        start: {
	          line: 167,
	          column: 6
	        },
	        end: {
	          line: 185,
	          column: 7
	        }
	      },
	      "106": {
	        start: {
	          line: 168,
	          column: 8
	        },
	        end: {
	          line: 184,
	          column: 9
	        }
	      },
	      "107": {
	        start: {
	          line: 168,
	          column: 36
	        },
	        end: {
	          line: 168,
	          column: 37
	        }
	      },
	      "108": {
	        start: {
	          line: 169,
	          column: 10
	        },
	        end: {
	          line: 169,
	          column: 50
	        }
	      },
	      "109": {
	        start: {
	          line: 170,
	          column: 10
	        },
	        end: {
	          line: 183,
	          column: 11
	        }
	      },
	      "110": {
	        start: {
	          line: 172,
	          column: 12
	        },
	        end: {
	          line: 172,
	          column: 65
	        }
	      },
	      "111": {
	        start: {
	          line: 173,
	          column: 12
	        },
	        end: {
	          line: 176,
	          column: 13
	        }
	      },
	      "112": {
	        start: {
	          line: 175,
	          column: 14
	        },
	        end: {
	          line: 175,
	          column: 43
	        }
	      },
	      "113": {
	        start: {
	          line: 177,
	          column: 12
	        },
	        end: {
	          line: 177,
	          column: 27
	        }
	      },
	      "114": {
	        start: {
	          line: 178,
	          column: 12
	        },
	        end: {
	          line: 178,
	          column: 81
	        }
	      },
	      "115": {
	        start: {
	          line: 179,
	          column: 12
	        },
	        end: {
	          line: 179,
	          column: 40
	        }
	      },
	      "116": {
	        start: {
	          line: 180,
	          column: 12
	        },
	        end: {
	          line: 180,
	          column: 53
	        }
	      },
	      "117": {
	        start: {
	          line: 181,
	          column: 12
	        },
	        end: {
	          line: 181,
	          column: 26
	        }
	      },
	      "118": {
	        start: {
	          line: 182,
	          column: 12
	        },
	        end: {
	          line: 182,
	          column: 18
	        }
	      },
	      "119": {
	        start: {
	          line: 186,
	          column: 6
	        },
	        end: {
	          line: 189,
	          column: 7
	        }
	      },
	      "120": {
	        start: {
	          line: 188,
	          column: 8
	        },
	        end: {
	          line: 188,
	          column: 40
	        }
	      },
	      "121": {
	        start: {
	          line: 192,
	          column: 6
	        },
	        end: {
	          line: 192,
	          column: 56
	        }
	      },
	      "122": {
	        start: {
	          line: 193,
	          column: 6
	        },
	        end: {
	          line: 193,
	          column: 56
	        }
	      },
	      "123": {
	        start: {
	          line: 194,
	          column: 6
	        },
	        end: {
	          line: 194,
	          column: 75
	        }
	      },
	      "124": {
	        start: {
	          line: 195,
	          column: 6
	        },
	        end: {
	          line: 195,
	          column: 34
	        }
	      },
	      "125": {
	        start: {
	          line: 198,
	          column: 2
	        },
	        end: {
	          line: 198,
	          column: 35
	        }
	      },
	      "126": {
	        start: {
	          line: 200,
	          column: 0
	        },
	        end: {
	          line: 200,
	          column: 33
	        }
	      },
	      "127": {
	        start: {
	          line: 201,
	          column: 16
	        },
	        end: {
	          line: 208,
	          column: 1
	        }
	      },
	      "128": {
	        start: {
	          line: 203,
	          column: 4
	        },
	        end: {
	          line: 203,
	          column: 17
	        }
	      },
	      "129": {
	        start: {
	          line: 206,
	          column: 4
	        },
	        end: {
	          line: 206,
	          column: 39
	        }
	      },
	      "130": {
	        start: {
	          line: 206,
	          column: 21
	        },
	        end: {
	          line: 206,
	          column: 38
	        }
	      },
	      "131": {
	        start: {
	          line: 209,
	          column: 27
	        },
	        end: {
	          line: 290,
	          column: 1
	        }
	      },
	      "132": {
	        start: {
	          line: 210,
	          column: 2
	        },
	        end: {
	          line: 212,
	          column: 3
	        }
	      },
	      "133": {
	        start: {
	          line: 211,
	          column: 4
	        },
	        end: {
	          line: 211,
	          column: 11
	        }
	      },
	      "134": {
	        start: {
	          line: 213,
	          column: 2
	        },
	        end: {
	          line: 215,
	          column: 3
	        }
	      },
	      "135": {
	        start: {
	          line: 214,
	          column: 4
	        },
	        end: {
	          line: 214,
	          column: 11
	        }
	      },
	      "136": {
	        start: {
	          line: 218,
	          column: 16
	        },
	        end: {
	          line: 218,
	          column: 29
	        }
	      },
	      "137": {
	        start: {
	          line: 219,
	          column: 16
	        },
	        end: {
	          line: 219,
	          column: 28
	        }
	      },
	      "138": {
	        start: {
	          line: 222,
	          column: 17
	        },
	        end: {
	          line: 222,
	          column: 19
	        }
	      },
	      "139": {
	        start: {
	          line: 223,
	          column: 17
	        },
	        end: {
	          line: 223,
	          column: 19
	        }
	      },
	      "140": {
	        start: {
	          line: 224,
	          column: 19
	        },
	        end: {
	          line: 224,
	          column: 21
	        }
	      },
	      "141": {
	        start: {
	          line: 225,
	          column: 2
	        },
	        end: {
	          line: 250,
	          column: 3
	        }
	      },
	      "142": {
	        start: {
	          line: 226,
	          column: 4
	        },
	        end: {
	          line: 249,
	          column: 5
	        }
	      },
	      "143": {
	        start: {
	          line: 227,
	          column: 6
	        },
	        end: {
	          line: 248,
	          column: 7
	        }
	      },
	      "144": {
	        start: {
	          line: 229,
	          column: 8
	        },
	        end: {
	          line: 233,
	          column: 9
	        }
	      },
	      "145": {
	        start: {
	          line: 230,
	          column: 10
	        },
	        end: {
	          line: 230,
	          column: 54
	        }
	      },
	      "146": {
	        start: {
	          line: 232,
	          column: 10
	        },
	        end: {
	          line: 232,
	          column: 135
	        }
	      },
	      "147": {
	        start: {
	          line: 235,
	          column: 8
	        },
	        end: {
	          line: 247,
	          column: 9
	        }
	      },
	      "148": {
	        start: {
	          line: 237,
	          column: 10
	        },
	        end: {
	          line: 240,
	          column: 13
	        }
	      },
	      "149": {
	        start: {
	          line: 243,
	          column: 10
	        },
	        end: {
	          line: 246,
	          column: 13
	        }
	      },
	      "150": {
	        start: {
	          line: 253,
	          column: 2
	        },
	        end: {
	          line: 253,
	          column: 48
	        }
	      },
	      "151": {
	        start: {
	          line: 254,
	          column: 2
	        },
	        end: {
	          line: 265,
	          column: 3
	        }
	      },
	      "152": {
	        start: {
	          line: 255,
	          column: 4
	        },
	        end: {
	          line: 255,
	          column: 29
	        }
	      },
	      "153": {
	        start: {
	          line: 256,
	          column: 22
	        },
	        end: {
	          line: 256,
	          column: 41
	        }
	      },
	      "154": {
	        start: {
	          line: 257,
	          column: 25
	        },
	        end: {
	          line: 257,
	          column: 51
	        }
	      },
	      "155": {
	        start: {
	          line: 258,
	          column: 4
	        },
	        end: {
	          line: 264,
	          column: 5
	        }
	      },
	      "156": {
	        start: {
	          line: 260,
	          column: 6
	        },
	        end: {
	          line: 263,
	          column: 9
	        }
	      },
	      "157": {
	        start: {
	          line: 268,
	          column: 2
	        },
	        end: {
	          line: 268,
	          column: 59
	        }
	      },
	      "158": {
	        start: {
	          line: 269,
	          column: 25
	        },
	        end: {
	          line: 269,
	          column: 40
	        }
	      },
	      "159": {
	        start: {
	          line: 270,
	          column: 2
	        },
	        end: {
	          line: 273,
	          column: 3
	        }
	      },
	      "160": {
	        start: {
	          line: 271,
	          column: 22
	        },
	        end: {
	          line: 271,
	          column: 37
	        }
	      },
	      "161": {
	        start: {
	          line: 272,
	          column: 4
	        },
	        end: {
	          line: 272,
	          column: 54
	        }
	      },
	      "162": {
	        start: {
	          line: 276,
	          column: 25
	        },
	        end: {
	          line: 276,
	          column: 40
	        }
	      },
	      "163": {
	        start: {
	          line: 278,
	          column: 2
	        },
	        end: {
	          line: 284,
	          column: 3
	        }
	      },
	      "164": {
	        start: {
	          line: 279,
	          column: 4
	        },
	        end: {
	          line: 283,
	          column: 5
	        }
	      },
	      "165": {
	        start: {
	          line: 280,
	          column: 27
	        },
	        end: {
	          line: 280,
	          column: 42
	        }
	      },
	      "166": {
	        start: {
	          line: 281,
	          column: 6
	        },
	        end: {
	          line: 281,
	          column: 85
	        }
	      },
	      "167": {
	        start: {
	          line: 282,
	          column: 6
	        },
	        end: {
	          line: 282,
	          column: 46
	        }
	      },
	      "168": {
	        start: {
	          line: 285,
	          column: 2
	        },
	        end: {
	          line: 288,
	          column: 3
	        }
	      },
	      "169": {
	        start: {
	          line: 286,
	          column: 4
	        },
	        end: {
	          line: 286,
	          column: 43
	        }
	      },
	      "170": {
	        start: {
	          line: 287,
	          column: 4
	        },
	        end: {
	          line: 287,
	          column: 11
	        }
	      },
	      "171": {
	        start: {
	          line: 289,
	          column: 2
	        },
	        end: {
	          line: 289,
	          column: 17
	        }
	      },
	      "172": {
	        start: {
	          line: 291,
	          column: 0
	        },
	        end: {
	          line: 291,
	          column: 34
	        }
	      },
	      "173": {
	        start: {
	          line: 292,
	          column: 42
	        },
	        end: {
	          line: 306,
	          column: 1
	        }
	      },
	      "174": {
	        start: {
	          line: 293,
	          column: 2
	        },
	        end: {
	          line: 295,
	          column: 3
	        }
	      },
	      "175": {
	        start: {
	          line: 294,
	          column: 4
	        },
	        end: {
	          line: 294,
	          column: 11
	        }
	      },
	      "176": {
	        start: {
	          line: 296,
	          column: 2
	        },
	        end: {
	          line: 298,
	          column: 3
	        }
	      },
	      "177": {
	        start: {
	          line: 297,
	          column: 4
	        },
	        end: {
	          line: 297,
	          column: 11
	        }
	      },
	      "178": {
	        start: {
	          line: 299,
	          column: 17
	        },
	        end: {
	          line: 299,
	          column: 40
	        }
	      },
	      "179": {
	        start: {
	          line: 301,
	          column: 2
	        },
	        end: {
	          line: 304,
	          column: 3
	        }
	      },
	      "180": {
	        start: {
	          line: 301,
	          column: 19
	        },
	        end: {
	          line: 301,
	          column: 20
	        }
	      },
	      "181": {
	        start: {
	          line: 302,
	          column: 4
	        },
	        end: {
	          line: 302,
	          column: 36
	        }
	      },
	      "182": {
	        start: {
	          line: 303,
	          column: 4
	        },
	        end: {
	          line: 303,
	          column: 49
	        }
	      },
	      "183": {
	        start: {
	          line: 305,
	          column: 2
	        },
	        end: {
	          line: 305,
	          column: 41
	        }
	      },
	      "184": {
	        start: {
	          line: 307,
	          column: 0
	        },
	        end: {
	          line: 307,
	          column: 64
	        }
	      },
	      "185": {
	        start: {
	          line: 308,
	          column: 29
	        },
	        end: {
	          line: 329,
	          column: 1
	        }
	      },
	      "186": {
	        start: {
	          line: 309,
	          column: 2
	        },
	        end: {
	          line: 315,
	          column: 3
	        }
	      },
	      "187": {
	        start: {
	          line: 310,
	          column: 4
	        },
	        end: {
	          line: 313,
	          column: 5
	        }
	      },
	      "188": {
	        start: {
	          line: 311,
	          column: 6
	        },
	        end: {
	          line: 311,
	          column: 47
	        }
	      },
	      "189": {
	        start: {
	          line: 312,
	          column: 6
	        },
	        end: {
	          line: 312,
	          column: 106
	        }
	      },
	      "190": {
	        start: {
	          line: 314,
	          column: 4
	        },
	        end: {
	          line: 314,
	          column: 11
	        }
	      },
	      "191": {
	        start: {
	          line: 316,
	          column: 2
	        },
	        end: {
	          line: 318,
	          column: 3
	        }
	      },
	      "192": {
	        start: {
	          line: 317,
	          column: 4
	        },
	        end: {
	          line: 317,
	          column: 11
	        }
	      },
	      "193": {
	        start: {
	          line: 321,
	          column: 2
	        },
	        end: {
	          line: 327,
	          column: 3
	        }
	      },
	      "194": {
	        start: {
	          line: 322,
	          column: 4
	        },
	        end: {
	          line: 324,
	          column: 5
	        }
	      },
	      "195": {
	        start: {
	          line: 323,
	          column: 6
	        },
	        end: {
	          line: 323,
	          column: 15
	        }
	      },
	      "196": {
	        start: {
	          line: 325,
	          column: 4
	        },
	        end: {
	          line: 325,
	          column: 52
	        }
	      },
	      "197": {
	        start: {
	          line: 326,
	          column: 4
	        },
	        end: {
	          line: 326,
	          column: 30
	        }
	      },
	      "198": {
	        start: {
	          line: 328,
	          column: 2
	        },
	        end: {
	          line: 328,
	          column: 17
	        }
	      },
	      "199": {
	        start: {
	          line: 330,
	          column: 0
	        },
	        end: {
	          line: 330,
	          column: 36
	        }
	      },
	      "200": {
	        start: {
	          line: 331,
	          column: 31
	        },
	        end: {
	          line: 363,
	          column: 1
	        }
	      },
	      "201": {
	        start: {
	          line: 332,
	          column: 2
	        },
	        end: {
	          line: 336,
	          column: 3
	        }
	      },
	      "202": {
	        start: {
	          line: 333,
	          column: 4
	        },
	        end: {
	          line: 333,
	          column: 41
	        }
	      },
	      "203": {
	        start: {
	          line: 334,
	          column: 9
	        },
	        end: {
	          line: 336,
	          column: 3
	        }
	      },
	      "204": {
	        start: {
	          line: 335,
	          column: 4
	        },
	        end: {
	          line: 335,
	          column: 23
	        }
	      },
	      "205": {
	        start: {
	          line: 337,
	          column: 21
	        },
	        end: {
	          line: 337,
	          column: 27
	        }
	      },
	      "206": {
	        start: {
	          line: 338,
	          column: 2
	        },
	        end: {
	          line: 361,
	          column: 3
	        }
	      },
	      "207": {
	        start: {
	          line: 339,
	          column: 22
	        },
	        end: {
	          line: 339,
	          column: 39
	        }
	      },
	      "208": {
	        start: {
	          line: 340,
	          column: 4
	        },
	        end: {
	          line: 360,
	          column: 5
	        }
	      },
	      "209": {
	        start: {
	          line: 341,
	          column: 6
	        },
	        end: {
	          line: 359,
	          column: 7
	        }
	      },
	      "210": {
	        start: {
	          line: 342,
	          column: 30
	        },
	        end: {
	          line: 342,
	          column: 64
	        }
	      },
	      "211": {
	        start: {
	          line: 343,
	          column: 28
	        },
	        end: {
	          line: 343,
	          column: 40
	        }
	      },
	      "212": {
	        start: {
	          line: 344,
	          column: 8
	        },
	        end: {
	          line: 346,
	          column: 9
	        }
	      },
	      "213": {
	        start: {
	          line: 345,
	          column: 10
	        },
	        end: {
	          line: 345,
	          column: 31
	        }
	      },
	      "214": {
	        start: {
	          line: 347,
	          column: 8
	        },
	        end: {
	          line: 351,
	          column: 9
	        }
	      },
	      "215": {
	        start: {
	          line: 348,
	          column: 10
	        },
	        end: {
	          line: 348,
	          column: 25
	        }
	      },
	      "216": {
	        start: {
	          line: 349,
	          column: 15
	        },
	        end: {
	          line: 351,
	          column: 9
	        }
	      },
	      "217": {
	        start: {
	          line: 350,
	          column: 10
	        },
	        end: {
	          line: 350,
	          column: 25
	        }
	      },
	      "218": {
	        start: {
	          line: 352,
	          column: 13
	        },
	        end: {
	          line: 359,
	          column: 7
	        }
	      },
	      "219": {
	        start: {
	          line: 353,
	          column: 28
	        },
	        end: {
	          line: 353,
	          column: 62
	        }
	      },
	      "220": {
	        start: {
	          line: 354,
	          column: 8
	        },
	        end: {
	          line: 356,
	          column: 9
	        }
	      },
	      "221": {
	        start: {
	          line: 355,
	          column: 10
	        },
	        end: {
	          line: 355,
	          column: 25
	        }
	      },
	      "222": {
	        start: {
	          line: 357,
	          column: 13
	        },
	        end: {
	          line: 359,
	          column: 7
	        }
	      },
	      "223": {
	        start: {
	          line: 358,
	          column: 8
	        },
	        end: {
	          line: 358,
	          column: 23
	        }
	      },
	      "224": {
	        start: {
	          line: 362,
	          column: 2
	        },
	        end: {
	          line: 362,
	          column: 22
	        }
	      },
	      "225": {
	        start: {
	          line: 365,
	          column: 2
	        },
	        end: {
	          line: 367,
	          column: 3
	        }
	      },
	      "226": {
	        start: {
	          line: 366,
	          column: 4
	        },
	        end: {
	          line: 366,
	          column: 11
	        }
	      },
	      "227": {
	        start: {
	          line: 368,
	          column: 2
	        },
	        end: {
	          line: 370,
	          column: 3
	        }
	      },
	      "228": {
	        start: {
	          line: 369,
	          column: 4
	        },
	        end: {
	          line: 369,
	          column: 11
	        }
	      },
	      "229": {
	        start: {
	          line: 371,
	          column: 17
	        },
	        end: {
	          line: 371,
	          column: 40
	        }
	      },
	      "230": {
	        start: {
	          line: 373,
	          column: 16
	        },
	        end: {
	          line: 375,
	          column: 3
	        }
	      },
	      "231": {
	        start: {
	          line: 376,
	          column: 2
	        },
	        end: {
	          line: 385,
	          column: 3
	        }
	      },
	      "232": {
	        start: {
	          line: 376,
	          column: 19
	        },
	        end: {
	          line: 376,
	          column: 20
	        }
	      },
	      "233": {
	        start: {
	          line: 377,
	          column: 4
	        },
	        end: {
	          line: 377,
	          column: 36
	        }
	      },
	      "234": {
	        start: {
	          line: 378,
	          column: 15
	        },
	        end: {
	          line: 378,
	          column: 28
	        }
	      },
	      "235": {
	        start: {
	          line: 379,
	          column: 4
	        },
	        end: {
	          line: 381,
	          column: 5
	        }
	      },
	      "236": {
	        start: {
	          line: 380,
	          column: 6
	        },
	        end: {
	          line: 380,
	          column: 82
	        }
	      },
	      "237": {
	        start: {
	          line: 382,
	          column: 4
	        },
	        end: {
	          line: 384,
	          column: 5
	        }
	      },
	      "238": {
	        start: {
	          line: 383,
	          column: 6
	        },
	        end: {
	          line: 383,
	          column: 33
	        }
	      },
	      "239": {
	        start: {
	          line: 386,
	          column: 2
	        },
	        end: {
	          line: 386,
	          column: 34
	        }
	      },
	      "240": {
	        start: {
	          line: 388,
	          column: 0
	        },
	        end: {
	          line: 388,
	          column: 66
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 6,
	            column: 70
	          },
	          end: {
	            line: 6,
	            column: 71
	          }
	        },
	        loc: {
	          start: {
	            line: 6,
	            column: 75
	          },
	          end: {
	            line: 6,
	            column: 93
	          }
	        },
	        line: 6
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 7,
	            column: 69
	          },
	          end: {
	            line: 7,
	            column: 70
	          }
	        },
	        loc: {
	          start: {
	            line: 7,
	            column: 86
	          },
	          end: {
	            line: 7,
	            column: 105
	          }
	        },
	        line: 7
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 7,
	            column: 108
	          },
	          end: {
	            line: 7,
	            column: 109
	          }
	        },
	        loc: {
	          start: {
	            line: 7,
	            column: 125
	          },
	          end: {
	            line: 15,
	            column: 1
	          }
	        },
	        line: 7
	      },
	      "3": {
	        name: "arraysHaveMatchByRef",
	        decl: {
	          start: {
	            line: 16,
	            column: 9
	          },
	          end: {
	            line: 16,
	            column: 29
	          }
	        },
	        loc: {
	          start: {
	            line: 16,
	            column: 58
	          },
	          end: {
	            line: 26,
	            column: 1
	          }
	        },
	        line: 16
	      },
	      "4": {
	        name: "matchItems",
	        decl: {
	          start: {
	            line: 27,
	            column: 9
	          },
	          end: {
	            line: 27,
	            column: 19
	          }
	        },
	        loc: {
	          start: {
	            line: 27,
	            column: 61
	          },
	          end: {
	            line: 68,
	            column: 1
	          }
	        },
	        line: 27
	      },
	      "5": {
	        name: "arraysDiffFilter",
	        decl: {
	          start: {
	            line: 69,
	            column: 35
	          },
	          end: {
	            line: 69,
	            column: 51
	          }
	        },
	        loc: {
	          start: {
	            line: 69,
	            column: 61
	          },
	          end: {
	            line: 199,
	            column: 1
	          }
	        },
	        line: 69
	      },
	      "6": {
	        name: "(anonymous_6)",
	        decl: {
	          start: {
	            line: 202,
	            column: 2
	          },
	          end: {
	            line: 202,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 202,
	            column: 20
	          },
	          end: {
	            line: 204,
	            column: 3
	          }
	        },
	        line: 202
	      },
	      "7": {
	        name: "(anonymous_7)",
	        decl: {
	          start: {
	            line: 205,
	            column: 2
	          },
	          end: {
	            line: 205,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 205,
	            column: 22
	          },
	          end: {
	            line: 207,
	            column: 3
	          }
	        },
	        line: 205
	      },
	      "8": {
	        name: "(anonymous_8)",
	        decl: {
	          start: {
	            line: 206,
	            column: 11
	          },
	          end: {
	            line: 206,
	            column: 12
	          }
	        },
	        loc: {
	          start: {
	            line: 206,
	            column: 21
	          },
	          end: {
	            line: 206,
	            column: 38
	          }
	        },
	        line: 206
	      },
	      "9": {
	        name: "nestedPatchFilter",
	        decl: {
	          start: {
	            line: 209,
	            column: 36
	          },
	          end: {
	            line: 209,
	            column: 53
	          }
	        },
	        loc: {
	          start: {
	            line: 209,
	            column: 63
	          },
	          end: {
	            line: 290,
	            column: 1
	          }
	        },
	        line: 209
	      },
	      "10": {
	        name: "collectChildrenPatchFilter",
	        decl: {
	          start: {
	            line: 292,
	            column: 51
	          },
	          end: {
	            line: 292,
	            column: 77
	          }
	        },
	        loc: {
	          start: {
	            line: 292,
	            column: 87
	          },
	          end: {
	            line: 306,
	            column: 1
	          }
	        },
	        line: 292
	      },
	      "11": {
	        name: "arraysReverseFilter",
	        decl: {
	          start: {
	            line: 308,
	            column: 38
	          },
	          end: {
	            line: 308,
	            column: 57
	          }
	        },
	        loc: {
	          start: {
	            line: 308,
	            column: 67
	          },
	          end: {
	            line: 329,
	            column: 1
	          }
	        },
	        line: 308
	      },
	      "12": {
	        name: "(anonymous_12)",
	        decl: {
	          start: {
	            line: 331,
	            column: 31
	          },
	          end: {
	            line: 331,
	            column: 32
	          }
	        },
	        loc: {
	          start: {
	            line: 331,
	            column: 60
	          },
	          end: {
	            line: 363,
	            column: 1
	          }
	        },
	        line: 331
	      },
	      "13": {
	        name: "collectChildrenReverseFilter",
	        decl: {
	          start: {
	            line: 364,
	            column: 16
	          },
	          end: {
	            line: 364,
	            column: 44
	          }
	        },
	        loc: {
	          start: {
	            line: 364,
	            column: 54
	          },
	          end: {
	            line: 387,
	            column: 1
	          }
	        },
	        line: 364
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 6,
	            column: 16
	          },
	          end: {
	            line: 6,
	            column: 93
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 6,
	            column: 54
	          },
	          end: {
	            line: 6,
	            column: 67
	          }
	        }, {
	          start: {
	            line: 6,
	            column: 70
	          },
	          end: {
	            line: 6,
	            column: 93
	          }
	        }],
	        line: 6
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 7,
	            column: 21
	          },
	          end: {
	            line: 15,
	            column: 1
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 7,
	            column: 69
	          },
	          end: {
	            line: 7,
	            column: 105
	          }
	        }, {
	          start: {
	            line: 7,
	            column: 108
	          },
	          end: {
	            line: 15,
	            column: 1
	          }
	        }],
	        line: 7
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 10,
	            column: 4
	          },
	          end: {
	            line: 12,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 10,
	            column: 4
	          },
	          end: {
	            line: 12,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 10
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 21,
	            column: 6
	          },
	          end: {
	            line: 23,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 21,
	            column: 6
	          },
	          end: {
	            line: 23,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 21
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 21,
	            column: 10
	          },
	          end: {
	            line: 21,
	            column: 44
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 21,
	            column: 10
	          },
	          end: {
	            line: 21,
	            column: 27
	          }
	        }, {
	          start: {
	            line: 21,
	            column: 31
	          },
	          end: {
	            line: 21,
	            column: 44
	          }
	        }],
	        line: 21
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 30,
	            column: 2
	          },
	          end: {
	            line: 32,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 30,
	            column: 2
	          },
	          end: {
	            line: 32,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 30
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 33,
	            column: 2
	          },
	          end: {
	            line: 35,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 33,
	            column: 2
	          },
	          end: {
	            line: 35,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 33
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 33,
	            column: 6
	          },
	          end: {
	            line: 33,
	            column: 62
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 33,
	            column: 6
	          },
	          end: {
	            line: 33,
	            column: 32
	          }
	        }, {
	          start: {
	            line: 33,
	            column: 36
	          },
	          end: {
	            line: 33,
	            column: 62
	          }
	        }],
	        line: 33
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 37,
	            column: 2
	          },
	          end: {
	            line: 40,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 37,
	            column: 2
	          },
	          end: {
	            line: 40,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 37
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 39,
	            column: 11
	          },
	          end: {
	            line: 39,
	            column: 55
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 39,
	            column: 11
	          },
	          end: {
	            line: 39,
	            column: 34
	          }
	        }, {
	          start: {
	            line: 39,
	            column: 38
	          },
	          end: {
	            line: 39,
	            column: 55
	          }
	        }],
	        line: 39
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 43,
	            column: 2
	          },
	          end: {
	            line: 51,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 43,
	            column: 2
	          },
	          end: {
	            line: 51,
	            column: 3
	          }
	        }, {
	          start: {
	            line: 49,
	            column: 9
	          },
	          end: {
	            line: 51,
	            column: 3
	          }
	        }],
	        line: 43
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 44,
	            column: 25
	          },
	          end: {
	            line: 44,
	            column: 49
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 44,
	            column: 25
	          },
	          end: {
	            line: 44,
	            column: 43
	          }
	        }, {
	          start: {
	            line: 44,
	            column: 47
	          },
	          end: {
	            line: 44,
	            column: 49
	          }
	        }],
	        line: 44
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 46,
	            column: 4
	          },
	          end: {
	            line: 48,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 46,
	            column: 4
	          },
	          end: {
	            line: 48,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 46
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 52,
	            column: 2
	          },
	          end: {
	            line: 54,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 52,
	            column: 2
	          },
	          end: {
	            line: 54,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 52
	      },
	      "14": {
	        loc: {
	          start: {
	            line: 55,
	            column: 2
	          },
	          end: {
	            line: 63,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 55,
	            column: 2
	          },
	          end: {
	            line: 63,
	            column: 3
	          }
	        }, {
	          start: {
	            line: 61,
	            column: 9
	          },
	          end: {
	            line: 63,
	            column: 3
	          }
	        }],
	        line: 55
	      },
	      "15": {
	        loc: {
	          start: {
	            line: 56,
	            column: 25
	          },
	          end: {
	            line: 56,
	            column: 49
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 56,
	            column: 25
	          },
	          end: {
	            line: 56,
	            column: 43
	          }
	        }, {
	          start: {
	            line: 56,
	            column: 47
	          },
	          end: {
	            line: 56,
	            column: 49
	          }
	        }],
	        line: 56
	      },
	      "16": {
	        loc: {
	          start: {
	            line: 58,
	            column: 4
	          },
	          end: {
	            line: 60,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 58,
	            column: 4
	          },
	          end: {
	            line: 60,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 58
	      },
	      "17": {
	        loc: {
	          start: {
	            line: 64,
	            column: 2
	          },
	          end: {
	            line: 66,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 64,
	            column: 2
	          },
	          end: {
	            line: 66,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 64
	      },
	      "18": {
	        loc: {
	          start: {
	            line: 70,
	            column: 2
	          },
	          end: {
	            line: 72,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 70,
	            column: 2
	          },
	          end: {
	            line: 72,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 70
	      },
	      "19": {
	        loc: {
	          start: {
	            line: 74,
	            column: 16
	          },
	          end: {
	            line: 74,
	            column: 61
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 74,
	            column: 16
	          },
	          end: {
	            line: 74,
	            column: 31
	          }
	        }, {
	          start: {
	            line: 74,
	            column: 35
	          },
	          end: {
	            line: 74,
	            column: 61
	          }
	        }],
	        line: 74
	      },
	      "20": {
	        loc: {
	          start: {
	            line: 75,
	            column: 21
	          },
	          end: {
	            line: 75,
	            column: 71
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 75,
	            column: 21
	          },
	          end: {
	            line: 75,
	            column: 36
	          }
	        }, {
	          start: {
	            line: 75,
	            column: 40
	          },
	          end: {
	            line: 75,
	            column: 71
	          }
	        }],
	        line: 75
	      },
	      "21": {
	        loc: {
	          start: {
	            line: 87,
	            column: 2
	          },
	          end: {
	            line: 89,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 87,
	            column: 2
	          },
	          end: {
	            line: 89,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 87
	      },
	      "22": {
	        loc: {
	          start: {
	            line: 87,
	            column: 6
	          },
	          end: {
	            line: 87,
	            column: 107
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 87,
	            column: 6
	          },
	          end: {
	            line: 87,
	            column: 14
	          }
	        }, {
	          start: {
	            line: 87,
	            column: 18
	          },
	          end: {
	            line: 87,
	            column: 26
	          }
	        }, {
	          start: {
	            line: 87,
	            column: 30
	          },
	          end: {
	            line: 87,
	            column: 54
	          }
	        }, {
	          start: {
	            line: 87,
	            column: 58
	          },
	          end: {
	            line: 87,
	            column: 107
	          }
	        }],
	        line: 87
	      },
	      "23": {
	        loc: {
	          start: {
	            line: 92,
	            column: 9
	          },
	          end: {
	            line: 92,
	            column: 115
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 92,
	            column: 9
	          },
	          end: {
	            line: 92,
	            column: 26
	          }
	        }, {
	          start: {
	            line: 92,
	            column: 30
	          },
	          end: {
	            line: 92,
	            column: 47
	          }
	        }, {
	          start: {
	            line: 92,
	            column: 51
	          },
	          end: {
	            line: 92,
	            column: 115
	          }
	        }],
	        line: 92
	      },
	      "24": {
	        loc: {
	          start: {
	            line: 99,
	            column: 9
	          },
	          end: {
	            line: 99,
	            column: 163
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 99,
	            column: 9
	          },
	          end: {
	            line: 99,
	            column: 39
	          }
	        }, {
	          start: {
	            line: 99,
	            column: 43
	          },
	          end: {
	            line: 99,
	            column: 73
	          }
	        }, {
	          start: {
	            line: 99,
	            column: 77
	          },
	          end: {
	            line: 99,
	            column: 163
	          }
	        }],
	        line: 99
	      },
	      "25": {
	        loc: {
	          start: {
	            line: 107,
	            column: 2
	          },
	          end: {
	            line: 122,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 107,
	            column: 2
	          },
	          end: {
	            line: 122,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 107
	      },
	      "26": {
	        loc: {
	          start: {
	            line: 108,
	            column: 4
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 108,
	            column: 4
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 108
	      },
	      "27": {
	        loc: {
	          start: {
	            line: 114,
	            column: 13
	          },
	          end: {
	            line: 116,
	            column: 5
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 114,
	            column: 13
	          },
	          end: {
	            line: 114,
	            column: 19
	          }
	        }, {
	          start: {
	            line: 114,
	            column: 23
	          },
	          end: {
	            line: 116,
	            column: 5
	          }
	        }],
	        line: 114
	      },
	      "28": {
	        loc: {
	          start: {
	            line: 123,
	            column: 2
	          },
	          end: {
	            line: 133,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 123,
	            column: 2
	          },
	          end: {
	            line: 133,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 123
	      },
	      "29": {
	        loc: {
	          start: {
	            line: 125,
	            column: 13
	          },
	          end: {
	            line: 127,
	            column: 5
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 125,
	            column: 13
	          },
	          end: {
	            line: 125,
	            column: 19
	          }
	        }, {
	          start: {
	            line: 125,
	            column: 23
	          },
	          end: {
	            line: 127,
	            column: 5
	          }
	        }],
	        line: 125
	      },
	      "30": {
	        loc: {
	          start: {
	            line: 143,
	            column: 11
	          },
	          end: {
	            line: 145,
	            column: 3
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 143,
	            column: 11
	          },
	          end: {
	            line: 143,
	            column: 17
	          }
	        }, {
	          start: {
	            line: 143,
	            column: 21
	          },
	          end: {
	            line: 145,
	            column: 3
	          }
	        }],
	        line: 143
	      },
	      "31": {
	        loc: {
	          start: {
	            line: 147,
	            column: 4
	          },
	          end: {
	            line: 151,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 147,
	            column: 4
	          },
	          end: {
	            line: 151,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 147
	      },
	      "32": {
	        loc: {
	          start: {
	            line: 154,
	            column: 2
	          },
	          end: {
	            line: 156,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 154,
	            column: 2
	          },
	          end: {
	            line: 156,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 154
	      },
	      "33": {
	        loc: {
	          start: {
	            line: 154,
	            column: 6
	          },
	          end: {
	            line: 154,
	            column: 94
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 154,
	            column: 6
	          },
	          end: {
	            line: 154,
	            column: 21
	          }
	        }, {
	          start: {
	            line: 154,
	            column: 25
	          },
	          end: {
	            line: 154,
	            column: 47
	          }
	        }, {
	          start: {
	            line: 154,
	            column: 51
	          },
	          end: {
	            line: 154,
	            column: 94
	          }
	        }],
	        line: 154
	      },
	      "34": {
	        loc: {
	          start: {
	            line: 158,
	            column: 2
	          },
	          end: {
	            line: 160,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 158,
	            column: 2
	          },
	          end: {
	            line: 160,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 158
	      },
	      "35": {
	        loc: {
	          start: {
	            line: 158,
	            column: 6
	          },
	          end: {
	            line: 158,
	            column: 92
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 158,
	            column: 6
	          },
	          end: {
	            line: 158,
	            column: 21
	          }
	        }, {
	          start: {
	            line: 158,
	            column: 25
	          },
	          end: {
	            line: 158,
	            column: 47
	          }
	        }, {
	          start: {
	            line: 158,
	            column: 51
	          },
	          end: {
	            line: 158,
	            column: 92
	          }
	        }],
	        line: 158
	      },
	      "36": {
	        loc: {
	          start: {
	            line: 164,
	            column: 4
	          },
	          end: {
	            line: 196,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 164,
	            column: 4
	          },
	          end: {
	            line: 196,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 190,
	            column: 11
	          },
	          end: {
	            line: 196,
	            column: 5
	          }
	        }],
	        line: 164
	      },
	      "37": {
	        loc: {
	          start: {
	            line: 167,
	            column: 6
	          },
	          end: {
	            line: 185,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 167,
	            column: 6
	          },
	          end: {
	            line: 185,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 167
	      },
	      "38": {
	        loc: {
	          start: {
	            line: 167,
	            column: 10
	          },
	          end: {
	            line: 167,
	            column: 46
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 167,
	            column: 10
	          },
	          end: {
	            line: 167,
	            column: 20
	          }
	        }, {
	          start: {
	            line: 167,
	            column: 24
	          },
	          end: {
	            line: 167,
	            column: 46
	          }
	        }],
	        line: 167
	      },
	      "39": {
	        loc: {
	          start: {
	            line: 170,
	            column: 10
	          },
	          end: {
	            line: 183,
	            column: 11
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 170,
	            column: 10
	          },
	          end: {
	            line: 183,
	            column: 11
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 170
	      },
	      "40": {
	        loc: {
	          start: {
	            line: 173,
	            column: 12
	          },
	          end: {
	            line: 176,
	            column: 13
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 173,
	            column: 12
	          },
	          end: {
	            line: 176,
	            column: 13
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 173
	      },
	      "41": {
	        loc: {
	          start: {
	            line: 186,
	            column: 6
	          },
	          end: {
	            line: 189,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 186,
	            column: 6
	          },
	          end: {
	            line: 189,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 186
	      },
	      "42": {
	        loc: {
	          start: {
	            line: 210,
	            column: 2
	          },
	          end: {
	            line: 212,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 210,
	            column: 2
	          },
	          end: {
	            line: 212,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 210
	      },
	      "43": {
	        loc: {
	          start: {
	            line: 213,
	            column: 2
	          },
	          end: {
	            line: 215,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 213,
	            column: 2
	          },
	          end: {
	            line: 215,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 213
	      },
	      "44": {
	        loc: {
	          start: {
	            line: 226,
	            column: 4
	          },
	          end: {
	            line: 249,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 226,
	            column: 4
	          },
	          end: {
	            line: 249,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 226
	      },
	      "45": {
	        loc: {
	          start: {
	            line: 227,
	            column: 6
	          },
	          end: {
	            line: 248,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 227,
	            column: 6
	          },
	          end: {
	            line: 248,
	            column: 7
	          }
	        }, {
	          start: {
	            line: 234,
	            column: 13
	          },
	          end: {
	            line: 248,
	            column: 7
	          }
	        }],
	        line: 227
	      },
	      "46": {
	        loc: {
	          start: {
	            line: 229,
	            column: 8
	          },
	          end: {
	            line: 233,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 229,
	            column: 8
	          },
	          end: {
	            line: 233,
	            column: 9
	          }
	        }, {
	          start: {
	            line: 231,
	            column: 15
	          },
	          end: {
	            line: 233,
	            column: 9
	          }
	        }],
	        line: 229
	      },
	      "47": {
	        loc: {
	          start: {
	            line: 229,
	            column: 12
	          },
	          end: {
	            line: 229,
	            column: 67
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 229,
	            column: 12
	          },
	          end: {
	            line: 229,
	            column: 33
	          }
	        }, {
	          start: {
	            line: 229,
	            column: 37
	          },
	          end: {
	            line: 229,
	            column: 67
	          }
	        }],
	        line: 229
	      },
	      "48": {
	        loc: {
	          start: {
	            line: 235,
	            column: 8
	          },
	          end: {
	            line: 247,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 235,
	            column: 8
	          },
	          end: {
	            line: 247,
	            column: 9
	          }
	        }, {
	          start: {
	            line: 241,
	            column: 15
	          },
	          end: {
	            line: 247,
	            column: 9
	          }
	        }],
	        line: 235
	      },
	      "49": {
	        loc: {
	          start: {
	            line: 258,
	            column: 4
	          },
	          end: {
	            line: 264,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 258,
	            column: 4
	          },
	          end: {
	            line: 264,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 258
	      },
	      "50": {
	        loc: {
	          start: {
	            line: 278,
	            column: 2
	          },
	          end: {
	            line: 284,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 278,
	            column: 2
	          },
	          end: {
	            line: 284,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 278
	      },
	      "51": {
	        loc: {
	          start: {
	            line: 285,
	            column: 2
	          },
	          end: {
	            line: 288,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 285,
	            column: 2
	          },
	          end: {
	            line: 288,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 285
	      },
	      "52": {
	        loc: {
	          start: {
	            line: 293,
	            column: 2
	          },
	          end: {
	            line: 295,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 293,
	            column: 2
	          },
	          end: {
	            line: 295,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 293
	      },
	      "53": {
	        loc: {
	          start: {
	            line: 293,
	            column: 6
	          },
	          end: {
	            line: 293,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 293,
	            column: 6
	          },
	          end: {
	            line: 293,
	            column: 14
	          }
	        }, {
	          start: {
	            line: 293,
	            column: 18
	          },
	          end: {
	            line: 293,
	            column: 35
	          }
	        }],
	        line: 293
	      },
	      "54": {
	        loc: {
	          start: {
	            line: 296,
	            column: 2
	          },
	          end: {
	            line: 298,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 296,
	            column: 2
	          },
	          end: {
	            line: 298,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 296
	      },
	      "55": {
	        loc: {
	          start: {
	            line: 309,
	            column: 2
	          },
	          end: {
	            line: 315,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 309,
	            column: 2
	          },
	          end: {
	            line: 315,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 309
	      },
	      "56": {
	        loc: {
	          start: {
	            line: 310,
	            column: 4
	          },
	          end: {
	            line: 313,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 310,
	            column: 4
	          },
	          end: {
	            line: 313,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 310
	      },
	      "57": {
	        loc: {
	          start: {
	            line: 316,
	            column: 2
	          },
	          end: {
	            line: 318,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 316,
	            column: 2
	          },
	          end: {
	            line: 318,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 316
	      },
	      "58": {
	        loc: {
	          start: {
	            line: 322,
	            column: 4
	          },
	          end: {
	            line: 324,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 322,
	            column: 4
	          },
	          end: {
	            line: 324,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 322
	      },
	      "59": {
	        loc: {
	          start: {
	            line: 332,
	            column: 2
	          },
	          end: {
	            line: 336,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 332,
	            column: 2
	          },
	          end: {
	            line: 336,
	            column: 3
	          }
	        }, {
	          start: {
	            line: 334,
	            column: 9
	          },
	          end: {
	            line: 336,
	            column: 3
	          }
	        }],
	        line: 332
	      },
	      "60": {
	        loc: {
	          start: {
	            line: 332,
	            column: 6
	          },
	          end: {
	            line: 332,
	            column: 51
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 332,
	            column: 6
	          },
	          end: {
	            line: 332,
	            column: 31
	          }
	        }, {
	          start: {
	            line: 332,
	            column: 35
	          },
	          end: {
	            line: 332,
	            column: 51
	          }
	        }],
	        line: 332
	      },
	      "61": {
	        loc: {
	          start: {
	            line: 334,
	            column: 9
	          },
	          end: {
	            line: 336,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 334,
	            column: 9
	          },
	          end: {
	            line: 336,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 334
	      },
	      "62": {
	        loc: {
	          start: {
	            line: 334,
	            column: 13
	          },
	          end: {
	            line: 334,
	            column: 53
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 334,
	            column: 13
	          },
	          end: {
	            line: 334,
	            column: 31
	          }
	        }, {
	          start: {
	            line: 334,
	            column: 35
	          },
	          end: {
	            line: 334,
	            column: 53
	          }
	        }],
	        line: 334
	      },
	      "63": {
	        loc: {
	          start: {
	            line: 340,
	            column: 4
	          },
	          end: {
	            line: 360,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 340,
	            column: 4
	          },
	          end: {
	            line: 360,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 340
	      },
	      "64": {
	        loc: {
	          start: {
	            line: 341,
	            column: 6
	          },
	          end: {
	            line: 359,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 341,
	            column: 6
	          },
	          end: {
	            line: 359,
	            column: 7
	          }
	        }, {
	          start: {
	            line: 352,
	            column: 13
	          },
	          end: {
	            line: 359,
	            column: 7
	          }
	        }],
	        line: 341
	      },
	      "65": {
	        loc: {
	          start: {
	            line: 344,
	            column: 8
	          },
	          end: {
	            line: 346,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 344,
	            column: 8
	          },
	          end: {
	            line: 346,
	            column: 9
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 344
	      },
	      "66": {
	        loc: {
	          start: {
	            line: 347,
	            column: 8
	          },
	          end: {
	            line: 351,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 347,
	            column: 8
	          },
	          end: {
	            line: 351,
	            column: 9
	          }
	        }, {
	          start: {
	            line: 349,
	            column: 15
	          },
	          end: {
	            line: 351,
	            column: 9
	          }
	        }],
	        line: 347
	      },
	      "67": {
	        loc: {
	          start: {
	            line: 347,
	            column: 12
	          },
	          end: {
	            line: 347,
	            column: 71
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 347,
	            column: 12
	          },
	          end: {
	            line: 347,
	            column: 41
	          }
	        }, {
	          start: {
	            line: 347,
	            column: 45
	          },
	          end: {
	            line: 347,
	            column: 71
	          }
	        }],
	        line: 347
	      },
	      "68": {
	        loc: {
	          start: {
	            line: 349,
	            column: 15
	          },
	          end: {
	            line: 351,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 349,
	            column: 15
	          },
	          end: {
	            line: 351,
	            column: 9
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 349
	      },
	      "69": {
	        loc: {
	          start: {
	            line: 349,
	            column: 19
	          },
	          end: {
	            line: 349,
	            column: 78
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 349,
	            column: 19
	          },
	          end: {
	            line: 349,
	            column: 48
	          }
	        }, {
	          start: {
	            line: 349,
	            column: 52
	          },
	          end: {
	            line: 349,
	            column: 78
	          }
	        }],
	        line: 349
	      },
	      "70": {
	        loc: {
	          start: {
	            line: 352,
	            column: 13
	          },
	          end: {
	            line: 359,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 352,
	            column: 13
	          },
	          end: {
	            line: 359,
	            column: 7
	          }
	        }, {
	          start: {
	            line: 357,
	            column: 13
	          },
	          end: {
	            line: 359,
	            column: 7
	          }
	        }],
	        line: 352
	      },
	      "71": {
	        loc: {
	          start: {
	            line: 354,
	            column: 8
	          },
	          end: {
	            line: 356,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 354,
	            column: 8
	          },
	          end: {
	            line: 356,
	            column: 9
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 354
	      },
	      "72": {
	        loc: {
	          start: {
	            line: 357,
	            column: 13
	          },
	          end: {
	            line: 359,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 357,
	            column: 13
	          },
	          end: {
	            line: 359,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 357
	      },
	      "73": {
	        loc: {
	          start: {
	            line: 357,
	            column: 17
	          },
	          end: {
	            line: 357,
	            column: 69
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 357,
	            column: 17
	          },
	          end: {
	            line: 357,
	            column: 39
	          }
	        }, {
	          start: {
	            line: 357,
	            column: 43
	          },
	          end: {
	            line: 357,
	            column: 69
	          }
	        }],
	        line: 357
	      },
	      "74": {
	        loc: {
	          start: {
	            line: 365,
	            column: 2
	          },
	          end: {
	            line: 367,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 365,
	            column: 2
	          },
	          end: {
	            line: 367,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 365
	      },
	      "75": {
	        loc: {
	          start: {
	            line: 365,
	            column: 6
	          },
	          end: {
	            line: 365,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 365,
	            column: 6
	          },
	          end: {
	            line: 365,
	            column: 14
	          }
	        }, {
	          start: {
	            line: 365,
	            column: 18
	          },
	          end: {
	            line: 365,
	            column: 35
	          }
	        }],
	        line: 365
	      },
	      "76": {
	        loc: {
	          start: {
	            line: 368,
	            column: 2
	          },
	          end: {
	            line: 370,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 368,
	            column: 2
	          },
	          end: {
	            line: 370,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 368
	      },
	      "77": {
	        loc: {
	          start: {
	            line: 379,
	            column: 4
	          },
	          end: {
	            line: 381,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 379,
	            column: 4
	          },
	          end: {
	            line: 381,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 379
	      },
	      "78": {
	        loc: {
	          start: {
	            line: 382,
	            column: 4
	          },
	          end: {
	            line: 384,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 382,
	            column: 4
	          },
	          end: {
	            line: 384,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 382
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0,
	      "72": 0,
	      "73": 0,
	      "74": 0,
	      "75": 0,
	      "76": 0,
	      "77": 0,
	      "78": 0,
	      "79": 0,
	      "80": 0,
	      "81": 0,
	      "82": 0,
	      "83": 0,
	      "84": 0,
	      "85": 0,
	      "86": 0,
	      "87": 0,
	      "88": 0,
	      "89": 0,
	      "90": 0,
	      "91": 0,
	      "92": 0,
	      "93": 0,
	      "94": 0,
	      "95": 0,
	      "96": 0,
	      "97": 0,
	      "98": 0,
	      "99": 0,
	      "100": 0,
	      "101": 0,
	      "102": 0,
	      "103": 0,
	      "104": 0,
	      "105": 0,
	      "106": 0,
	      "107": 0,
	      "108": 0,
	      "109": 0,
	      "110": 0,
	      "111": 0,
	      "112": 0,
	      "113": 0,
	      "114": 0,
	      "115": 0,
	      "116": 0,
	      "117": 0,
	      "118": 0,
	      "119": 0,
	      "120": 0,
	      "121": 0,
	      "122": 0,
	      "123": 0,
	      "124": 0,
	      "125": 0,
	      "126": 0,
	      "127": 0,
	      "128": 0,
	      "129": 0,
	      "130": 0,
	      "131": 0,
	      "132": 0,
	      "133": 0,
	      "134": 0,
	      "135": 0,
	      "136": 0,
	      "137": 0,
	      "138": 0,
	      "139": 0,
	      "140": 0,
	      "141": 0,
	      "142": 0,
	      "143": 0,
	      "144": 0,
	      "145": 0,
	      "146": 0,
	      "147": 0,
	      "148": 0,
	      "149": 0,
	      "150": 0,
	      "151": 0,
	      "152": 0,
	      "153": 0,
	      "154": 0,
	      "155": 0,
	      "156": 0,
	      "157": 0,
	      "158": 0,
	      "159": 0,
	      "160": 0,
	      "161": 0,
	      "162": 0,
	      "163": 0,
	      "164": 0,
	      "165": 0,
	      "166": 0,
	      "167": 0,
	      "168": 0,
	      "169": 0,
	      "170": 0,
	      "171": 0,
	      "172": 0,
	      "173": 0,
	      "174": 0,
	      "175": 0,
	      "176": 0,
	      "177": 0,
	      "178": 0,
	      "179": 0,
	      "180": 0,
	      "181": 0,
	      "182": 0,
	      "183": 0,
	      "184": 0,
	      "185": 0,
	      "186": 0,
	      "187": 0,
	      "188": 0,
	      "189": 0,
	      "190": 0,
	      "191": 0,
	      "192": 0,
	      "193": 0,
	      "194": 0,
	      "195": 0,
	      "196": 0,
	      "197": 0,
	      "198": 0,
	      "199": 0,
	      "200": 0,
	      "201": 0,
	      "202": 0,
	      "203": 0,
	      "204": 0,
	      "205": 0,
	      "206": 0,
	      "207": 0,
	      "208": 0,
	      "209": 0,
	      "210": 0,
	      "211": 0,
	      "212": 0,
	      "213": 0,
	      "214": 0,
	      "215": 0,
	      "216": 0,
	      "217": 0,
	      "218": 0,
	      "219": 0,
	      "220": 0,
	      "221": 0,
	      "222": 0,
	      "223": 0,
	      "224": 0,
	      "225": 0,
	      "226": 0,
	      "227": 0,
	      "228": 0,
	      "229": 0,
	      "230": 0,
	      "231": 0,
	      "232": 0,
	      "233": 0,
	      "234": 0,
	      "235": 0,
	      "236": 0,
	      "237": 0,
	      "238": 0,
	      "239": 0,
	      "240": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0],
	      "8": [0, 0],
	      "9": [0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0],
	      "13": [0, 0],
	      "14": [0, 0],
	      "15": [0, 0],
	      "16": [0, 0],
	      "17": [0, 0],
	      "18": [0, 0],
	      "19": [0, 0],
	      "20": [0, 0],
	      "21": [0, 0],
	      "22": [0, 0, 0, 0],
	      "23": [0, 0, 0],
	      "24": [0, 0, 0],
	      "25": [0, 0],
	      "26": [0, 0],
	      "27": [0, 0],
	      "28": [0, 0],
	      "29": [0, 0],
	      "30": [0, 0],
	      "31": [0, 0],
	      "32": [0, 0],
	      "33": [0, 0, 0],
	      "34": [0, 0],
	      "35": [0, 0, 0],
	      "36": [0, 0],
	      "37": [0, 0],
	      "38": [0, 0],
	      "39": [0, 0],
	      "40": [0, 0],
	      "41": [0, 0],
	      "42": [0, 0],
	      "43": [0, 0],
	      "44": [0, 0],
	      "45": [0, 0],
	      "46": [0, 0],
	      "47": [0, 0],
	      "48": [0, 0],
	      "49": [0, 0],
	      "50": [0, 0],
	      "51": [0, 0],
	      "52": [0, 0],
	      "53": [0, 0],
	      "54": [0, 0],
	      "55": [0, 0],
	      "56": [0, 0],
	      "57": [0, 0],
	      "58": [0, 0],
	      "59": [0, 0],
	      "60": [0, 0],
	      "61": [0, 0],
	      "62": [0, 0],
	      "63": [0, 0],
	      "64": [0, 0],
	      "65": [0, 0],
	      "66": [0, 0],
	      "67": [0, 0],
	      "68": [0, 0],
	      "69": [0, 0],
	      "70": [0, 0],
	      "71": [0, 0],
	      "72": [0, 0],
	      "73": [0, 0],
	      "74": [0, 0],
	      "75": [0, 0],
	      "76": [0, 0],
	      "77": [0, 0],
	      "78": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/arrays.js"],
	      sourcesContent: ["import DiffContext from '../contexts/diff';\nimport PatchContext from '../contexts/patch';\nimport ReverseContext from '../contexts/reverse';\n\nimport lcs from './lcs';\n\nconst ARRAY_MOVE = 3;\n\nconst isArray =\n  typeof Array.isArray === 'function' ? Array.isArray : a => a instanceof Array;\n\nconst arrayIndexOf =\n  typeof Array.prototype.indexOf === 'function'\n    ? (array, item) => array.indexOf(item)\n    : (array, item) => {\n        const length = array.length;\n        for (let i = 0; i < length; i++) {\n          if (array[i] === item) {\n            return i;\n          }\n        }\n        return -1;\n      };\n\nfunction arraysHaveMatchByRef(array1, array2, len1, len2) {\n  for (let index1 = 0; index1 < len1; index1++) {\n    const val1 = array1[index1];\n    for (let index2 = 0; index2 < len2; index2++) {\n      const val2 = array2[index2];\n      if (index1 !== index2 && val1 === val2) {\n        return true;\n      }\n    }\n  }\n}\n\nfunction matchItems(array1, array2, index1, index2, context) {\n  const value1 = array1[index1];\n  const value2 = array2[index2];\n  if (value1 === value2) {\n    return true;\n  }\n  if (typeof value1 !== 'object' || typeof value2 !== 'object') {\n    return false;\n  }\n  const objectHash = context.objectHash;\n  if (!objectHash) {\n    // no way to match objects was provided, try match by position\n    return context.matchByPosition && index1 === index2;\n  }\n  let hash1;\n  let hash2;\n  if (typeof index1 === 'number') {\n    context.hashCache1 = context.hashCache1 || [];\n    hash1 = context.hashCache1[index1];\n    if (typeof hash1 === 'undefined') {\n      context.hashCache1[index1] = hash1 = objectHash(value1, index1);\n    }\n  } else {\n    hash1 = objectHash(value1);\n  }\n  if (typeof hash1 === 'undefined') {\n    return false;\n  }\n  if (typeof index2 === 'number') {\n    context.hashCache2 = context.hashCache2 || [];\n    hash2 = context.hashCache2[index2];\n    if (typeof hash2 === 'undefined') {\n      context.hashCache2[index2] = hash2 = objectHash(value2, index2);\n    }\n  } else {\n    hash2 = objectHash(value2);\n  }\n  if (typeof hash2 === 'undefined') {\n    return false;\n  }\n  return hash1 === hash2;\n}\n\nexport const diffFilter = function arraysDiffFilter(context) {\n  if (!context.leftIsArray) {\n    return;\n  }\n\n  const matchContext = {\n    objectHash: context.options && context.options.objectHash,\n    matchByPosition: context.options && context.options.matchByPosition,\n  };\n  let commonHead = 0;\n  let commonTail = 0;\n  let index;\n  let index1;\n  let index2;\n  const array1 = context.left;\n  const array2 = context.right;\n  const len1 = array1.length;\n  const len2 = array2.length;\n\n  let child;\n\n  if (\n    len1 > 0 &&\n    len2 > 0 &&\n    !matchContext.objectHash &&\n    typeof matchContext.matchByPosition !== 'boolean'\n  ) {\n    matchContext.matchByPosition = !arraysHaveMatchByRef(\n      array1,\n      array2,\n      len1,\n      len2,\n    );\n  }\n\n  // separate common head\n  while (\n    commonHead < len1 &&\n    commonHead < len2 &&\n    matchItems(array1, array2, commonHead, commonHead, matchContext)\n  ) {\n    index = commonHead;\n    child = new DiffContext(context.left[index], context.right[index]);\n    context.push(child, index);\n    commonHead++;\n  }\n  // separate common tail\n  while (\n    commonTail + commonHead < len1 &&\n    commonTail + commonHead < len2 &&\n    matchItems(\n      array1,\n      array2,\n      len1 - 1 - commonTail,\n      len2 - 1 - commonTail,\n      matchContext,\n    )\n  ) {\n    index1 = len1 - 1 - commonTail;\n    index2 = len2 - 1 - commonTail;\n    child = new DiffContext(context.left[index1], context.right[index2]);\n    context.push(child, index2);\n    commonTail++;\n  }\n  let result;\n  if (commonHead + commonTail === len1) {\n    if (len1 === len2) {\n      // arrays are identical\n      context.setResult(undefined).exit();\n      return;\n    }\n    // trivial case, a block (1 or more consecutive items) was added\n    result = result || {\n      _t: 'a',\n    };\n    for (index = commonHead; index < len2 - commonTail; index++) {\n      result[index] = [array2[index]];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  if (commonHead + commonTail === len2) {\n    // trivial case, a block (1 or more consecutive items) was removed\n    result = result || {\n      _t: 'a',\n    };\n    for (index = commonHead; index < len1 - commonTail; index++) {\n      result[`_${index}`] = [array1[index], 0, 0];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  // reset hash cache\n  delete matchContext.hashCache1;\n  delete matchContext.hashCache2;\n\n  // diff is not trivial, find the LCS (Longest Common Subsequence)\n  const trimmed1 = array1.slice(commonHead, len1 - commonTail);\n  const trimmed2 = array2.slice(commonHead, len2 - commonTail);\n  const seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);\n  const removedItems = [];\n  result = result || {\n    _t: 'a',\n  };\n  for (index = commonHead; index < len1 - commonTail; index++) {\n    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {\n      // removed\n      result[`_${index}`] = [array1[index], 0, 0];\n      removedItems.push(index);\n    }\n  }\n\n  let detectMove = true;\n  if (\n    context.options &&\n    context.options.arrays &&\n    context.options.arrays.detectMove === false\n  ) {\n    detectMove = false;\n  }\n  let includeValueOnMove = false;\n  if (\n    context.options &&\n    context.options.arrays &&\n    context.options.arrays.includeValueOnMove\n  ) {\n    includeValueOnMove = true;\n  }\n\n  const removedItemsLength = removedItems.length;\n  for (index = commonHead; index < len2 - commonTail; index++) {\n    const indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);\n    if (indexOnArray2 < 0) {\n      // added, try to match with a removed item and register as position move\n      let isMove = false;\n      if (detectMove && removedItemsLength > 0) {\n        for (\n          let removeItemIndex1 = 0;\n          removeItemIndex1 < removedItemsLength;\n          removeItemIndex1++\n        ) {\n          index1 = removedItems[removeItemIndex1];\n          if (\n            matchItems(\n              trimmed1,\n              trimmed2,\n              index1 - commonHead,\n              index - commonHead,\n              matchContext,\n            )\n          ) {\n            // store position move as: [originalValue, newPosition, ARRAY_MOVE]\n            result[`_${index1}`].splice(1, 2, index, ARRAY_MOVE);\n            if (!includeValueOnMove) {\n              // don't include moved value on diff, to save bytes\n              result[`_${index1}`][0] = '';\n            }\n\n            index2 = index;\n            child = new DiffContext(\n              context.left[index1],\n              context.right[index2],\n            );\n            context.push(child, index2);\n            removedItems.splice(removeItemIndex1, 1);\n            isMove = true;\n            break;\n          }\n        }\n      }\n      if (!isMove) {\n        // added\n        result[index] = [array2[index]];\n      }\n    } else {\n      // match, do inner diff\n      index1 = seq.indices1[indexOnArray2] + commonHead;\n      index2 = seq.indices2[indexOnArray2] + commonHead;\n      child = new DiffContext(context.left[index1], context.right[index2]);\n      context.push(child, index2);\n    }\n  }\n\n  context.setResult(result).exit();\n};\ndiffFilter.filterName = 'arrays';\n\nconst compare = {\n  numerically(a, b) {\n    return a - b;\n  },\n  numericallyBy(name) {\n    return (a, b) => a[name] - b[name];\n  },\n};\n\nexport const patchFilter = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  let index;\n  let index1;\n\n  const delta = context.delta;\n  const array = context.left;\n\n  // first, separate removals, insertions and modifications\n  let toRemove = [];\n  let toInsert = [];\n  const toModify = [];\n  for (index in delta) {\n    if (index !== '_t') {\n      if (index[0] === '_') {\n        // removed item from original array\n        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {\n          toRemove.push(parseInt(index.slice(1), 10));\n        } else {\n          throw new Error(\n            'only removal or move can be applied at original array indices,' +\n              ` invalid diff type: ${delta[index][2]}`,\n          );\n        }\n      } else {\n        if (delta[index].length === 1) {\n          // added item at new array\n          toInsert.push({\n            index: parseInt(index, 10),\n            value: delta[index][0],\n          });\n        } else {\n          // modified item at new array\n          toModify.push({\n            index: parseInt(index, 10),\n            delta: delta[index],\n          });\n        }\n      }\n    }\n  }\n\n  // remove items, in reverse order to avoid sawing our own floor\n  toRemove = toRemove.sort(compare.numerically);\n  for (index = toRemove.length - 1; index >= 0; index--) {\n    index1 = toRemove[index];\n    const indexDiff = delta[`_${index1}`];\n    const removedValue = array.splice(index1, 1)[0];\n    if (indexDiff[2] === ARRAY_MOVE) {\n      // reinsert later\n      toInsert.push({\n        index: indexDiff[1],\n        value: removedValue,\n      });\n    }\n  }\n\n  // insert items, in reverse order to avoid moving our own floor\n  toInsert = toInsert.sort(compare.numericallyBy('index'));\n  const toInsertLength = toInsert.length;\n  for (index = 0; index < toInsertLength; index++) {\n    const insertion = toInsert[index];\n    array.splice(insertion.index, 0, insertion.value);\n  }\n\n  // apply modifications\n  const toModifyLength = toModify.length;\n  let child;\n  if (toModifyLength > 0) {\n    for (index = 0; index < toModifyLength; index++) {\n      const modification = toModify[index];\n      child = new PatchContext(\n        context.left[modification.index],\n        modification.delta,\n      );\n      context.push(child, modification.index);\n    }\n  }\n\n  if (!context.children) {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.exit();\n};\npatchFilter.filterName = 'arrays';\n\nexport const collectChildrenPatchFilter = function collectChildrenPatchFilter(\n  context,\n) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  const length = context.children.length;\n  let child;\n  for (let index = 0; index < length; index++) {\n    child = context.children[index];\n    context.left[child.childName] = child.result;\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter.filterName = 'arraysCollectChildren';\n\nexport const reverseFilter = function arraysReverseFilter(context) {\n  if (!context.nested) {\n    if (context.delta[2] === ARRAY_MOVE) {\n      context.newName = `_${context.delta[1]}`;\n      context\n        .setResult([\n          context.delta[0],\n          parseInt(context.childName.substr(1), 10),\n          ARRAY_MOVE,\n        ])\n        .exit();\n    }\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  let name;\n  let child;\n  for (name in context.delta) {\n    if (name === '_t') {\n      continue;\n    }\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter.filterName = 'arrays';\n\nconst reverseArrayDeltaIndex = (delta, index, itemDelta) => {\n  if (typeof index === 'string' && index[0] === '_') {\n    return parseInt(index.substr(1), 10);\n  } else if (isArray(itemDelta) && itemDelta[2] === 0) {\n    return `_${index}`;\n  }\n\n  let reverseIndex = +index;\n  for (const deltaIndex in delta) {\n    const deltaItem = delta[deltaIndex];\n    if (isArray(deltaItem)) {\n      if (deltaItem[2] === ARRAY_MOVE) {\n        const moveFromIndex = parseInt(deltaIndex.substr(1), 10);\n        const moveToIndex = deltaItem[1];\n        if (moveToIndex === +index) {\n          return moveFromIndex;\n        }\n        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {\n          reverseIndex++;\n        } else if (\n          moveFromIndex >= reverseIndex &&\n          moveToIndex < reverseIndex\n        ) {\n          reverseIndex--;\n        }\n      } else if (deltaItem[2] === 0) {\n        const deleteIndex = parseInt(deltaIndex.substr(1), 10);\n        if (deleteIndex <= reverseIndex) {\n          reverseIndex++;\n        }\n      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {\n        reverseIndex--;\n      }\n    }\n  }\n\n  return reverseIndex;\n};\n\nexport function collectChildrenReverseFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  const length = context.children.length;\n  let child;\n  const delta = {\n    _t: 'a',\n  };\n\n  for (let index = 0; index < length; index++) {\n    child = context.children[index];\n    let name = child.newName;\n    if (typeof name === 'undefined') {\n      name = reverseArrayDeltaIndex(\n        context.delta,\n        child.childName,\n        child.result,\n      );\n    }\n    if (delta[name] !== child.result) {\n      delta[name] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n}\ncollectChildrenReverseFilter.filterName = 'arraysCollectChildren';\n"],
	      names: ["DiffContext", "PatchContext", "ReverseContext", "lcs", "ARRAY_MOVE", "isArray", "Array", "a", "arrayIndexOf", "prototype", "indexOf", "array", "item", "length", "i", "arraysHaveMatchByRef", "array1", "array2", "len1", "len2", "index1", "val1", "index2", "val2", "matchItems", "context", "value1", "value2", "objectHash", "matchByPosition", "hash1", "hash2", "hashCache1", "hashCache2", "diffFilter", "arraysDiffFilter", "leftIsArray", "matchContext", "options", "commonHead", "commonTail", "index", "left", "right", "child", "push", "result", "setResult", "undefined", "exit", "_t", "trimmed1", "slice", "trimmed2", "seq", "get", "removedItems", "indices1", "detectMove", "arrays", "includeValueOnMove", "removedItemsLength", "indexOnArray2", "indices2", "isMove", "removeItemIndex1", "splice", "filterName", "compare", "numerically", "b", "numericallyBy", "name", "patchFilter", "nestedPatchFilter", "nested", "delta", "toRemove", "toInsert", "toModify", "parseInt", "Error", "value", "sort", "indexDiff", "removedValue", "toInsertLength", "insertion", "toModifyLength", "modification", "children", "collectChildrenPatchFilter", "childName", "reverseFilter", "arraysReverseFilter", "newName", "substr", "reverseArrayDeltaIndex", "itemDelta", "reverseIndex", "deltaIndex", "deltaItem", "moveFromIndex", "moveToIndex", "deleteIndex", "collectChildrenReverseFilter"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "6c892b145d1d9d4115fa0472ca6ce15c2e1b8e40"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_5ijtfroyd = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_5ijtfroyd();
	const ARRAY_MOVE = (cov_5ijtfroyd().s[0]++, 3);
	const isArray$1 = (cov_5ijtfroyd().s[1]++, typeof Array.isArray === 'function' ? (cov_5ijtfroyd().b[0][0]++, Array.isArray) : (cov_5ijtfroyd().b[0][1]++, a => {
	  cov_5ijtfroyd().f[0]++;
	  cov_5ijtfroyd().s[2]++;
	  return a instanceof Array;
	}));
	const arrayIndexOf = (cov_5ijtfroyd().s[3]++, typeof Array.prototype.indexOf === 'function' ? (cov_5ijtfroyd().b[1][0]++, (array, item) => {
	  cov_5ijtfroyd().f[1]++;
	  cov_5ijtfroyd().s[4]++;
	  return array.indexOf(item);
	}) : (cov_5ijtfroyd().b[1][1]++, (array, item) => {
	  cov_5ijtfroyd().f[2]++;
	  const length = (cov_5ijtfroyd().s[5]++, array.length);
	  cov_5ijtfroyd().s[6]++;
	  for (let i = (cov_5ijtfroyd().s[7]++, 0); i < length; i++) {
	    cov_5ijtfroyd().s[8]++;
	    if (array[i] === item) {
	      cov_5ijtfroyd().b[2][0]++;
	      cov_5ijtfroyd().s[9]++;
	      return i;
	    } else {
	      cov_5ijtfroyd().b[2][1]++;
	    }
	  }
	  cov_5ijtfroyd().s[10]++;
	  return -1;
	}));
	function arraysHaveMatchByRef(array1, array2, len1, len2) {
	  cov_5ijtfroyd().f[3]++;
	  cov_5ijtfroyd().s[11]++;
	  for (let index1 = (cov_5ijtfroyd().s[12]++, 0); index1 < len1; index1++) {
	    const val1 = (cov_5ijtfroyd().s[13]++, array1[index1]);
	    cov_5ijtfroyd().s[14]++;
	    for (let index2 = (cov_5ijtfroyd().s[15]++, 0); index2 < len2; index2++) {
	      const val2 = (cov_5ijtfroyd().s[16]++, array2[index2]);
	      cov_5ijtfroyd().s[17]++;
	      if ((cov_5ijtfroyd().b[4][0]++, index1 !== index2) && (cov_5ijtfroyd().b[4][1]++, val1 === val2)) {
	        cov_5ijtfroyd().b[3][0]++;
	        cov_5ijtfroyd().s[18]++;
	        return true;
	      } else {
	        cov_5ijtfroyd().b[3][1]++;
	      }
	    }
	  }
	}
	function matchItems(array1, array2, index1, index2, context) {
	  cov_5ijtfroyd().f[4]++;
	  const value1 = (cov_5ijtfroyd().s[19]++, array1[index1]);
	  const value2 = (cov_5ijtfroyd().s[20]++, array2[index2]);
	  cov_5ijtfroyd().s[21]++;
	  if (value1 === value2) {
	    cov_5ijtfroyd().b[5][0]++;
	    cov_5ijtfroyd().s[22]++;
	    return true;
	  } else {
	    cov_5ijtfroyd().b[5][1]++;
	  }
	  cov_5ijtfroyd().s[23]++;
	  if ((cov_5ijtfroyd().b[7][0]++, typeof value1 !== 'object') || (cov_5ijtfroyd().b[7][1]++, typeof value2 !== 'object')) {
	    cov_5ijtfroyd().b[6][0]++;
	    cov_5ijtfroyd().s[24]++;
	    return false;
	  } else {
	    cov_5ijtfroyd().b[6][1]++;
	  }
	  const objectHash = (cov_5ijtfroyd().s[25]++, context.objectHash);
	  cov_5ijtfroyd().s[26]++;
	  if (!objectHash) {
	    cov_5ijtfroyd().b[8][0]++;
	    cov_5ijtfroyd().s[27]++; // no way to match objects was provided, try match by position
	    return (cov_5ijtfroyd().b[9][0]++, context.matchByPosition) && (cov_5ijtfroyd().b[9][1]++, index1 === index2);
	  } else {
	    cov_5ijtfroyd().b[8][1]++;
	  }
	  let hash1;
	  let hash2;
	  cov_5ijtfroyd().s[28]++;
	  if (typeof index1 === 'number') {
	    cov_5ijtfroyd().b[10][0]++;
	    cov_5ijtfroyd().s[29]++;
	    context.hashCache1 = (cov_5ijtfroyd().b[11][0]++, context.hashCache1) || (cov_5ijtfroyd().b[11][1]++, []);
	    cov_5ijtfroyd().s[30]++;
	    hash1 = context.hashCache1[index1];
	    cov_5ijtfroyd().s[31]++;
	    if (typeof hash1 === 'undefined') {
	      cov_5ijtfroyd().b[12][0]++;
	      cov_5ijtfroyd().s[32]++;
	      context.hashCache1[index1] = hash1 = objectHash(value1, index1);
	    } else {
	      cov_5ijtfroyd().b[12][1]++;
	    }
	  } else {
	    cov_5ijtfroyd().b[10][1]++;
	    cov_5ijtfroyd().s[33]++;
	    hash1 = objectHash(value1);
	  }
	  cov_5ijtfroyd().s[34]++;
	  if (typeof hash1 === 'undefined') {
	    cov_5ijtfroyd().b[13][0]++;
	    cov_5ijtfroyd().s[35]++;
	    return false;
	  } else {
	    cov_5ijtfroyd().b[13][1]++;
	  }
	  cov_5ijtfroyd().s[36]++;
	  if (typeof index2 === 'number') {
	    cov_5ijtfroyd().b[14][0]++;
	    cov_5ijtfroyd().s[37]++;
	    context.hashCache2 = (cov_5ijtfroyd().b[15][0]++, context.hashCache2) || (cov_5ijtfroyd().b[15][1]++, []);
	    cov_5ijtfroyd().s[38]++;
	    hash2 = context.hashCache2[index2];
	    cov_5ijtfroyd().s[39]++;
	    if (typeof hash2 === 'undefined') {
	      cov_5ijtfroyd().b[16][0]++;
	      cov_5ijtfroyd().s[40]++;
	      context.hashCache2[index2] = hash2 = objectHash(value2, index2);
	    } else {
	      cov_5ijtfroyd().b[16][1]++;
	    }
	  } else {
	    cov_5ijtfroyd().b[14][1]++;
	    cov_5ijtfroyd().s[41]++;
	    hash2 = objectHash(value2);
	  }
	  cov_5ijtfroyd().s[42]++;
	  if (typeof hash2 === 'undefined') {
	    cov_5ijtfroyd().b[17][0]++;
	    cov_5ijtfroyd().s[43]++;
	    return false;
	  } else {
	    cov_5ijtfroyd().b[17][1]++;
	  }
	  cov_5ijtfroyd().s[44]++;
	  return hash1 === hash2;
	}
	cov_5ijtfroyd().s[45]++;
	const diffFilter$2 = function arraysDiffFilter(context) {
	  cov_5ijtfroyd().f[5]++;
	  cov_5ijtfroyd().s[46]++;
	  if (!context.leftIsArray) {
	    cov_5ijtfroyd().b[18][0]++;
	    cov_5ijtfroyd().s[47]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[18][1]++;
	  }
	  const matchContext = (cov_5ijtfroyd().s[48]++, {
	    objectHash: (cov_5ijtfroyd().b[19][0]++, context.options) && (cov_5ijtfroyd().b[19][1]++, context.options.objectHash),
	    matchByPosition: (cov_5ijtfroyd().b[20][0]++, context.options) && (cov_5ijtfroyd().b[20][1]++, context.options.matchByPosition)
	  });
	  let commonHead = (cov_5ijtfroyd().s[49]++, 0);
	  let commonTail = (cov_5ijtfroyd().s[50]++, 0);
	  let index;
	  let index1;
	  let index2;
	  const array1 = (cov_5ijtfroyd().s[51]++, context.left);
	  const array2 = (cov_5ijtfroyd().s[52]++, context.right);
	  const len1 = (cov_5ijtfroyd().s[53]++, array1.length);
	  const len2 = (cov_5ijtfroyd().s[54]++, array2.length);
	  let child;
	  cov_5ijtfroyd().s[55]++;
	  if ((cov_5ijtfroyd().b[22][0]++, len1 > 0) && (cov_5ijtfroyd().b[22][1]++, len2 > 0) && (cov_5ijtfroyd().b[22][2]++, !matchContext.objectHash) && (cov_5ijtfroyd().b[22][3]++, typeof matchContext.matchByPosition !== 'boolean')) {
	    cov_5ijtfroyd().b[21][0]++;
	    cov_5ijtfroyd().s[56]++;
	    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);
	  } else {
	    cov_5ijtfroyd().b[21][1]++;
	  } // separate common head
	  cov_5ijtfroyd().s[57]++;
	  while ((cov_5ijtfroyd().b[23][0]++, commonHead < len1) && (cov_5ijtfroyd().b[23][1]++, commonHead < len2) && (cov_5ijtfroyd().b[23][2]++, matchItems(array1, array2, commonHead, commonHead, matchContext))) {
	    cov_5ijtfroyd().s[58]++;
	    index = commonHead;
	    cov_5ijtfroyd().s[59]++;
	    child = new DiffContext(context.left[index], context.right[index]);
	    cov_5ijtfroyd().s[60]++;
	    context.push(child, index);
	    cov_5ijtfroyd().s[61]++;
	    commonHead++;
	  } // separate common tail
	  cov_5ijtfroyd().s[62]++;
	  while ((cov_5ijtfroyd().b[24][0]++, commonTail + commonHead < len1) && (cov_5ijtfroyd().b[24][1]++, commonTail + commonHead < len2) && (cov_5ijtfroyd().b[24][2]++, matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext))) {
	    cov_5ijtfroyd().s[63]++;
	    index1 = len1 - 1 - commonTail;
	    cov_5ijtfroyd().s[64]++;
	    index2 = len2 - 1 - commonTail;
	    cov_5ijtfroyd().s[65]++;
	    child = new DiffContext(context.left[index1], context.right[index2]);
	    cov_5ijtfroyd().s[66]++;
	    context.push(child, index2);
	    cov_5ijtfroyd().s[67]++;
	    commonTail++;
	  }
	  let result;
	  cov_5ijtfroyd().s[68]++;
	  if (commonHead + commonTail === len1) {
	    cov_5ijtfroyd().b[25][0]++;
	    cov_5ijtfroyd().s[69]++;
	    if (len1 === len2) {
	      cov_5ijtfroyd().b[26][0]++;
	      cov_5ijtfroyd().s[70]++; // arrays are identical
	      context.setResult(undefined).exit();
	      cov_5ijtfroyd().s[71]++;
	      return;
	    } else {
	      cov_5ijtfroyd().b[26][1]++;
	    } // trivial case, a block (1 or more consecutive items) was added
	    cov_5ijtfroyd().s[72]++;
	    result = (cov_5ijtfroyd().b[27][0]++, result) || (cov_5ijtfroyd().b[27][1]++, {
	      _t: 'a'
	    });
	    cov_5ijtfroyd().s[73]++;
	    for (index = commonHead; index < len2 - commonTail; index++) {
	      cov_5ijtfroyd().s[74]++;
	      result[index] = [array2[index]];
	    }
	    cov_5ijtfroyd().s[75]++;
	    context.setResult(result).exit();
	    cov_5ijtfroyd().s[76]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[25][1]++;
	  }
	  cov_5ijtfroyd().s[77]++;
	  if (commonHead + commonTail === len2) {
	    cov_5ijtfroyd().b[28][0]++;
	    cov_5ijtfroyd().s[78]++; // trivial case, a block (1 or more consecutive items) was removed
	    result = (cov_5ijtfroyd().b[29][0]++, result) || (cov_5ijtfroyd().b[29][1]++, {
	      _t: 'a'
	    });
	    cov_5ijtfroyd().s[79]++;
	    for (index = commonHead; index < len1 - commonTail; index++) {
	      cov_5ijtfroyd().s[80]++;
	      result[`_${index}`] = [array1[index], 0, 0];
	    }
	    cov_5ijtfroyd().s[81]++;
	    context.setResult(result).exit();
	    cov_5ijtfroyd().s[82]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[28][1]++;
	  } // reset hash cache
	  cov_5ijtfroyd().s[83]++;
	  delete matchContext.hashCache1;
	  cov_5ijtfroyd().s[84]++;
	  delete matchContext.hashCache2; // diff is not trivial, find the LCS (Longest Common Subsequence)
	  const trimmed1 = (cov_5ijtfroyd().s[85]++, array1.slice(commonHead, len1 - commonTail));
	  const trimmed2 = (cov_5ijtfroyd().s[86]++, array2.slice(commonHead, len2 - commonTail));
	  const seq = (cov_5ijtfroyd().s[87]++, lcs$1.get(trimmed1, trimmed2, matchItems, matchContext));
	  const removedItems = (cov_5ijtfroyd().s[88]++, []);
	  cov_5ijtfroyd().s[89]++;
	  result = (cov_5ijtfroyd().b[30][0]++, result) || (cov_5ijtfroyd().b[30][1]++, {
	    _t: 'a'
	  });
	  cov_5ijtfroyd().s[90]++;
	  for (index = commonHead; index < len1 - commonTail; index++) {
	    cov_5ijtfroyd().s[91]++;
	    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {
	      cov_5ijtfroyd().b[31][0]++;
	      cov_5ijtfroyd().s[92]++; // removed
	      result[`_${index}`] = [array1[index], 0, 0];
	      cov_5ijtfroyd().s[93]++;
	      removedItems.push(index);
	    } else {
	      cov_5ijtfroyd().b[31][1]++;
	    }
	  }
	  let detectMove = (cov_5ijtfroyd().s[94]++, true);
	  cov_5ijtfroyd().s[95]++;
	  if ((cov_5ijtfroyd().b[33][0]++, context.options) && (cov_5ijtfroyd().b[33][1]++, context.options.arrays) && (cov_5ijtfroyd().b[33][2]++, context.options.arrays.detectMove === false)) {
	    cov_5ijtfroyd().b[32][0]++;
	    cov_5ijtfroyd().s[96]++;
	    detectMove = false;
	  } else {
	    cov_5ijtfroyd().b[32][1]++;
	  }
	  let includeValueOnMove = (cov_5ijtfroyd().s[97]++, false);
	  cov_5ijtfroyd().s[98]++;
	  if ((cov_5ijtfroyd().b[35][0]++, context.options) && (cov_5ijtfroyd().b[35][1]++, context.options.arrays) && (cov_5ijtfroyd().b[35][2]++, context.options.arrays.includeValueOnMove)) {
	    cov_5ijtfroyd().b[34][0]++;
	    cov_5ijtfroyd().s[99]++;
	    includeValueOnMove = true;
	  } else {
	    cov_5ijtfroyd().b[34][1]++;
	  }
	  const removedItemsLength = (cov_5ijtfroyd().s[100]++, removedItems.length);
	  cov_5ijtfroyd().s[101]++;
	  for (index = commonHead; index < len2 - commonTail; index++) {
	    const indexOnArray2 = (cov_5ijtfroyd().s[102]++, arrayIndexOf(seq.indices2, index - commonHead));
	    cov_5ijtfroyd().s[103]++;
	    if (indexOnArray2 < 0) {
	      cov_5ijtfroyd().b[36][0]++; // added, try to match with a removed item and register as position move
	      let isMove = (cov_5ijtfroyd().s[104]++, false);
	      cov_5ijtfroyd().s[105]++;
	      if ((cov_5ijtfroyd().b[38][0]++, detectMove) && (cov_5ijtfroyd().b[38][1]++, removedItemsLength > 0)) {
	        cov_5ijtfroyd().b[37][0]++;
	        cov_5ijtfroyd().s[106]++;
	        for (let removeItemIndex1 = (cov_5ijtfroyd().s[107]++, 0); removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
	          cov_5ijtfroyd().s[108]++;
	          index1 = removedItems[removeItemIndex1];
	          cov_5ijtfroyd().s[109]++;
	          if (matchItems(trimmed1, trimmed2, index1 - commonHead, index - commonHead, matchContext)) {
	            cov_5ijtfroyd().b[39][0]++;
	            cov_5ijtfroyd().s[110]++; // store position move as: [originalValue, newPosition, ARRAY_MOVE]
	            result[`_${index1}`].splice(1, 2, index, ARRAY_MOVE);
	            cov_5ijtfroyd().s[111]++;
	            if (!includeValueOnMove) {
	              cov_5ijtfroyd().b[40][0]++;
	              cov_5ijtfroyd().s[112]++; // don't include moved value on diff, to save bytes
	              result[`_${index1}`][0] = '';
	            } else {
	              cov_5ijtfroyd().b[40][1]++;
	            }
	            cov_5ijtfroyd().s[113]++;
	            index2 = index;
	            cov_5ijtfroyd().s[114]++;
	            child = new DiffContext(context.left[index1], context.right[index2]);
	            cov_5ijtfroyd().s[115]++;
	            context.push(child, index2);
	            cov_5ijtfroyd().s[116]++;
	            removedItems.splice(removeItemIndex1, 1);
	            cov_5ijtfroyd().s[117]++;
	            isMove = true;
	            cov_5ijtfroyd().s[118]++;
	            break;
	          } else {
	            cov_5ijtfroyd().b[39][1]++;
	          }
	        }
	      } else {
	        cov_5ijtfroyd().b[37][1]++;
	      }
	      cov_5ijtfroyd().s[119]++;
	      if (!isMove) {
	        cov_5ijtfroyd().b[41][0]++;
	        cov_5ijtfroyd().s[120]++; // added
	        result[index] = [array2[index]];
	      } else {
	        cov_5ijtfroyd().b[41][1]++;
	      }
	    } else {
	      cov_5ijtfroyd().b[36][1]++;
	      cov_5ijtfroyd().s[121]++; // match, do inner diff
	      index1 = seq.indices1[indexOnArray2] + commonHead;
	      cov_5ijtfroyd().s[122]++;
	      index2 = seq.indices2[indexOnArray2] + commonHead;
	      cov_5ijtfroyd().s[123]++;
	      child = new DiffContext(context.left[index1], context.right[index2]);
	      cov_5ijtfroyd().s[124]++;
	      context.push(child, index2);
	    }
	  }
	  cov_5ijtfroyd().s[125]++;
	  context.setResult(result).exit();
	};
	cov_5ijtfroyd().s[126]++;
	diffFilter$2.filterName = 'arrays';
	const compare = (cov_5ijtfroyd().s[127]++, {
	  numerically(a, b) {
	    cov_5ijtfroyd().f[6]++;
	    cov_5ijtfroyd().s[128]++;
	    return a - b;
	  },
	  numericallyBy(name) {
	    cov_5ijtfroyd().f[7]++;
	    cov_5ijtfroyd().s[129]++;
	    return (a, b) => {
	      cov_5ijtfroyd().f[8]++;
	      cov_5ijtfroyd().s[130]++;
	      return a[name] - b[name];
	    };
	  }
	});
	cov_5ijtfroyd().s[131]++;
	const patchFilter$1 = function nestedPatchFilter(context) {
	  cov_5ijtfroyd().f[9]++;
	  cov_5ijtfroyd().s[132]++;
	  if (!context.nested) {
	    cov_5ijtfroyd().b[42][0]++;
	    cov_5ijtfroyd().s[133]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[42][1]++;
	  }
	  cov_5ijtfroyd().s[134]++;
	  if (context.delta._t !== 'a') {
	    cov_5ijtfroyd().b[43][0]++;
	    cov_5ijtfroyd().s[135]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[43][1]++;
	  }
	  let index;
	  let index1;
	  const delta = (cov_5ijtfroyd().s[136]++, context.delta);
	  const array = (cov_5ijtfroyd().s[137]++, context.left); // first, separate removals, insertions and modifications
	  let toRemove = (cov_5ijtfroyd().s[138]++, []);
	  let toInsert = (cov_5ijtfroyd().s[139]++, []);
	  const toModify = (cov_5ijtfroyd().s[140]++, []);
	  cov_5ijtfroyd().s[141]++;
	  for (index in delta) {
	    cov_5ijtfroyd().s[142]++;
	    if (index !== '_t') {
	      cov_5ijtfroyd().b[44][0]++;
	      cov_5ijtfroyd().s[143]++;
	      if (index[0] === '_') {
	        cov_5ijtfroyd().b[45][0]++;
	        cov_5ijtfroyd().s[144]++; // removed item from original array
	        if ((cov_5ijtfroyd().b[47][0]++, delta[index][2] === 0) || (cov_5ijtfroyd().b[47][1]++, delta[index][2] === ARRAY_MOVE)) {
	          cov_5ijtfroyd().b[46][0]++;
	          cov_5ijtfroyd().s[145]++;
	          toRemove.push(parseInt(index.slice(1), 10));
	        } else {
	          cov_5ijtfroyd().b[46][1]++;
	          cov_5ijtfroyd().s[146]++;
	          throw new Error('only removal or move can be applied at original array indices,' + ` invalid diff type: ${delta[index][2]}`);
	        }
	      } else {
	        cov_5ijtfroyd().b[45][1]++;
	        cov_5ijtfroyd().s[147]++;
	        if (delta[index].length === 1) {
	          cov_5ijtfroyd().b[48][0]++;
	          cov_5ijtfroyd().s[148]++; // added item at new array
	          toInsert.push({
	            index: parseInt(index, 10),
	            value: delta[index][0]
	          });
	        } else {
	          cov_5ijtfroyd().b[48][1]++;
	          cov_5ijtfroyd().s[149]++; // modified item at new array
	          toModify.push({
	            index: parseInt(index, 10),
	            delta: delta[index]
	          });
	        }
	      }
	    } else {
	      cov_5ijtfroyd().b[44][1]++;
	    }
	  } // remove items, in reverse order to avoid sawing our own floor
	  cov_5ijtfroyd().s[150]++;
	  toRemove = toRemove.sort(compare.numerically);
	  cov_5ijtfroyd().s[151]++;
	  for (index = toRemove.length - 1; index >= 0; index--) {
	    cov_5ijtfroyd().s[152]++;
	    index1 = toRemove[index];
	    const indexDiff = (cov_5ijtfroyd().s[153]++, delta[`_${index1}`]);
	    const removedValue = (cov_5ijtfroyd().s[154]++, array.splice(index1, 1)[0]);
	    cov_5ijtfroyd().s[155]++;
	    if (indexDiff[2] === ARRAY_MOVE) {
	      cov_5ijtfroyd().b[49][0]++;
	      cov_5ijtfroyd().s[156]++; // reinsert later
	      toInsert.push({
	        index: indexDiff[1],
	        value: removedValue
	      });
	    } else {
	      cov_5ijtfroyd().b[49][1]++;
	    }
	  } // insert items, in reverse order to avoid moving our own floor
	  cov_5ijtfroyd().s[157]++;
	  toInsert = toInsert.sort(compare.numericallyBy('index'));
	  const toInsertLength = (cov_5ijtfroyd().s[158]++, toInsert.length);
	  cov_5ijtfroyd().s[159]++;
	  for (index = 0; index < toInsertLength; index++) {
	    const insertion = (cov_5ijtfroyd().s[160]++, toInsert[index]);
	    cov_5ijtfroyd().s[161]++;
	    array.splice(insertion.index, 0, insertion.value);
	  } // apply modifications
	  const toModifyLength = (cov_5ijtfroyd().s[162]++, toModify.length);
	  let child;
	  cov_5ijtfroyd().s[163]++;
	  if (toModifyLength > 0) {
	    cov_5ijtfroyd().b[50][0]++;
	    cov_5ijtfroyd().s[164]++;
	    for (index = 0; index < toModifyLength; index++) {
	      const modification = (cov_5ijtfroyd().s[165]++, toModify[index]);
	      cov_5ijtfroyd().s[166]++;
	      child = new PatchContext(context.left[modification.index], modification.delta);
	      cov_5ijtfroyd().s[167]++;
	      context.push(child, modification.index);
	    }
	  } else {
	    cov_5ijtfroyd().b[50][1]++;
	  }
	  cov_5ijtfroyd().s[168]++;
	  if (!context.children) {
	    cov_5ijtfroyd().b[51][0]++;
	    cov_5ijtfroyd().s[169]++;
	    context.setResult(context.left).exit();
	    cov_5ijtfroyd().s[170]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[51][1]++;
	  }
	  cov_5ijtfroyd().s[171]++;
	  context.exit();
	};
	cov_5ijtfroyd().s[172]++;
	patchFilter$1.filterName = 'arrays';
	cov_5ijtfroyd().s[173]++;
	const collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {
	  cov_5ijtfroyd().f[10]++;
	  cov_5ijtfroyd().s[174]++;
	  if ((cov_5ijtfroyd().b[53][0]++, !context) || (cov_5ijtfroyd().b[53][1]++, !context.children)) {
	    cov_5ijtfroyd().b[52][0]++;
	    cov_5ijtfroyd().s[175]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[52][1]++;
	  }
	  cov_5ijtfroyd().s[176]++;
	  if (context.delta._t !== 'a') {
	    cov_5ijtfroyd().b[54][0]++;
	    cov_5ijtfroyd().s[177]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[54][1]++;
	  }
	  const length = (cov_5ijtfroyd().s[178]++, context.children.length);
	  let child;
	  cov_5ijtfroyd().s[179]++;
	  for (let index = (cov_5ijtfroyd().s[180]++, 0); index < length; index++) {
	    cov_5ijtfroyd().s[181]++;
	    child = context.children[index];
	    cov_5ijtfroyd().s[182]++;
	    context.left[child.childName] = child.result;
	  }
	  cov_5ijtfroyd().s[183]++;
	  context.setResult(context.left).exit();
	};
	cov_5ijtfroyd().s[184]++;
	collectChildrenPatchFilter.filterName = 'arraysCollectChildren';
	cov_5ijtfroyd().s[185]++;
	const reverseFilter$1 = function arraysReverseFilter(context) {
	  cov_5ijtfroyd().f[11]++;
	  cov_5ijtfroyd().s[186]++;
	  if (!context.nested) {
	    cov_5ijtfroyd().b[55][0]++;
	    cov_5ijtfroyd().s[187]++;
	    if (context.delta[2] === ARRAY_MOVE) {
	      cov_5ijtfroyd().b[56][0]++;
	      cov_5ijtfroyd().s[188]++;
	      context.newName = `_${context.delta[1]}`;
	      cov_5ijtfroyd().s[189]++;
	      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();
	    } else {
	      cov_5ijtfroyd().b[56][1]++;
	    }
	    cov_5ijtfroyd().s[190]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[55][1]++;
	  }
	  cov_5ijtfroyd().s[191]++;
	  if (context.delta._t !== 'a') {
	    cov_5ijtfroyd().b[57][0]++;
	    cov_5ijtfroyd().s[192]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[57][1]++;
	  }
	  let name;
	  let child;
	  cov_5ijtfroyd().s[193]++;
	  for (name in context.delta) {
	    cov_5ijtfroyd().s[194]++;
	    if (name === '_t') {
	      cov_5ijtfroyd().b[58][0]++;
	      cov_5ijtfroyd().s[195]++;
	      continue;
	    } else {
	      cov_5ijtfroyd().b[58][1]++;
	    }
	    cov_5ijtfroyd().s[196]++;
	    child = new ReverseContext(context.delta[name]);
	    cov_5ijtfroyd().s[197]++;
	    context.push(child, name);
	  }
	  cov_5ijtfroyd().s[198]++;
	  context.exit();
	};
	cov_5ijtfroyd().s[199]++;
	reverseFilter$1.filterName = 'arrays';
	cov_5ijtfroyd().s[200]++;
	const reverseArrayDeltaIndex = (delta, index, itemDelta) => {
	  cov_5ijtfroyd().f[12]++;
	  cov_5ijtfroyd().s[201]++;
	  if ((cov_5ijtfroyd().b[60][0]++, typeof index === 'string') && (cov_5ijtfroyd().b[60][1]++, index[0] === '_')) {
	    cov_5ijtfroyd().b[59][0]++;
	    cov_5ijtfroyd().s[202]++;
	    return parseInt(index.substr(1), 10);
	  } else {
	    cov_5ijtfroyd().b[59][1]++;
	    cov_5ijtfroyd().s[203]++;
	    if ((cov_5ijtfroyd().b[62][0]++, isArray$1(itemDelta)) && (cov_5ijtfroyd().b[62][1]++, itemDelta[2] === 0)) {
	      cov_5ijtfroyd().b[61][0]++;
	      cov_5ijtfroyd().s[204]++;
	      return `_${index}`;
	    } else {
	      cov_5ijtfroyd().b[61][1]++;
	    }
	  }
	  let reverseIndex = (cov_5ijtfroyd().s[205]++, +index);
	  cov_5ijtfroyd().s[206]++;
	  for (const deltaIndex in delta) {
	    const deltaItem = (cov_5ijtfroyd().s[207]++, delta[deltaIndex]);
	    cov_5ijtfroyd().s[208]++;
	    if (isArray$1(deltaItem)) {
	      cov_5ijtfroyd().b[63][0]++;
	      cov_5ijtfroyd().s[209]++;
	      if (deltaItem[2] === ARRAY_MOVE) {
	        cov_5ijtfroyd().b[64][0]++;
	        const moveFromIndex = (cov_5ijtfroyd().s[210]++, parseInt(deltaIndex.substr(1), 10));
	        const moveToIndex = (cov_5ijtfroyd().s[211]++, deltaItem[1]);
	        cov_5ijtfroyd().s[212]++;
	        if (moveToIndex === +index) {
	          cov_5ijtfroyd().b[65][0]++;
	          cov_5ijtfroyd().s[213]++;
	          return moveFromIndex;
	        } else {
	          cov_5ijtfroyd().b[65][1]++;
	        }
	        cov_5ijtfroyd().s[214]++;
	        if ((cov_5ijtfroyd().b[67][0]++, moveFromIndex <= reverseIndex) && (cov_5ijtfroyd().b[67][1]++, moveToIndex > reverseIndex)) {
	          cov_5ijtfroyd().b[66][0]++;
	          cov_5ijtfroyd().s[215]++;
	          reverseIndex++;
	        } else {
	          cov_5ijtfroyd().b[66][1]++;
	          cov_5ijtfroyd().s[216]++;
	          if ((cov_5ijtfroyd().b[69][0]++, moveFromIndex >= reverseIndex) && (cov_5ijtfroyd().b[69][1]++, moveToIndex < reverseIndex)) {
	            cov_5ijtfroyd().b[68][0]++;
	            cov_5ijtfroyd().s[217]++;
	            reverseIndex--;
	          } else {
	            cov_5ijtfroyd().b[68][1]++;
	          }
	        }
	      } else {
	        cov_5ijtfroyd().b[64][1]++;
	        cov_5ijtfroyd().s[218]++;
	        if (deltaItem[2] === 0) {
	          cov_5ijtfroyd().b[70][0]++;
	          const deleteIndex = (cov_5ijtfroyd().s[219]++, parseInt(deltaIndex.substr(1), 10));
	          cov_5ijtfroyd().s[220]++;
	          if (deleteIndex <= reverseIndex) {
	            cov_5ijtfroyd().b[71][0]++;
	            cov_5ijtfroyd().s[221]++;
	            reverseIndex++;
	          } else {
	            cov_5ijtfroyd().b[71][1]++;
	          }
	        } else {
	          cov_5ijtfroyd().b[70][1]++;
	          cov_5ijtfroyd().s[222]++;
	          if ((cov_5ijtfroyd().b[73][0]++, deltaItem.length === 1) && (cov_5ijtfroyd().b[73][1]++, deltaIndex <= reverseIndex)) {
	            cov_5ijtfroyd().b[72][0]++;
	            cov_5ijtfroyd().s[223]++;
	            reverseIndex--;
	          } else {
	            cov_5ijtfroyd().b[72][1]++;
	          }
	        }
	      }
	    } else {
	      cov_5ijtfroyd().b[63][1]++;
	    }
	  }
	  cov_5ijtfroyd().s[224]++;
	  return reverseIndex;
	};
	function collectChildrenReverseFilter(context) {
	  cov_5ijtfroyd().f[13]++;
	  cov_5ijtfroyd().s[225]++;
	  if ((cov_5ijtfroyd().b[75][0]++, !context) || (cov_5ijtfroyd().b[75][1]++, !context.children)) {
	    cov_5ijtfroyd().b[74][0]++;
	    cov_5ijtfroyd().s[226]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[74][1]++;
	  }
	  cov_5ijtfroyd().s[227]++;
	  if (context.delta._t !== 'a') {
	    cov_5ijtfroyd().b[76][0]++;
	    cov_5ijtfroyd().s[228]++;
	    return;
	  } else {
	    cov_5ijtfroyd().b[76][1]++;
	  }
	  const length = (cov_5ijtfroyd().s[229]++, context.children.length);
	  let child;
	  const delta = (cov_5ijtfroyd().s[230]++, {
	    _t: 'a'
	  });
	  cov_5ijtfroyd().s[231]++;
	  for (let index = (cov_5ijtfroyd().s[232]++, 0); index < length; index++) {
	    cov_5ijtfroyd().s[233]++;
	    child = context.children[index];
	    let name = (cov_5ijtfroyd().s[234]++, child.newName);
	    cov_5ijtfroyd().s[235]++;
	    if (typeof name === 'undefined') {
	      cov_5ijtfroyd().b[77][0]++;
	      cov_5ijtfroyd().s[236]++;
	      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);
	    } else {
	      cov_5ijtfroyd().b[77][1]++;
	    }
	    cov_5ijtfroyd().s[237]++;
	    if (delta[name] !== child.result) {
	      cov_5ijtfroyd().b[78][0]++;
	      cov_5ijtfroyd().s[238]++;
	      delta[name] = child.result;
	    } else {
	      cov_5ijtfroyd().b[78][1]++;
	    }
	  }
	  cov_5ijtfroyd().s[239]++;
	  context.setResult(delta).exit();
	}
	cov_5ijtfroyd().s[240]++;
	collectChildrenReverseFilter.filterName = 'arraysCollectChildren';
	function cov_132fncsbmf() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/dates.js";
	  var hash = "723f26ad134a397874b74629fb63183ad8f3552f";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/dates.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 1,
	          column: 26
	        },
	        end: {
	          line: 16,
	          column: 1
	        }
	      },
	      "1": {
	        start: {
	          line: 2,
	          column: 2
	        },
	        end: {
	          line: 15,
	          column: 3
	        }
	      },
	      "2": {
	        start: {
	          line: 3,
	          column: 4
	        },
	        end: {
	          line: 11,
	          column: 5
	        }
	      },
	      "3": {
	        start: {
	          line: 4,
	          column: 6
	        },
	        end: {
	          line: 8,
	          column: 7
	        }
	      },
	      "4": {
	        start: {
	          line: 5,
	          column: 8
	        },
	        end: {
	          line: 5,
	          column: 57
	        }
	      },
	      "5": {
	        start: {
	          line: 7,
	          column: 8
	        },
	        end: {
	          line: 7,
	          column: 37
	        }
	      },
	      "6": {
	        start: {
	          line: 10,
	          column: 6
	        },
	        end: {
	          line: 10,
	          column: 55
	        }
	      },
	      "7": {
	        start: {
	          line: 12,
	          column: 4
	        },
	        end: {
	          line: 12,
	          column: 19
	        }
	      },
	      "8": {
	        start: {
	          line: 13,
	          column: 9
	        },
	        end: {
	          line: 15,
	          column: 3
	        }
	      },
	      "9": {
	        start: {
	          line: 14,
	          column: 4
	        },
	        end: {
	          line: 14,
	          column: 60
	        }
	      },
	      "10": {
	        start: {
	          line: 17,
	          column: 0
	        },
	        end: {
	          line: 17,
	          column: 32
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "datesDiffFilter",
	        decl: {
	          start: {
	            line: 1,
	            column: 35
	          },
	          end: {
	            line: 1,
	            column: 50
	          }
	        },
	        loc: {
	          start: {
	            line: 1,
	            column: 60
	          },
	          end: {
	            line: 16,
	            column: 1
	          }
	        },
	        line: 1
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 2,
	            column: 2
	          },
	          end: {
	            line: 15,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 2,
	            column: 2
	          },
	          end: {
	            line: 15,
	            column: 3
	          }
	        }, {
	          start: {
	            line: 13,
	            column: 9
	          },
	          end: {
	            line: 15,
	            column: 3
	          }
	        }],
	        line: 2
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 3,
	            column: 4
	          },
	          end: {
	            line: 11,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 3,
	            column: 4
	          },
	          end: {
	            line: 11,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 9,
	            column: 11
	          },
	          end: {
	            line: 11,
	            column: 5
	          }
	        }],
	        line: 3
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 4,
	            column: 6
	          },
	          end: {
	            line: 8,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 4,
	            column: 6
	          },
	          end: {
	            line: 8,
	            column: 7
	          }
	        }, {
	          start: {
	            line: 6,
	            column: 13
	          },
	          end: {
	            line: 8,
	            column: 7
	          }
	        }],
	        line: 4
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 13,
	            column: 9
	          },
	          end: {
	            line: 15,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 13,
	            column: 9
	          },
	          end: {
	            line: 15,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 13
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0
	    },
	    f: {
	      "0": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/dates.js"],
	      sourcesContent: ["export const diffFilter = function datesDiffFilter(context) {\n  if (context.left instanceof Date) {\n    if (context.right instanceof Date) {\n      if (context.left.getTime() !== context.right.getTime()) {\n        context.setResult([context.left, context.right]);\n      } else {\n        context.setResult(undefined);\n      }\n    } else {\n      context.setResult([context.left, context.right]);\n    }\n    context.exit();\n  } else if (context.right instanceof Date) {\n    context.setResult([context.left, context.right]).exit();\n  }\n};\ndiffFilter.filterName = 'dates';\n"],
	      names: ["diffFilter", "datesDiffFilter", "context", "left", "Date", "right", "getTime", "setResult", "undefined", "exit", "filterName"],
	      mappings: "AAAA,OAAO,MAAMA,UAAU,GAAG,SAASC,eAAeA,CAACC,OAAO,EAAE;EAC1D,IAAIA,OAAO,CAACC,IAAI,YAAYC,IAAI,EAAE;IAChC,IAAIF,OAAO,CAACG,KAAK,YAAYD,IAAI,EAAE;MACjC,IAAIF,OAAO,CAACC,IAAI,CAACG,OAAO,CAAC,CAAC,KAAKJ,OAAO,CAACG,KAAK,CAACC,OAAO,CAAC,CAAC,EAAE;QACtDJ,OAAO,CAACK,SAAS,CAAC,CAACL,OAAO,CAACC,IAAI,EAAED,OAAO,CAACG,KAAK,CAAC,CAAC;MAClD,CAAC,MAAM;QACLH,OAAO,CAACK,SAAS,CAACC,SAAS,CAAC;MAC9B;IACF,CAAC,MAAM;MACLN,OAAO,CAACK,SAAS,CAAC,CAACL,OAAO,CAACC,IAAI,EAAED,OAAO,CAACG,KAAK,CAAC,CAAC;IAClD;IACAH,OAAO,CAACO,IAAI,CAAC,CAAC;EAChB,CAAC,MAAM,IAAIP,OAAO,CAACG,KAAK,YAAYD,IAAI,EAAE;IACxCF,OAAO,CAACK,SAAS,CAAC,CAACL,OAAO,CAACC,IAAI,EAAED,OAAO,CAACG,KAAK,CAAC,CAAC,CAACI,IAAI,CAAC,CAAC;EACzD;AACF,CAAC;AACDT,UAAU,CAACU,UAAU,GAAG,OAAO",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "723f26ad134a397874b74629fb63183ad8f3552f"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_132fncsbmf = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_132fncsbmf();
	cov_132fncsbmf().s[0]++;
	const diffFilter$1 = function datesDiffFilter(context) {
	  cov_132fncsbmf().f[0]++;
	  cov_132fncsbmf().s[1]++;
	  if (context.left instanceof Date) {
	    cov_132fncsbmf().b[0][0]++;
	    cov_132fncsbmf().s[2]++;
	    if (context.right instanceof Date) {
	      cov_132fncsbmf().b[1][0]++;
	      cov_132fncsbmf().s[3]++;
	      if (context.left.getTime() !== context.right.getTime()) {
	        cov_132fncsbmf().b[2][0]++;
	        cov_132fncsbmf().s[4]++;
	        context.setResult([context.left, context.right]);
	      } else {
	        cov_132fncsbmf().b[2][1]++;
	        cov_132fncsbmf().s[5]++;
	        context.setResult(undefined);
	      }
	    } else {
	      cov_132fncsbmf().b[1][1]++;
	      cov_132fncsbmf().s[6]++;
	      context.setResult([context.left, context.right]);
	    }
	    cov_132fncsbmf().s[7]++;
	    context.exit();
	  } else {
	    cov_132fncsbmf().b[0][1]++;
	    cov_132fncsbmf().s[8]++;
	    if (context.right instanceof Date) {
	      cov_132fncsbmf().b[3][0]++;
	      cov_132fncsbmf().s[9]++;
	      context.setResult([context.left, context.right]).exit();
	    } else {
	      cov_132fncsbmf().b[3][1]++;
	    }
	  }
	};
	cov_132fncsbmf().s[10]++;
	diffFilter$1.filterName = 'dates';
	function cov_1podi6ndkj() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/texts.js";
	  var hash = "64059feb1e98bf1a0ed66b2edf7e32d2efe70159";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/texts.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 3,
	          column: 18
	        },
	        end: {
	          line: 3,
	          column: 19
	        }
	      },
	      "1": {
	        start: {
	          line: 4,
	          column: 27
	        },
	        end: {
	          line: 4,
	          column: 29
	        }
	      },
	      "2": {
	        start: {
	          line: 5,
	          column: 22
	        },
	        end: {
	          line: 5,
	          column: 26
	        }
	      },
	      "3": {
	        start: {
	          line: 6,
	          column: 26
	        },
	        end: {
	          line: 49,
	          column: 1
	        }
	      },
	      "4": {
	        start: {
	          line: 9,
	          column: 2
	        },
	        end: {
	          line: 47,
	          column: 3
	        }
	      },
	      "5": {
	        start: {
	          line: 12,
	          column: 4
	        },
	        end: {
	          line: 21,
	          column: 5
	        }
	      },
	      "6": {
	        start: {
	          line: 14,
	          column: 6
	        },
	        end: {
	          line: 14,
	          column: 123
	        }
	      },
	      "7": {
	        start: {
	          line: 15,
	          column: 11
	        },
	        end: {
	          line: 21,
	          column: 5
	        }
	      },
	      "8": {
	        start: {
	          line: 16,
	          column: 6
	        },
	        end: {
	          line: 20,
	          column: 7
	        }
	      },
	      "9": {
	        start: {
	          line: 17,
	          column: 8
	        },
	        end: {
	          line: 17,
	          column: 36
	        }
	      },
	      "10": {
	        start: {
	          line: 19,
	          column: 8
	        },
	        end: {
	          line: 19,
	          column: 24
	        }
	      },
	      "11": {
	        start: {
	          line: 23,
	          column: 4
	        },
	        end: {
	          line: 31,
	          column: 5
	        }
	      },
	      "12": {
	        start: {
	          line: 24,
	          column: 6
	        },
	        end: {
	          line: 26,
	          column: 7
	        }
	      },
	      "13": {
	        start: {
	          line: 25,
	          column: 8
	        },
	        end: {
	          line: 25,
	          column: 20
	        }
	      },
	      "14": {
	        start: {
	          line: 27,
	          column: 20
	        },
	        end: {
	          line: 27,
	          column: 72
	        }
	      },
	      "15": {
	        start: {
	          line: 29,
	          column: 6
	        },
	        end: {
	          line: 29,
	          column: 46
	        }
	      },
	      "16": {
	        start: {
	          line: 30,
	          column: 6
	        },
	        end: {
	          line: 30,
	          column: 18
	        }
	      },
	      "17": {
	        start: {
	          line: 32,
	          column: 4
	        },
	        end: {
	          line: 46,
	          column: 6
	        }
	      },
	      "18": {
	        start: {
	          line: 34,
	          column: 8
	        },
	        end: {
	          line: 34,
	          column: 70
	        }
	      },
	      "19": {
	        start: {
	          line: 37,
	          column: 24
	        },
	        end: {
	          line: 37,
	          column: 82
	        }
	      },
	      "20": {
	        start: {
	          line: 38,
	          column: 8
	        },
	        end: {
	          line: 43,
	          column: 9
	        }
	      },
	      "21": {
	        start: {
	          line: 38,
	          column: 21
	        },
	        end: {
	          line: 38,
	          column: 22
	        }
	      },
	      "22": {
	        start: {
	          line: 39,
	          column: 10
	        },
	        end: {
	          line: 42,
	          column: 11
	        }
	      },
	      "23": {
	        start: {
	          line: 40,
	          column: 26
	        },
	        end: {
	          line: 40,
	          column: 56
	        }
	      },
	      "24": {
	        start: {
	          line: 41,
	          column: 12
	        },
	        end: {
	          line: 41,
	          column: 41
	        }
	      },
	      "25": {
	        start: {
	          line: 44,
	          column: 8
	        },
	        end: {
	          line: 44,
	          column: 26
	        }
	      },
	      "26": {
	        start: {
	          line: 48,
	          column: 2
	        },
	        end: {
	          line: 48,
	          column: 25
	        }
	      },
	      "27": {
	        start: {
	          line: 50,
	          column: 26
	        },
	        end: {
	          line: 69,
	          column: 1
	        }
	      },
	      "28": {
	        start: {
	          line: 51,
	          column: 2
	        },
	        end: {
	          line: 53,
	          column: 3
	        }
	      },
	      "29": {
	        start: {
	          line: 52,
	          column: 4
	        },
	        end: {
	          line: 52,
	          column: 11
	        }
	      },
	      "30": {
	        start: {
	          line: 54,
	          column: 20
	        },
	        end: {
	          line: 54,
	          column: 123
	        }
	      },
	      "31": {
	        start: {
	          line: 55,
	          column: 2
	        },
	        end: {
	          line: 58,
	          column: 3
	        }
	      },
	      "32": {
	        start: {
	          line: 56,
	          column: 4
	        },
	        end: {
	          line: 56,
	          column: 60
	        }
	      },
	      "33": {
	        start: {
	          line: 57,
	          column: 4
	        },
	        end: {
	          line: 57,
	          column: 11
	        }
	      },
	      "34": {
	        start: {
	          line: 60,
	          column: 25
	        },
	        end: {
	          line: 60,
	          column: 44
	        }
	      },
	      "35": {
	        start: {
	          line: 61,
	          column: 2
	        },
	        end: {
	          line: 66,
	          column: 3
	        }
	      },
	      "36": {
	        start: {
	          line: 64,
	          column: 4
	        },
	        end: {
	          line: 64,
	          column: 60
	        }
	      },
	      "37": {
	        start: {
	          line: 65,
	          column: 4
	        },
	        end: {
	          line: 65,
	          column: 11
	        }
	      },
	      "38": {
	        start: {
	          line: 67,
	          column: 15
	        },
	        end: {
	          line: 67,
	          column: 34
	        }
	      },
	      "39": {
	        start: {
	          line: 68,
	          column: 2
	        },
	        end: {
	          line: 68,
	          column: 78
	        }
	      },
	      "40": {
	        start: {
	          line: 70,
	          column: 0
	        },
	        end: {
	          line: 70,
	          column: 32
	        }
	      },
	      "41": {
	        start: {
	          line: 71,
	          column: 27
	        },
	        end: {
	          line: 82,
	          column: 1
	        }
	      },
	      "42": {
	        start: {
	          line: 72,
	          column: 2
	        },
	        end: {
	          line: 74,
	          column: 3
	        }
	      },
	      "43": {
	        start: {
	          line: 73,
	          column: 4
	        },
	        end: {
	          line: 73,
	          column: 11
	        }
	      },
	      "44": {
	        start: {
	          line: 75,
	          column: 2
	        },
	        end: {
	          line: 77,
	          column: 3
	        }
	      },
	      "45": {
	        start: {
	          line: 76,
	          column: 4
	        },
	        end: {
	          line: 76,
	          column: 11
	        }
	      },
	      "46": {
	        start: {
	          line: 80,
	          column: 16
	        },
	        end: {
	          line: 80,
	          column: 45
	        }
	      },
	      "47": {
	        start: {
	          line: 81,
	          column: 2
	        },
	        end: {
	          line: 81,
	          column: 66
	        }
	      },
	      "48": {
	        start: {
	          line: 83,
	          column: 0
	        },
	        end: {
	          line: 83,
	          column: 33
	        }
	      },
	      "49": {
	        start: {
	          line: 84,
	          column: 25
	        },
	        end: {
	          line: 115,
	          column: 1
	        }
	      },
	      "50": {
	        start: {
	          line: 89,
	          column: 15
	        },
	        end: {
	          line: 89,
	          column: 19
	        }
	      },
	      "51": {
	        start: {
	          line: 90,
	          column: 22
	        },
	        end: {
	          line: 90,
	          column: 61
	        }
	      },
	      "52": {
	        start: {
	          line: 92,
	          column: 16
	        },
	        end: {
	          line: 92,
	          column: 33
	        }
	      },
	      "53": {
	        start: {
	          line: 93,
	          column: 2
	        },
	        end: {
	          line: 113,
	          column: 3
	        }
	      },
	      "54": {
	        start: {
	          line: 94,
	          column: 4
	        },
	        end: {
	          line: 94,
	          column: 20
	        }
	      },
	      "55": {
	        start: {
	          line: 95,
	          column: 22
	        },
	        end: {
	          line: 95,
	          column: 38
	        }
	      },
	      "56": {
	        start: {
	          line: 96,
	          column: 4
	        },
	        end: {
	          line: 112,
	          column: 5
	        }
	      },
	      "57": {
	        start: {
	          line: 97,
	          column: 6
	        },
	        end: {
	          line: 97,
	          column: 38
	        }
	      },
	      "58": {
	        start: {
	          line: 98,
	          column: 6
	        },
	        end: {
	          line: 98,
	          column: 21
	        }
	      },
	      "59": {
	        start: {
	          line: 101,
	          column: 6
	        },
	        end: {
	          line: 101,
	          column: 108
	        }
	      },
	      "60": {
	        start: {
	          line: 102,
	          column: 11
	        },
	        end: {
	          line: 112,
	          column: 5
	        }
	      },
	      "61": {
	        start: {
	          line: 103,
	          column: 6
	        },
	        end: {
	          line: 103,
	          column: 41
	        }
	      },
	      "62": {
	        start: {
	          line: 104,
	          column: 6
	        },
	        end: {
	          line: 109,
	          column: 7
	        }
	      },
	      "63": {
	        start: {
	          line: 106,
	          column: 8
	        },
	        end: {
	          line: 106,
	          column: 27
	        }
	      },
	      "64": {
	        start: {
	          line: 107,
	          column: 8
	        },
	        end: {
	          line: 107,
	          column: 32
	        }
	      },
	      "65": {
	        start: {
	          line: 108,
	          column: 8
	        },
	        end: {
	          line: 108,
	          column: 31
	        }
	      },
	      "66": {
	        start: {
	          line: 110,
	          column: 11
	        },
	        end: {
	          line: 112,
	          column: 5
	        }
	      },
	      "67": {
	        start: {
	          line: 111,
	          column: 6
	        },
	        end: {
	          line: 111,
	          column: 41
	        }
	      },
	      "68": {
	        start: {
	          line: 114,
	          column: 2
	        },
	        end: {
	          line: 114,
	          column: 26
	        }
	      },
	      "69": {
	        start: {
	          line: 116,
	          column: 29
	        },
	        end: {
	          line: 126,
	          column: 1
	        }
	      },
	      "70": {
	        start: {
	          line: 117,
	          column: 2
	        },
	        end: {
	          line: 119,
	          column: 3
	        }
	      },
	      "71": {
	        start: {
	          line: 118,
	          column: 4
	        },
	        end: {
	          line: 118,
	          column: 11
	        }
	      },
	      "72": {
	        start: {
	          line: 120,
	          column: 2
	        },
	        end: {
	          line: 122,
	          column: 3
	        }
	      },
	      "73": {
	        start: {
	          line: 121,
	          column: 4
	        },
	        end: {
	          line: 121,
	          column: 11
	        }
	      },
	      "74": {
	        start: {
	          line: 125,
	          column: 2
	        },
	        end: {
	          line: 125,
	          column: 79
	        }
	      },
	      "75": {
	        start: {
	          line: 127,
	          column: 0
	        },
	        end: {
	          line: 127,
	          column: 35
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 6,
	            column: 26
	          },
	          end: {
	            line: 6,
	            column: 27
	          }
	        },
	        loc: {
	          start: {
	            line: 6,
	            column: 46
	          },
	          end: {
	            line: 49,
	            column: 1
	          }
	        },
	        line: 6
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 33,
	            column: 12
	          },
	          end: {
	            line: 33,
	            column: 13
	          }
	        },
	        loc: {
	          start: {
	            line: 33,
	            column: 34
	          },
	          end: {
	            line: 35,
	            column: 7
	          }
	        },
	        line: 33
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 36,
	            column: 13
	          },
	          end: {
	            line: 36,
	            column: 14
	          }
	        },
	        loc: {
	          start: {
	            line: 36,
	            column: 36
	          },
	          end: {
	            line: 45,
	            column: 7
	          }
	        },
	        line: 36
	      },
	      "3": {
	        name: "textsDiffFilter",
	        decl: {
	          start: {
	            line: 50,
	            column: 35
	          },
	          end: {
	            line: 50,
	            column: 50
	          }
	        },
	        loc: {
	          start: {
	            line: 50,
	            column: 60
	          },
	          end: {
	            line: 69,
	            column: 1
	          }
	        },
	        line: 50
	      },
	      "4": {
	        name: "textsPatchFilter",
	        decl: {
	          start: {
	            line: 71,
	            column: 36
	          },
	          end: {
	            line: 71,
	            column: 52
	          }
	        },
	        loc: {
	          start: {
	            line: 71,
	            column: 62
	          },
	          end: {
	            line: 82,
	            column: 1
	          }
	        },
	        line: 71
	      },
	      "5": {
	        name: "(anonymous_5)",
	        decl: {
	          start: {
	            line: 84,
	            column: 25
	          },
	          end: {
	            line: 84,
	            column: 26
	          }
	        },
	        loc: {
	          start: {
	            line: 84,
	            column: 42
	          },
	          end: {
	            line: 115,
	            column: 1
	          }
	        },
	        line: 84
	      },
	      "6": {
	        name: "textsReverseFilter",
	        decl: {
	          start: {
	            line: 116,
	            column: 38
	          },
	          end: {
	            line: 116,
	            column: 56
	          }
	        },
	        loc: {
	          start: {
	            line: 116,
	            column: 66
	          },
	          end: {
	            line: 126,
	            column: 1
	          }
	        },
	        line: 116
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 9,
	            column: 2
	          },
	          end: {
	            line: 47,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 9,
	            column: 2
	          },
	          end: {
	            line: 47,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 9
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 12,
	            column: 4
	          },
	          end: {
	            line: 21,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 12,
	            column: 4
	          },
	          end: {
	            line: 21,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 15,
	            column: 11
	          },
	          end: {
	            line: 21,
	            column: 5
	          }
	        }],
	        line: 12
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 14,
	            column: 17
	          },
	          end: {
	            line: 14,
	            column: 122
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 14,
	            column: 58
	          },
	          end: {
	            line: 14,
	            column: 80
	          }
	        }, {
	          start: {
	            line: 14,
	            column: 83
	          },
	          end: {
	            line: 14,
	            column: 122
	          }
	        }],
	        line: 14
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 15,
	            column: 11
	          },
	          end: {
	            line: 21,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 15,
	            column: 11
	          },
	          end: {
	            line: 21,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 15
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 17,
	            column: 19
	          },
	          end: {
	            line: 17,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 17,
	            column: 19
	          },
	          end: {
	            line: 17,
	            column: 22
	          }
	        }, {
	          start: {
	            line: 17,
	            column: 26
	          },
	          end: {
	            line: 17,
	            column: 35
	          }
	        }],
	        line: 17
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 23,
	            column: 4
	          },
	          end: {
	            line: 31,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 23,
	            column: 4
	          },
	          end: {
	            line: 31,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 23
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 24,
	            column: 6
	          },
	          end: {
	            line: 26,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 24,
	            column: 6
	          },
	          end: {
	            line: 26,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 24
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 39,
	            column: 10
	          },
	          end: {
	            line: 42,
	            column: 11
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 39,
	            column: 10
	          },
	          end: {
	            line: 42,
	            column: 11
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 39
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 51,
	            column: 2
	          },
	          end: {
	            line: 53,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 51,
	            column: 2
	          },
	          end: {
	            line: 53,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 51
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 54,
	            column: 20
	          },
	          end: {
	            line: 54,
	            column: 123
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 54,
	            column: 20
	          },
	          end: {
	            line: 54,
	            column: 35
	          }
	        }, {
	          start: {
	            line: 54,
	            column: 39
	          },
	          end: {
	            line: 54,
	            column: 63
	          }
	        }, {
	          start: {
	            line: 54,
	            column: 67
	          },
	          end: {
	            line: 54,
	            column: 101
	          }
	        }, {
	          start: {
	            line: 54,
	            column: 105
	          },
	          end: {
	            line: 54,
	            column: 123
	          }
	        }],
	        line: 54
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 55,
	            column: 2
	          },
	          end: {
	            line: 58,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 55,
	            column: 2
	          },
	          end: {
	            line: 58,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 55
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 55,
	            column: 6
	          },
	          end: {
	            line: 55,
	            column: 73
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 55,
	            column: 6
	          },
	          end: {
	            line: 55,
	            column: 37
	          }
	        }, {
	          start: {
	            line: 55,
	            column: 41
	          },
	          end: {
	            line: 55,
	            column: 73
	          }
	        }],
	        line: 55
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 61,
	            column: 2
	          },
	          end: {
	            line: 66,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 61,
	            column: 2
	          },
	          end: {
	            line: 66,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 61
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 72,
	            column: 2
	          },
	          end: {
	            line: 74,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 72,
	            column: 2
	          },
	          end: {
	            line: 74,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 72
	      },
	      "14": {
	        loc: {
	          start: {
	            line: 75,
	            column: 2
	          },
	          end: {
	            line: 77,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 75,
	            column: 2
	          },
	          end: {
	            line: 77,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 75
	      },
	      "15": {
	        loc: {
	          start: {
	            line: 96,
	            column: 4
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 96,
	            column: 4
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 102,
	            column: 11
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        }],
	        line: 96
	      },
	      "16": {
	        loc: {
	          start: {
	            line: 102,
	            column: 11
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 102,
	            column: 11
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 110,
	            column: 11
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        }],
	        line: 102
	      },
	      "17": {
	        loc: {
	          start: {
	            line: 104,
	            column: 6
	          },
	          end: {
	            line: 109,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 104,
	            column: 6
	          },
	          end: {
	            line: 109,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 104
	      },
	      "18": {
	        loc: {
	          start: {
	            line: 110,
	            column: 11
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 110,
	            column: 11
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 110
	      },
	      "19": {
	        loc: {
	          start: {
	            line: 117,
	            column: 2
	          },
	          end: {
	            line: 119,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 117,
	            column: 2
	          },
	          end: {
	            line: 119,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 117
	      },
	      "20": {
	        loc: {
	          start: {
	            line: 120,
	            column: 2
	          },
	          end: {
	            line: 122,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 120,
	            column: 2
	          },
	          end: {
	            line: 122,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 120
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0,
	      "72": 0,
	      "73": 0,
	      "74": 0,
	      "75": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0],
	      "8": [0, 0],
	      "9": [0, 0, 0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0],
	      "13": [0, 0],
	      "14": [0, 0],
	      "15": [0, 0],
	      "16": [0, 0],
	      "17": [0, 0],
	      "18": [0, 0],
	      "19": [0, 0],
	      "20": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/filters/texts.js"],
	      sourcesContent: ["/* global diff_match_patch */\nimport dmp from 'diff-match-patch';\n\nconst TEXT_DIFF = 2;\nconst DEFAULT_MIN_LENGTH = 60;\nlet cachedDiffPatch = null;\n\nconst getDiffMatchPatch = function(required) {\n  /* jshint camelcase: false */\n\n  if (!cachedDiffPatch) {\n    let instance;\n    /* eslint-disable camelcase, new-cap */\n    if (typeof diff_match_patch !== 'undefined') {\n      // already loaded, probably a browser\n      instance =\n        typeof diff_match_patch === 'function'\n          ? new diff_match_patch()\n          : new diff_match_patch.diff_match_patch();\n    } else if (dmp) {\n      try {\n        instance = dmp && new dmp();\n      } catch (err) {\n        instance = null;\n      }\n    }\n    /* eslint-enable camelcase, new-cap */\n    if (!instance) {\n      if (!required) {\n        return null;\n      }\n      const error = new Error('text diff_match_patch library not found');\n      // eslint-disable-next-line camelcase\n      error.diff_match_patch_not_found = true;\n      throw error;\n    }\n    cachedDiffPatch = {\n      diff: function(txt1, txt2) {\n        return instance.patch_toText(instance.patch_make(txt1, txt2));\n      },\n      patch: function(txt1, patch) {\n        const results = instance.patch_apply(\n          instance.patch_fromText(patch),\n          txt1,\n        );\n        for (let i = 0; i < results[1].length; i++) {\n          if (!results[1][i]) {\n            const error = new Error('text patch failed');\n            error.textPatchFailed = true;\n          }\n        }\n        return results[0];\n      },\n    };\n  }\n  return cachedDiffPatch;\n};\n\nexport const diffFilter = function textsDiffFilter(context) {\n  if (context.leftType !== 'string') {\n    return;\n  }\n  const minLength =\n    (context.options &&\n      context.options.textDiff &&\n      context.options.textDiff.minLength) ||\n    DEFAULT_MIN_LENGTH;\n  if (context.left.length < minLength || context.right.length < minLength) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  // large text, try to use a text-diff algorithm\n  const diffMatchPatch = getDiffMatchPatch();\n  if (!diffMatchPatch) {\n    // diff-match-patch library not available,\n    // fallback to regular string replace\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  const diff = diffMatchPatch.diff;\n  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();\n};\ndiffFilter.filterName = 'texts';\n\nexport const patchFilter = function textsPatchFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-patch algorithm\n  const patch = getDiffMatchPatch(true).patch;\n  context.setResult(patch(context.left, context.delta[0])).exit();\n};\npatchFilter.filterName = 'texts';\n\nconst textDeltaReverse = function(delta) {\n  let i;\n  let l;\n  let line;\n  let lineTmp;\n  let header = null;\n  const headerRegex = /^@@ +-(\\d+),(\\d+) +\\+(\\d+),(\\d+) +@@$/;\n  let lineHeader;\n  const lines = delta.split('\\n');\n  for (i = 0, l = lines.length; i < l; i++) {\n    line = lines[i];\n    const lineStart = line.slice(0, 1);\n    if (lineStart === '@') {\n      header = headerRegex.exec(line);\n      lineHeader = i;\n\n      // fix header\n      lines[lineHeader] =\n        '@@ -' +\n        header[3] +\n        ',' +\n        header[4] +\n        ' +' +\n        header[1] +\n        ',' +\n        header[2] +\n        ' @@';\n    } else if (lineStart === '+') {\n      lines[i] = '-' + lines[i].slice(1);\n      if (lines[i - 1].slice(0, 1) === '+') {\n        // swap lines to keep default order (-+)\n        lineTmp = lines[i];\n        lines[i] = lines[i - 1];\n        lines[i - 1] = lineTmp;\n      }\n    } else if (lineStart === '-') {\n      lines[i] = '+' + lines[i].slice(1);\n    }\n  }\n  return lines.join('\\n');\n};\n\nexport const reverseFilter = function textsReverseFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-diff algorithm\n  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();\n};\nreverseFilter.filterName = 'texts';\n"],
	      names: ["dmp", "TEXT_DIFF", "DEFAULT_MIN_LENGTH", "cachedDiffPatch", "getDiffMatchPatch", "required", "instance", "diff_match_patch", "err", "error", "Error", "diff_match_patch_not_found", "diff", "txt1", "txt2", "patch_toText", "patch_make", "patch", "results", "patch_apply", "patch_fromText", "i", "length", "textPatchFailed", "diffFilter", "textsDiffFilter", "context", "leftType", "minLength", "options", "textDiff", "left", "right", "setResult", "exit", "diffMatchPatch", "filterName", "patchFilter", "textsPatchFilter", "nested", "delta", "textDeltaReverse", "l", "line", "lineTmp", "header", "headerRegex", "lineHeader", "lines", "split", "lineStart", "slice", "exec", "join", "reverseFilter", "textsReverseFilter"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "64059feb1e98bf1a0ed66b2edf7e32d2efe70159"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_1podi6ndkj = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_1podi6ndkj();
	const TEXT_DIFF = (cov_1podi6ndkj().s[0]++, 2);
	const DEFAULT_MIN_LENGTH = (cov_1podi6ndkj().s[1]++, 60);
	let cachedDiffPatch = (cov_1podi6ndkj().s[2]++, null);
	cov_1podi6ndkj().s[3]++;
	const getDiffMatchPatch = function (required) {
	  cov_1podi6ndkj().f[0]++;
	  cov_1podi6ndkj().s[4]++; /* jshint camelcase: false */
	  if (!cachedDiffPatch) {
	    cov_1podi6ndkj().b[0][0]++;
	    let instance; /* eslint-disable camelcase, new-cap */
	    cov_1podi6ndkj().s[5]++;
	    if (typeof diff_match_patch !== 'undefined') {
	      cov_1podi6ndkj().b[1][0]++;
	      cov_1podi6ndkj().s[6]++; // already loaded, probably a browser
	      instance = typeof diff_match_patch === 'function' ? (cov_1podi6ndkj().b[2][0]++, new diff_match_patch()) : (cov_1podi6ndkj().b[2][1]++, new diff_match_patch.diff_match_patch());
	    } else {
	      cov_1podi6ndkj().b[1][1]++;
	      cov_1podi6ndkj().s[7]++;
	      if (dmp) {
	        cov_1podi6ndkj().b[3][0]++;
	        cov_1podi6ndkj().s[8]++;
	        try {
	          cov_1podi6ndkj().s[9]++;
	          instance = (cov_1podi6ndkj().b[4][0]++, dmp) && (cov_1podi6ndkj().b[4][1]++, new dmp());
	        } catch (err) {
	          cov_1podi6ndkj().s[10]++;
	          instance = null;
	        }
	      } else {
	        cov_1podi6ndkj().b[3][1]++;
	      }
	    } /* eslint-enable camelcase, new-cap */
	    cov_1podi6ndkj().s[11]++;
	    if (!instance) {
	      cov_1podi6ndkj().b[5][0]++;
	      cov_1podi6ndkj().s[12]++;
	      if (!required) {
	        cov_1podi6ndkj().b[6][0]++;
	        cov_1podi6ndkj().s[13]++;
	        return null;
	      } else {
	        cov_1podi6ndkj().b[6][1]++;
	      }
	      const error = (cov_1podi6ndkj().s[14]++, new Error('text diff_match_patch library not found')); // eslint-disable-next-line camelcase
	      cov_1podi6ndkj().s[15]++;
	      error.diff_match_patch_not_found = true;
	      cov_1podi6ndkj().s[16]++;
	      throw error;
	    } else {
	      cov_1podi6ndkj().b[5][1]++;
	    }
	    cov_1podi6ndkj().s[17]++;
	    cachedDiffPatch = {
	      diff: function (txt1, txt2) {
	        cov_1podi6ndkj().f[1]++;
	        cov_1podi6ndkj().s[18]++;
	        return instance.patch_toText(instance.patch_make(txt1, txt2));
	      },
	      patch: function (txt1, patch) {
	        cov_1podi6ndkj().f[2]++;
	        const results = (cov_1podi6ndkj().s[19]++, instance.patch_apply(instance.patch_fromText(patch), txt1));
	        cov_1podi6ndkj().s[20]++;
	        for (let i = (cov_1podi6ndkj().s[21]++, 0); i < results[1].length; i++) {
	          cov_1podi6ndkj().s[22]++;
	          if (!results[1][i]) {
	            cov_1podi6ndkj().b[7][0]++;
	            const error = (cov_1podi6ndkj().s[23]++, new Error('text patch failed'));
	            cov_1podi6ndkj().s[24]++;
	            error.textPatchFailed = true;
	          } else {
	            cov_1podi6ndkj().b[7][1]++;
	          }
	        }
	        cov_1podi6ndkj().s[25]++;
	        return results[0];
	      }
	    };
	  } else {
	    cov_1podi6ndkj().b[0][1]++;
	  }
	  cov_1podi6ndkj().s[26]++;
	  return cachedDiffPatch;
	};
	cov_1podi6ndkj().s[27]++;
	const diffFilter = function textsDiffFilter(context) {
	  cov_1podi6ndkj().f[3]++;
	  cov_1podi6ndkj().s[28]++;
	  if (context.leftType !== 'string') {
	    cov_1podi6ndkj().b[8][0]++;
	    cov_1podi6ndkj().s[29]++;
	    return;
	  } else {
	    cov_1podi6ndkj().b[8][1]++;
	  }
	  const minLength = (cov_1podi6ndkj().s[30]++, (cov_1podi6ndkj().b[9][0]++, context.options) && (cov_1podi6ndkj().b[9][1]++, context.options.textDiff) && (cov_1podi6ndkj().b[9][2]++, context.options.textDiff.minLength) || (cov_1podi6ndkj().b[9][3]++, DEFAULT_MIN_LENGTH));
	  cov_1podi6ndkj().s[31]++;
	  if ((cov_1podi6ndkj().b[11][0]++, context.left.length < minLength) || (cov_1podi6ndkj().b[11][1]++, context.right.length < minLength)) {
	    cov_1podi6ndkj().b[10][0]++;
	    cov_1podi6ndkj().s[32]++;
	    context.setResult([context.left, context.right]).exit();
	    cov_1podi6ndkj().s[33]++;
	    return;
	  } else {
	    cov_1podi6ndkj().b[10][1]++;
	  } // large text, try to use a text-diff algorithm
	  const diffMatchPatch = (cov_1podi6ndkj().s[34]++, getDiffMatchPatch());
	  cov_1podi6ndkj().s[35]++;
	  if (!diffMatchPatch) {
	    cov_1podi6ndkj().b[12][0]++;
	    cov_1podi6ndkj().s[36]++; // diff-match-patch library not available,
	    // fallback to regular string replace
	    context.setResult([context.left, context.right]).exit();
	    cov_1podi6ndkj().s[37]++;
	    return;
	  } else {
	    cov_1podi6ndkj().b[12][1]++;
	  }
	  const diff = (cov_1podi6ndkj().s[38]++, diffMatchPatch.diff);
	  cov_1podi6ndkj().s[39]++;
	  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();
	};
	cov_1podi6ndkj().s[40]++;
	diffFilter.filterName = 'texts';
	cov_1podi6ndkj().s[41]++;
	const patchFilter = function textsPatchFilter(context) {
	  cov_1podi6ndkj().f[4]++;
	  cov_1podi6ndkj().s[42]++;
	  if (context.nested) {
	    cov_1podi6ndkj().b[13][0]++;
	    cov_1podi6ndkj().s[43]++;
	    return;
	  } else {
	    cov_1podi6ndkj().b[13][1]++;
	  }
	  cov_1podi6ndkj().s[44]++;
	  if (context.delta[2] !== TEXT_DIFF) {
	    cov_1podi6ndkj().b[14][0]++;
	    cov_1podi6ndkj().s[45]++;
	    return;
	  } else {
	    cov_1podi6ndkj().b[14][1]++;
	  } // text-diff, use a text-patch algorithm
	  const patch = (cov_1podi6ndkj().s[46]++, getDiffMatchPatch(true).patch);
	  cov_1podi6ndkj().s[47]++;
	  context.setResult(patch(context.left, context.delta[0])).exit();
	};
	cov_1podi6ndkj().s[48]++;
	patchFilter.filterName = 'texts';
	cov_1podi6ndkj().s[49]++;
	const textDeltaReverse = function (delta) {
	  cov_1podi6ndkj().f[5]++;
	  let i;
	  let l;
	  let line;
	  let lineTmp;
	  let header = (cov_1podi6ndkj().s[50]++, null);
	  const headerRegex = (cov_1podi6ndkj().s[51]++, /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/);
	  let lineHeader;
	  const lines = (cov_1podi6ndkj().s[52]++, delta.split('\n'));
	  cov_1podi6ndkj().s[53]++;
	  for (i = 0, l = lines.length; i < l; i++) {
	    cov_1podi6ndkj().s[54]++;
	    line = lines[i];
	    const lineStart = (cov_1podi6ndkj().s[55]++, line.slice(0, 1));
	    cov_1podi6ndkj().s[56]++;
	    if (lineStart === '@') {
	      cov_1podi6ndkj().b[15][0]++;
	      cov_1podi6ndkj().s[57]++;
	      header = headerRegex.exec(line);
	      cov_1podi6ndkj().s[58]++;
	      lineHeader = i; // fix header
	      cov_1podi6ndkj().s[59]++;
	      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';
	    } else {
	      cov_1podi6ndkj().b[15][1]++;
	      cov_1podi6ndkj().s[60]++;
	      if (lineStart === '+') {
	        cov_1podi6ndkj().b[16][0]++;
	        cov_1podi6ndkj().s[61]++;
	        lines[i] = '-' + lines[i].slice(1);
	        cov_1podi6ndkj().s[62]++;
	        if (lines[i - 1].slice(0, 1) === '+') {
	          cov_1podi6ndkj().b[17][0]++;
	          cov_1podi6ndkj().s[63]++; // swap lines to keep default order (-+)
	          lineTmp = lines[i];
	          cov_1podi6ndkj().s[64]++;
	          lines[i] = lines[i - 1];
	          cov_1podi6ndkj().s[65]++;
	          lines[i - 1] = lineTmp;
	        } else {
	          cov_1podi6ndkj().b[17][1]++;
	        }
	      } else {
	        cov_1podi6ndkj().b[16][1]++;
	        cov_1podi6ndkj().s[66]++;
	        if (lineStart === '-') {
	          cov_1podi6ndkj().b[18][0]++;
	          cov_1podi6ndkj().s[67]++;
	          lines[i] = '+' + lines[i].slice(1);
	        } else {
	          cov_1podi6ndkj().b[18][1]++;
	        }
	      }
	    }
	  }
	  cov_1podi6ndkj().s[68]++;
	  return lines.join('\n');
	};
	cov_1podi6ndkj().s[69]++;
	const reverseFilter = function textsReverseFilter(context) {
	  cov_1podi6ndkj().f[6]++;
	  cov_1podi6ndkj().s[70]++;
	  if (context.nested) {
	    cov_1podi6ndkj().b[19][0]++;
	    cov_1podi6ndkj().s[71]++;
	    return;
	  } else {
	    cov_1podi6ndkj().b[19][1]++;
	  }
	  cov_1podi6ndkj().s[72]++;
	  if (context.delta[2] !== TEXT_DIFF) {
	    cov_1podi6ndkj().b[20][0]++;
	    cov_1podi6ndkj().s[73]++;
	    return;
	  } else {
	    cov_1podi6ndkj().b[20][1]++;
	  } // text-diff, use a text-diff algorithm
	  cov_1podi6ndkj().s[74]++;
	  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();
	};
	cov_1podi6ndkj().s[75]++;
	reverseFilter.filterName = 'texts';
	function cov_1f1v849a6e() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/diffpatcher.js";
	  var hash = "d0463d0ee316470c6022dd741d57abb4ca5a0a2e";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/diffpatcher.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 14,
	          column: 4
	        },
	        end: {
	          line: 14,
	          column: 44
	        }
	      },
	      "1": {
	        start: {
	          line: 15,
	          column: 4
	        },
	        end: {
	          line: 15,
	          column: 203
	        }
	      },
	      "2": {
	        start: {
	          line: 16,
	          column: 4
	        },
	        end: {
	          line: 16,
	          column: 219
	        }
	      },
	      "3": {
	        start: {
	          line: 17,
	          column: 4
	        },
	        end: {
	          line: 17,
	          column: 233
	        }
	      },
	      "4": {
	        start: {
	          line: 20,
	          column: 4
	        },
	        end: {
	          line: 20,
	          column: 48
	        }
	      },
	      "5": {
	        start: {
	          line: 23,
	          column: 4
	        },
	        end: {
	          line: 23,
	          column: 64
	        }
	      },
	      "6": {
	        start: {
	          line: 26,
	          column: 4
	        },
	        end: {
	          line: 26,
	          column: 65
	        }
	      },
	      "7": {
	        start: {
	          line: 29,
	          column: 4
	        },
	        end: {
	          line: 29,
	          column: 61
	        }
	      },
	      "8": {
	        start: {
	          line: 32,
	          column: 4
	        },
	        end: {
	          line: 32,
	          column: 50
	        }
	      },
	      "9": {
	        start: {
	          line: 35,
	          column: 4
	        },
	        end: {
	          line: 35,
	          column: 24
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 13,
	            column: 2
	          },
	          end: {
	            line: 13,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 13,
	            column: 23
	          },
	          end: {
	            line: 18,
	            column: 3
	          }
	        },
	        line: 13
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 19,
	            column: 2
	          },
	          end: {
	            line: 19,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 19,
	            column: 12
	          },
	          end: {
	            line: 21,
	            column: 3
	          }
	        },
	        line: 19
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 22,
	            column: 2
	          },
	          end: {
	            line: 22,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 22,
	            column: 20
	          },
	          end: {
	            line: 24,
	            column: 3
	          }
	        },
	        line: 22
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 25,
	            column: 2
	          },
	          end: {
	            line: 25,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 25,
	            column: 21
	          },
	          end: {
	            line: 27,
	            column: 3
	          }
	        },
	        line: 25
	      },
	      "4": {
	        name: "(anonymous_4)",
	        decl: {
	          start: {
	            line: 28,
	            column: 2
	          },
	          end: {
	            line: 28,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 28,
	            column: 17
	          },
	          end: {
	            line: 30,
	            column: 3
	          }
	        },
	        line: 28
	      },
	      "5": {
	        name: "(anonymous_5)",
	        decl: {
	          start: {
	            line: 31,
	            column: 2
	          },
	          end: {
	            line: 31,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 31,
	            column: 24
	          },
	          end: {
	            line: 33,
	            column: 3
	          }
	        },
	        line: 31
	      },
	      "6": {
	        name: "(anonymous_6)",
	        decl: {
	          start: {
	            line: 34,
	            column: 2
	          },
	          end: {
	            line: 34,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 34,
	            column: 15
	          },
	          end: {
	            line: 36,
	            column: 3
	          }
	        },
	        line: 34
	      }
	    },
	    branchMap: {},
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0
	    },
	    b: {},
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/diffpatcher.js"],
	      sourcesContent: ["import Processor from './processor';\nimport Pipe from './pipe';\nimport DiffContext from './contexts/diff';\nimport PatchContext from './contexts/patch';\nimport ReverseContext from './contexts/reverse';\nimport clone from './clone';\n\nimport * as trivial from './filters/trivial';\nimport * as nested from './filters/nested';\nimport * as arrays from './filters/arrays';\nimport * as dates from './filters/dates';\nimport * as texts from './filters/texts';\n\nclass DiffPatcher {\n  constructor(options) {\n    this.processor = new Processor(options);\n    this.processor.pipe(\n      new Pipe('diff')\n        .append(\n          nested.collectChildrenDiffFilter,\n          trivial.diffFilter,\n          dates.diffFilter,\n          texts.diffFilter,\n          nested.objectsDiffFilter,\n          arrays.diffFilter,\n        )\n        .shouldHaveResult(),\n    );\n    this.processor.pipe(\n      new Pipe('patch')\n        .append(\n          nested.collectChildrenPatchFilter,\n          arrays.collectChildrenPatchFilter,\n          trivial.patchFilter,\n          texts.patchFilter,\n          nested.patchFilter,\n          arrays.patchFilter,\n        )\n        .shouldHaveResult(),\n    );\n    this.processor.pipe(\n      new Pipe('reverse')\n        .append(\n          nested.collectChildrenReverseFilter,\n          arrays.collectChildrenReverseFilter,\n          trivial.reverseFilter,\n          texts.reverseFilter,\n          nested.reverseFilter,\n          arrays.reverseFilter,\n        )\n        .shouldHaveResult(),\n    );\n  }\n\n  options(...args) {\n    return this.processor.options(...args);\n  }\n\n  diff(left, right) {\n    return this.processor.process(new DiffContext(left, right));\n  }\n\n  patch(left, delta) {\n    return this.processor.process(new PatchContext(left, delta));\n  }\n\n  reverse(delta) {\n    return this.processor.process(new ReverseContext(delta));\n  }\n\n  unpatch(right, delta) {\n    return this.patch(right, this.reverse(delta));\n  }\n\n  clone(value) {\n    return clone(value);\n  }\n}\n\nexport default DiffPatcher;\n"],
	      names: ["Processor", "Pipe", "DiffContext", "PatchContext", "ReverseContext", "clone", "trivial", "nested", "arrays", "dates", "texts", "DiffPatcher", "constructor", "options", "processor", "pipe", "append", "collectChildrenDiffFilter", "diffFilter", "objectsDiffFilter", "shouldHaveResult", "collectChildrenPatchFilter", "patchFilter", "collectChildrenReverseFilter", "reverseFilter", "arguments", "diff", "left", "right", "process", "patch", "delta", "reverse", "unpatch", "value"],
	      mappings: "AAAA,OAAOA,SAAS,MAAM,aAAa;AACnC,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,WAAW,MAAM,iBAAiB;AACzC,OAAOC,YAAY,MAAM,kBAAkB;AAC3C,OAAOC,cAAc,MAAM,oBAAoB;AAC/C,OAAOC,KAAK,MAAM,SAAS;AAE3B,OAAO,KAAKC,OAAO,MAAM,mBAAmB;AAC5C,OAAO,KAAKC,MAAM,MAAM,kBAAkB;AAC1C,OAAO,KAAKC,MAAM,MAAM,kBAAkB;AAC1C,OAAO,KAAKC,KAAK,MAAM,iBAAiB;AACxC,OAAO,KAAKC,KAAK,MAAM,iBAAiB;AAExC,MAAMC,WAAW,CAAC;EAChBC,WAAWA,CAACC,OAAO,EAAE;IACnB,IAAI,CAACC,SAAS,GAAG,IAAId,SAAS,CAACa,OAAO,CAAC;IACvC,IAAI,CAACC,SAAS,CAACC,IAAI,CACjB,IAAId,IAAI,CAAC,MAAM,CAAC,CACbe,MAAM,CACLT,MAAM,CAACU,yBAAyB,EAChCX,OAAO,CAACY,UAAU,EAClBT,KAAK,CAACS,UAAU,EAChBR,KAAK,CAACQ,UAAU,EAChBX,MAAM,CAACY,iBAAiB,EACxBX,MAAM,CAACU,UACT,CAAC,CACAE,gBAAgB,CAAC,CACtB,CAAC;IACD,IAAI,CAACN,SAAS,CAACC,IAAI,CACjB,IAAId,IAAI,CAAC,OAAO,CAAC,CACde,MAAM,CACLT,MAAM,CAACc,0BAA0B,EACjCb,MAAM,CAACa,0BAA0B,EACjCf,OAAO,CAACgB,WAAW,EACnBZ,KAAK,CAACY,WAAW,EACjBf,MAAM,CAACe,WAAW,EAClBd,MAAM,CAACc,WACT,CAAC,CACAF,gBAAgB,CAAC,CACtB,CAAC;IACD,IAAI,CAACN,SAAS,CAACC,IAAI,CACjB,IAAId,IAAI,CAAC,SAAS,CAAC,CAChBe,MAAM,CACLT,MAAM,CAACgB,4BAA4B,EACnCf,MAAM,CAACe,4BAA4B,EACnCjB,OAAO,CAACkB,aAAa,EACrBd,KAAK,CAACc,aAAa,EACnBjB,MAAM,CAACiB,aAAa,EACpBhB,MAAM,CAACgB,aACT,CAAC,CACAJ,gBAAgB,CAAC,CACtB,CAAC;EACH;EAEAP,OAAOA,CAAA,EAAU;IACf,OAAO,IAAI,CAACC,SAAS,CAACD,OAAO,CAAC,GAAAY,SAAO,CAAC;EACxC;EAEAC,IAAIA,CAACC,IAAI,EAAEC,KAAK,EAAE;IAChB,OAAO,IAAI,CAACd,SAAS,CAACe,OAAO,CAAC,IAAI3B,WAAW,CAACyB,IAAI,EAAEC,KAAK,CAAC,CAAC;EAC7D;EAEAE,KAAKA,CAACH,IAAI,EAAEI,KAAK,EAAE;IACjB,OAAO,IAAI,CAACjB,SAAS,CAACe,OAAO,CAAC,IAAI1B,YAAY,CAACwB,IAAI,EAAEI,KAAK,CAAC,CAAC;EAC9D;EAEAC,OAAOA,CAACD,KAAK,EAAE;IACb,OAAO,IAAI,CAACjB,SAAS,CAACe,OAAO,CAAC,IAAIzB,cAAc,CAAC2B,KAAK,CAAC,CAAC;EAC1D;EAEAE,OAAOA,CAACL,KAAK,EAAEG,KAAK,EAAE;IACpB,OAAO,IAAI,CAACD,KAAK,CAACF,KAAK,EAAE,IAAI,CAACI,OAAO,CAACD,KAAK,CAAC,CAAC;EAC/C;EAEA1B,KAAKA,CAAC6B,KAAK,EAAE;IACX,OAAO7B,KAAK,CAAC6B,KAAK,CAAC;EACrB;AACF;AAEA,eAAevB,WAAW",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "d0463d0ee316470c6022dd741d57abb4ca5a0a2e"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_1f1v849a6e = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_1f1v849a6e();
	let DiffPatcher$1 = class DiffPatcher {
	  constructor(options) {
	    cov_1f1v849a6e().f[0]++;
	    cov_1f1v849a6e().s[0]++;
	    this.processor = new Processor(options);
	    cov_1f1v849a6e().s[1]++;
	    this.processor.pipe(new Pipe('diff').append(collectChildrenDiffFilter, diffFilter$3, diffFilter$1, diffFilter, objectsDiffFilter, diffFilter$2).shouldHaveResult());
	    cov_1f1v849a6e().s[2]++;
	    this.processor.pipe(new Pipe('patch').append(collectChildrenPatchFilter$1, collectChildrenPatchFilter, patchFilter$3, patchFilter, patchFilter$2, patchFilter$1).shouldHaveResult());
	    cov_1f1v849a6e().s[3]++;
	    this.processor.pipe(new Pipe('reverse').append(collectChildrenReverseFilter$1, collectChildrenReverseFilter, reverseFilter$3, reverseFilter, reverseFilter$2, reverseFilter$1).shouldHaveResult());
	  }
	  options() {
	    cov_1f1v849a6e().f[1]++;
	    cov_1f1v849a6e().s[4]++;
	    return this.processor.options(...arguments);
	  }
	  diff(left, right) {
	    cov_1f1v849a6e().f[2]++;
	    cov_1f1v849a6e().s[5]++;
	    return this.processor.process(new DiffContext(left, right));
	  }
	  patch(left, delta) {
	    cov_1f1v849a6e().f[3]++;
	    cov_1f1v849a6e().s[6]++;
	    return this.processor.process(new PatchContext(left, delta));
	  }
	  reverse(delta) {
	    cov_1f1v849a6e().f[4]++;
	    cov_1f1v849a6e().s[7]++;
	    return this.processor.process(new ReverseContext(delta));
	  }
	  unpatch(right, delta) {
	    cov_1f1v849a6e().f[5]++;
	    cov_1f1v849a6e().s[8]++;
	    return this.patch(right, this.reverse(delta));
	  }
	  clone(value) {
	    cov_1f1v849a6e().f[6]++;
	    cov_1f1v849a6e().s[9]++;
	    return clone$1(value);
	  }
	};
	function cov_2b92ly2zmp() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/base.js";
	  var hash = "b448007f15dac7840c820a5b6aac43426b9aee98";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/base.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 1,
	          column: 16
	        },
	        end: {
	          line: 1,
	          column: 93
	        }
	      },
	      "1": {
	        start: {
	          line: 1,
	          column: 75
	        },
	        end: {
	          line: 1,
	          column: 93
	        }
	      },
	      "2": {
	        start: {
	          line: 2,
	          column: 22
	        },
	        end: {
	          line: 10,
	          column: 1
	        }
	      },
	      "3": {
	        start: {
	          line: 2,
	          column: 65
	        },
	        end: {
	          line: 2,
	          column: 81
	        }
	      },
	      "4": {
	        start: {
	          line: 3,
	          column: 16
	        },
	        end: {
	          line: 3,
	          column: 18
	        }
	      },
	      "5": {
	        start: {
	          line: 4,
	          column: 2
	        },
	        end: {
	          line: 8,
	          column: 3
	        }
	      },
	      "6": {
	        start: {
	          line: 5,
	          column: 4
	        },
	        end: {
	          line: 7,
	          column: 5
	        }
	      },
	      "7": {
	        start: {
	          line: 6,
	          column: 6
	        },
	        end: {
	          line: 6,
	          column: 27
	        }
	      },
	      "8": {
	        start: {
	          line: 9,
	          column: 2
	        },
	        end: {
	          line: 9,
	          column: 15
	        }
	      },
	      "9": {
	        start: {
	          line: 11,
	          column: 23
	        },
	        end: {
	          line: 16,
	          column: 1
	        }
	      },
	      "10": {
	        start: {
	          line: 12,
	          column: 2
	        },
	        end: {
	          line: 14,
	          column: 3
	        }
	      },
	      "11": {
	        start: {
	          line: 13,
	          column: 4
	        },
	        end: {
	          line: 13,
	          column: 24
	        }
	      },
	      "12": {
	        start: {
	          line: 15,
	          column: 2
	        },
	        end: {
	          line: 15,
	          column: 13
	        }
	      },
	      "13": {
	        start: {
	          line: 17,
	          column: 29
	        },
	        end: {
	          line: 27,
	          column: 1
	        }
	      },
	      "14": {
	        start: {
	          line: 18,
	          column: 2
	        },
	        end: {
	          line: 26,
	          column: 3
	        }
	      },
	      "15": {
	        start: {
	          line: 19,
	          column: 4
	        },
	        end: {
	          line: 19,
	          column: 14
	        }
	      },
	      "16": {
	        start: {
	          line: 21,
	          column: 4
	        },
	        end: {
	          line: 25,
	          column: 5
	        }
	      },
	      "17": {
	        start: {
	          line: 22,
	          column: 6
	        },
	        end: {
	          line: 22,
	          column: 40
	        }
	      },
	      "18": {
	        start: {
	          line: 24,
	          column: 6
	        },
	        end: {
	          line: 24,
	          column: 37
	        }
	      },
	      "19": {
	        start: {
	          line: 28,
	          column: 25
	        },
	        end: {
	          line: 28,
	          column: 96
	        }
	      },
	      "20": {
	        start: {
	          line: 28,
	          column: 41
	        },
	        end: {
	          line: 28,
	          column: 96
	        }
	      },
	      "21": {
	        start: {
	          line: 31,
	          column: 20
	        },
	        end: {
	          line: 31,
	          column: 22
	        }
	      },
	      "22": {
	        start: {
	          line: 32,
	          column: 4
	        },
	        end: {
	          line: 32,
	          column: 33
	        }
	      },
	      "23": {
	        start: {
	          line: 33,
	          column: 4
	        },
	        end: {
	          line: 33,
	          column: 39
	        }
	      },
	      "24": {
	        start: {
	          line: 34,
	          column: 4
	        },
	        end: {
	          line: 34,
	          column: 34
	        }
	      },
	      "25": {
	        start: {
	          line: 37,
	          column: 4
	        },
	        end: {
	          line: 37,
	          column: 24
	        }
	      },
	      "26": {
	        start: {
	          line: 38,
	          column: 4
	        },
	        end: {
	          line: 40,
	          column: 6
	        }
	      },
	      "27": {
	        start: {
	          line: 39,
	          column: 6
	        },
	        end: {
	          line: 39,
	          column: 37
	        }
	      },
	      "28": {
	        start: {
	          line: 43,
	          column: 4
	        },
	        end: {
	          line: 43,
	          column: 62
	        }
	      },
	      "29": {
	        start: {
	          line: 46,
	          column: 4
	        },
	        end: {
	          line: 46,
	          column: 26
	        }
	      },
	      "30": {
	        start: {
	          line: 51,
	          column: 8
	        },
	        end: {
	          line: 51,
	          column: 12
	        }
	      },
	      "31": {
	        start: {
	          line: 52,
	          column: 4
	        },
	        end: {
	          line: 54,
	          column: 5
	        }
	      },
	      "32": {
	        start: {
	          line: 53,
	          column: 6
	        },
	        end: {
	          line: 53,
	          column: 29
	        }
	      },
	      "33": {
	        start: {
	          line: 57,
	          column: 30
	        },
	        end: {
	          line: 57,
	          column: 48
	        }
	      },
	      "34": {
	        start: {
	          line: 58,
	          column: 22
	        },
	        end: {
	          line: 58,
	          column: 64
	        }
	      },
	      "35": {
	        start: {
	          line: 59,
	          column: 4
	        },
	        end: {
	          line: 61,
	          column: 5
	        }
	      },
	      "36": {
	        start: {
	          line: 60,
	          column: 6
	        },
	        end: {
	          line: 60,
	          column: 23
	        }
	      },
	      "37": {
	        start: {
	          line: 62,
	          column: 17
	        },
	        end: {
	          line: 62,
	          column: 52
	        }
	      },
	      "38": {
	        start: {
	          line: 63,
	          column: 21
	        },
	        end: {
	          line: 63,
	          column: 81
	        }
	      },
	      "39": {
	        start: {
	          line: 64,
	          column: 4
	        },
	        end: {
	          line: 68,
	          column: 5
	        }
	      },
	      "40": {
	        start: {
	          line: 65,
	          column: 6
	        },
	        end: {
	          line: 65,
	          column: 68
	        }
	      },
	      "41": {
	        start: {
	          line: 67,
	          column: 6
	        },
	        end: {
	          line: 67,
	          column: 46
	        }
	      },
	      "42": {
	        start: {
	          line: 70,
	          column: 4
	        },
	        end: {
	          line: 78,
	          column: 5
	        }
	      },
	      "43": {
	        start: {
	          line: 71,
	          column: 6
	        },
	        end: {
	          line: 71,
	          column: 92
	        }
	      },
	      "44": {
	        start: {
	          line: 72,
	          column: 6
	        },
	        end: {
	          line: 72,
	          column: 84
	        }
	      },
	      "45": {
	        start: {
	          line: 74,
	          column: 6
	        },
	        end: {
	          line: 74,
	          column: 97
	        }
	      },
	      "46": {
	        start: {
	          line: 75,
	          column: 6
	        },
	        end: {
	          line: 77,
	          column: 7
	        }
	      },
	      "47": {
	        start: {
	          line: 76,
	          column: 8
	        },
	        end: {
	          line: 76,
	          column: 33
	        }
	      },
	      "48": {
	        start: {
	          line: 79,
	          column: 4
	        },
	        end: {
	          line: 83,
	          column: 5
	        }
	      },
	      "49": {
	        start: {
	          line: 80,
	          column: 6
	        },
	        end: {
	          line: 80,
	          column: 66
	        }
	      },
	      "50": {
	        start: {
	          line: 82,
	          column: 6
	        },
	        end: {
	          line: 82,
	          column: 44
	        }
	      },
	      "51": {
	        start: {
	          line: 86,
	          column: 17
	        },
	        end: {
	          line: 86,
	          column: 21
	        }
	      },
	      "52": {
	        start: {
	          line: 87,
	          column: 4
	        },
	        end: {
	          line: 89,
	          column: 7
	        }
	      },
	      "53": {
	        start: {
	          line: 88,
	          column: 6
	        },
	        end: {
	          line: 88,
	          column: 107
	        }
	      },
	      "54": {
	        start: {
	          line: 92,
	          column: 17
	        },
	        end: {
	          line: 92,
	          column: 37
	        }
	      },
	      "55": {
	        start: {
	          line: 93,
	          column: 22
	        },
	        end: {
	          line: 93,
	          column: 38
	        }
	      },
	      "56": {
	        start: {
	          line: 94,
	          column: 29
	        },
	        end: {
	          line: 94,
	          column: 31
	        }
	      },
	      "57": {
	        start: {
	          line: 96,
	          column: 4
	        },
	        end: {
	          line: 104,
	          column: 5
	        }
	      },
	      "58": {
	        start: {
	          line: 97,
	          column: 6
	        },
	        end: {
	          line: 103,
	          column: 7
	        }
	      },
	      "59": {
	        start: {
	          line: 98,
	          column: 8
	        },
	        end: {
	          line: 102,
	          column: 9
	        }
	      },
	      "60": {
	        start: {
	          line: 99,
	          column: 10
	        },
	        end: {
	          line: 101,
	          column: 11
	        }
	      },
	      "61": {
	        start: {
	          line: 100,
	          column: 12
	        },
	        end: {
	          line: 100,
	          column: 28
	        }
	      },
	      "62": {
	        start: {
	          line: 106,
	          column: 4
	        },
	        end: {
	          line: 121,
	          column: 5
	        }
	      },
	      "63": {
	        start: {
	          line: 107,
	          column: 6
	        },
	        end: {
	          line: 120,
	          column: 7
	        }
	      },
	      "64": {
	        start: {
	          line: 108,
	          column: 22
	        },
	        end: {
	          line: 108,
	          column: 33
	        }
	      },
	      "65": {
	        start: {
	          line: 109,
	          column: 8
	        },
	        end: {
	          line: 119,
	          column: 9
	        }
	      },
	      "66": {
	        start: {
	          line: 110,
	          column: 10
	        },
	        end: {
	          line: 113,
	          column: 12
	        }
	      },
	      "67": {
	        start: {
	          line: 114,
	          column: 10
	        },
	        end: {
	          line: 118,
	          column: 11
	        }
	      },
	      "68": {
	        start: {
	          line: 115,
	          column: 12
	        },
	        end: {
	          line: 117,
	          column: 13
	        }
	      },
	      "69": {
	        start: {
	          line: 116,
	          column: 14
	        },
	        end: {
	          line: 116,
	          column: 45
	        }
	      },
	      "70": {
	        start: {
	          line: 122,
	          column: 4
	        },
	        end: {
	          line: 126,
	          column: 5
	        }
	      },
	      "71": {
	        start: {
	          line: 123,
	          column: 6
	        },
	        end: {
	          line: 123,
	          column: 34
	        }
	      },
	      "72": {
	        start: {
	          line: 125,
	          column: 6
	        },
	        end: {
	          line: 125,
	          column: 18
	        }
	      },
	      "73": {
	        start: {
	          line: 127,
	          column: 4
	        },
	        end: {
	          line: 135,
	          column: 5
	        }
	      },
	      "74": {
	        start: {
	          line: 127,
	          column: 21
	        },
	        end: {
	          line: 127,
	          column: 22
	        }
	      },
	      "75": {
	        start: {
	          line: 127,
	          column: 33
	        },
	        end: {
	          line: 127,
	          column: 44
	        }
	      },
	      "76": {
	        start: {
	          line: 128,
	          column: 18
	        },
	        end: {
	          line: 128,
	          column: 29
	        }
	      },
	      "77": {
	        start: {
	          line: 129,
	          column: 6
	        },
	        end: {
	          line: 131,
	          column: 7
	        }
	      },
	      "78": {
	        start: {
	          line: 130,
	          column: 8
	        },
	        end: {
	          line: 130,
	          column: 17
	        }
	      },
	      "79": {
	        start: {
	          line: 132,
	          column: 22
	        },
	        end: {
	          line: 132,
	          column: 105
	        }
	      },
	      "80": {
	        start: {
	          line: 133,
	          column: 21
	        },
	        end: {
	          line: 133,
	          column: 41
	        }
	      },
	      "81": {
	        start: {
	          line: 134,
	          column: 6
	        },
	        end: {
	          line: 134,
	          column: 58
	        }
	      },
	      "82": {
	        start: {
	          line: 138,
	          column: 4
	        },
	        end: {
	          line: 143,
	          column: 5
	        }
	      },
	      "83": {
	        start: {
	          line: 139,
	          column: 6
	        },
	        end: {
	          line: 141,
	          column: 7
	        }
	      },
	      "84": {
	        start: {
	          line: 140,
	          column: 8
	        },
	        end: {
	          line: 140,
	          column: 33
	        }
	      },
	      "85": {
	        start: {
	          line: 142,
	          column: 6
	        },
	        end: {
	          line: 142,
	          column: 25
	        }
	      },
	      "86": {
	        start: {
	          line: 144,
	          column: 4
	        },
	        end: {
	          line: 162,
	          column: 5
	        }
	      },
	      "87": {
	        start: {
	          line: 145,
	          column: 6
	        },
	        end: {
	          line: 147,
	          column: 7
	        }
	      },
	      "88": {
	        start: {
	          line: 146,
	          column: 8
	        },
	        end: {
	          line: 146,
	          column: 23
	        }
	      },
	      "89": {
	        start: {
	          line: 148,
	          column: 6
	        },
	        end: {
	          line: 150,
	          column: 7
	        }
	      },
	      "90": {
	        start: {
	          line: 149,
	          column: 8
	        },
	        end: {
	          line: 149,
	          column: 26
	        }
	      },
	      "91": {
	        start: {
	          line: 151,
	          column: 6
	        },
	        end: {
	          line: 153,
	          column: 7
	        }
	      },
	      "92": {
	        start: {
	          line: 152,
	          column: 8
	        },
	        end: {
	          line: 152,
	          column: 25
	        }
	      },
	      "93": {
	        start: {
	          line: 154,
	          column: 6
	        },
	        end: {
	          line: 156,
	          column: 7
	        }
	      },
	      "94": {
	        start: {
	          line: 155,
	          column: 8
	        },
	        end: {
	          line: 155,
	          column: 26
	        }
	      },
	      "95": {
	        start: {
	          line: 157,
	          column: 6
	        },
	        end: {
	          line: 159,
	          column: 7
	        }
	      },
	      "96": {
	        start: {
	          line: 158,
	          column: 8
	        },
	        end: {
	          line: 158,
	          column: 23
	        }
	      },
	      "97": {
	        start: {
	          line: 160,
	          column: 11
	        },
	        end: {
	          line: 162,
	          column: 5
	        }
	      },
	      "98": {
	        start: {
	          line: 161,
	          column: 6
	        },
	        end: {
	          line: 161,
	          column: 20
	        }
	      },
	      "99": {
	        start: {
	          line: 163,
	          column: 4
	        },
	        end: {
	          line: 163,
	          column: 21
	        }
	      },
	      "100": {
	        start: {
	          line: 166,
	          column: 19
	        },
	        end: {
	          line: 166,
	          column: 21
	        }
	      },
	      "101": {
	        start: {
	          line: 167,
	          column: 18
	        },
	        end: {
	          line: 167,
	          column: 38
	        }
	      },
	      "102": {
	        start: {
	          line: 168,
	          column: 4
	        },
	        end: {
	          line: 196,
	          column: 5
	        }
	      },
	      "103": {
	        start: {
	          line: 168,
	          column: 17
	        },
	        end: {
	          line: 168,
	          column: 18
	        }
	      },
	      "104": {
	        start: {
	          line: 168,
	          column: 24
	        },
	        end: {
	          line: 168,
	          column: 36
	        }
	      },
	      "105": {
	        start: {
	          line: 169,
	          column: 19
	        },
	        end: {
	          line: 169,
	          column: 27
	        }
	      },
	      "106": {
	        start: {
	          line: 170,
	          column: 25
	        },
	        end: {
	          line: 172,
	          column: 7
	        }
	      },
	      "107": {
	        start: {
	          line: 173,
	          column: 23
	        },
	        end: {
	          line: 173,
	          column: 70
	        }
	      },
	      "108": {
	        start: {
	          line: 174,
	          column: 6
	        },
	        end: {
	          line: 177,
	          column: 8
	        }
	      },
	      "109": {
	        start: {
	          line: 178,
	          column: 21
	        },
	        end: {
	          line: 178,
	          column: 46
	        }
	      },
	      "110": {
	        start: {
	          line: 179,
	          column: 6
	        },
	        end: {
	          line: 194,
	          column: 7
	        }
	      },
	      "111": {
	        start: {
	          line: 179,
	          column: 28
	        },
	        end: {
	          line: 179,
	          column: 29
	        }
	      },
	      "112": {
	        start: {
	          line: 179,
	          column: 46
	        },
	        end: {
	          line: 179,
	          column: 59
	        }
	      },
	      "113": {
	        start: {
	          line: 180,
	          column: 22
	        },
	        end: {
	          line: 180,
	          column: 40
	        }
	      },
	      "114": {
	        start: {
	          line: 181,
	          column: 8
	        },
	        end: {
	          line: 183,
	          column: 9
	        }
	      },
	      "115": {
	        start: {
	          line: 182,
	          column: 10
	        },
	        end: {
	          line: 182,
	          column: 19
	        }
	      },
	      "116": {
	        start: {
	          line: 184,
	          column: 28
	        },
	        end: {
	          line: 186,
	          column: 9
	        }
	      },
	      "117": {
	        start: {
	          line: 187,
	          column: 8
	        },
	        end: {
	          line: 191,
	          column: 9
	        }
	      },
	      "118": {
	        start: {
	          line: 188,
	          column: 10
	        },
	        end: {
	          line: 188,
	          column: 37
	        }
	      },
	      "119": {
	        start: {
	          line: 189,
	          column: 15
	        },
	        end: {
	          line: 191,
	          column: 9
	        }
	      },
	      "120": {
	        start: {
	          line: 190,
	          column: 10
	        },
	        end: {
	          line: 190,
	          column: 39
	        }
	      },
	      "121": {
	        start: {
	          line: 192,
	          column: 8
	        },
	        end: {
	          line: 192,
	          column: 42
	        }
	      },
	      "122": {
	        start: {
	          line: 193,
	          column: 8
	        },
	        end: {
	          line: 193,
	          column: 44
	        }
	      },
	      "123": {
	        start: {
	          line: 195,
	          column: 6
	        },
	        end: {
	          line: 195,
	          column: 30
	        }
	      },
	      "124": {
	        start: {
	          line: 197,
	          column: 4
	        },
	        end: {
	          line: 197,
	          column: 18
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 1,
	            column: 70
	          },
	          end: {
	            line: 1,
	            column: 71
	          }
	        },
	        loc: {
	          start: {
	            line: 1,
	            column: 75
	          },
	          end: {
	            line: 1,
	            column: 93
	          }
	        },
	        line: 1
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 2,
	            column: 58
	          },
	          end: {
	            line: 2,
	            column: 59
	          }
	        },
	        loc: {
	          start: {
	            line: 2,
	            column: 65
	          },
	          end: {
	            line: 2,
	            column: 81
	          }
	        },
	        line: 2
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 2,
	            column: 84
	          },
	          end: {
	            line: 2,
	            column: 85
	          }
	        },
	        loc: {
	          start: {
	            line: 2,
	            column: 91
	          },
	          end: {
	            line: 10,
	            column: 1
	          }
	        },
	        line: 2
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 11,
	            column: 23
	          },
	          end: {
	            line: 11,
	            column: 24
	          }
	        },
	        loc: {
	          start: {
	            line: 11,
	            column: 30
	          },
	          end: {
	            line: 16,
	            column: 1
	          }
	        },
	        line: 11
	      },
	      "4": {
	        name: "(anonymous_4)",
	        decl: {
	          start: {
	            line: 17,
	            column: 29
	          },
	          end: {
	            line: 17,
	            column: 30
	          }
	        },
	        loc: {
	          start: {
	            line: 17,
	            column: 36
	          },
	          end: {
	            line: 27,
	            column: 1
	          }
	        },
	        line: 17
	      },
	      "5": {
	        name: "(anonymous_5)",
	        decl: {
	          start: {
	            line: 28,
	            column: 25
	          },
	          end: {
	            line: 28,
	            column: 26
	          }
	        },
	        loc: {
	          start: {
	            line: 28,
	            column: 41
	          },
	          end: {
	            line: 28,
	            column: 96
	          }
	        },
	        line: 28
	      },
	      "6": {
	        name: "(anonymous_6)",
	        decl: {
	          start: {
	            line: 30,
	            column: 2
	          },
	          end: {
	            line: 30,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 30,
	            column: 22
	          },
	          end: {
	            line: 35,
	            column: 3
	          }
	        },
	        line: 30
	      },
	      "7": {
	        name: "(anonymous_7)",
	        decl: {
	          start: {
	            line: 36,
	            column: 2
	          },
	          end: {
	            line: 36,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 36,
	            column: 26
	          },
	          end: {
	            line: 41,
	            column: 3
	          }
	        },
	        line: 36
	      },
	      "8": {
	        name: "(anonymous_8)",
	        decl: {
	          start: {
	            line: 38,
	            column: 18
	          },
	          end: {
	            line: 38,
	            column: 19
	          }
	        },
	        loc: {
	          start: {
	            line: 38,
	            column: 30
	          },
	          end: {
	            line: 40,
	            column: 5
	          }
	        },
	        line: 38
	      },
	      "9": {
	        name: "(anonymous_9)",
	        decl: {
	          start: {
	            line: 42,
	            column: 2
	          },
	          end: {
	            line: 42,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 42,
	            column: 45
	          },
	          end: {
	            line: 44,
	            column: 3
	          }
	        },
	        line: 42
	      },
	      "10": {
	        name: "(anonymous_10)",
	        decl: {
	          start: {
	            line: 45,
	            column: 2
	          },
	          end: {
	            line: 45,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 45,
	            column: 45
	          },
	          end: {
	            line: 47,
	            column: 3
	          }
	        },
	        line: 45
	      },
	      "11": {
	        name: "(anonymous_11)",
	        decl: {
	          start: {
	            line: 48,
	            column: 2
	          },
	          end: {
	            line: 48,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 48,
	            column: 17
	          },
	          end: {
	            line: 55,
	            column: 3
	          }
	        },
	        line: 48
	      },
	      "12": {
	        name: "(anonymous_12)",
	        decl: {
	          start: {
	            line: 56,
	            column: 2
	          },
	          end: {
	            line: 56,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 56,
	            column: 65
	          },
	          end: {
	            line: 84,
	            column: 3
	          }
	        },
	        line: 56
	      },
	      "13": {
	        name: "(anonymous_13)",
	        decl: {
	          start: {
	            line: 85,
	            column: 2
	          },
	          end: {
	            line: 85,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 85,
	            column: 44
	          },
	          end: {
	            line: 90,
	            column: 3
	          }
	        },
	        line: 85
	      },
	      "14": {
	        name: "(anonymous_14)",
	        decl: {
	          start: {
	            line: 87,
	            column: 38
	          },
	          end: {
	            line: 87,
	            column: 39
	          }
	        },
	        loc: {
	          start: {
	            line: 87,
	            column: 75
	          },
	          end: {
	            line: 89,
	            column: 5
	          }
	        },
	        line: 87
	      },
	      "15": {
	        name: "(anonymous_15)",
	        decl: {
	          start: {
	            line: 91,
	            column: 2
	          },
	          end: {
	            line: 91,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 91,
	            column: 35
	          },
	          end: {
	            line: 136,
	            column: 3
	          }
	        },
	        line: 91
	      },
	      "16": {
	        name: "(anonymous_16)",
	        decl: {
	          start: {
	            line: 137,
	            column: 2
	          },
	          end: {
	            line: 137,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 137,
	            column: 33
	          },
	          end: {
	            line: 164,
	            column: 3
	          }
	        },
	        line: 137
	      },
	      "17": {
	        name: "(anonymous_17)",
	        decl: {
	          start: {
	            line: 165,
	            column: 2
	          },
	          end: {
	            line: 165,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 165,
	            column: 23
	          },
	          end: {
	            line: 198,
	            column: 3
	          }
	        },
	        line: 165
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 1,
	            column: 16
	          },
	          end: {
	            line: 1,
	            column: 93
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 1,
	            column: 54
	          },
	          end: {
	            line: 1,
	            column: 67
	          }
	        }, {
	          start: {
	            line: 1,
	            column: 70
	          },
	          end: {
	            line: 1,
	            column: 93
	          }
	        }],
	        line: 1
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 2,
	            column: 22
	          },
	          end: {
	            line: 10,
	            column: 1
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 2,
	            column: 58
	          },
	          end: {
	            line: 2,
	            column: 81
	          }
	        }, {
	          start: {
	            line: 2,
	            column: 84
	          },
	          end: {
	            line: 10,
	            column: 1
	          }
	        }],
	        line: 2
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 5,
	            column: 4
	          },
	          end: {
	            line: 7,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 5,
	            column: 4
	          },
	          end: {
	            line: 7,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 5
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 12,
	            column: 2
	          },
	          end: {
	            line: 14,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 12,
	            column: 2
	          },
	          end: {
	            line: 14,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 12
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 18,
	            column: 2
	          },
	          end: {
	            line: 26,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 18,
	            column: 2
	          },
	          end: {
	            line: 26,
	            column: 3
	          }
	        }, {
	          start: {
	            line: 20,
	            column: 9
	          },
	          end: {
	            line: 26,
	            column: 3
	          }
	        }],
	        line: 18
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 21,
	            column: 4
	          },
	          end: {
	            line: 25,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 21,
	            column: 4
	          },
	          end: {
	            line: 25,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 23,
	            column: 11
	          },
	          end: {
	            line: 25,
	            column: 5
	          }
	        }],
	        line: 21
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 52,
	            column: 4
	          },
	          end: {
	            line: 54,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 52,
	            column: 4
	          },
	          end: {
	            line: 54,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 52
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 57,
	            column: 30
	          },
	          end: {
	            line: 57,
	            column: 48
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 57,
	            column: 30
	          },
	          end: {
	            line: 57,
	            column: 35
	          }
	        }, {
	          start: {
	            line: 57,
	            column: 39
	          },
	          end: {
	            line: 57,
	            column: 48
	          }
	        }],
	        line: 57
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 58,
	            column: 22
	          },
	          end: {
	            line: 58,
	            column: 64
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 58,
	            column: 42
	          },
	          end: {
	            line: 58,
	            column: 57
	          }
	        }, {
	          start: {
	            line: 58,
	            column: 60
	          },
	          end: {
	            line: 58,
	            column: 64
	          }
	        }],
	        line: 58
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 59,
	            column: 4
	          },
	          end: {
	            line: 61,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 59,
	            column: 4
	          },
	          end: {
	            line: 61,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 59
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 59,
	            column: 8
	          },
	          end: {
	            line: 59,
	            column: 66
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 59,
	            column: 8
	          },
	          end: {
	            line: 59,
	            column: 36
	          }
	        }, {
	          start: {
	            line: 59,
	            column: 40
	          },
	          end: {
	            line: 59,
	            column: 66
	          }
	        }],
	        line: 59
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 63,
	            column: 21
	          },
	          end: {
	            line: 63,
	            column: 81
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 63,
	            column: 39
	          },
	          end: {
	            line: 63,
	            column: 76
	          }
	        }, {
	          start: {
	            line: 63,
	            column: 79
	          },
	          end: {
	            line: 63,
	            column: 81
	          }
	        }],
	        line: 63
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 63,
	            column: 39
	          },
	          end: {
	            line: 63,
	            column: 76
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 63,
	            column: 58
	          },
	          end: {
	            line: 63,
	            column: 65
	          }
	        }, {
	          start: {
	            line: 63,
	            column: 68
	          },
	          end: {
	            line: 63,
	            column: 76
	          }
	        }],
	        line: 63
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 64,
	            column: 4
	          },
	          end: {
	            line: 68,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 64,
	            column: 4
	          },
	          end: {
	            line: 68,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 66,
	            column: 11
	          },
	          end: {
	            line: 68,
	            column: 5
	          }
	        }],
	        line: 64
	      },
	      "14": {
	        loc: {
	          start: {
	            line: 71,
	            column: 23
	          },
	          end: {
	            line: 71,
	            column: 91
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 71,
	            column: 23
	          },
	          end: {
	            line: 71,
	            column: 45
	          }
	        }, {
	          start: {
	            line: 71,
	            column: 49
	          },
	          end: {
	            line: 71,
	            column: 91
	          }
	        }],
	        line: 71
	      },
	      "15": {
	        loc: {
	          start: {
	            line: 75,
	            column: 6
	          },
	          end: {
	            line: 77,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 75,
	            column: 6
	          },
	          end: {
	            line: 77,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 75
	      },
	      "16": {
	        loc: {
	          start: {
	            line: 75,
	            column: 10
	          },
	          end: {
	            line: 75,
	            column: 57
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 75,
	            column: 10
	          },
	          end: {
	            line: 75,
	            column: 40
	          }
	        }, {
	          start: {
	            line: 75,
	            column: 44
	          },
	          end: {
	            line: 75,
	            column: 57
	          }
	        }],
	        line: 75
	      },
	      "17": {
	        loc: {
	          start: {
	            line: 79,
	            column: 4
	          },
	          end: {
	            line: 83,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 79,
	            column: 4
	          },
	          end: {
	            line: 83,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 81,
	            column: 11
	          },
	          end: {
	            line: 83,
	            column: 5
	          }
	        }],
	        line: 79
	      },
	      "18": {
	        loc: {
	          start: {
	            line: 88,
	            column: 40
	          },
	          end: {
	            line: 88,
	            column: 72
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 88,
	            column: 47
	          },
	          end: {
	            line: 88,
	            column: 60
	          }
	        }, {
	          start: {
	            line: 88,
	            column: 63
	          },
	          end: {
	            line: 88,
	            column: 72
	          }
	        }],
	        line: 88
	      },
	      "19": {
	        loc: {
	          start: {
	            line: 96,
	            column: 4
	          },
	          end: {
	            line: 104,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 96,
	            column: 4
	          },
	          end: {
	            line: 104,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 96
	      },
	      "20": {
	        loc: {
	          start: {
	            line: 98,
	            column: 8
	          },
	          end: {
	            line: 102,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 98,
	            column: 8
	          },
	          end: {
	            line: 102,
	            column: 9
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 98
	      },
	      "21": {
	        loc: {
	          start: {
	            line: 99,
	            column: 10
	          },
	          end: {
	            line: 101,
	            column: 11
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 99,
	            column: 10
	          },
	          end: {
	            line: 101,
	            column: 11
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 99
	      },
	      "22": {
	        loc: {
	          start: {
	            line: 99,
	            column: 14
	          },
	          end: {
	            line: 99,
	            column: 108
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 99,
	            column: 14
	          },
	          end: {
	            line: 99,
	            column: 48
	          }
	        }, {
	          start: {
	            line: 99,
	            column: 53
	          },
	          end: {
	            line: 99,
	            column: 63
	          }
	        }, {
	          start: {
	            line: 99,
	            column: 67
	          },
	          end: {
	            line: 99,
	            column: 107
	          }
	        }],
	        line: 99
	      },
	      "23": {
	        loc: {
	          start: {
	            line: 107,
	            column: 6
	          },
	          end: {
	            line: 120,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 107,
	            column: 6
	          },
	          end: {
	            line: 120,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 107
	      },
	      "24": {
	        loc: {
	          start: {
	            line: 109,
	            column: 8
	          },
	          end: {
	            line: 119,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 109,
	            column: 8
	          },
	          end: {
	            line: 119,
	            column: 9
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 109
	      },
	      "25": {
	        loc: {
	          start: {
	            line: 109,
	            column: 12
	          },
	          end: {
	            line: 109,
	            column: 44
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 109,
	            column: 12
	          },
	          end: {
	            line: 109,
	            column: 26
	          }
	        }, {
	          start: {
	            line: 109,
	            column: 30
	          },
	          end: {
	            line: 109,
	            column: 44
	          }
	        }],
	        line: 109
	      },
	      "26": {
	        loc: {
	          start: {
	            line: 112,
	            column: 19
	          },
	          end: {
	            line: 112,
	            column: 57
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 112,
	            column: 19
	          },
	          end: {
	            line: 112,
	            column: 23
	          }
	        }, {
	          start: {
	            line: 112,
	            column: 27
	          },
	          end: {
	            line: 112,
	            column: 57
	          }
	        }],
	        line: 112
	      },
	      "27": {
	        loc: {
	          start: {
	            line: 114,
	            column: 10
	          },
	          end: {
	            line: 118,
	            column: 11
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 114,
	            column: 10
	          },
	          end: {
	            line: 118,
	            column: 11
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 114
	      },
	      "28": {
	        loc: {
	          start: {
	            line: 115,
	            column: 12
	          },
	          end: {
	            line: 117,
	            column: 13
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 115,
	            column: 12
	          },
	          end: {
	            line: 117,
	            column: 13
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 115
	      },
	      "29": {
	        loc: {
	          start: {
	            line: 115,
	            column: 16
	          },
	          end: {
	            line: 115,
	            column: 85
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 115,
	            column: 16
	          },
	          end: {
	            line: 115,
	            column: 43
	          }
	        }, {
	          start: {
	            line: 115,
	            column: 47
	          },
	          end: {
	            line: 115,
	            column: 85
	          }
	        }],
	        line: 115
	      },
	      "30": {
	        loc: {
	          start: {
	            line: 122,
	            column: 4
	          },
	          end: {
	            line: 126,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 122,
	            column: 4
	          },
	          end: {
	            line: 126,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 124,
	            column: 11
	          },
	          end: {
	            line: 126,
	            column: 5
	          }
	        }],
	        line: 122
	      },
	      "31": {
	        loc: {
	          start: {
	            line: 129,
	            column: 6
	          },
	          end: {
	            line: 131,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 129,
	            column: 6
	          },
	          end: {
	            line: 131,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 129
	      },
	      "32": {
	        loc: {
	          start: {
	            line: 129,
	            column: 10
	          },
	          end: {
	            line: 129,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 129,
	            column: 10
	          },
	          end: {
	            line: 129,
	            column: 19
	          }
	        }, {
	          start: {
	            line: 129,
	            column: 23
	          },
	          end: {
	            line: 129,
	            column: 35
	          }
	        }],
	        line: 129
	      },
	      "33": {
	        loc: {
	          start: {
	            line: 132,
	            column: 22
	          },
	          end: {
	            line: 132,
	            column: 105
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 132,
	            column: 34
	          },
	          end: {
	            line: 132,
	            column: 99
	          }
	        }, {
	          start: {
	            line: 132,
	            column: 102
	          },
	          end: {
	            line: 132,
	            column: 105
	          }
	        }],
	        line: 132
	      },
	      "34": {
	        loc: {
	          start: {
	            line: 132,
	            column: 34
	          },
	          end: {
	            line: 132,
	            column: 99
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 132,
	            column: 60
	          },
	          end: {
	            line: 132,
	            column: 63
	          }
	        }, {
	          start: {
	            line: 132,
	            column: 66
	          },
	          end: {
	            line: 132,
	            column: 99
	          }
	        }],
	        line: 132
	      },
	      "35": {
	        loc: {
	          start: {
	            line: 138,
	            column: 4
	          },
	          end: {
	            line: 143,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 138,
	            column: 4
	          },
	          end: {
	            line: 143,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 138
	      },
	      "36": {
	        loc: {
	          start: {
	            line: 139,
	            column: 6
	          },
	          end: {
	            line: 141,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 139,
	            column: 6
	          },
	          end: {
	            line: 141,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 139
	      },
	      "37": {
	        loc: {
	          start: {
	            line: 144,
	            column: 4
	          },
	          end: {
	            line: 162,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 144,
	            column: 4
	          },
	          end: {
	            line: 162,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 160,
	            column: 11
	          },
	          end: {
	            line: 162,
	            column: 5
	          }
	        }],
	        line: 144
	      },
	      "38": {
	        loc: {
	          start: {
	            line: 145,
	            column: 6
	          },
	          end: {
	            line: 147,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 145,
	            column: 6
	          },
	          end: {
	            line: 147,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 145
	      },
	      "39": {
	        loc: {
	          start: {
	            line: 148,
	            column: 6
	          },
	          end: {
	            line: 150,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 148,
	            column: 6
	          },
	          end: {
	            line: 150,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 148
	      },
	      "40": {
	        loc: {
	          start: {
	            line: 151,
	            column: 6
	          },
	          end: {
	            line: 153,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 151,
	            column: 6
	          },
	          end: {
	            line: 153,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 151
	      },
	      "41": {
	        loc: {
	          start: {
	            line: 151,
	            column: 10
	          },
	          end: {
	            line: 151,
	            column: 46
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 151,
	            column: 10
	          },
	          end: {
	            line: 151,
	            column: 28
	          }
	        }, {
	          start: {
	            line: 151,
	            column: 32
	          },
	          end: {
	            line: 151,
	            column: 46
	          }
	        }],
	        line: 151
	      },
	      "42": {
	        loc: {
	          start: {
	            line: 154,
	            column: 6
	          },
	          end: {
	            line: 156,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 154,
	            column: 6
	          },
	          end: {
	            line: 156,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 154
	      },
	      "43": {
	        loc: {
	          start: {
	            line: 154,
	            column: 10
	          },
	          end: {
	            line: 154,
	            column: 46
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 154,
	            column: 10
	          },
	          end: {
	            line: 154,
	            column: 28
	          }
	        }, {
	          start: {
	            line: 154,
	            column: 32
	          },
	          end: {
	            line: 154,
	            column: 46
	          }
	        }],
	        line: 154
	      },
	      "44": {
	        loc: {
	          start: {
	            line: 157,
	            column: 6
	          },
	          end: {
	            line: 159,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 157,
	            column: 6
	          },
	          end: {
	            line: 159,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 157
	      },
	      "45": {
	        loc: {
	          start: {
	            line: 157,
	            column: 10
	          },
	          end: {
	            line: 157,
	            column: 46
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 157,
	            column: 10
	          },
	          end: {
	            line: 157,
	            column: 28
	          }
	        }, {
	          start: {
	            line: 157,
	            column: 32
	          },
	          end: {
	            line: 157,
	            column: 46
	          }
	        }],
	        line: 157
	      },
	      "46": {
	        loc: {
	          start: {
	            line: 160,
	            column: 11
	          },
	          end: {
	            line: 162,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 160,
	            column: 11
	          },
	          end: {
	            line: 162,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 160
	      },
	      "47": {
	        loc: {
	          start: {
	            line: 181,
	            column: 8
	          },
	          end: {
	            line: 183,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 181,
	            column: 8
	          },
	          end: {
	            line: 183,
	            column: 9
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 181
	      },
	      "48": {
	        loc: {
	          start: {
	            line: 187,
	            column: 8
	          },
	          end: {
	            line: 191,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 187,
	            column: 8
	          },
	          end: {
	            line: 191,
	            column: 9
	          }
	        }, {
	          start: {
	            line: 189,
	            column: 15
	          },
	          end: {
	            line: 191,
	            column: 9
	          }
	        }],
	        line: 187
	      },
	      "49": {
	        loc: {
	          start: {
	            line: 189,
	            column: 15
	          },
	          end: {
	            line: 191,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 189,
	            column: 15
	          },
	          end: {
	            line: 191,
	            column: 9
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 189
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0,
	      "72": 0,
	      "73": 0,
	      "74": 0,
	      "75": 0,
	      "76": 0,
	      "77": 0,
	      "78": 0,
	      "79": 0,
	      "80": 0,
	      "81": 0,
	      "82": 0,
	      "83": 0,
	      "84": 0,
	      "85": 0,
	      "86": 0,
	      "87": 0,
	      "88": 0,
	      "89": 0,
	      "90": 0,
	      "91": 0,
	      "92": 0,
	      "93": 0,
	      "94": 0,
	      "95": 0,
	      "96": 0,
	      "97": 0,
	      "98": 0,
	      "99": 0,
	      "100": 0,
	      "101": 0,
	      "102": 0,
	      "103": 0,
	      "104": 0,
	      "105": 0,
	      "106": 0,
	      "107": 0,
	      "108": 0,
	      "109": 0,
	      "110": 0,
	      "111": 0,
	      "112": 0,
	      "113": 0,
	      "114": 0,
	      "115": 0,
	      "116": 0,
	      "117": 0,
	      "118": 0,
	      "119": 0,
	      "120": 0,
	      "121": 0,
	      "122": 0,
	      "123": 0,
	      "124": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0],
	      "8": [0, 0],
	      "9": [0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0],
	      "13": [0, 0],
	      "14": [0, 0],
	      "15": [0, 0],
	      "16": [0, 0],
	      "17": [0, 0],
	      "18": [0, 0],
	      "19": [0, 0],
	      "20": [0, 0],
	      "21": [0, 0],
	      "22": [0, 0, 0],
	      "23": [0, 0],
	      "24": [0, 0],
	      "25": [0, 0],
	      "26": [0, 0],
	      "27": [0, 0],
	      "28": [0, 0],
	      "29": [0, 0],
	      "30": [0, 0],
	      "31": [0, 0],
	      "32": [0, 0],
	      "33": [0, 0],
	      "34": [0, 0],
	      "35": [0, 0],
	      "36": [0, 0],
	      "37": [0, 0],
	      "38": [0, 0],
	      "39": [0, 0],
	      "40": [0, 0],
	      "41": [0, 0],
	      "42": [0, 0],
	      "43": [0, 0],
	      "44": [0, 0],
	      "45": [0, 0],
	      "46": [0, 0],
	      "47": [0, 0],
	      "48": [0, 0],
	      "49": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/base.js"],
	      sourcesContent: ["const isArray =\n  typeof Array.isArray === 'function' ? Array.isArray : a => a instanceof Array;\n\nconst getObjectKeys =\n  typeof Object.keys === 'function'\n    ? obj => Object.keys(obj)\n    : obj => {\n      const names = [];\n      for (const property in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, property)) {\n          names.push(property);\n        }\n      }\n      return names;\n    };\n\nconst trimUnderscore = str => {\n  if (str.substr(0, 1) === '_') {\n    return str.slice(1);\n  }\n  return str;\n};\n\nconst arrayKeyToSortNumber = key => {\n  if (key === '_t') {\n    return -1;\n  } else {\n    if (key.substr(0, 1) === '_') {\n      return parseInt(key.slice(1), 10);\n    } else {\n      return parseInt(key, 10) + 0.1;\n    }\n  }\n};\n\nconst arrayKeyComparer = (key1, key2) =>\n  arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);\n\nclass BaseFormatter {\n  format(delta, left) {\n    const context = {};\n    this.prepareContext(context);\n    this.recurse(context, delta, left);\n    return this.finalize(context);\n  }\n\n  prepareContext(context) {\n    context.buffer = [];\n    context.out = function(...args) {\n      this.buffer.push(...args);\n    };\n  }\n\n  typeFormattterNotFound(context, deltaType) {\n    throw new Error(`cannot format delta type: ${deltaType}`);\n  }\n\n  typeFormattterErrorFormatter(context, err) {\n    return err.toString();\n  }\n\n  finalize({ buffer }) {\n    if (isArray(buffer)) {\n      return buffer.join('');\n    }\n  }\n\n  recurse(context, delta, left, key, leftKey, movedFrom, isLast) {\n    const useMoveOriginHere = delta && movedFrom;\n    const leftValue = useMoveOriginHere ? movedFrom.value : left;\n\n    if (typeof delta === 'undefined' && typeof key === 'undefined') {\n      return undefined;\n    }\n\n    const type = this.getDeltaType(delta, movedFrom);\n    const nodeType =\n      type === 'node' ? (delta._t === 'a' ? 'array' : 'object') : '';\n\n    if (typeof key !== 'undefined') {\n      this.nodeBegin(context, key, leftKey, type, nodeType, isLast);\n    } else {\n      this.rootBegin(context, type, nodeType);\n    }\n\n    let typeFormattter;\n    try {\n      typeFormattter =\n        this[`format_${type}`] || this.typeFormattterNotFound(context, type);\n      typeFormattter.call(\n        this,\n        context,\n        delta,\n        leftValue,\n        key,\n        leftKey,\n        movedFrom,\n      );\n    } catch (err) {\n      this.typeFormattterErrorFormatter(\n        context,\n        err,\n        delta,\n        leftValue,\n        key,\n        leftKey,\n        movedFrom,\n      );\n      if (typeof console !== 'undefined' && console.error) {\n        console.error(err.stack);\n      }\n    }\n\n    if (typeof key !== 'undefined') {\n      this.nodeEnd(context, key, leftKey, type, nodeType, isLast);\n    } else {\n      this.rootEnd(context, type, nodeType);\n    }\n  }\n\n  formatDeltaChildren(context, delta, left) {\n    const self = this;\n    this.forEachDeltaKey(delta, left, (key, leftKey, movedFrom, isLast) => {\n      self.recurse(\n        context,\n        delta[key],\n        left ? left[leftKey] : undefined,\n        key,\n        leftKey,\n        movedFrom,\n        isLast,\n      );\n    });\n  }\n\n  forEachDeltaKey(delta, left, fn) {\n    const keys = getObjectKeys(delta);\n    const arrayKeys = delta._t === 'a';\n    const moveDestinations = {};\n    let name;\n    if (typeof left !== 'undefined') {\n      for (name in left) {\n        if (Object.prototype.hasOwnProperty.call(left, name)) {\n          if (\n            typeof delta[name] === 'undefined' &&\n            (!arrayKeys || typeof delta[`_${name}`] === 'undefined')\n          ) {\n            keys.push(name);\n          }\n        }\n      }\n    }\n    // look for move destinations\n    for (name in delta) {\n      if (Object.prototype.hasOwnProperty.call(delta, name)) {\n        const value = delta[name];\n        if (isArray(value) && value[2] === 3) {\n          moveDestinations[value[1].toString()] = {\n            key: name,\n            value: left && left[parseInt(name.substr(1))],\n          };\n          if (this.includeMoveDestinations !== false) {\n            if (\n              typeof left === 'undefined' &&\n              typeof delta[value[1]] === 'undefined'\n            ) {\n              keys.push(value[1].toString());\n            }\n          }\n        }\n      }\n    }\n    if (arrayKeys) {\n      keys.sort(arrayKeyComparer);\n    } else {\n      keys.sort();\n    }\n    for (let index = 0, length = keys.length; index < length; index++) {\n      const key = keys[index];\n      if (arrayKeys && key === '_t') {\n        continue;\n      }\n      const leftKey = arrayKeys\n        ? typeof key === 'number' ? key : parseInt(trimUnderscore(key), 10)\n        : key;\n      const isLast = index === length - 1;\n      fn(key, leftKey, moveDestinations[leftKey], isLast);\n    }\n  }\n\n  getDeltaType(delta, movedFrom) {\n    if (typeof delta === 'undefined') {\n      if (typeof movedFrom !== 'undefined') {\n        return 'movedestination';\n      }\n      return 'unchanged';\n    }\n    if (isArray(delta)) {\n      if (delta.length === 1) {\n        return 'added';\n      }\n      if (delta.length === 2) {\n        return 'modified';\n      }\n      if (delta.length === 3 && delta[2] === 0) {\n        return 'deleted';\n      }\n      if (delta.length === 3 && delta[2] === 2) {\n        return 'textdiff';\n      }\n      if (delta.length === 3 && delta[2] === 3) {\n        return 'moved';\n      }\n    } else if (typeof delta === 'object') {\n      return 'node';\n    }\n    return 'unknown';\n  }\n\n  parseTextDiff(value) {\n    const output = [];\n    const lines = value.split('\\n@@ ');\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      const lineOutput = {\n        pieces: [],\n      };\n      const location = /^(?:@@ )?[-+]?(\\d+),(\\d+)/.exec(line).slice(1);\n      lineOutput.location = {\n        line: location[0],\n        chr: location[1],\n      };\n      const pieces = line.split('\\n').slice(1);\n      for (\n        let pieceIndex = 0, piecesLength = pieces.length;\n        pieceIndex < piecesLength;\n        pieceIndex++\n      ) {\n        const piece = pieces[pieceIndex];\n        if (!piece.length) {\n          continue;\n        }\n        const pieceOutput = {\n          type: 'context',\n        };\n        if (piece.substr(0, 1) === '+') {\n          pieceOutput.type = 'added';\n        } else if (piece.substr(0, 1) === '-') {\n          pieceOutput.type = 'deleted';\n        }\n        pieceOutput.text = piece.slice(1);\n        lineOutput.pieces.push(pieceOutput);\n      }\n      output.push(lineOutput);\n    }\n    return output;\n  }\n}\n\nexport default BaseFormatter;\n"],
	      names: ["isArray", "Array", "a", "getObjectKeys", "Object", "keys", "obj", "names", "property", "prototype", "hasOwnProperty", "call", "push", "trimUnderscore", "str", "substr", "slice", "arrayKeyToSortNumber", "key", "parseInt", "arrayKeyComparer", "key1", "key2", "BaseFormatter", "format", "delta", "left", "context", "prepareContext", "recurse", "finalize", "buffer", "out", "arguments", "typeFormattterNotFound", "deltaType", "Error", "typeFormattterErrorFormatter", "err", "toString", "_ref", "join", "leftKey", "movedFrom", "isLast", "useMoveOriginHere", "leftValue", "value", "undefined", "type", "getDeltaType", "nodeType", "_t", "nodeBegin", "rootBegin", "typeFormattter", "console", "error", "stack", "nodeEnd", "rootEnd", "formatDeltaChildren", "self", "forEachDeltaKey", "fn", "arrayKeys", "moveDestinations", "name", "includeMoveDestinations", "sort", "index", "length", "parseTextDiff", "output", "lines", "split", "i", "l", "line", "lineOutput", "pieces", "location", "exec", "chr", "pieceIndex", "piecesLength", "piece", "pieceOutput", "text"],
	      mappings: "AAAA,MAAMA,OAAO,GACX,OAAOC,KAAK,CAACD,OAAO,KAAK,UAAU,GAAGC,KAAK,CAACD,OAAO,GAAGE,CAAC,IAAIA,CAAC,YAAYD,KAAK;AAE/E,MAAME,aAAa,GACjB,OAAOC,MAAM,CAACC,IAAI,KAAK,UAAU,GAC7BC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAAC,GACvBA,GAAG,IAAI;EACP,MAAMC,KAAK,GAAG,EAAE;EAChB,KAAK,MAAMC,QAAQ,IAAIF,GAAG,EAAE;IAC1B,IAAIF,MAAM,CAACK,SAAS,CAACC,cAAc,CAACC,IAAI,CAACL,GAAG,EAAEE,QAAQ,CAAC,EAAE;MACvDD,KAAK,CAACK,IAAI,CAACJ,QAAQ,CAAC;IACtB;EACF;EACA,OAAOD,KAAK;AACd,CAAC;AAEL,MAAMM,cAAc,GAAGC,GAAG,IAAI;EAC5B,IAAIA,GAAG,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE;IAC5B,OAAOD,GAAG,CAACE,KAAK,CAAC,CAAC,CAAC;EACrB;EACA,OAAOF,GAAG;AACZ,CAAC;AAED,MAAMG,oBAAoB,GAAGC,GAAG,IAAI;EAClC,IAAIA,GAAG,KAAK,IAAI,EAAE;IAChB,OAAO,CAAC,CAAC;EACX,CAAC,MAAM;IACL,IAAIA,GAAG,CAACH,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE;MAC5B,OAAOI,QAAQ,CAACD,GAAG,CAACF,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;IACnC,CAAC,MAAM;MACL,OAAOG,QAAQ,CAACD,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG;IAChC;EACF;AACF,CAAC;AAED,MAAME,gBAAgB,GAAGA,CAACC,IAAI,EAAEC,IAAI,KAClCL,oBAAoB,CAACI,IAAI,CAAC,GAAGJ,oBAAoB,CAACK,IAAI,CAAC;AAEzD,MAAMC,aAAa,CAAC;EAClBC,MAAMA,CAACC,KAAK,EAAEC,IAAI,EAAE;IAClB,MAAMC,OAAO,GAAG,CAAC,CAAC;IAClB,IAAI,CAACC,cAAc,CAACD,OAAO,CAAC;IAC5B,IAAI,CAACE,OAAO,CAACF,OAAO,EAAEF,KAAK,EAAEC,IAAI,CAAC;IAClC,OAAO,IAAI,CAACI,QAAQ,CAACH,OAAO,CAAC;EAC/B;EAEAC,cAAcA,CAACD,OAAO,EAAE;IACtBA,OAAO,CAACI,MAAM,GAAG,EAAE;IACnBJ,OAAO,CAACK,GAAG,GAAG,YAAkB;MAC9B,IAAI,CAACD,MAAM,CAACnB,IAAI,CAAC,GAAAqB,SAAO,CAAC;IAC3B,CAAC;EACH;EAEAC,sBAAsBA,CAACP,OAAO,EAAEQ,SAAS,EAAE;IACzC,MAAM,IAAIC,KAAK,CAAE,6BAA4BD,SAAU,EAAC,CAAC;EAC3D;EAEAE,4BAA4BA,CAACV,OAAO,EAAEW,GAAG,EAAE;IACzC,OAAOA,GAAG,CAACC,QAAQ,CAAC,CAAC;EACvB;EAEAT,QAAQA,CAAAU,IAAA,EAAa;IAAA,IAAZ;MAAET;IAAO,CAAC,GAAAS,IAAA;IACjB,IAAIxC,OAAO,CAAC+B,MAAM,CAAC,EAAE;MACnB,OAAOA,MAAM,CAACU,IAAI,CAAC,EAAE,CAAC;IACxB;EACF;EAEAZ,OAAOA,CAACF,OAAO,EAAEF,KAAK,EAAEC,IAAI,EAAER,GAAG,EAAEwB,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAE;IAC7D,MAAMC,iBAAiB,GAAGpB,KAAK,IAAIkB,SAAS;IAC5C,MAAMG,SAAS,GAAGD,iBAAiB,GAAGF,SAAS,CAACI,KAAK,GAAGrB,IAAI;IAE5D,IAAI,OAAOD,KAAK,KAAK,WAAW,IAAI,OAAOP,GAAG,KAAK,WAAW,EAAE;MAC9D,OAAO8B,SAAS;IAClB;IAEA,MAAMC,IAAI,GAAG,IAAI,CAACC,YAAY,CAACzB,KAAK,EAAEkB,SAAS,CAAC;IAChD,MAAMQ,QAAQ,GACZF,IAAI,KAAK,MAAM,GAAIxB,KAAK,CAAC2B,EAAE,KAAK,GAAG,GAAG,OAAO,GAAG,QAAQ,GAAI,EAAE;IAEhE,IAAI,OAAOlC,GAAG,KAAK,WAAW,EAAE;MAC9B,IAAI,CAACmC,SAAS,CAAC1B,OAAO,EAAET,GAAG,EAAEwB,OAAO,EAAEO,IAAI,EAAEE,QAAQ,EAAEP,MAAM,CAAC;IAC/D,CAAC,MAAM;MACL,IAAI,CAACU,SAAS,CAAC3B,OAAO,EAAEsB,IAAI,EAAEE,QAAQ,CAAC;IACzC;IAEA,IAAII,cAAc;IAClB,IAAI;MACFA,cAAc,GACZ,IAAI,CAAE,UAASN,IAAK,EAAC,CAAC,IAAI,IAAI,CAACf,sBAAsB,CAACP,OAAO,EAAEsB,IAAI,CAAC;MACtEM,cAAc,CAAC5C,IAAI,CACjB,IAAI,EACJgB,OAAO,EACPF,KAAK,EACLqB,SAAS,EACT5B,GAAG,EACHwB,OAAO,EACPC,SACF,CAAC;IACH,CAAC,CAAC,OAAOL,GAAG,EAAE;MACZ,IAAI,CAACD,4BAA4B,CAC/BV,OAAO,EACPW,GAAG,EACHb,KAAK,EACLqB,SAAS,EACT5B,GAAG,EACHwB,OAAO,EACPC,SACF,CAAC;MACD,IAAI,OAAOa,OAAO,KAAK,WAAW,IAAIA,OAAO,CAACC,KAAK,EAAE;QACnDD,OAAO,CAACC,KAAK,CAACnB,GAAG,CAACoB,KAAK,CAAC;MAC1B;IACF;IAEA,IAAI,OAAOxC,GAAG,KAAK,WAAW,EAAE;MAC9B,IAAI,CAACyC,OAAO,CAAChC,OAAO,EAAET,GAAG,EAAEwB,OAAO,EAAEO,IAAI,EAAEE,QAAQ,EAAEP,MAAM,CAAC;IAC7D,CAAC,MAAM;MACL,IAAI,CAACgB,OAAO,CAACjC,OAAO,EAAEsB,IAAI,EAAEE,QAAQ,CAAC;IACvC;EACF;EAEAU,mBAAmBA,CAAClC,OAAO,EAAEF,KAAK,EAAEC,IAAI,EAAE;IACxC,MAAMoC,IAAI,GAAG,IAAI;IACjB,IAAI,CAACC,eAAe,CAACtC,KAAK,EAAEC,IAAI,EAAE,CAACR,GAAG,EAAEwB,OAAO,EAAEC,SAAS,EAAEC,MAAM,KAAK;MACrEkB,IAAI,CAACjC,OAAO,CACVF,OAAO,EACPF,KAAK,CAACP,GAAG,CAAC,EACVQ,IAAI,GAAGA,IAAI,CAACgB,OAAO,CAAC,GAAGM,SAAS,EAChC9B,GAAG,EACHwB,OAAO,EACPC,SAAS,EACTC,MACF,CAAC;IACH,CAAC,CAAC;EACJ;EAEAmB,eAAeA,CAACtC,KAAK,EAAEC,IAAI,EAAEsC,EAAE,EAAE;IAC/B,MAAM3D,IAAI,GAAGF,aAAa,CAACsB,KAAK,CAAC;IACjC,MAAMwC,SAAS,GAAGxC,KAAK,CAAC2B,EAAE,KAAK,GAAG;IAClC,MAAMc,gBAAgB,GAAG,CAAC,CAAC;IAC3B,IAAIC,IAAI;IACR,IAAI,OAAOzC,IAAI,KAAK,WAAW,EAAE;MAC/B,KAAKyC,IAAI,IAAIzC,IAAI,EAAE;QACjB,IAAItB,MAAM,CAACK,SAAS,CAACC,cAAc,CAACC,IAAI,CAACe,IAAI,EAAEyC,IAAI,CAAC,EAAE;UACpD,IACE,OAAO1C,KAAK,CAAC0C,IAAI,CAAC,KAAK,WAAW,KACjC,CAACF,SAAS,IAAI,OAAOxC,KAAK,CAAE,IAAG0C,IAAK,EAAC,CAAC,KAAK,WAAW,CAAC,EACxD;YACA9D,IAAI,CAACO,IAAI,CAACuD,IAAI,CAAC;UACjB;QACF;MACF;IACF;IACA;IACA,KAAKA,IAAI,IAAI1C,KAAK,EAAE;MAClB,IAAIrB,MAAM,CAACK,SAAS,CAACC,cAAc,CAACC,IAAI,CAACc,KAAK,EAAE0C,IAAI,CAAC,EAAE;QACrD,MAAMpB,KAAK,GAAGtB,KAAK,CAAC0C,IAAI,CAAC;QACzB,IAAInE,OAAO,CAAC+C,KAAK,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;UACpCmB,gBAAgB,CAACnB,KAAK,CAAC,CAAC,CAAC,CAACR,QAAQ,CAAC,CAAC,CAAC,GAAG;YACtCrB,GAAG,EAAEiD,IAAI;YACTpB,KAAK,EAAErB,IAAI,IAAIA,IAAI,CAACP,QAAQ,CAACgD,IAAI,CAACpD,MAAM,CAAC,CAAC,CAAC,CAAC;UAC9C,CAAC;UACD,IAAI,IAAI,CAACqD,uBAAuB,KAAK,KAAK,EAAE;YAC1C,IACE,OAAO1C,IAAI,KAAK,WAAW,IAC3B,OAAOD,KAAK,CAACsB,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,WAAW,EACtC;cACA1C,IAAI,CAACO,IAAI,CAACmC,KAAK,CAAC,CAAC,CAAC,CAACR,QAAQ,CAAC,CAAC,CAAC;YAChC;UACF;QACF;MACF;IACF;IACA,IAAI0B,SAAS,EAAE;MACb5D,IAAI,CAACgE,IAAI,CAACjD,gBAAgB,CAAC;IAC7B,CAAC,MAAM;MACLf,IAAI,CAACgE,IAAI,CAAC,CAAC;IACb;IACA,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEC,MAAM,GAAGlE,IAAI,CAACkE,MAAM,EAAED,KAAK,GAAGC,MAAM,EAAED,KAAK,EAAE,EAAE;MACjE,MAAMpD,GAAG,GAAGb,IAAI,CAACiE,KAAK,CAAC;MACvB,IAAIL,SAAS,IAAI/C,GAAG,KAAK,IAAI,EAAE;QAC7B;MACF;MACA,MAAMwB,OAAO,GAAGuB,SAAS,GACrB,OAAO/C,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAGC,QAAQ,CAACN,cAAc,CAACK,GAAG,CAAC,EAAE,EAAE,CAAC,GACjEA,GAAG;MACP,MAAM0B,MAAM,GAAG0B,KAAK,KAAKC,MAAM,GAAG,CAAC;MACnCP,EAAE,CAAC9C,GAAG,EAAEwB,OAAO,EAAEwB,gBAAgB,CAACxB,OAAO,CAAC,EAAEE,MAAM,CAAC;IACrD;EACF;EAEAM,YAAYA,CAACzB,KAAK,EAAEkB,SAAS,EAAE;IAC7B,IAAI,OAAOlB,KAAK,KAAK,WAAW,EAAE;MAChC,IAAI,OAAOkB,SAAS,KAAK,WAAW,EAAE;QACpC,OAAO,iBAAiB;MAC1B;MACA,OAAO,WAAW;IACpB;IACA,IAAI3C,OAAO,CAACyB,KAAK,CAAC,EAAE;MAClB,IAAIA,KAAK,CAAC8C,MAAM,KAAK,CAAC,EAAE;QACtB,OAAO,OAAO;MAChB;MACA,IAAI9C,KAAK,CAAC8C,MAAM,KAAK,CAAC,EAAE;QACtB,OAAO,UAAU;MACnB;MACA,IAAI9C,KAAK,CAAC8C,MAAM,KAAK,CAAC,IAAI9C,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;QACxC,OAAO,SAAS;MAClB;MACA,IAAIA,KAAK,CAAC8C,MAAM,KAAK,CAAC,IAAI9C,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;QACxC,OAAO,UAAU;MACnB;MACA,IAAIA,KAAK,CAAC8C,MAAM,KAAK,CAAC,IAAI9C,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;QACxC,OAAO,OAAO;MAChB;IACF,CAAC,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MACpC,OAAO,MAAM;IACf;IACA,OAAO,SAAS;EAClB;EAEA+C,aAAaA,CAACzB,KAAK,EAAE;IACnB,MAAM0B,MAAM,GAAG,EAAE;IACjB,MAAMC,KAAK,GAAG3B,KAAK,CAAC4B,KAAK,CAAC,OAAO,CAAC;IAClC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGH,KAAK,CAACH,MAAM,EAAEK,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAC5C,MAAME,IAAI,GAAGJ,KAAK,CAACE,CAAC,CAAC;MACrB,MAAMG,UAAU,GAAG;QACjBC,MAAM,EAAE;MACV,CAAC;MACD,MAAMC,QAAQ,GAAG,2BAA2B,CAACC,IAAI,CAACJ,IAAI,CAAC,CAAC9D,KAAK,CAAC,CAAC,CAAC;MAChE+D,UAAU,CAACE,QAAQ,GAAG;QACpBH,IAAI,EAAEG,QAAQ,CAAC,CAAC,CAAC;QACjBE,GAAG,EAAEF,QAAQ,CAAC,CAAC;MACjB,CAAC;MACD,MAAMD,MAAM,GAAGF,IAAI,CAACH,KAAK,CAAC,IAAI,CAAC,CAAC3D,KAAK,CAAC,CAAC,CAAC;MACxC,KACE,IAAIoE,UAAU,GAAG,CAAC,EAAEC,YAAY,GAAGL,MAAM,CAACT,MAAM,EAChDa,UAAU,GAAGC,YAAY,EACzBD,UAAU,EAAE,EACZ;QACA,MAAME,KAAK,GAAGN,MAAM,CAACI,UAAU,CAAC;QAChC,IAAI,CAACE,KAAK,CAACf,MAAM,EAAE;UACjB;QACF;QACA,MAAMgB,WAAW,GAAG;UAClBtC,IAAI,EAAE;QACR,CAAC;QACD,IAAIqC,KAAK,CAACvE,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE;UAC9BwE,WAAW,CAACtC,IAAI,GAAG,OAAO;QAC5B,CAAC,MAAM,IAAIqC,KAAK,CAACvE,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE;UACrCwE,WAAW,CAACtC,IAAI,GAAG,SAAS;QAC9B;QACAsC,WAAW,CAACC,IAAI,GAAGF,KAAK,CAACtE,KAAK,CAAC,CAAC,CAAC;QACjC+D,UAAU,CAACC,MAAM,CAACpE,IAAI,CAAC2E,WAAW,CAAC;MACrC;MACAd,MAAM,CAAC7D,IAAI,CAACmE,UAAU,CAAC;IACzB;IACA,OAAON,MAAM;EACf;AACF;AAEA,eAAelD,aAAa",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "b448007f15dac7840c820a5b6aac43426b9aee98"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_2b92ly2zmp = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_2b92ly2zmp();
	const isArray$4 = (cov_2b92ly2zmp().s[0]++, typeof Array.isArray === 'function' ? (cov_2b92ly2zmp().b[0][0]++, Array.isArray) : (cov_2b92ly2zmp().b[0][1]++, a => {
	  cov_2b92ly2zmp().f[0]++;
	  cov_2b92ly2zmp().s[1]++;
	  return a instanceof Array;
	}));
	const getObjectKeys = (cov_2b92ly2zmp().s[2]++, typeof Object.keys === 'function' ? (cov_2b92ly2zmp().b[1][0]++, obj => {
	  cov_2b92ly2zmp().f[1]++;
	  cov_2b92ly2zmp().s[3]++;
	  return Object.keys(obj);
	}) : (cov_2b92ly2zmp().b[1][1]++, obj => {
	  cov_2b92ly2zmp().f[2]++;
	  const names = (cov_2b92ly2zmp().s[4]++, []);
	  cov_2b92ly2zmp().s[5]++;
	  for (const property in obj) {
	    cov_2b92ly2zmp().s[6]++;
	    if (Object.prototype.hasOwnProperty.call(obj, property)) {
	      cov_2b92ly2zmp().b[2][0]++;
	      cov_2b92ly2zmp().s[7]++;
	      names.push(property);
	    } else {
	      cov_2b92ly2zmp().b[2][1]++;
	    }
	  }
	  cov_2b92ly2zmp().s[8]++;
	  return names;
	}));
	cov_2b92ly2zmp().s[9]++;
	const trimUnderscore = str => {
	  cov_2b92ly2zmp().f[3]++;
	  cov_2b92ly2zmp().s[10]++;
	  if (str.substr(0, 1) === '_') {
	    cov_2b92ly2zmp().b[3][0]++;
	    cov_2b92ly2zmp().s[11]++;
	    return str.slice(1);
	  } else {
	    cov_2b92ly2zmp().b[3][1]++;
	  }
	  cov_2b92ly2zmp().s[12]++;
	  return str;
	};
	cov_2b92ly2zmp().s[13]++;
	const arrayKeyToSortNumber = key => {
	  cov_2b92ly2zmp().f[4]++;
	  cov_2b92ly2zmp().s[14]++;
	  if (key === '_t') {
	    cov_2b92ly2zmp().b[4][0]++;
	    cov_2b92ly2zmp().s[15]++;
	    return -1;
	  } else {
	    cov_2b92ly2zmp().b[4][1]++;
	    cov_2b92ly2zmp().s[16]++;
	    if (key.substr(0, 1) === '_') {
	      cov_2b92ly2zmp().b[5][0]++;
	      cov_2b92ly2zmp().s[17]++;
	      return parseInt(key.slice(1), 10);
	    } else {
	      cov_2b92ly2zmp().b[5][1]++;
	      cov_2b92ly2zmp().s[18]++;
	      return parseInt(key, 10) + 0.1;
	    }
	  }
	};
	cov_2b92ly2zmp().s[19]++;
	const arrayKeyComparer = (key1, key2) => {
	  cov_2b92ly2zmp().f[5]++;
	  cov_2b92ly2zmp().s[20]++;
	  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);
	};
	class BaseFormatter {
	  format(delta, left) {
	    cov_2b92ly2zmp().f[6]++;
	    const context = (cov_2b92ly2zmp().s[21]++, {});
	    cov_2b92ly2zmp().s[22]++;
	    this.prepareContext(context);
	    cov_2b92ly2zmp().s[23]++;
	    this.recurse(context, delta, left);
	    cov_2b92ly2zmp().s[24]++;
	    return this.finalize(context);
	  }
	  prepareContext(context) {
	    cov_2b92ly2zmp().f[7]++;
	    cov_2b92ly2zmp().s[25]++;
	    context.buffer = [];
	    cov_2b92ly2zmp().s[26]++;
	    context.out = function () {
	      cov_2b92ly2zmp().f[8]++;
	      cov_2b92ly2zmp().s[27]++;
	      this.buffer.push(...arguments);
	    };
	  }
	  typeFormattterNotFound(context, deltaType) {
	    cov_2b92ly2zmp().f[9]++;
	    cov_2b92ly2zmp().s[28]++;
	    throw new Error(`cannot format delta type: ${deltaType}`);
	  }
	  typeFormattterErrorFormatter(context, err) {
	    cov_2b92ly2zmp().f[10]++;
	    cov_2b92ly2zmp().s[29]++;
	    return err.toString();
	  }
	  finalize(_ref) {
	    cov_2b92ly2zmp().f[11]++;
	    let {
	      buffer
	    } = (cov_2b92ly2zmp().s[30]++, _ref);
	    cov_2b92ly2zmp().s[31]++;
	    if (isArray$4(buffer)) {
	      cov_2b92ly2zmp().b[6][0]++;
	      cov_2b92ly2zmp().s[32]++;
	      return buffer.join('');
	    } else {
	      cov_2b92ly2zmp().b[6][1]++;
	    }
	  }
	  recurse(context, delta, left, key, leftKey, movedFrom, isLast) {
	    cov_2b92ly2zmp().f[12]++;
	    const useMoveOriginHere = (cov_2b92ly2zmp().s[33]++, (cov_2b92ly2zmp().b[7][0]++, delta) && (cov_2b92ly2zmp().b[7][1]++, movedFrom));
	    const leftValue = (cov_2b92ly2zmp().s[34]++, useMoveOriginHere ? (cov_2b92ly2zmp().b[8][0]++, movedFrom.value) : (cov_2b92ly2zmp().b[8][1]++, left));
	    cov_2b92ly2zmp().s[35]++;
	    if ((cov_2b92ly2zmp().b[10][0]++, typeof delta === 'undefined') && (cov_2b92ly2zmp().b[10][1]++, typeof key === 'undefined')) {
	      cov_2b92ly2zmp().b[9][0]++;
	      cov_2b92ly2zmp().s[36]++;
	      return undefined;
	    } else {
	      cov_2b92ly2zmp().b[9][1]++;
	    }
	    const type = (cov_2b92ly2zmp().s[37]++, this.getDeltaType(delta, movedFrom));
	    const nodeType = (cov_2b92ly2zmp().s[38]++, type === 'node' ? (cov_2b92ly2zmp().b[11][0]++, delta._t === 'a' ? (cov_2b92ly2zmp().b[12][0]++, 'array') : (cov_2b92ly2zmp().b[12][1]++, 'object')) : (cov_2b92ly2zmp().b[11][1]++, ''));
	    cov_2b92ly2zmp().s[39]++;
	    if (typeof key !== 'undefined') {
	      cov_2b92ly2zmp().b[13][0]++;
	      cov_2b92ly2zmp().s[40]++;
	      this.nodeBegin(context, key, leftKey, type, nodeType, isLast);
	    } else {
	      cov_2b92ly2zmp().b[13][1]++;
	      cov_2b92ly2zmp().s[41]++;
	      this.rootBegin(context, type, nodeType);
	    }
	    let typeFormattter;
	    cov_2b92ly2zmp().s[42]++;
	    try {
	      cov_2b92ly2zmp().s[43]++;
	      typeFormattter = (cov_2b92ly2zmp().b[14][0]++, this[`format_${type}`]) || (cov_2b92ly2zmp().b[14][1]++, this.typeFormattterNotFound(context, type));
	      cov_2b92ly2zmp().s[44]++;
	      typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);
	    } catch (err) {
	      cov_2b92ly2zmp().s[45]++;
	      this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);
	      cov_2b92ly2zmp().s[46]++;
	      if ((cov_2b92ly2zmp().b[16][0]++, typeof console !== 'undefined') && (cov_2b92ly2zmp().b[16][1]++, console.error)) {
	        cov_2b92ly2zmp().b[15][0]++;
	        cov_2b92ly2zmp().s[47]++;
	        console.error(err.stack);
	      } else {
	        cov_2b92ly2zmp().b[15][1]++;
	      }
	    }
	    cov_2b92ly2zmp().s[48]++;
	    if (typeof key !== 'undefined') {
	      cov_2b92ly2zmp().b[17][0]++;
	      cov_2b92ly2zmp().s[49]++;
	      this.nodeEnd(context, key, leftKey, type, nodeType, isLast);
	    } else {
	      cov_2b92ly2zmp().b[17][1]++;
	      cov_2b92ly2zmp().s[50]++;
	      this.rootEnd(context, type, nodeType);
	    }
	  }
	  formatDeltaChildren(context, delta, left) {
	    cov_2b92ly2zmp().f[13]++;
	    const self = (cov_2b92ly2zmp().s[51]++, this);
	    cov_2b92ly2zmp().s[52]++;
	    this.forEachDeltaKey(delta, left, (key, leftKey, movedFrom, isLast) => {
	      cov_2b92ly2zmp().f[14]++;
	      cov_2b92ly2zmp().s[53]++;
	      self.recurse(context, delta[key], left ? (cov_2b92ly2zmp().b[18][0]++, left[leftKey]) : (cov_2b92ly2zmp().b[18][1]++, undefined), key, leftKey, movedFrom, isLast);
	    });
	  }
	  forEachDeltaKey(delta, left, fn) {
	    cov_2b92ly2zmp().f[15]++;
	    const keys = (cov_2b92ly2zmp().s[54]++, getObjectKeys(delta));
	    const arrayKeys = (cov_2b92ly2zmp().s[55]++, delta._t === 'a');
	    const moveDestinations = (cov_2b92ly2zmp().s[56]++, {});
	    let name;
	    cov_2b92ly2zmp().s[57]++;
	    if (typeof left !== 'undefined') {
	      cov_2b92ly2zmp().b[19][0]++;
	      cov_2b92ly2zmp().s[58]++;
	      for (name in left) {
	        cov_2b92ly2zmp().s[59]++;
	        if (Object.prototype.hasOwnProperty.call(left, name)) {
	          cov_2b92ly2zmp().b[20][0]++;
	          cov_2b92ly2zmp().s[60]++;
	          if ((cov_2b92ly2zmp().b[22][0]++, typeof delta[name] === 'undefined') && ((cov_2b92ly2zmp().b[22][1]++, !arrayKeys) || (cov_2b92ly2zmp().b[22][2]++, typeof delta[`_${name}`] === 'undefined'))) {
	            cov_2b92ly2zmp().b[21][0]++;
	            cov_2b92ly2zmp().s[61]++;
	            keys.push(name);
	          } else {
	            cov_2b92ly2zmp().b[21][1]++;
	          }
	        } else {
	          cov_2b92ly2zmp().b[20][1]++;
	        }
	      }
	    } else {
	      cov_2b92ly2zmp().b[19][1]++;
	    } // look for move destinations
	    cov_2b92ly2zmp().s[62]++;
	    for (name in delta) {
	      cov_2b92ly2zmp().s[63]++;
	      if (Object.prototype.hasOwnProperty.call(delta, name)) {
	        cov_2b92ly2zmp().b[23][0]++;
	        const value = (cov_2b92ly2zmp().s[64]++, delta[name]);
	        cov_2b92ly2zmp().s[65]++;
	        if ((cov_2b92ly2zmp().b[25][0]++, isArray$4(value)) && (cov_2b92ly2zmp().b[25][1]++, value[2] === 3)) {
	          cov_2b92ly2zmp().b[24][0]++;
	          cov_2b92ly2zmp().s[66]++;
	          moveDestinations[value[1].toString()] = {
	            key: name,
	            value: (cov_2b92ly2zmp().b[26][0]++, left) && (cov_2b92ly2zmp().b[26][1]++, left[parseInt(name.substr(1))])
	          };
	          cov_2b92ly2zmp().s[67]++;
	          if (this.includeMoveDestinations !== false) {
	            cov_2b92ly2zmp().b[27][0]++;
	            cov_2b92ly2zmp().s[68]++;
	            if ((cov_2b92ly2zmp().b[29][0]++, typeof left === 'undefined') && (cov_2b92ly2zmp().b[29][1]++, typeof delta[value[1]] === 'undefined')) {
	              cov_2b92ly2zmp().b[28][0]++;
	              cov_2b92ly2zmp().s[69]++;
	              keys.push(value[1].toString());
	            } else {
	              cov_2b92ly2zmp().b[28][1]++;
	            }
	          } else {
	            cov_2b92ly2zmp().b[27][1]++;
	          }
	        } else {
	          cov_2b92ly2zmp().b[24][1]++;
	        }
	      } else {
	        cov_2b92ly2zmp().b[23][1]++;
	      }
	    }
	    cov_2b92ly2zmp().s[70]++;
	    if (arrayKeys) {
	      cov_2b92ly2zmp().b[30][0]++;
	      cov_2b92ly2zmp().s[71]++;
	      keys.sort(arrayKeyComparer);
	    } else {
	      cov_2b92ly2zmp().b[30][1]++;
	      cov_2b92ly2zmp().s[72]++;
	      keys.sort();
	    }
	    cov_2b92ly2zmp().s[73]++;
	    for (let index = (cov_2b92ly2zmp().s[74]++, 0), length = (cov_2b92ly2zmp().s[75]++, keys.length); index < length; index++) {
	      const key = (cov_2b92ly2zmp().s[76]++, keys[index]);
	      cov_2b92ly2zmp().s[77]++;
	      if ((cov_2b92ly2zmp().b[32][0]++, arrayKeys) && (cov_2b92ly2zmp().b[32][1]++, key === '_t')) {
	        cov_2b92ly2zmp().b[31][0]++;
	        cov_2b92ly2zmp().s[78]++;
	        continue;
	      } else {
	        cov_2b92ly2zmp().b[31][1]++;
	      }
	      const leftKey = (cov_2b92ly2zmp().s[79]++, arrayKeys ? (cov_2b92ly2zmp().b[33][0]++, typeof key === 'number' ? (cov_2b92ly2zmp().b[34][0]++, key) : (cov_2b92ly2zmp().b[34][1]++, parseInt(trimUnderscore(key), 10))) : (cov_2b92ly2zmp().b[33][1]++, key));
	      const isLast = (cov_2b92ly2zmp().s[80]++, index === length - 1);
	      cov_2b92ly2zmp().s[81]++;
	      fn(key, leftKey, moveDestinations[leftKey], isLast);
	    }
	  }
	  getDeltaType(delta, movedFrom) {
	    cov_2b92ly2zmp().f[16]++;
	    cov_2b92ly2zmp().s[82]++;
	    if (typeof delta === 'undefined') {
	      cov_2b92ly2zmp().b[35][0]++;
	      cov_2b92ly2zmp().s[83]++;
	      if (typeof movedFrom !== 'undefined') {
	        cov_2b92ly2zmp().b[36][0]++;
	        cov_2b92ly2zmp().s[84]++;
	        return 'movedestination';
	      } else {
	        cov_2b92ly2zmp().b[36][1]++;
	      }
	      cov_2b92ly2zmp().s[85]++;
	      return 'unchanged';
	    } else {
	      cov_2b92ly2zmp().b[35][1]++;
	    }
	    cov_2b92ly2zmp().s[86]++;
	    if (isArray$4(delta)) {
	      cov_2b92ly2zmp().b[37][0]++;
	      cov_2b92ly2zmp().s[87]++;
	      if (delta.length === 1) {
	        cov_2b92ly2zmp().b[38][0]++;
	        cov_2b92ly2zmp().s[88]++;
	        return 'added';
	      } else {
	        cov_2b92ly2zmp().b[38][1]++;
	      }
	      cov_2b92ly2zmp().s[89]++;
	      if (delta.length === 2) {
	        cov_2b92ly2zmp().b[39][0]++;
	        cov_2b92ly2zmp().s[90]++;
	        return 'modified';
	      } else {
	        cov_2b92ly2zmp().b[39][1]++;
	      }
	      cov_2b92ly2zmp().s[91]++;
	      if ((cov_2b92ly2zmp().b[41][0]++, delta.length === 3) && (cov_2b92ly2zmp().b[41][1]++, delta[2] === 0)) {
	        cov_2b92ly2zmp().b[40][0]++;
	        cov_2b92ly2zmp().s[92]++;
	        return 'deleted';
	      } else {
	        cov_2b92ly2zmp().b[40][1]++;
	      }
	      cov_2b92ly2zmp().s[93]++;
	      if ((cov_2b92ly2zmp().b[43][0]++, delta.length === 3) && (cov_2b92ly2zmp().b[43][1]++, delta[2] === 2)) {
	        cov_2b92ly2zmp().b[42][0]++;
	        cov_2b92ly2zmp().s[94]++;
	        return 'textdiff';
	      } else {
	        cov_2b92ly2zmp().b[42][1]++;
	      }
	      cov_2b92ly2zmp().s[95]++;
	      if ((cov_2b92ly2zmp().b[45][0]++, delta.length === 3) && (cov_2b92ly2zmp().b[45][1]++, delta[2] === 3)) {
	        cov_2b92ly2zmp().b[44][0]++;
	        cov_2b92ly2zmp().s[96]++;
	        return 'moved';
	      } else {
	        cov_2b92ly2zmp().b[44][1]++;
	      }
	    } else {
	      cov_2b92ly2zmp().b[37][1]++;
	      cov_2b92ly2zmp().s[97]++;
	      if (typeof delta === 'object') {
	        cov_2b92ly2zmp().b[46][0]++;
	        cov_2b92ly2zmp().s[98]++;
	        return 'node';
	      } else {
	        cov_2b92ly2zmp().b[46][1]++;
	      }
	    }
	    cov_2b92ly2zmp().s[99]++;
	    return 'unknown';
	  }
	  parseTextDiff(value) {
	    cov_2b92ly2zmp().f[17]++;
	    const output = (cov_2b92ly2zmp().s[100]++, []);
	    const lines = (cov_2b92ly2zmp().s[101]++, value.split('\n@@ '));
	    cov_2b92ly2zmp().s[102]++;
	    for (let i = (cov_2b92ly2zmp().s[103]++, 0), l = (cov_2b92ly2zmp().s[104]++, lines.length); i < l; i++) {
	      const line = (cov_2b92ly2zmp().s[105]++, lines[i]);
	      const lineOutput = (cov_2b92ly2zmp().s[106]++, {
	        pieces: []
	      });
	      const location = (cov_2b92ly2zmp().s[107]++, /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1));
	      cov_2b92ly2zmp().s[108]++;
	      lineOutput.location = {
	        line: location[0],
	        chr: location[1]
	      };
	      const pieces = (cov_2b92ly2zmp().s[109]++, line.split('\n').slice(1));
	      cov_2b92ly2zmp().s[110]++;
	      for (let pieceIndex = (cov_2b92ly2zmp().s[111]++, 0), piecesLength = (cov_2b92ly2zmp().s[112]++, pieces.length); pieceIndex < piecesLength; pieceIndex++) {
	        const piece = (cov_2b92ly2zmp().s[113]++, pieces[pieceIndex]);
	        cov_2b92ly2zmp().s[114]++;
	        if (!piece.length) {
	          cov_2b92ly2zmp().b[47][0]++;
	          cov_2b92ly2zmp().s[115]++;
	          continue;
	        } else {
	          cov_2b92ly2zmp().b[47][1]++;
	        }
	        const pieceOutput = (cov_2b92ly2zmp().s[116]++, {
	          type: 'context'
	        });
	        cov_2b92ly2zmp().s[117]++;
	        if (piece.substr(0, 1) === '+') {
	          cov_2b92ly2zmp().b[48][0]++;
	          cov_2b92ly2zmp().s[118]++;
	          pieceOutput.type = 'added';
	        } else {
	          cov_2b92ly2zmp().b[48][1]++;
	          cov_2b92ly2zmp().s[119]++;
	          if (piece.substr(0, 1) === '-') {
	            cov_2b92ly2zmp().b[49][0]++;
	            cov_2b92ly2zmp().s[120]++;
	            pieceOutput.type = 'deleted';
	          } else {
	            cov_2b92ly2zmp().b[49][1]++;
	          }
	        }
	        cov_2b92ly2zmp().s[121]++;
	        pieceOutput.text = piece.slice(1);
	        cov_2b92ly2zmp().s[122]++;
	        lineOutput.pieces.push(pieceOutput);
	      }
	      cov_2b92ly2zmp().s[123]++;
	      output.push(lineOutput);
	    }
	    cov_2b92ly2zmp().s[124]++;
	    return output;
	  }
	}
	var base = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  default: BaseFormatter
	});
	function cov_rzt4n93sr() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/html.js";
	  var hash = "d12473e42bec778f005626b8004b210a1381c474";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/html.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 4,
	          column: 4
	        },
	        end: {
	          line: 4,
	          column: 65
	        }
	      },
	      "1": {
	        start: {
	          line: 7,
	          column: 4
	        },
	        end: {
	          line: 7,
	          column: 76
	        }
	      },
	      "2": {
	        start: {
	          line: 10,
	          column: 18
	        },
	        end: {
	          line: 10,
	          column: 43
	        }
	      },
	      "3": {
	        start: {
	          line: 11,
	          column: 4
	        },
	        end: {
	          line: 11,
	          column: 55
	        }
	      },
	      "4": {
	        start: {
	          line: 12,
	          column: 4
	        },
	        end: {
	          line: 22,
	          column: 5
	        }
	      },
	      "5": {
	        start: {
	          line: 12,
	          column: 17
	        },
	        end: {
	          line: 12,
	          column: 18
	        }
	      },
	      "6": {
	        start: {
	          line: 12,
	          column: 24
	        },
	        end: {
	          line: 12,
	          column: 36
	        }
	      },
	      "7": {
	        start: {
	          line: 13,
	          column: 19
	        },
	        end: {
	          line: 13,
	          column: 27
	        }
	      },
	      "8": {
	        start: {
	          line: 14,
	          column: 6
	        },
	        end: {
	          line: 14,
	          column: 269
	        }
	      },
	      "9": {
	        start: {
	          line: 15,
	          column: 21
	        },
	        end: {
	          line: 15,
	          column: 32
	        }
	      },
	      "10": {
	        start: {
	          line: 16,
	          column: 6
	        },
	        end: {
	          line: 20,
	          column: 7
	        }
	      },
	      "11": {
	        start: {
	          line: 16,
	          column: 28
	        },
	        end: {
	          line: 16,
	          column: 29
	        }
	      },
	      "12": {
	        start: {
	          line: 16,
	          column: 46
	        },
	        end: {
	          line: 16,
	          column: 59
	        }
	      },
	      "13": {
	        start: {
	          line: 18,
	          column: 22
	        },
	        end: {
	          line: 18,
	          column: 40
	        }
	      },
	      "14": {
	        start: {
	          line: 19,
	          column: 8
	        },
	        end: {
	          line: 19,
	          column: 118
	        }
	      },
	      "15": {
	        start: {
	          line: 21,
	          column: 6
	        },
	        end: {
	          line: 21,
	          column: 33
	        }
	      },
	      "16": {
	        start: {
	          line: 23,
	          column: 4
	        },
	        end: {
	          line: 23,
	          column: 25
	        }
	      },
	      "17": {
	        start: {
	          line: 26,
	          column: 22
	        },
	        end: {
	          line: 26,
	          column: 108
	        }
	      },
	      "18": {
	        start: {
	          line: 27,
	          column: 4
	        },
	        end: {
	          line: 27,
	          column: 66
	        }
	      },
	      "19": {
	        start: {
	          line: 30,
	          column: 4
	        },
	        end: {
	          line: 30,
	          column: 143
	        }
	      },
	      "20": {
	        start: {
	          line: 33,
	          column: 22
	        },
	        end: {
	          line: 33,
	          column: 108
	        }
	      },
	      "21": {
	        start: {
	          line: 34,
	          column: 4
	        },
	        end: {
	          line: 34,
	          column: 129
	        }
	      },
	      "22": {
	        start: {
	          line: 37,
	          column: 4
	        },
	        end: {
	          line: 37,
	          column: 25
	        }
	      },
	      "23": {
	        start: {
	          line: 44,
	          column: 4
	        },
	        end: {
	          line: 46,
	          column: 5
	        }
	      },
	      "24": {
	        start: {
	          line: 45,
	          column: 6
	        },
	        end: {
	          line: 45,
	          column: 13
	        }
	      },
	      "25": {
	        start: {
	          line: 47,
	          column: 4
	        },
	        end: {
	          line: 47,
	          column: 53
	        }
	      },
	      "26": {
	        start: {
	          line: 48,
	          column: 4
	        },
	        end: {
	          line: 48,
	          column: 36
	        }
	      },
	      "27": {
	        start: {
	          line: 49,
	          column: 4
	        },
	        end: {
	          line: 49,
	          column: 26
	        }
	      },
	      "28": {
	        start: {
	          line: 52,
	          column: 4
	        },
	        end: {
	          line: 54,
	          column: 5
	        }
	      },
	      "29": {
	        start: {
	          line: 53,
	          column: 6
	        },
	        end: {
	          line: 53,
	          column: 13
	        }
	      },
	      "30": {
	        start: {
	          line: 55,
	          column: 4
	        },
	        end: {
	          line: 55,
	          column: 53
	        }
	      },
	      "31": {
	        start: {
	          line: 56,
	          column: 4
	        },
	        end: {
	          line: 56,
	          column: 36
	        }
	      },
	      "32": {
	        start: {
	          line: 57,
	          column: 4
	        },
	        end: {
	          line: 57,
	          column: 26
	        }
	      },
	      "33": {
	        start: {
	          line: 61,
	          column: 21
	        },
	        end: {
	          line: 61,
	          column: 58
	        }
	      },
	      "34": {
	        start: {
	          line: 62,
	          column: 4
	        },
	        end: {
	          line: 62,
	          column: 87
	        }
	      },
	      "35": {
	        start: {
	          line: 63,
	          column: 4
	        },
	        end: {
	          line: 63,
	          column: 51
	        }
	      },
	      "36": {
	        start: {
	          line: 64,
	          column: 4
	        },
	        end: {
	          line: 64,
	          column: 25
	        }
	      },
	      "37": {
	        start: {
	          line: 67,
	          column: 4
	        },
	        end: {
	          line: 67,
	          column: 53
	        }
	      },
	      "38": {
	        start: {
	          line: 68,
	          column: 4
	        },
	        end: {
	          line: 68,
	          column: 40
	        }
	      },
	      "39": {
	        start: {
	          line: 69,
	          column: 4
	        },
	        end: {
	          line: 69,
	          column: 26
	        }
	      },
	      "40": {
	        start: {
	          line: 72,
	          column: 4
	        },
	        end: {
	          line: 72,
	          column: 78
	        }
	      },
	      "41": {
	        start: {
	          line: 73,
	          column: 4
	        },
	        end: {
	          line: 73,
	          column: 40
	        }
	      },
	      "42": {
	        start: {
	          line: 74,
	          column: 4
	        },
	        end: {
	          line: 74,
	          column: 90
	        }
	      },
	      "43": {
	        start: {
	          line: 75,
	          column: 4
	        },
	        end: {
	          line: 75,
	          column: 40
	        }
	      },
	      "44": {
	        start: {
	          line: 76,
	          column: 4
	        },
	        end: {
	          line: 76,
	          column: 26
	        }
	      },
	      "45": {
	        start: {
	          line: 79,
	          column: 4
	        },
	        end: {
	          line: 79,
	          column: 53
	        }
	      },
	      "46": {
	        start: {
	          line: 80,
	          column: 4
	        },
	        end: {
	          line: 80,
	          column: 40
	        }
	      },
	      "47": {
	        start: {
	          line: 81,
	          column: 4
	        },
	        end: {
	          line: 81,
	          column: 26
	        }
	      },
	      "48": {
	        start: {
	          line: 84,
	          column: 4
	        },
	        end: {
	          line: 84,
	          column: 53
	        }
	      },
	      "49": {
	        start: {
	          line: 85,
	          column: 4
	        },
	        end: {
	          line: 85,
	          column: 40
	        }
	      },
	      "50": {
	        start: {
	          line: 86,
	          column: 4
	        },
	        end: {
	          line: 86,
	          column: 88
	        }
	      },
	      "51": {
	        start: {
	          line: 89,
	          column: 4
	        },
	        end: {
	          line: 103,
	          column: 15
	        }
	      },
	      "52": {
	        start: {
	          line: 104,
	          column: 4
	        },
	        end: {
	          line: 104,
	          column: 29
	        }
	      },
	      "53": {
	        start: {
	          line: 107,
	          column: 4
	        },
	        end: {
	          line: 107,
	          column: 53
	        }
	      },
	      "54": {
	        start: {
	          line: 108,
	          column: 4
	        },
	        end: {
	          line: 108,
	          column: 49
	        }
	      },
	      "55": {
	        start: {
	          line: 109,
	          column: 4
	        },
	        end: {
	          line: 109,
	          column: 26
	        }
	      },
	      "56": {
	        start: {
	          line: 113,
	          column: 13
	        },
	        end: {
	          line: 113,
	          column: 17
	        }
	      },
	      "57": {
	        start: {
	          line: 114,
	          column: 23
	        },
	        end: {
	          line: 114,
	          column: 108
	        }
	      },
	      "58": {
	        start: {
	          line: 115,
	          column: 2
	        },
	        end: {
	          line: 117,
	          column: 3
	        }
	      },
	      "59": {
	        start: {
	          line: 115,
	          column: 15
	        },
	        end: {
	          line: 115,
	          column: 16
	        }
	      },
	      "60": {
	        start: {
	          line: 116,
	          column: 4
	        },
	        end: {
	          line: 116,
	          column: 64
	        }
	      },
	      "61": {
	        start: {
	          line: 118,
	          column: 2
	        },
	        end: {
	          line: 118,
	          column: 14
	        }
	      },
	      "62": {
	        start: {
	          line: 120,
	          column: 21
	        },
	        end: {
	          line: 173,
	          column: 1
	        }
	      },
	      "63": {
	        start: {
	          line: 121,
	          column: 15
	        },
	        end: {
	          line: 121,
	          column: 34
	        }
	      },
	      "64": {
	        start: {
	          line: 122,
	          column: 25
	        },
	        end: {
	          line: 128,
	          column: 3
	        }
	      },
	      "65": {
	        start: {
	          line: 126,
	          column: 8
	        },
	        end: {
	          line: 126,
	          column: 12
	        }
	      },
	      "66": {
	        start: {
	          line: 127,
	          column: 4
	        },
	        end: {
	          line: 127,
	          column: 36
	        }
	      },
	      "67": {
	        start: {
	          line: 129,
	          column: 22
	        },
	        end: {
	          line: 134,
	          column: 3
	        }
	      },
	      "68": {
	        start: {
	          line: 130,
	          column: 18
	        },
	        end: {
	          line: 130,
	          column: 44
	        }
	      },
	      "69": {
	        start: {
	          line: 131,
	          column: 4
	        },
	        end: {
	          line: 133,
	          column: 5
	        }
	      },
	      "70": {
	        start: {
	          line: 131,
	          column: 17
	        },
	        end: {
	          line: 131,
	          column: 18
	        }
	      },
	      "71": {
	        start: {
	          line: 131,
	          column: 24
	        },
	        end: {
	          line: 131,
	          column: 36
	        }
	      },
	      "72": {
	        start: {
	          line: 132,
	          column: 6
	        },
	        end: {
	          line: 132,
	          column: 19
	        }
	      },
	      "73": {
	        start: {
	          line: 135,
	          column: 23
	        },
	        end: {
	          line: 142,
	          column: 3
	        }
	      },
	      "74": {
	        start: {
	          line: 138,
	          column: 8
	        },
	        end: {
	          line: 138,
	          column: 13
	        }
	      },
	      "75": {
	        start: {
	          line: 139,
	          column: 4
	        },
	        end: {
	          line: 141,
	          column: 5
	        }
	      },
	      "76": {
	        start: {
	          line: 139,
	          column: 17
	        },
	        end: {
	          line: 139,
	          column: 18
	        }
	      },
	      "77": {
	        start: {
	          line: 139,
	          column: 24
	        },
	        end: {
	          line: 139,
	          column: 39
	        }
	      },
	      "78": {
	        start: {
	          line: 140,
	          column: 6
	        },
	        end: {
	          line: 140,
	          column: 25
	        }
	      },
	      "79": {
	        start: {
	          line: 143,
	          column: 2
	        },
	        end: {
	          line: 172,
	          column: 5
	        }
	      },
	      "80": {
	        start: {
	          line: 148,
	          column: 8
	        },
	        end: {
	          line: 148,
	          column: 13
	        }
	      },
	      "81": {
	        start: {
	          line: 149,
	          column: 24
	        },
	        end: {
	          line: 149,
	          column: 34
	        }
	      },
	      "82": {
	        start: {
	          line: 150,
	          column: 16
	        },
	        end: {
	          line: 150,
	          column: 27
	        }
	      },
	      "83": {
	        start: {
	          line: 151,
	          column: 17
	        },
	        end: {
	          line: 151,
	          column: 32
	        }
	      },
	      "84": {
	        start: {
	          line: 152,
	          column: 4
	        },
	        end: {
	          line: 152,
	          column: 31
	        }
	      },
	      "85": {
	        start: {
	          line: 153,
	          column: 24
	        },
	        end: {
	          line: 153,
	          column: 101
	        }
	      },
	      "86": {
	        start: {
	          line: 154,
	          column: 22
	        },
	        end: {
	          line: 154,
	          column: 44
	        }
	      },
	      "87": {
	        start: {
	          line: 156,
	          column: 4
	        },
	        end: {
	          line: 160,
	          column: 7
	        }
	      },
	      "88": {
	        start: {
	          line: 157,
	          column: 6
	        },
	        end: {
	          line: 159,
	          column: 7
	        }
	      },
	      "89": {
	        start: {
	          line: 158,
	          column: 8
	        },
	        end: {
	          line: 158,
	          column: 32
	        }
	      },
	      "90": {
	        start: {
	          line: 161,
	          column: 4
	        },
	        end: {
	          line: 163,
	          column: 5
	        }
	      },
	      "91": {
	        start: {
	          line: 162,
	          column: 6
	        },
	        end: {
	          line: 162,
	          column: 13
	        }
	      },
	      "92": {
	        start: {
	          line: 164,
	          column: 4
	        },
	        end: {
	          line: 171,
	          column: 20
	        }
	      },
	      "93": {
	        start: {
	          line: 165,
	          column: 23
	        },
	        end: {
	          line: 165,
	          column: 72
	        }
	      },
	      "94": {
	        start: {
	          line: 166,
	          column: 6
	        },
	        end: {
	          line: 166,
	          column: 57
	        }
	      },
	      "95": {
	        start: {
	          line: 167,
	          column: 6
	        },
	        end: {
	          line: 167,
	          column: 60
	        }
	      },
	      "96": {
	        start: {
	          line: 168,
	          column: 20
	        },
	        end: {
	          line: 168,
	          column: 154
	        }
	      },
	      "97": {
	        start: {
	          line: 169,
	          column: 6
	        },
	        end: {
	          line: 169,
	          column: 36
	        }
	      },
	      "98": {
	        start: {
	          line: 170,
	          column: 6
	        },
	        end: {
	          line: 170,
	          column: 29
	        }
	      },
	      "99": {
	        start: {
	          line: 178,
	          column: 29
	        },
	        end: {
	          line: 230,
	          column: 1
	        }
	      },
	      "100": {
	        start: {
	          line: 179,
	          column: 13
	        },
	        end: {
	          line: 179,
	          column: 34
	        }
	      },
	      "101": {
	        start: {
	          line: 180,
	          column: 17
	        },
	        end: {
	          line: 180,
	          column: 43
	        }
	      },
	      "102": {
	        start: {
	          line: 181,
	          column: 18
	        },
	        end: {
	          line: 186,
	          column: 3
	        }
	      },
	      "103": {
	        start: {
	          line: 187,
	          column: 15
	        },
	        end: {
	          line: 187,
	          column: 27
	        }
	      },
	      "104": {
	        start: {
	          line: 188,
	          column: 2
	        },
	        end: {
	          line: 190,
	          column: 3
	        }
	      },
	      "105": {
	        start: {
	          line: 189,
	          column: 4
	        },
	        end: {
	          line: 189,
	          column: 11
	        }
	      },
	      "106": {
	        start: {
	          line: 191,
	          column: 2
	        },
	        end: {
	          line: 200,
	          column: 3
	        }
	      },
	      "107": {
	        start: {
	          line: 192,
	          column: 4
	        },
	        end: {
	          line: 192,
	          column: 33
	        }
	      },
	      "108": {
	        start: {
	          line: 193,
	          column: 4
	        },
	        end: {
	          line: 193,
	          column: 32
	        }
	      },
	      "109": {
	        start: {
	          line: 194,
	          column: 4
	        },
	        end: {
	          line: 194,
	          column: 33
	        }
	      },
	      "110": {
	        start: {
	          line: 195,
	          column: 4
	        },
	        end: {
	          line: 195,
	          column: 32
	        }
	      },
	      "111": {
	        start: {
	          line: 196,
	          column: 4
	        },
	        end: {
	          line: 198,
	          column: 5
	        }
	      },
	      "112": {
	        start: {
	          line: 197,
	          column: 6
	        },
	        end: {
	          line: 197,
	          column: 31
	        }
	      },
	      "113": {
	        start: {
	          line: 199,
	          column: 4
	        },
	        end: {
	          line: 199,
	          column: 11
	        }
	      },
	      "114": {
	        start: {
	          line: 201,
	          column: 2
	        },
	        end: {
	          line: 211,
	          column: 3
	        }
	      },
	      "115": {
	        start: {
	          line: 202,
	          column: 4
	        },
	        end: {
	          line: 202,
	          column: 33
	        }
	      },
	      "116": {
	        start: {
	          line: 203,
	          column: 4
	        },
	        end: {
	          line: 203,
	          column: 30
	        }
	      },
	      "117": {
	        start: {
	          line: 204,
	          column: 4
	        },
	        end: {
	          line: 206,
	          column: 11
	        }
	      },
	      "118": {
	        start: {
	          line: 205,
	          column: 6
	        },
	        end: {
	          line: 205,
	          column: 31
	        }
	      },
	      "119": {
	        start: {
	          line: 208,
	          column: 4
	        },
	        end: {
	          line: 208,
	          column: 32
	        }
	      },
	      "120": {
	        start: {
	          line: 209,
	          column: 4
	        },
	        end: {
	          line: 209,
	          column: 30
	        }
	      },
	      "121": {
	        start: {
	          line: 210,
	          column: 4
	        },
	        end: {
	          line: 210,
	          column: 32
	        }
	      },
	      "122": {
	        start: {
	          line: 212,
	          column: 21
	        },
	        end: {
	          line: 214,
	          column: 9
	        }
	      },
	      "123": {
	        start: {
	          line: 213,
	          column: 4
	        },
	        end: {
	          line: 213,
	          column: 21
	        }
	      },
	      "124": {
	        start: {
	          line: 215,
	          column: 2
	        },
	        end: {
	          line: 229,
	          column: 12
	        }
	      },
	      "125": {
	        start: {
	          line: 216,
	          column: 4
	        },
	        end: {
	          line: 216,
	          column: 33
	        }
	      },
	      "126": {
	        start: {
	          line: 217,
	          column: 4
	        },
	        end: {
	          line: 217,
	          column: 32
	        }
	      },
	      "127": {
	        start: {
	          line: 218,
	          column: 4
	        },
	        end: {
	          line: 224,
	          column: 5
	        }
	      },
	      "128": {
	        start: {
	          line: 219,
	          column: 6
	        },
	        end: {
	          line: 219,
	          column: 31
	        }
	      },
	      "129": {
	        start: {
	          line: 220,
	          column: 6
	        },
	        end: {
	          line: 220,
	          column: 35
	        }
	      },
	      "130": {
	        start: {
	          line: 222,
	          column: 6
	        },
	        end: {
	          line: 222,
	          column: 32
	        }
	      },
	      "131": {
	        start: {
	          line: 223,
	          column: 6
	        },
	        end: {
	          line: 223,
	          column: 34
	        }
	      },
	      "132": {
	        start: {
	          line: 225,
	          column: 4
	        },
	        end: {
	          line: 228,
	          column: 20
	        }
	      },
	      "133": {
	        start: {
	          line: 226,
	          column: 6
	        },
	        end: {
	          line: 226,
	          column: 35
	        }
	      },
	      "134": {
	        start: {
	          line: 227,
	          column: 6
	        },
	        end: {
	          line: 227,
	          column: 32
	        }
	      },
	      "135": {
	        start: {
	          line: 231,
	          column: 29
	        },
	        end: {
	          line: 231,
	          column: 79
	        }
	      },
	      "136": {
	        start: {
	          line: 231,
	          column: 46
	        },
	        end: {
	          line: 231,
	          column: 79
	        }
	      },
	      "137": {
	        start: {
	          line: 235,
	          column: 2
	        },
	        end: {
	          line: 237,
	          column: 3
	        }
	      },
	      "138": {
	        start: {
	          line: 236,
	          column: 4
	        },
	        end: {
	          line: 236,
	          column: 42
	        }
	      },
	      "139": {
	        start: {
	          line: 238,
	          column: 2
	        },
	        end: {
	          line: 238,
	          column: 45
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 3,
	            column: 2
	          },
	          end: {
	            line: 3,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 3,
	            column: 45
	          },
	          end: {
	            line: 5,
	            column: 3
	          }
	        },
	        line: 3
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 6,
	            column: 2
	          },
	          end: {
	            line: 6,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 6,
	            column: 30
	          },
	          end: {
	            line: 8,
	            column: 3
	          }
	        },
	        line: 6
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 9,
	            column: 2
	          },
	          end: {
	            line: 9,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 9,
	            column: 39
	          },
	          end: {
	            line: 24,
	            column: 3
	          }
	        },
	        line: 9
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 25,
	            column: 2
	          },
	          end: {
	            line: 25,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 25,
	            column: 37
	          },
	          end: {
	            line: 28,
	            column: 3
	          }
	        },
	        line: 25
	      },
	      "4": {
	        name: "(anonymous_4)",
	        decl: {
	          start: {
	            line: 29,
	            column: 2
	          },
	          end: {
	            line: 29,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 29,
	            column: 19
	          },
	          end: {
	            line: 31,
	            column: 3
	          }
	        },
	        line: 29
	      },
	      "5": {
	        name: "(anonymous_5)",
	        decl: {
	          start: {
	            line: 32,
	            column: 2
	          },
	          end: {
	            line: 32,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 32,
	            column: 51
	          },
	          end: {
	            line: 35,
	            column: 3
	          }
	        },
	        line: 32
	      },
	      "6": {
	        name: "(anonymous_6)",
	        decl: {
	          start: {
	            line: 36,
	            column: 2
	          },
	          end: {
	            line: 36,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 36,
	            column: 19
	          },
	          end: {
	            line: 38,
	            column: 3
	          }
	        },
	        line: 36
	      },
	      "7": {
	        name: "(anonymous_7)",
	        decl: {
	          start: {
	            line: 43,
	            column: 2
	          },
	          end: {
	            line: 43,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 43,
	            column: 41
	          },
	          end: {
	            line: 50,
	            column: 3
	          }
	        },
	        line: 43
	      },
	      "8": {
	        name: "(anonymous_8)",
	        decl: {
	          start: {
	            line: 51,
	            column: 2
	          },
	          end: {
	            line: 51,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 51,
	            column: 47
	          },
	          end: {
	            line: 58,
	            column: 3
	          }
	        },
	        line: 51
	      },
	      "9": {
	        name: "(anonymous_9)",
	        decl: {
	          start: {
	            line: 59,
	            column: 2
	          },
	          end: {
	            line: 59,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 59,
	            column: 36
	          },
	          end: {
	            line: 65,
	            column: 3
	          }
	        },
	        line: 59
	      },
	      "10": {
	        name: "(anonymous_10)",
	        decl: {
	          start: {
	            line: 66,
	            column: 2
	          },
	          end: {
	            line: 66,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 66,
	            column: 31
	          },
	          end: {
	            line: 70,
	            column: 3
	          }
	        },
	        line: 66
	      },
	      "11": {
	        name: "(anonymous_11)",
	        decl: {
	          start: {
	            line: 71,
	            column: 2
	          },
	          end: {
	            line: 71,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 71,
	            column: 34
	          },
	          end: {
	            line: 77,
	            column: 3
	          }
	        },
	        line: 71
	      },
	      "12": {
	        name: "(anonymous_12)",
	        decl: {
	          start: {
	            line: 78,
	            column: 2
	          },
	          end: {
	            line: 78,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 78,
	            column: 33
	          },
	          end: {
	            line: 82,
	            column: 3
	          }
	        },
	        line: 78
	      },
	      "13": {
	        name: "(anonymous_13)",
	        decl: {
	          start: {
	            line: 83,
	            column: 2
	          },
	          end: {
	            line: 83,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 83,
	            column: 31
	          },
	          end: {
	            line: 105,
	            column: 3
	          }
	        },
	        line: 83
	      },
	      "14": {
	        name: "(anonymous_14)",
	        decl: {
	          start: {
	            line: 106,
	            column: 2
	          },
	          end: {
	            line: 106,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 106,
	            column: 34
	          },
	          end: {
	            line: 110,
	            column: 3
	          }
	        },
	        line: 106
	      },
	      "15": {
	        name: "htmlEscape",
	        decl: {
	          start: {
	            line: 112,
	            column: 9
	          },
	          end: {
	            line: 112,
	            column: 19
	          }
	        },
	        loc: {
	          start: {
	            line: 112,
	            column: 26
	          },
	          end: {
	            line: 119,
	            column: 1
	          }
	        },
	        line: 112
	      },
	      "16": {
	        name: "jsondiffpatchHtmlFormatterAdjustArrows",
	        decl: {
	          start: {
	            line: 120,
	            column: 30
	          },
	          end: {
	            line: 120,
	            column: 68
	          }
	        },
	        loc: {
	          start: {
	            line: 120,
	            column: 78
	          },
	          end: {
	            line: 173,
	            column: 1
	          }
	        },
	        line: 120
	      },
	      "17": {
	        name: "(anonymous_17)",
	        decl: {
	          start: {
	            line: 122,
	            column: 25
	          },
	          end: {
	            line: 122,
	            column: 26
	          }
	        },
	        loc: {
	          start: {
	            line: 122,
	            column: 33
	          },
	          end: {
	            line: 128,
	            column: 3
	          }
	        },
	        line: 122
	      },
	      "18": {
	        name: "(anonymous_18)",
	        decl: {
	          start: {
	            line: 129,
	            column: 22
	          },
	          end: {
	            line: 129,
	            column: 23
	          }
	        },
	        loc: {
	          start: {
	            line: 129,
	            column: 41
	          },
	          end: {
	            line: 134,
	            column: 3
	          }
	        },
	        line: 129
	      },
	      "19": {
	        name: "(anonymous_19)",
	        decl: {
	          start: {
	            line: 135,
	            column: 23
	          },
	          end: {
	            line: 135,
	            column: 24
	          }
	        },
	        loc: {
	          start: {
	            line: 135,
	            column: 38
	          },
	          end: {
	            line: 142,
	            column: 3
	          }
	        },
	        line: 135
	      },
	      "20": {
	        name: "(anonymous_20)",
	        decl: {
	          start: {
	            line: 143,
	            column: 44
	          },
	          end: {
	            line: 143,
	            column: 45
	          }
	        },
	        loc: {
	          start: {
	            line: 143,
	            column: 53
	          },
	          end: {
	            line: 172,
	            column: 3
	          }
	        },
	        line: 143
	      },
	      "21": {
	        name: "(anonymous_21)",
	        decl: {
	          start: {
	            line: 156,
	            column: 28
	          },
	          end: {
	            line: 156,
	            column: 29
	          }
	        },
	        loc: {
	          start: {
	            line: 156,
	            column: 37
	          },
	          end: {
	            line: 160,
	            column: 5
	          }
	        },
	        line: 156
	      },
	      "22": {
	        name: "(anonymous_22)",
	        decl: {
	          start: {
	            line: 178,
	            column: 29
	          },
	          end: {
	            line: 178,
	            column: 30
	          }
	        },
	        loc: {
	          start: {
	            line: 178,
	            column: 52
	          },
	          end: {
	            line: 230,
	            column: 1
	          }
	        },
	        line: 178
	      },
	      "23": {
	        name: "(anonymous_23)",
	        decl: {
	          start: {
	            line: 204,
	            column: 15
	          },
	          end: {
	            line: 204,
	            column: 16
	          }
	        },
	        loc: {
	          start: {
	            line: 204,
	            column: 21
	          },
	          end: {
	            line: 206,
	            column: 5
	          }
	        },
	        line: 204
	      },
	      "24": {
	        name: "(anonymous_24)",
	        decl: {
	          start: {
	            line: 212,
	            column: 33
	          },
	          end: {
	            line: 212,
	            column: 34
	          }
	        },
	        loc: {
	          start: {
	            line: 212,
	            column: 39
	          },
	          end: {
	            line: 214,
	            column: 3
	          }
	        },
	        line: 212
	      },
	      "25": {
	        name: "(anonymous_25)",
	        decl: {
	          start: {
	            line: 215,
	            column: 13
	          },
	          end: {
	            line: 215,
	            column: 14
	          }
	        },
	        loc: {
	          start: {
	            line: 215,
	            column: 19
	          },
	          end: {
	            line: 229,
	            column: 3
	          }
	        },
	        line: 215
	      },
	      "26": {
	        name: "(anonymous_26)",
	        decl: {
	          start: {
	            line: 225,
	            column: 15
	          },
	          end: {
	            line: 225,
	            column: 16
	          }
	        },
	        loc: {
	          start: {
	            line: 225,
	            column: 21
	          },
	          end: {
	            line: 228,
	            column: 5
	          }
	        },
	        line: 225
	      },
	      "27": {
	        name: "(anonymous_27)",
	        decl: {
	          start: {
	            line: 231,
	            column: 29
	          },
	          end: {
	            line: 231,
	            column: 30
	          }
	        },
	        loc: {
	          start: {
	            line: 231,
	            column: 46
	          },
	          end: {
	            line: 231,
	            column: 79
	          }
	        },
	        line: 231
	      },
	      "28": {
	        name: "format",
	        decl: {
	          start: {
	            line: 234,
	            column: 16
	          },
	          end: {
	            line: 234,
	            column: 22
	          }
	        },
	        loc: {
	          start: {
	            line: 234,
	            column: 36
	          },
	          end: {
	            line: 239,
	            column: 1
	          }
	        },
	        line: 234
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 26,
	            column: 46
	          },
	          end: {
	            line: 26,
	            column: 106
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 26,
	            column: 57
	          },
	          end: {
	            line: 26,
	            column: 101
	          }
	        }, {
	          start: {
	            line: 26,
	            column: 104
	          },
	          end: {
	            line: 26,
	            column: 106
	          }
	        }],
	        line: 26
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 30,
	            column: 25
	          },
	          end: {
	            line: 30,
	            column: 139
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 30,
	            column: 45
	          },
	          end: {
	            line: 30,
	            column: 134
	          }
	        }, {
	          start: {
	            line: 30,
	            column: 137
	          },
	          end: {
	            line: 30,
	            column: 139
	          }
	        }],
	        line: 30
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 33,
	            column: 46
	          },
	          end: {
	            line: 33,
	            column: 106
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 33,
	            column: 57
	          },
	          end: {
	            line: 33,
	            column: 101
	          }
	        }, {
	          start: {
	            line: 33,
	            column: 104
	          },
	          end: {
	            line: 33,
	            column: 106
	          }
	        }],
	        line: 33
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 44,
	            column: 4
	          },
	          end: {
	            line: 46,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 44,
	            column: 4
	          },
	          end: {
	            line: 46,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 44
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 52,
	            column: 4
	          },
	          end: {
	            line: 54,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 52,
	            column: 4
	          },
	          end: {
	            line: 54,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 52
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 61,
	            column: 21
	          },
	          end: {
	            line: 61,
	            column: 58
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 61,
	            column: 40
	          },
	          end: {
	            line: 61,
	            column: 47
	          }
	        }, {
	          start: {
	            line: 61,
	            column: 50
	          },
	          end: {
	            line: 61,
	            column: 58
	          }
	        }],
	        line: 61
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 121,
	            column: 15
	          },
	          end: {
	            line: 121,
	            column: 34
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 121,
	            column: 15
	          },
	          end: {
	            line: 121,
	            column: 22
	          }
	        }, {
	          start: {
	            line: 121,
	            column: 26
	          },
	          end: {
	            line: 121,
	            column: 34
	          }
	        }],
	        line: 121
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 127,
	            column: 11
	          },
	          end: {
	            line: 127,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 127,
	            column: 11
	          },
	          end: {
	            line: 127,
	            column: 22
	          }
	        }, {
	          start: {
	            line: 127,
	            column: 26
	          },
	          end: {
	            line: 127,
	            column: 35
	          }
	        }],
	        line: 127
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 157,
	            column: 6
	          },
	          end: {
	            line: 159,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 157,
	            column: 6
	          },
	          end: {
	            line: 159,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 157
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 161,
	            column: 4
	          },
	          end: {
	            line: 163,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 161,
	            column: 4
	          },
	          end: {
	            line: 163,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 161
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 167,
	            column: 27
	          },
	          end: {
	            line: 167,
	            column: 54
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 167,
	            column: 42
	          },
	          end: {
	            line: 167,
	            column: 43
	          }
	        }, {
	          start: {
	            line: 167,
	            column: 46
	          },
	          end: {
	            line: 167,
	            column: 54
	          }
	        }],
	        line: 167
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 168,
	            column: 20
	          },
	          end: {
	            line: 168,
	            column: 154
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 168,
	            column: 35
	          },
	          end: {
	            line: 168,
	            column: 94
	          }
	        }, {
	          start: {
	            line: 168,
	            column: 97
	          },
	          end: {
	            line: 168,
	            column: 154
	          }
	        }],
	        line: 168
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 179,
	            column: 13
	          },
	          end: {
	            line: 179,
	            column: 34
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 179,
	            column: 13
	          },
	          end: {
	            line: 179,
	            column: 17
	          }
	        }, {
	          start: {
	            line: 179,
	            column: 21
	          },
	          end: {
	            line: 179,
	            column: 34
	          }
	        }],
	        line: 179
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 188,
	            column: 2
	          },
	          end: {
	            line: 190,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 188,
	            column: 2
	          },
	          end: {
	            line: 190,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 188
	      },
	      "14": {
	        loc: {
	          start: {
	            line: 191,
	            column: 2
	          },
	          end: {
	            line: 200,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 191,
	            column: 2
	          },
	          end: {
	            line: 200,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 191
	      },
	      "15": {
	        loc: {
	          start: {
	            line: 196,
	            column: 4
	          },
	          end: {
	            line: 198,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 196,
	            column: 4
	          },
	          end: {
	            line: 198,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 196
	      },
	      "16": {
	        loc: {
	          start: {
	            line: 201,
	            column: 2
	          },
	          end: {
	            line: 211,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 201,
	            column: 2
	          },
	          end: {
	            line: 211,
	            column: 3
	          }
	        }, {
	          start: {
	            line: 207,
	            column: 9
	          },
	          end: {
	            line: 211,
	            column: 3
	          }
	        }],
	        line: 201
	      },
	      "17": {
	        loc: {
	          start: {
	            line: 218,
	            column: 4
	          },
	          end: {
	            line: 224,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 218,
	            column: 4
	          },
	          end: {
	            line: 224,
	            column: 5
	          }
	        }, {
	          start: {
	            line: 221,
	            column: 11
	          },
	          end: {
	            line: 224,
	            column: 5
	          }
	        }],
	        line: 218
	      },
	      "18": {
	        loc: {
	          start: {
	            line: 235,
	            column: 2
	          },
	          end: {
	            line: 237,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 235,
	            column: 2
	          },
	          end: {
	            line: 237,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 235
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0,
	      "72": 0,
	      "73": 0,
	      "74": 0,
	      "75": 0,
	      "76": 0,
	      "77": 0,
	      "78": 0,
	      "79": 0,
	      "80": 0,
	      "81": 0,
	      "82": 0,
	      "83": 0,
	      "84": 0,
	      "85": 0,
	      "86": 0,
	      "87": 0,
	      "88": 0,
	      "89": 0,
	      "90": 0,
	      "91": 0,
	      "92": 0,
	      "93": 0,
	      "94": 0,
	      "95": 0,
	      "96": 0,
	      "97": 0,
	      "98": 0,
	      "99": 0,
	      "100": 0,
	      "101": 0,
	      "102": 0,
	      "103": 0,
	      "104": 0,
	      "105": 0,
	      "106": 0,
	      "107": 0,
	      "108": 0,
	      "109": 0,
	      "110": 0,
	      "111": 0,
	      "112": 0,
	      "113": 0,
	      "114": 0,
	      "115": 0,
	      "116": 0,
	      "117": 0,
	      "118": 0,
	      "119": 0,
	      "120": 0,
	      "121": 0,
	      "122": 0,
	      "123": 0,
	      "124": 0,
	      "125": 0,
	      "126": 0,
	      "127": 0,
	      "128": 0,
	      "129": 0,
	      "130": 0,
	      "131": 0,
	      "132": 0,
	      "133": 0,
	      "134": 0,
	      "135": 0,
	      "136": 0,
	      "137": 0,
	      "138": 0,
	      "139": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0],
	      "8": [0, 0],
	      "9": [0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0],
	      "13": [0, 0],
	      "14": [0, 0],
	      "15": [0, 0],
	      "16": [0, 0],
	      "17": [0, 0],
	      "18": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/html.js"],
	      sourcesContent: ["import BaseFormatter from './base';\n\nclass HtmlFormatter extends BaseFormatter {\n  typeFormattterErrorFormatter(context, err) {\n    context.out(`<pre class=\"jsondiffpatch-error\">${err}</pre>`);\n  }\n\n  formatValue(context, value) {\n    context.out(`<pre>${htmlEscape(JSON.stringify(value, null, 2))}</pre>`);\n  }\n\n  formatTextDiffString(context, value) {\n    const lines = this.parseTextDiff(value);\n    context.out('<ul class=\"jsondiffpatch-textdiff\">');\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      context.out(\n        '<li><div class=\"jsondiffpatch-textdiff-location\">' +\n          `<span class=\"jsondiffpatch-textdiff-line-number\">${\n            line.location.line\n          }</span><span class=\"jsondiffpatch-textdiff-char\">${\n            line.location.chr\n          }</span></div><div class=\"jsondiffpatch-textdiff-line\">`,\n      );\n      const pieces = line.pieces;\n      for (\n        let pieceIndex = 0, piecesLength = pieces.length;\n        pieceIndex < piecesLength;\n        pieceIndex++\n      ) {\n        /* global decodeURI */\n        const piece = pieces[pieceIndex];\n        context.out(\n          `<span class=\"jsondiffpatch-textdiff-${piece.type}\">${htmlEscape(\n            decodeURI(piece.text),\n          )}</span>`,\n        );\n      }\n      context.out('</div></li>');\n    }\n    context.out('</ul>');\n  }\n\n  rootBegin(context, type, nodeType) {\n    const nodeClass = `jsondiffpatch-${type}${\n      nodeType ? ` jsondiffpatch-child-node-type-${nodeType}` : ''\n    }`;\n    context.out(`<div class=\"jsondiffpatch-delta ${nodeClass}\">`);\n  }\n\n  rootEnd(context) {\n    context.out(\n      `</div>${\n        context.hasArrows\n          ? '<script type=\"text/javascript\">setTimeout(' +\n            `${adjustArrows.toString()},10);</script>`\n          : ''\n      }`,\n    );\n  }\n\n  nodeBegin(context, key, leftKey, type, nodeType) {\n    const nodeClass = `jsondiffpatch-${type}${\n      nodeType ? ` jsondiffpatch-child-node-type-${nodeType}` : ''\n    }`;\n    context.out(\n      `<li class=\"${nodeClass}\" data-key=\"${leftKey}\">` +\n        `<div class=\"jsondiffpatch-property-name\">${leftKey}</div>`,\n    );\n  }\n\n  nodeEnd(context) {\n    context.out('</li>');\n  }\n\n  /* jshint camelcase: false */\n  /* eslint-disable camelcase */\n\n  format_unchanged(context, delta, left) {\n    if (typeof left === 'undefined') {\n      return;\n    }\n    context.out('<div class=\"jsondiffpatch-value\">');\n    this.formatValue(context, left);\n    context.out('</div>');\n  }\n\n  format_movedestination(context, delta, left) {\n    if (typeof left === 'undefined') {\n      return;\n    }\n    context.out('<div class=\"jsondiffpatch-value\">');\n    this.formatValue(context, left);\n    context.out('</div>');\n  }\n\n  format_node(context, delta, left) {\n    // recurse\n    const nodeType = delta._t === 'a' ? 'array' : 'object';\n    context.out(\n      `<ul class=\"jsondiffpatch-node jsondiffpatch-node-type-${nodeType}\">`,\n    );\n    this.formatDeltaChildren(context, delta, left);\n    context.out('</ul>');\n  }\n\n  format_added(context, delta) {\n    context.out('<div class=\"jsondiffpatch-value\">');\n    this.formatValue(context, delta[0]);\n    context.out('</div>');\n  }\n\n  format_modified(context, delta) {\n    context.out('<div class=\"jsondiffpatch-value jsondiffpatch-left-value\">');\n    this.formatValue(context, delta[0]);\n    context.out(\n      '</div>' + '<div class=\"jsondiffpatch-value jsondiffpatch-right-value\">',\n    );\n    this.formatValue(context, delta[1]);\n    context.out('</div>');\n  }\n\n  format_deleted(context, delta) {\n    context.out('<div class=\"jsondiffpatch-value\">');\n    this.formatValue(context, delta[0]);\n    context.out('</div>');\n  }\n\n  format_moved(context, delta) {\n    context.out('<div class=\"jsondiffpatch-value\">');\n    this.formatValue(context, delta[0]);\n    context.out(\n      `</div><div class=\"jsondiffpatch-moved-destination\">${delta[1]}</div>`,\n    );\n\n    // draw an SVG arrow from here to move destination\n    context.out(\n      /* jshint multistr: true */\n      '<div class=\"jsondiffpatch-arrow\" ' +\n        `style=\"position: relative; left: -34px;\">\n          <svg width=\"30\" height=\"60\" ` +\n        `style=\"position: absolute; display: none;\">\n          <defs>\n              <marker id=\"markerArrow\" markerWidth=\"8\" markerHeight=\"8\"\n                 refx=\"2\" refy=\"4\"\n                     orient=\"auto\" markerUnits=\"userSpaceOnUse\">\n                  <path d=\"M1,1 L1,7 L7,4 L1,1\" style=\"fill: #339;\" />\n              </marker>\n          </defs>\n          <path d=\"M30,0 Q-10,25 26,50\"\n            style=\"stroke: #88f; stroke-width: 2px; fill: none; ` +\n        `stroke-opacity: 0.5; marker-end: url(#markerArrow);\"\n          ></path>\n          </svg>\n      </div>`,\n    );\n    context.hasArrows = true;\n  }\n\n  format_textdiff(context, delta) {\n    context.out('<div class=\"jsondiffpatch-value\">');\n    this.formatTextDiffString(context, delta[0]);\n    context.out('</div>');\n  }\n}\n\nfunction htmlEscape(text) {\n  let html = text;\n  const replacements = [\n    [/&/g, '&amp;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n    [/'/g, '&apos;'],\n    [/\"/g, '&quot;'],\n  ];\n  for (let i = 0; i < replacements.length; i++) {\n    html = html.replace(replacements[i][0], replacements[i][1]);\n  }\n  return html;\n}\n\nconst adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {\n  const node = nodeArg || document;\n  const getElementText = ({ textContent, innerText }) =>\n    textContent || innerText;\n  const eachByQuery = (el, query, fn) => {\n    const elems = el.querySelectorAll(query);\n    for (let i = 0, l = elems.length; i < l; i++) {\n      fn(elems[i]);\n    }\n  };\n  const eachChildren = ({ children }, fn) => {\n    for (let i = 0, l = children.length; i < l; i++) {\n      fn(children[i], i);\n    }\n  };\n  eachByQuery(\n    node,\n    '.jsondiffpatch-arrow',\n    ({ parentNode, children, style }) => {\n      const arrowParent = parentNode;\n      const svg = children[0];\n      const path = svg.children[1];\n      svg.style.display = 'none';\n      const destination = getElementText(\n        arrowParent.querySelector('.jsondiffpatch-moved-destination'),\n      );\n      const container = arrowParent.parentNode;\n      let destinationElem;\n      eachChildren(container, child => {\n        if (child.getAttribute('data-key') === destination) {\n          destinationElem = child;\n        }\n      });\n      if (!destinationElem) {\n        return;\n      }\n      try {\n        const distance = destinationElem.offsetTop - arrowParent.offsetTop;\n        svg.setAttribute('height', Math.abs(distance) + 6);\n        style.top = `${-8 + (distance > 0 ? 0 : distance)}px`;\n        const curve =\n          distance > 0\n            ? `M30,0 Q-10,${Math.round(distance / 2)} 26,${distance - 4}`\n            : `M30,${-distance} Q-10,${Math.round(-distance / 2)} 26,4`;\n        path.setAttribute('d', curve);\n        svg.style.display = '';\n      } catch (err) {}\n    },\n  );\n};\n\n/* jshint camelcase: true */\n/* eslint-enable camelcase */\n\nexport const showUnchanged = (show, node, delay) => {\n  const el = node || document.body;\n  const prefix = 'jsondiffpatch-unchanged-';\n  const classes = {\n    showing: `${prefix}showing`,\n    hiding: `${prefix}hiding`,\n    visible: `${prefix}visible`,\n    hidden: `${prefix}hidden`,\n  };\n  const list = el.classList;\n  if (!list) {\n    return;\n  }\n  if (!delay) {\n    list.remove(classes.showing);\n    list.remove(classes.hiding);\n    list.remove(classes.visible);\n    list.remove(classes.hidden);\n    if (show === false) {\n      list.add(classes.hidden);\n    }\n    return;\n  }\n  if (show === false) {\n    list.remove(classes.showing);\n    list.add(classes.visible);\n    setTimeout(() => {\n      list.add(classes.hiding);\n    }, 10);\n  } else {\n    list.remove(classes.hiding);\n    list.add(classes.showing);\n    list.remove(classes.hidden);\n  }\n  const intervalId = setInterval(() => {\n    adjustArrows(el);\n  }, 100);\n  setTimeout(() => {\n    list.remove(classes.showing);\n    list.remove(classes.hiding);\n    if (show === false) {\n      list.add(classes.hidden);\n      list.remove(classes.visible);\n    } else {\n      list.add(classes.visible);\n      list.remove(classes.hidden);\n    }\n    setTimeout(() => {\n      list.remove(classes.visible);\n      clearInterval(intervalId);\n    }, delay + 400);\n  }, delay);\n};\n\nexport const hideUnchanged = (node, delay) => showUnchanged(false, node, delay);\n\nexport default HtmlFormatter;\n\nlet defaultInstance;\n\nexport function format(delta, left) {\n  if (!defaultInstance) {\n    defaultInstance = new HtmlFormatter();\n  }\n  return defaultInstance.format(delta, left);\n}\n"],
	      names: ["BaseFormatter", "HtmlFormatter", "typeFormattterErrorFormatter", "context", "err", "out", "formatValue", "value", "htmlEscape", "JSON", "stringify", "formatTextDiffString", "lines", "parseTextDiff", "i", "l", "length", "line", "location", "chr", "pieces", "pieceIndex", "piecesLength", "piece", "type", "decodeURI", "text", "rootBegin", "nodeType", "nodeClass", "rootEnd", "hasArrows", "adjustArrows", "toString", "nodeBegin", "key", "leftKey", "nodeEnd", "format_unchanged", "delta", "left", "format_movedestination", "format_node", "_t", "formatDeltaChildren", "format_added", "format_modified", "format_deleted", "format_moved", "format_textdiff", "html", "replacements", "replace", "jsondiffpatchHtmlFormatterAdjustArrows", "nodeArg", "node", "document", "getElementText", "_ref", "textContent", "innerText", "eachByQuery", "el", "query", "fn", "elems", "querySelectorAll", "eachChildren", "_ref2", "children", "_ref3", "parentNode", "style", "arrowParent", "svg", "path", "display", "destination", "querySelector", "container", "destinationElem", "child", "getAttribute", "distance", "offsetTop", "setAttribute", "Math", "abs", "top", "curve", "round", "showUnchanged", "show", "delay", "body", "prefix", "classes", "showing", "hiding", "visible", "hidden", "list", "classList", "remove", "add", "setTimeout", "intervalId", "setInterval", "clearInterval", "hideUnchanged", "defaultInstance", "format"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "d12473e42bec778f005626b8004b210a1381c474"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_rzt4n93sr = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_rzt4n93sr();
	class HtmlFormatter extends BaseFormatter {
	  typeFormattterErrorFormatter(context, err) {
	    cov_rzt4n93sr().f[0]++;
	    cov_rzt4n93sr().s[0]++;
	    context.out(`<pre class="jsondiffpatch-error">${err}</pre>`);
	  }
	  formatValue(context, value) {
	    cov_rzt4n93sr().f[1]++;
	    cov_rzt4n93sr().s[1]++;
	    context.out(`<pre>${htmlEscape(JSON.stringify(value, null, 2))}</pre>`);
	  }
	  formatTextDiffString(context, value) {
	    cov_rzt4n93sr().f[2]++;
	    const lines = (cov_rzt4n93sr().s[2]++, this.parseTextDiff(value));
	    cov_rzt4n93sr().s[3]++;
	    context.out('<ul class="jsondiffpatch-textdiff">');
	    cov_rzt4n93sr().s[4]++;
	    for (let i = (cov_rzt4n93sr().s[5]++, 0), l = (cov_rzt4n93sr().s[6]++, lines.length); i < l; i++) {
	      const line = (cov_rzt4n93sr().s[7]++, lines[i]);
	      cov_rzt4n93sr().s[8]++;
	      context.out('<li><div class="jsondiffpatch-textdiff-location">' + `<span class="jsondiffpatch-textdiff-line-number">${line.location.line}</span><span class="jsondiffpatch-textdiff-char">${line.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`);
	      const pieces = (cov_rzt4n93sr().s[9]++, line.pieces);
	      cov_rzt4n93sr().s[10]++;
	      for (let pieceIndex = (cov_rzt4n93sr().s[11]++, 0), piecesLength = (cov_rzt4n93sr().s[12]++, pieces.length); pieceIndex < piecesLength; pieceIndex++) {
	        /* global decodeURI */const piece = (cov_rzt4n93sr().s[13]++, pieces[pieceIndex]);
	        cov_rzt4n93sr().s[14]++;
	        context.out(`<span class="jsondiffpatch-textdiff-${piece.type}">${htmlEscape(decodeURI(piece.text))}</span>`);
	      }
	      cov_rzt4n93sr().s[15]++;
	      context.out('</div></li>');
	    }
	    cov_rzt4n93sr().s[16]++;
	    context.out('</ul>');
	  }
	  rootBegin(context, type, nodeType) {
	    cov_rzt4n93sr().f[3]++;
	    const nodeClass = (cov_rzt4n93sr().s[17]++, `jsondiffpatch-${type}${nodeType ? (cov_rzt4n93sr().b[0][0]++, ` jsondiffpatch-child-node-type-${nodeType}`) : (cov_rzt4n93sr().b[0][1]++, '')}`);
	    cov_rzt4n93sr().s[18]++;
	    context.out(`<div class="jsondiffpatch-delta ${nodeClass}">`);
	  }
	  rootEnd(context) {
	    cov_rzt4n93sr().f[4]++;
	    cov_rzt4n93sr().s[19]++;
	    context.out(`</div>${context.hasArrows ? (cov_rzt4n93sr().b[1][0]++, '<script type="text/javascript">setTimeout(' + `${adjustArrows.toString()},10);</script>`) : (cov_rzt4n93sr().b[1][1]++, '')}`);
	  }
	  nodeBegin(context, key, leftKey, type, nodeType) {
	    cov_rzt4n93sr().f[5]++;
	    const nodeClass = (cov_rzt4n93sr().s[20]++, `jsondiffpatch-${type}${nodeType ? (cov_rzt4n93sr().b[2][0]++, ` jsondiffpatch-child-node-type-${nodeType}`) : (cov_rzt4n93sr().b[2][1]++, '')}`);
	    cov_rzt4n93sr().s[21]++;
	    context.out(`<li class="${nodeClass}" data-key="${leftKey}">` + `<div class="jsondiffpatch-property-name">${leftKey}</div>`);
	  }
	  nodeEnd(context) {
	    cov_rzt4n93sr().f[6]++;
	    cov_rzt4n93sr().s[22]++;
	    context.out('</li>');
	  } /* jshint camelcase: false */ /* eslint-disable camelcase */
	  format_unchanged(context, delta, left) {
	    cov_rzt4n93sr().f[7]++;
	    cov_rzt4n93sr().s[23]++;
	    if (typeof left === 'undefined') {
	      cov_rzt4n93sr().b[3][0]++;
	      cov_rzt4n93sr().s[24]++;
	      return;
	    } else {
	      cov_rzt4n93sr().b[3][1]++;
	    }
	    cov_rzt4n93sr().s[25]++;
	    context.out('<div class="jsondiffpatch-value">');
	    cov_rzt4n93sr().s[26]++;
	    this.formatValue(context, left);
	    cov_rzt4n93sr().s[27]++;
	    context.out('</div>');
	  }
	  format_movedestination(context, delta, left) {
	    cov_rzt4n93sr().f[8]++;
	    cov_rzt4n93sr().s[28]++;
	    if (typeof left === 'undefined') {
	      cov_rzt4n93sr().b[4][0]++;
	      cov_rzt4n93sr().s[29]++;
	      return;
	    } else {
	      cov_rzt4n93sr().b[4][1]++;
	    }
	    cov_rzt4n93sr().s[30]++;
	    context.out('<div class="jsondiffpatch-value">');
	    cov_rzt4n93sr().s[31]++;
	    this.formatValue(context, left);
	    cov_rzt4n93sr().s[32]++;
	    context.out('</div>');
	  }
	  format_node(context, delta, left) {
	    cov_rzt4n93sr().f[9]++; // recurse
	    const nodeType = (cov_rzt4n93sr().s[33]++, delta._t === 'a' ? (cov_rzt4n93sr().b[5][0]++, 'array') : (cov_rzt4n93sr().b[5][1]++, 'object'));
	    cov_rzt4n93sr().s[34]++;
	    context.out(`<ul class="jsondiffpatch-node jsondiffpatch-node-type-${nodeType}">`);
	    cov_rzt4n93sr().s[35]++;
	    this.formatDeltaChildren(context, delta, left);
	    cov_rzt4n93sr().s[36]++;
	    context.out('</ul>');
	  }
	  format_added(context, delta) {
	    cov_rzt4n93sr().f[10]++;
	    cov_rzt4n93sr().s[37]++;
	    context.out('<div class="jsondiffpatch-value">');
	    cov_rzt4n93sr().s[38]++;
	    this.formatValue(context, delta[0]);
	    cov_rzt4n93sr().s[39]++;
	    context.out('</div>');
	  }
	  format_modified(context, delta) {
	    cov_rzt4n93sr().f[11]++;
	    cov_rzt4n93sr().s[40]++;
	    context.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">');
	    cov_rzt4n93sr().s[41]++;
	    this.formatValue(context, delta[0]);
	    cov_rzt4n93sr().s[42]++;
	    context.out('</div>' + '<div class="jsondiffpatch-value jsondiffpatch-right-value">');
	    cov_rzt4n93sr().s[43]++;
	    this.formatValue(context, delta[1]);
	    cov_rzt4n93sr().s[44]++;
	    context.out('</div>');
	  }
	  format_deleted(context, delta) {
	    cov_rzt4n93sr().f[12]++;
	    cov_rzt4n93sr().s[45]++;
	    context.out('<div class="jsondiffpatch-value">');
	    cov_rzt4n93sr().s[46]++;
	    this.formatValue(context, delta[0]);
	    cov_rzt4n93sr().s[47]++;
	    context.out('</div>');
	  }
	  format_moved(context, delta) {
	    cov_rzt4n93sr().f[13]++;
	    cov_rzt4n93sr().s[48]++;
	    context.out('<div class="jsondiffpatch-value">');
	    cov_rzt4n93sr().s[49]++;
	    this.formatValue(context, delta[0]);
	    cov_rzt4n93sr().s[50]++;
	    context.out(`</div><div class="jsondiffpatch-moved-destination">${delta[1]}</div>`); // draw an SVG arrow from here to move destination
	    cov_rzt4n93sr().s[51]++;
	    context.out( /* jshint multistr: true */'<div class="jsondiffpatch-arrow" ' + `style="position: relative; left: -34px;">
          <svg width="30" height="60" ` + `style="position: absolute; display: none;">
          <defs>
              <marker id="markerArrow" markerWidth="8" markerHeight="8"
                 refx="2" refy="4"
                     orient="auto" markerUnits="userSpaceOnUse">
                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />
              </marker>
          </defs>
          <path d="M30,0 Q-10,25 26,50"
            style="stroke: #88f; stroke-width: 2px; fill: none; ` + `stroke-opacity: 0.5; marker-end: url(#markerArrow);"
          ></path>
          </svg>
      </div>`);
	    cov_rzt4n93sr().s[52]++;
	    context.hasArrows = true;
	  }
	  format_textdiff(context, delta) {
	    cov_rzt4n93sr().f[14]++;
	    cov_rzt4n93sr().s[53]++;
	    context.out('<div class="jsondiffpatch-value">');
	    cov_rzt4n93sr().s[54]++;
	    this.formatTextDiffString(context, delta[0]);
	    cov_rzt4n93sr().s[55]++;
	    context.out('</div>');
	  }
	}
	function htmlEscape(text) {
	  cov_rzt4n93sr().f[15]++;
	  let html = (cov_rzt4n93sr().s[56]++, text);
	  const replacements = (cov_rzt4n93sr().s[57]++, [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/'/g, '&apos;'], [/"/g, '&quot;']]);
	  cov_rzt4n93sr().s[58]++;
	  for (let i = (cov_rzt4n93sr().s[59]++, 0); i < replacements.length; i++) {
	    cov_rzt4n93sr().s[60]++;
	    html = html.replace(replacements[i][0], replacements[i][1]);
	  }
	  cov_rzt4n93sr().s[61]++;
	  return html;
	}
	cov_rzt4n93sr().s[62]++;
	const adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {
	  cov_rzt4n93sr().f[16]++;
	  const node = (cov_rzt4n93sr().s[63]++, (cov_rzt4n93sr().b[6][0]++, nodeArg) || (cov_rzt4n93sr().b[6][1]++, document));
	  cov_rzt4n93sr().s[64]++;
	  const getElementText = _ref => {
	    cov_rzt4n93sr().f[17]++;
	    let {
	      textContent,
	      innerText
	    } = (cov_rzt4n93sr().s[65]++, _ref);
	    cov_rzt4n93sr().s[66]++;
	    return (cov_rzt4n93sr().b[7][0]++, textContent) || (cov_rzt4n93sr().b[7][1]++, innerText);
	  };
	  cov_rzt4n93sr().s[67]++;
	  const eachByQuery = (el, query, fn) => {
	    cov_rzt4n93sr().f[18]++;
	    const elems = (cov_rzt4n93sr().s[68]++, el.querySelectorAll(query));
	    cov_rzt4n93sr().s[69]++;
	    for (let i = (cov_rzt4n93sr().s[70]++, 0), l = (cov_rzt4n93sr().s[71]++, elems.length); i < l; i++) {
	      cov_rzt4n93sr().s[72]++;
	      fn(elems[i]);
	    }
	  };
	  cov_rzt4n93sr().s[73]++;
	  const eachChildren = (_ref2, fn) => {
	    cov_rzt4n93sr().f[19]++;
	    let {
	      children
	    } = (cov_rzt4n93sr().s[74]++, _ref2);
	    cov_rzt4n93sr().s[75]++;
	    for (let i = (cov_rzt4n93sr().s[76]++, 0), l = (cov_rzt4n93sr().s[77]++, children.length); i < l; i++) {
	      cov_rzt4n93sr().s[78]++;
	      fn(children[i], i);
	    }
	  };
	  cov_rzt4n93sr().s[79]++;
	  eachByQuery(node, '.jsondiffpatch-arrow', _ref3 => {
	    cov_rzt4n93sr().f[20]++;
	    let {
	      parentNode,
	      children,
	      style
	    } = (cov_rzt4n93sr().s[80]++, _ref3);
	    const arrowParent = (cov_rzt4n93sr().s[81]++, parentNode);
	    const svg = (cov_rzt4n93sr().s[82]++, children[0]);
	    const path = (cov_rzt4n93sr().s[83]++, svg.children[1]);
	    cov_rzt4n93sr().s[84]++;
	    svg.style.display = 'none';
	    const destination = (cov_rzt4n93sr().s[85]++, getElementText(arrowParent.querySelector('.jsondiffpatch-moved-destination')));
	    const container = (cov_rzt4n93sr().s[86]++, arrowParent.parentNode);
	    let destinationElem;
	    cov_rzt4n93sr().s[87]++;
	    eachChildren(container, child => {
	      cov_rzt4n93sr().f[21]++;
	      cov_rzt4n93sr().s[88]++;
	      if (child.getAttribute('data-key') === destination) {
	        cov_rzt4n93sr().b[8][0]++;
	        cov_rzt4n93sr().s[89]++;
	        destinationElem = child;
	      } else {
	        cov_rzt4n93sr().b[8][1]++;
	      }
	    });
	    cov_rzt4n93sr().s[90]++;
	    if (!destinationElem) {
	      cov_rzt4n93sr().b[9][0]++;
	      cov_rzt4n93sr().s[91]++;
	      return;
	    } else {
	      cov_rzt4n93sr().b[9][1]++;
	    }
	    cov_rzt4n93sr().s[92]++;
	    try {
	      const distance = (cov_rzt4n93sr().s[93]++, destinationElem.offsetTop - arrowParent.offsetTop);
	      cov_rzt4n93sr().s[94]++;
	      svg.setAttribute('height', Math.abs(distance) + 6);
	      cov_rzt4n93sr().s[95]++;
	      style.top = `${-8 + (distance > 0 ? (cov_rzt4n93sr().b[10][0]++, 0) : (cov_rzt4n93sr().b[10][1]++, distance))}px`;
	      const curve = (cov_rzt4n93sr().s[96]++, distance > 0 ? (cov_rzt4n93sr().b[11][0]++, `M30,0 Q-10,${Math.round(distance / 2)} 26,${distance - 4}`) : (cov_rzt4n93sr().b[11][1]++, `M30,${-distance} Q-10,${Math.round(-distance / 2)} 26,4`));
	      cov_rzt4n93sr().s[97]++;
	      path.setAttribute('d', curve);
	      cov_rzt4n93sr().s[98]++;
	      svg.style.display = '';
	    } catch (err) {}
	  });
	}; /* jshint camelcase: true */ /* eslint-enable camelcase */
	cov_rzt4n93sr().s[99]++;
	const showUnchanged = (show, node, delay) => {
	  cov_rzt4n93sr().f[22]++;
	  const el = (cov_rzt4n93sr().s[100]++, (cov_rzt4n93sr().b[12][0]++, node) || (cov_rzt4n93sr().b[12][1]++, document.body));
	  const prefix = (cov_rzt4n93sr().s[101]++, 'jsondiffpatch-unchanged-');
	  const classes = (cov_rzt4n93sr().s[102]++, {
	    showing: `${prefix}showing`,
	    hiding: `${prefix}hiding`,
	    visible: `${prefix}visible`,
	    hidden: `${prefix}hidden`
	  });
	  const list = (cov_rzt4n93sr().s[103]++, el.classList);
	  cov_rzt4n93sr().s[104]++;
	  if (!list) {
	    cov_rzt4n93sr().b[13][0]++;
	    cov_rzt4n93sr().s[105]++;
	    return;
	  } else {
	    cov_rzt4n93sr().b[13][1]++;
	  }
	  cov_rzt4n93sr().s[106]++;
	  if (!delay) {
	    cov_rzt4n93sr().b[14][0]++;
	    cov_rzt4n93sr().s[107]++;
	    list.remove(classes.showing);
	    cov_rzt4n93sr().s[108]++;
	    list.remove(classes.hiding);
	    cov_rzt4n93sr().s[109]++;
	    list.remove(classes.visible);
	    cov_rzt4n93sr().s[110]++;
	    list.remove(classes.hidden);
	    cov_rzt4n93sr().s[111]++;
	    if (show === false) {
	      cov_rzt4n93sr().b[15][0]++;
	      cov_rzt4n93sr().s[112]++;
	      list.add(classes.hidden);
	    } else {
	      cov_rzt4n93sr().b[15][1]++;
	    }
	    cov_rzt4n93sr().s[113]++;
	    return;
	  } else {
	    cov_rzt4n93sr().b[14][1]++;
	  }
	  cov_rzt4n93sr().s[114]++;
	  if (show === false) {
	    cov_rzt4n93sr().b[16][0]++;
	    cov_rzt4n93sr().s[115]++;
	    list.remove(classes.showing);
	    cov_rzt4n93sr().s[116]++;
	    list.add(classes.visible);
	    cov_rzt4n93sr().s[117]++;
	    setTimeout(() => {
	      cov_rzt4n93sr().f[23]++;
	      cov_rzt4n93sr().s[118]++;
	      list.add(classes.hiding);
	    }, 10);
	  } else {
	    cov_rzt4n93sr().b[16][1]++;
	    cov_rzt4n93sr().s[119]++;
	    list.remove(classes.hiding);
	    cov_rzt4n93sr().s[120]++;
	    list.add(classes.showing);
	    cov_rzt4n93sr().s[121]++;
	    list.remove(classes.hidden);
	  }
	  const intervalId = (cov_rzt4n93sr().s[122]++, setInterval(() => {
	    cov_rzt4n93sr().f[24]++;
	    cov_rzt4n93sr().s[123]++;
	    adjustArrows(el);
	  }, 100));
	  cov_rzt4n93sr().s[124]++;
	  setTimeout(() => {
	    cov_rzt4n93sr().f[25]++;
	    cov_rzt4n93sr().s[125]++;
	    list.remove(classes.showing);
	    cov_rzt4n93sr().s[126]++;
	    list.remove(classes.hiding);
	    cov_rzt4n93sr().s[127]++;
	    if (show === false) {
	      cov_rzt4n93sr().b[17][0]++;
	      cov_rzt4n93sr().s[128]++;
	      list.add(classes.hidden);
	      cov_rzt4n93sr().s[129]++;
	      list.remove(classes.visible);
	    } else {
	      cov_rzt4n93sr().b[17][1]++;
	      cov_rzt4n93sr().s[130]++;
	      list.add(classes.visible);
	      cov_rzt4n93sr().s[131]++;
	      list.remove(classes.hidden);
	    }
	    cov_rzt4n93sr().s[132]++;
	    setTimeout(() => {
	      cov_rzt4n93sr().f[26]++;
	      cov_rzt4n93sr().s[133]++;
	      list.remove(classes.visible);
	      cov_rzt4n93sr().s[134]++;
	      clearInterval(intervalId);
	    }, delay + 400);
	  }, delay);
	};
	cov_rzt4n93sr().s[135]++;
	const hideUnchanged = (node, delay) => {
	  cov_rzt4n93sr().f[27]++;
	  cov_rzt4n93sr().s[136]++;
	  return showUnchanged(false, node, delay);
	};
	let defaultInstance$4;
	function format$3(delta, left) {
	  cov_rzt4n93sr().f[28]++;
	  cov_rzt4n93sr().s[137]++;
	  if (!defaultInstance$4) {
	    cov_rzt4n93sr().b[18][0]++;
	    cov_rzt4n93sr().s[138]++;
	    defaultInstance$4 = new HtmlFormatter();
	  } else {
	    cov_rzt4n93sr().b[18][1]++;
	  }
	  cov_rzt4n93sr().s[139]++;
	  return defaultInstance$4.format(delta, left);
	}
	var html = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  default: HtmlFormatter,
	  format: format$3,
	  hideUnchanged: hideUnchanged,
	  showUnchanged: showUnchanged
	});
	function cov_n1qx8kuqm() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/annotated.js";
	  var hash = "faa565abb59958ba52f34699e8df999b61a8faca";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/annotated.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 4,
	          column: 4
	        },
	        end: {
	          line: 4,
	          column: 12
	        }
	      },
	      "1": {
	        start: {
	          line: 5,
	          column: 4
	        },
	        end: {
	          line: 5,
	          column: 41
	        }
	      },
	      "2": {
	        start: {
	          line: 8,
	          column: 4
	        },
	        end: {
	          line: 8,
	          column: 34
	        }
	      },
	      "3": {
	        start: {
	          line: 9,
	          column: 4
	        },
	        end: {
	          line: 12,
	          column: 6
	        }
	      },
	      "4": {
	        start: {
	          line: 10,
	          column: 6
	        },
	        end: {
	          line: 10,
	          column: 96
	        }
	      },
	      "5": {
	        start: {
	          line: 11,
	          column: 6
	        },
	        end: {
	          line: 11,
	          column: 76
	        }
	      },
	      "6": {
	        start: {
	          line: 13,
	          column: 4
	        },
	        end: {
	          line: 21,
	          column: 6
	        }
	      },
	      "7": {
	        start: {
	          line: 14,
	          column: 6
	        },
	        end: {
	          line: 14,
	          column: 143
	        }
	      },
	      "8": {
	        start: {
	          line: 15,
	          column: 6
	        },
	        end: {
	          line: 15,
	          column: 37
	        }
	      },
	      "9": {
	        start: {
	          line: 16,
	          column: 6
	        },
	        end: {
	          line: 16,
	          column: 63
	        }
	      },
	      "10": {
	        start: {
	          line: 17,
	          column: 6
	        },
	        end: {
	          line: 17,
	          column: 24
	        }
	      },
	      "11": {
	        start: {
	          line: 18,
	          column: 6
	        },
	        end: {
	          line: 18,
	          column: 75
	        }
	      },
	      "12": {
	        start: {
	          line: 19,
	          column: 6
	        },
	        end: {
	          line: 19,
	          column: 28
	        }
	      },
	      "13": {
	        start: {
	          line: 20,
	          column: 6
	        },
	        end: {
	          line: 20,
	          column: 38
	        }
	      },
	      "14": {
	        start: {
	          line: 24,
	          column: 4
	        },
	        end: {
	          line: 24,
	          column: 69
	        }
	      },
	      "15": {
	        start: {
	          line: 27,
	          column: 18
	        },
	        end: {
	          line: 27,
	          column: 43
	        }
	      },
	      "16": {
	        start: {
	          line: 28,
	          column: 4
	        },
	        end: {
	          line: 28,
	          column: 55
	        }
	      },
	      "17": {
	        start: {
	          line: 29,
	          column: 4
	        },
	        end: {
	          line: 38,
	          column: 5
	        }
	      },
	      "18": {
	        start: {
	          line: 29,
	          column: 17
	        },
	        end: {
	          line: 29,
	          column: 18
	        }
	      },
	      "19": {
	        start: {
	          line: 29,
	          column: 24
	        },
	        end: {
	          line: 29,
	          column: 36
	        }
	      },
	      "20": {
	        start: {
	          line: 30,
	          column: 19
	        },
	        end: {
	          line: 30,
	          column: 27
	        }
	      },
	      "21": {
	        start: {
	          line: 31,
	          column: 6
	        },
	        end: {
	          line: 31,
	          column: 269
	        }
	      },
	      "22": {
	        start: {
	          line: 32,
	          column: 21
	        },
	        end: {
	          line: 32,
	          column: 32
	        }
	      },
	      "23": {
	        start: {
	          line: 33,
	          column: 6
	        },
	        end: {
	          line: 36,
	          column: 7
	        }
	      },
	      "24": {
	        start: {
	          line: 33,
	          column: 28
	        },
	        end: {
	          line: 33,
	          column: 29
	        }
	      },
	      "25": {
	        start: {
	          line: 33,
	          column: 46
	        },
	        end: {
	          line: 33,
	          column: 59
	        }
	      },
	      "26": {
	        start: {
	          line: 34,
	          column: 22
	        },
	        end: {
	          line: 34,
	          column: 40
	        }
	      },
	      "27": {
	        start: {
	          line: 35,
	          column: 8
	        },
	        end: {
	          line: 35,
	          column: 95
	        }
	      },
	      "28": {
	        start: {
	          line: 37,
	          column: 6
	        },
	        end: {
	          line: 37,
	          column: 33
	        }
	      },
	      "29": {
	        start: {
	          line: 39,
	          column: 4
	        },
	        end: {
	          line: 39,
	          column: 25
	        }
	      },
	      "30": {
	        start: {
	          line: 42,
	          column: 4
	        },
	        end: {
	          line: 42,
	          column: 65
	        }
	      },
	      "31": {
	        start: {
	          line: 43,
	          column: 4
	        },
	        end: {
	          line: 46,
	          column: 5
	        }
	      },
	      "32": {
	        start: {
	          line: 44,
	          column: 6
	        },
	        end: {
	          line: 44,
	          column: 23
	        }
	      },
	      "33": {
	        start: {
	          line: 45,
	          column: 6
	        },
	        end: {
	          line: 45,
	          column: 23
	        }
	      },
	      "34": {
	        start: {
	          line: 47,
	          column: 4
	        },
	        end: {
	          line: 49,
	          column: 5
	        }
	      },
	      "35": {
	        start: {
	          line: 48,
	          column: 6
	        },
	        end: {
	          line: 48,
	          column: 85
	        }
	      },
	      "36": {
	        start: {
	          line: 52,
	          column: 4
	        },
	        end: {
	          line: 55,
	          column: 5
	        }
	      },
	      "37": {
	        start: {
	          line: 53,
	          column: 6
	        },
	        end: {
	          line: 53,
	          column: 25
	        }
	      },
	      "38": {
	        start: {
	          line: 54,
	          column: 6
	        },
	        end: {
	          line: 54,
	          column: 23
	        }
	      },
	      "39": {
	        start: {
	          line: 56,
	          column: 4
	        },
	        end: {
	          line: 56,
	          column: 28
	        }
	      },
	      "40": {
	        start: {
	          line: 59,
	          column: 4
	        },
	        end: {
	          line: 59,
	          column: 41
	        }
	      },
	      "41": {
	        start: {
	          line: 60,
	          column: 4
	        },
	        end: {
	          line: 62,
	          column: 5
	        }
	      },
	      "42": {
	        start: {
	          line: 61,
	          column: 6
	        },
	        end: {
	          line: 61,
	          column: 23
	        }
	      },
	      "43": {
	        start: {
	          line: 63,
	          column: 4
	        },
	        end: {
	          line: 65,
	          column: 5
	        }
	      },
	      "44": {
	        start: {
	          line: 64,
	          column: 6
	        },
	        end: {
	          line: 64,
	          column: 85
	        }
	      },
	      "45": {
	        start: {
	          line: 68,
	          column: 4
	        },
	        end: {
	          line: 70,
	          column: 5
	        }
	      },
	      "46": {
	        start: {
	          line: 69,
	          column: 6
	        },
	        end: {
	          line: 69,
	          column: 25
	        }
	      },
	      "47": {
	        start: {
	          line: 71,
	          column: 4
	        },
	        end: {
	          line: 71,
	          column: 41
	        }
	      },
	      "48": {
	        start: {
	          line: 81,
	          column: 4
	        },
	        end: {
	          line: 81,
	          column: 51
	        }
	      },
	      "49": {
	        start: {
	          line: 87,
	          column: 25
	        },
	        end: {
	          line: 87,
	          column: 94
	        }
	      },
	      "50": {
	        start: {
	          line: 87,
	          column: 33
	        },
	        end: {
	          line: 87,
	          column: 94
	        }
	      },
	      "51": {
	        start: {
	          line: 88,
	          column: 25
	        },
	        end: {
	          line: 126,
	          column: 1
	        }
	      },
	      "52": {
	        start: {
	          line: 90,
	          column: 25
	        },
	        end: {
	          line: 90,
	          column: 51
	        }
	      },
	      "53": {
	        start: {
	          line: 91,
	          column: 4
	        },
	        end: {
	          line: 93,
	          column: 5
	        }
	      },
	      "54": {
	        start: {
	          line: 92,
	          column: 6
	        },
	        end: {
	          line: 92,
	          column: 40
	        }
	      },
	      "55": {
	        start: {
	          line: 94,
	          column: 4
	        },
	        end: {
	          line: 96,
	          column: 5
	        }
	      },
	      "56": {
	        start: {
	          line: 95,
	          column: 6
	        },
	        end: {
	          line: 95,
	          column: 57
	        }
	      },
	      "57": {
	        start: {
	          line: 97,
	          column: 4
	        },
	        end: {
	          line: 97,
	          column: 70
	        }
	      },
	      "58": {
	        start: {
	          line: 100,
	          column: 25
	        },
	        end: {
	          line: 100,
	          column: 66
	        }
	      },
	      "59": {
	        start: {
	          line: 101,
	          column: 4
	        },
	        end: {
	          line: 103,
	          column: 5
	        }
	      },
	      "60": {
	        start: {
	          line: 102,
	          column: 6
	        },
	        end: {
	          line: 102,
	          column: 43
	        }
	      },
	      "61": {
	        start: {
	          line: 104,
	          column: 4
	        },
	        end: {
	          line: 106,
	          column: 5
	        }
	      },
	      "62": {
	        start: {
	          line: 105,
	          column: 6
	        },
	        end: {
	          line: 105,
	          column: 57
	        }
	      },
	      "63": {
	        start: {
	          line: 107,
	          column: 4
	        },
	        end: {
	          line: 107,
	          column: 73
	        }
	      },
	      "64": {
	        start: {
	          line: 110,
	          column: 25
	        },
	        end: {
	          line: 110,
	          column: 62
	        }
	      },
	      "65": {
	        start: {
	          line: 111,
	          column: 4
	        },
	        end: {
	          line: 113,
	          column: 5
	        }
	      },
	      "66": {
	        start: {
	          line: 112,
	          column: 6
	        },
	        end: {
	          line: 112,
	          column: 43
	        }
	      },
	      "67": {
	        start: {
	          line: 114,
	          column: 4
	        },
	        end: {
	          line: 116,
	          column: 5
	        }
	      },
	      "68": {
	        start: {
	          line: 115,
	          column: 6
	        },
	        end: {
	          line: 115,
	          column: 54
	        }
	      },
	      "69": {
	        start: {
	          line: 117,
	          column: 4
	        },
	        end: {
	          line: 117,
	          column: 73
	        }
	      },
	      "70": {
	        start: {
	          line: 120,
	          column: 4
	        },
	        end: {
	          line: 120,
	          column: 188
	        }
	      },
	      "71": {
	        start: {
	          line: 123,
	          column: 21
	        },
	        end: {
	          line: 123,
	          column: 157
	        }
	      },
	      "72": {
	        start: {
	          line: 124,
	          column: 4
	        },
	        end: {
	          line: 124,
	          column: 150
	        }
	      },
	      "73": {
	        start: {
	          line: 127,
	          column: 24
	        },
	        end: {
	          line: 139,
	          column: 1
	        }
	      },
	      "74": {
	        start: {
	          line: 128,
	          column: 20
	        },
	        end: {
	          line: 128,
	          column: 44
	        }
	      },
	      "75": {
	        start: {
	          line: 129,
	          column: 20
	        },
	        end: {
	          line: 129,
	          column: 47
	        }
	      },
	      "76": {
	        start: {
	          line: 130,
	          column: 19
	        },
	        end: {
	          line: 130,
	          column: 100
	        }
	      },
	      "77": {
	        start: {
	          line: 131,
	          column: 13
	        },
	        end: {
	          line: 131,
	          column: 43
	        }
	      },
	      "78": {
	        start: {
	          line: 132,
	          column: 2
	        },
	        end: {
	          line: 135,
	          column: 3
	        }
	      },
	      "79": {
	        start: {
	          line: 134,
	          column: 4
	        },
	        end: {
	          line: 134,
	          column: 49
	        }
	      },
	      "80": {
	        start: {
	          line: 136,
	          column: 2
	        },
	        end: {
	          line: 136,
	          column: 19
	        }
	      },
	      "81": {
	        start: {
	          line: 137,
	          column: 2
	        },
	        end: {
	          line: 137,
	          column: 30
	        }
	      },
	      "82": {
	        start: {
	          line: 138,
	          column: 2
	        },
	        end: {
	          line: 138,
	          column: 21
	        }
	      },
	      "83": {
	        start: {
	          line: 142,
	          column: 0
	        },
	        end: {
	          line: 142,
	          column: 60
	        }
	      },
	      "84": {
	        start: {
	          line: 143,
	          column: 0
	        },
	        end: {
	          line: 143,
	          column: 63
	        }
	      },
	      "85": {
	        start: {
	          line: 144,
	          column: 0
	        },
	        end: {
	          line: 144,
	          column: 62
	        }
	      },
	      "86": {
	        start: {
	          line: 145,
	          column: 0
	        },
	        end: {
	          line: 145,
	          column: 60
	        }
	      },
	      "87": {
	        start: {
	          line: 146,
	          column: 0
	        },
	        end: {
	          line: 146,
	          column: 63
	        }
	      },
	      "88": {
	        start: {
	          line: 154,
	          column: 2
	        },
	        end: {
	          line: 156,
	          column: 3
	        }
	      },
	      "89": {
	        start: {
	          line: 155,
	          column: 4
	        },
	        end: {
	          line: 155,
	          column: 47
	        }
	      },
	      "90": {
	        start: {
	          line: 157,
	          column: 2
	        },
	        end: {
	          line: 157,
	          column: 45
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 3,
	            column: 2
	          },
	          end: {
	            line: 3,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 3,
	            column: 16
	          },
	          end: {
	            line: 6,
	            column: 3
	          }
	        },
	        line: 3
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 7,
	            column: 2
	          },
	          end: {
	            line: 7,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 7,
	            column: 26
	          },
	          end: {
	            line: 22,
	            column: 3
	          }
	        },
	        line: 7
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 9,
	            column: 21
	          },
	          end: {
	            line: 9,
	            column: 22
	          }
	        },
	        loc: {
	          start: {
	            line: 9,
	            column: 39
	          },
	          end: {
	            line: 12,
	            column: 5
	          }
	        },
	        line: 9
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 13,
	            column: 18
	          },
	          end: {
	            line: 13,
	            column: 19
	          }
	        },
	        loc: {
	          start: {
	            line: 13,
	            column: 38
	          },
	          end: {
	            line: 21,
	            column: 5
	          }
	        },
	        line: 13
	      },
	      "4": {
	        name: "(anonymous_4)",
	        decl: {
	          start: {
	            line: 23,
	            column: 2
	          },
	          end: {
	            line: 23,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 23,
	            column: 45
	          },
	          end: {
	            line: 25,
	            column: 3
	          }
	        },
	        line: 23
	      },
	      "5": {
	        name: "(anonymous_5)",
	        decl: {
	          start: {
	            line: 26,
	            column: 2
	          },
	          end: {
	            line: 26,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 26,
	            column: 39
	          },
	          end: {
	            line: 40,
	            column: 3
	          }
	        },
	        line: 26
	      },
	      "6": {
	        name: "(anonymous_6)",
	        decl: {
	          start: {
	            line: 41,
	            column: 2
	          },
	          end: {
	            line: 41,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 41,
	            column: 37
	          },
	          end: {
	            line: 50,
	            column: 3
	          }
	        },
	        line: 41
	      },
	      "7": {
	        name: "(anonymous_7)",
	        decl: {
	          start: {
	            line: 51,
	            column: 2
	          },
	          end: {
	            line: 51,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 51,
	            column: 25
	          },
	          end: {
	            line: 57,
	            column: 3
	          }
	        },
	        line: 51
	      },
	      "8": {
	        name: "(anonymous_8)",
	        decl: {
	          start: {
	            line: 58,
	            column: 2
	          },
	          end: {
	            line: 58,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 58,
	            column: 51
	          },
	          end: {
	            line: 66,
	            column: 3
	          }
	        },
	        line: 58
	      },
	      "9": {
	        name: "(anonymous_9)",
	        decl: {
	          start: {
	            line: 67,
	            column: 2
	          },
	          end: {
	            line: 67,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 67,
	            column: 57
	          },
	          end: {
	            line: 72,
	            column: 3
	          }
	        },
	        line: 67
	      },
	      "10": {
	        name: "(anonymous_10)",
	        decl: {
	          start: {
	            line: 77,
	            column: 2
	          },
	          end: {
	            line: 77,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 77,
	            column: 21
	          },
	          end: {
	            line: 77,
	            column: 23
	          }
	        },
	        line: 77
	      },
	      "11": {
	        name: "(anonymous_11)",
	        decl: {
	          start: {
	            line: 78,
	            column: 2
	          },
	          end: {
	            line: 78,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 78,
	            column: 27
	          },
	          end: {
	            line: 78,
	            column: 29
	          }
	        },
	        line: 78
	      },
	      "12": {
	        name: "(anonymous_12)",
	        decl: {
	          start: {
	            line: 79,
	            column: 2
	          },
	          end: {
	            line: 79,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 79,
	            column: 36
	          },
	          end: {
	            line: 82,
	            column: 3
	          }
	        },
	        line: 79
	      },
	      "13": {
	        name: "(anonymous_13)",
	        decl: {
	          start: {
	            line: 87,
	            column: 25
	          },
	          end: {
	            line: 87,
	            column: 26
	          }
	        },
	        loc: {
	          start: {
	            line: 87,
	            column: 33
	          },
	          end: {
	            line: 87,
	            column: 94
	          }
	        },
	        line: 87
	      },
	      "14": {
	        name: "(anonymous_14)",
	        decl: {
	          start: {
	            line: 89,
	            column: 2
	          },
	          end: {
	            line: 89,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 89,
	            column: 35
	          },
	          end: {
	            line: 98,
	            column: 3
	          }
	        },
	        line: 89
	      },
	      "15": {
	        name: "(anonymous_15)",
	        decl: {
	          start: {
	            line: 99,
	            column: 2
	          },
	          end: {
	            line: 99,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 99,
	            column: 38
	          },
	          end: {
	            line: 108,
	            column: 3
	          }
	        },
	        line: 99
	      },
	      "16": {
	        name: "(anonymous_16)",
	        decl: {
	          start: {
	            line: 109,
	            column: 2
	          },
	          end: {
	            line: 109,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 109,
	            column: 37
	          },
	          end: {
	            line: 118,
	            column: 3
	          }
	        },
	        line: 109
	      },
	      "17": {
	        name: "(anonymous_17)",
	        decl: {
	          start: {
	            line: 119,
	            column: 2
	          },
	          end: {
	            line: 119,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 119,
	            column: 35
	          },
	          end: {
	            line: 121,
	            column: 3
	          }
	        },
	        line: 119
	      },
	      "18": {
	        name: "(anonymous_18)",
	        decl: {
	          start: {
	            line: 122,
	            column: 2
	          },
	          end: {
	            line: 122,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 122,
	            column: 38
	          },
	          end: {
	            line: 125,
	            column: 3
	          }
	        },
	        line: 122
	      },
	      "19": {
	        name: "(anonymous_19)",
	        decl: {
	          start: {
	            line: 127,
	            column: 24
	          },
	          end: {
	            line: 127,
	            column: 25
	          }
	        },
	        loc: {
	          start: {
	            line: 127,
	            column: 50
	          },
	          end: {
	            line: 139,
	            column: 1
	          }
	        },
	        line: 127
	      },
	      "20": {
	        name: "format",
	        decl: {
	          start: {
	            line: 153,
	            column: 16
	          },
	          end: {
	            line: 153,
	            column: 22
	          }
	        },
	        loc: {
	          start: {
	            line: 153,
	            column: 36
	          },
	          end: {
	            line: 158,
	            column: 1
	          }
	        },
	        line: 153
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 10,
	            column: 26
	          },
	          end: {
	            line: 10,
	            column: 47
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 10,
	            column: 26
	          },
	          end: {
	            line: 10,
	            column: 42
	          }
	        }, {
	          start: {
	            line: 10,
	            column: 46
	          },
	          end: {
	            line: 10,
	            column: 47
	          }
	        }],
	        line: 10
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 10,
	            column: 52
	          },
	          end: {
	            line: 10,
	            column: 94
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 10,
	            column: 84
	          },
	          end: {
	            line: 10,
	            column: 85
	          }
	        }, {
	          start: {
	            line: 10,
	            column: 88
	          },
	          end: {
	            line: 10,
	            column: 94
	          }
	        }],
	        line: 10
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 43,
	            column: 4
	          },
	          end: {
	            line: 46,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 43,
	            column: 4
	          },
	          end: {
	            line: 46,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 43
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 47,
	            column: 4
	          },
	          end: {
	            line: 49,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 47,
	            column: 4
	          },
	          end: {
	            line: 49,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 47
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 52,
	            column: 4
	          },
	          end: {
	            line: 55,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 52,
	            column: 4
	          },
	          end: {
	            line: 55,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 52
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 60,
	            column: 4
	          },
	          end: {
	            line: 62,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 60,
	            column: 4
	          },
	          end: {
	            line: 62,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 60
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 63,
	            column: 4
	          },
	          end: {
	            line: 65,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 63,
	            column: 4
	          },
	          end: {
	            line: 65,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 63
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 68,
	            column: 4
	          },
	          end: {
	            line: 70,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 68,
	            column: 4
	          },
	          end: {
	            line: 70,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 68
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 71,
	            column: 20
	          },
	          end: {
	            line: 71,
	            column: 37
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 71,
	            column: 29
	          },
	          end: {
	            line: 71,
	            column: 31
	          }
	        }, {
	          start: {
	            line: 71,
	            column: 34
	          },
	          end: {
	            line: 71,
	            column: 37
	          }
	        }],
	        line: 71
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 91,
	            column: 4
	          },
	          end: {
	            line: 93,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 91,
	            column: 4
	          },
	          end: {
	            line: 93,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 91
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 94,
	            column: 4
	          },
	          end: {
	            line: 96,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 94,
	            column: 4
	          },
	          end: {
	            line: 96,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 94
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 101,
	            column: 4
	          },
	          end: {
	            line: 103,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 101,
	            column: 4
	          },
	          end: {
	            line: 103,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 101
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 104,
	            column: 4
	          },
	          end: {
	            line: 106,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 104,
	            column: 4
	          },
	          end: {
	            line: 106,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 104
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 111,
	            column: 4
	          },
	          end: {
	            line: 113,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 111,
	            column: 4
	          },
	          end: {
	            line: 113,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 111
	      },
	      "14": {
	        loc: {
	          start: {
	            line: 114,
	            column: 4
	          },
	          end: {
	            line: 116,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 114,
	            column: 4
	          },
	          end: {
	            line: 116,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 114
	      },
	      "15": {
	        loc: {
	          start: {
	            line: 123,
	            column: 21
	          },
	          end: {
	            line: 123,
	            column: 157
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 123,
	            column: 54
	          },
	          end: {
	            line: 123,
	            column: 56
	          }
	        }, {
	          start: {
	            line: 123,
	            column: 59
	          },
	          end: {
	            line: 123,
	            column: 157
	          }
	        }],
	        line: 123
	      },
	      "16": {
	        loc: {
	          start: {
	            line: 123,
	            column: 59
	          },
	          end: {
	            line: 123,
	            column: 157
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 123,
	            column: 89
	          },
	          end: {
	            line: 123,
	            column: 111
	          }
	        }, {
	          start: {
	            line: 123,
	            column: 114
	          },
	          end: {
	            line: 123,
	            column: 157
	          }
	        }],
	        line: 123
	      },
	      "17": {
	        loc: {
	          start: {
	            line: 130,
	            column: 19
	          },
	          end: {
	            line: 130,
	            column: 100
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 130,
	            column: 19
	          },
	          end: {
	            line: 130,
	            column: 28
	          }
	        }, {
	          start: {
	            line: 130,
	            column: 32
	          },
	          end: {
	            line: 130,
	            column: 100
	          }
	        }],
	        line: 130
	      },
	      "18": {
	        loc: {
	          start: {
	            line: 132,
	            column: 2
	          },
	          end: {
	            line: 135,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 132,
	            column: 2
	          },
	          end: {
	            line: 135,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 132
	      },
	      "19": {
	        loc: {
	          start: {
	            line: 154,
	            column: 2
	          },
	          end: {
	            line: 156,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 154,
	            column: 2
	          },
	          end: {
	            line: 156,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 154
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0,
	      "72": 0,
	      "73": 0,
	      "74": 0,
	      "75": 0,
	      "76": 0,
	      "77": 0,
	      "78": 0,
	      "79": 0,
	      "80": 0,
	      "81": 0,
	      "82": 0,
	      "83": 0,
	      "84": 0,
	      "85": 0,
	      "86": 0,
	      "87": 0,
	      "88": 0,
	      "89": 0,
	      "90": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0],
	      "8": [0, 0],
	      "9": [0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0],
	      "13": [0, 0],
	      "14": [0, 0],
	      "15": [0, 0],
	      "16": [0, 0],
	      "17": [0, 0],
	      "18": [0, 0],
	      "19": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/annotated.js"],
	      sourcesContent: ["import BaseFormatter from './base';\n\nclass AnnotatedFormatter extends BaseFormatter {\n  constructor() {\n    super();\n    this.includeMoveDestinations = false;\n  }\n\n  prepareContext(context) {\n    super.prepareContext(context);\n    context.indent = function(levels) {\n      this.indentLevel =\n        (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);\n      this.indentPad = new Array(this.indentLevel + 1).join('&nbsp;&nbsp;');\n    };\n    context.row = (json, htmlNote) => {\n      context.out(\n        '<tr><td style=\"white-space: nowrap;\">' +\n          '<pre class=\"jsondiffpatch-annotated-indent\"' +\n          ' style=\"display: inline-block\">',\n      );\n      context.out(context.indentPad);\n      context.out('</pre><pre style=\"display: inline-block\">');\n      context.out(json);\n      context.out('</pre></td><td class=\"jsondiffpatch-delta-note\"><div>');\n      context.out(htmlNote);\n      context.out('</div></td></tr>');\n    };\n  }\n\n  typeFormattterErrorFormatter(context, err) {\n    context.row('', `<pre class=\"jsondiffpatch-error\">${err}</pre>`);\n  }\n\n  formatTextDiffString(context, value) {\n    const lines = this.parseTextDiff(value);\n    context.out('<ul class=\"jsondiffpatch-textdiff\">');\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      context.out(\n        '<li><div class=\"jsondiffpatch-textdiff-location\">' +\n          `<span class=\"jsondiffpatch-textdiff-line-number\">${\n            line.location.line\n          }</span><span class=\"jsondiffpatch-textdiff-char\">${\n            line.location.chr\n          }</span></div><div class=\"jsondiffpatch-textdiff-line\">`,\n      );\n      const pieces = line.pieces;\n      for (\n        let pieceIndex = 0, piecesLength = pieces.length;\n        pieceIndex < piecesLength;\n        pieceIndex++\n      ) {\n        const piece = pieces[pieceIndex];\n        context.out(\n          `<span class=\"jsondiffpatch-textdiff-${piece.type}\">${\n            piece.text\n          }</span>`,\n        );\n      }\n      context.out('</div></li>');\n    }\n    context.out('</ul>');\n  }\n\n  rootBegin(context, type, nodeType) {\n    context.out('<table class=\"jsondiffpatch-annotated-delta\">');\n    if (type === 'node') {\n      context.row('{');\n      context.indent();\n    }\n    if (nodeType === 'array') {\n      context.row(\n        '\"_t\": \"a\",',\n        'Array delta (member names indicate array indices)',\n      );\n    }\n  }\n\n  rootEnd(context, type) {\n    if (type === 'node') {\n      context.indent(-1);\n      context.row('}');\n    }\n    context.out('</table>');\n  }\n\n  nodeBegin(context, key, leftKey, type, nodeType) {\n    context.row(`&quot;${key}&quot;: {`);\n    if (type === 'node') {\n      context.indent();\n    }\n    if (nodeType === 'array') {\n      context.row(\n        '\"_t\": \"a\",',\n        'Array delta (member names indicate array indices)',\n      );\n    }\n  }\n\n  nodeEnd(context, key, leftKey, type, nodeType, isLast) {\n    if (type === 'node') {\n      context.indent(-1);\n    }\n    context.row(`}${isLast ? '' : ','}`);\n  }\n\n  /* jshint camelcase: false */\n\n  /* eslint-disable camelcase */\n  format_unchanged() {}\n\n  format_movedestination() {}\n\n  format_node(context, delta, left) {\n    // recurse\n    this.formatDeltaChildren(context, delta, left);\n  }\n}\n\n/* eslint-enable camelcase */\n\nconst wrapPropertyName = name =>\n  `<pre style=\"display:inline-block\">&quot;${name}&quot;</pre>`;\n\nconst deltaAnnotations = {\n  added(delta, left, key, leftKey) {\n    const formatLegend = ' <pre>([newValue])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return `new value${formatLegend}`;\n    }\n    if (typeof leftKey === 'number') {\n      return `insert at index ${leftKey}${formatLegend}`;\n    }\n    return `add property ${wrapPropertyName(leftKey)}${formatLegend}`;\n  },\n  modified(delta, left, key, leftKey) {\n    const formatLegend = ' <pre>([previousValue, newValue])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return `modify value${formatLegend}`;\n    }\n    if (typeof leftKey === 'number') {\n      return `modify at index ${leftKey}${formatLegend}`;\n    }\n    return `modify property ${wrapPropertyName(leftKey)}${formatLegend}`;\n  },\n  deleted(delta, left, key, leftKey) {\n    const formatLegend = ' <pre>([previousValue, 0, 0])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return `delete value${formatLegend}`;\n    }\n    if (typeof leftKey === 'number') {\n      return `remove index ${leftKey}${formatLegend}`;\n    }\n    return `delete property ${wrapPropertyName(leftKey)}${formatLegend}`;\n  },\n  moved(delta, left, key, leftKey) {\n    return (\n      'move from <span title=\"(position to remove at original state)\">' +\n      `index ${leftKey}</span> to <span title=\"(position to insert at final` +\n      ` state)\">index ${delta[1]}</span>`\n    );\n  },\n  textdiff(delta, left, key, leftKey) {\n    const location =\n      typeof leftKey === 'undefined'\n        ? ''\n        : typeof leftKey === 'number'\n          ? ` at index ${leftKey}`\n          : ` at property ${wrapPropertyName(leftKey)}`;\n    return (\n      `text diff${location}, format is <a href=\"https://code.google.com/` +\n      'p/google-diff-match-patch/wiki/Unidiff\">a variation of Unidiff</a>'\n    );\n  },\n};\n\nconst formatAnyChange = function(context, delta) {\n  const deltaType = this.getDeltaType(delta);\n  const annotator = deltaAnnotations[deltaType];\n  const htmlNote =\n    annotator &&\n    annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));\n  let json = JSON.stringify(delta, null, 2);\n  if (deltaType === 'textdiff') {\n    // split text diffs lines\n    json = json.split('\\\\n').join('\\\\n\"+\\n   \"');\n  }\n  context.indent();\n  context.row(json, htmlNote);\n  context.indent(-1);\n};\n\n/* eslint-disable camelcase */\nAnnotatedFormatter.prototype.format_added = formatAnyChange;\nAnnotatedFormatter.prototype.format_modified = formatAnyChange;\nAnnotatedFormatter.prototype.format_deleted = formatAnyChange;\nAnnotatedFormatter.prototype.format_moved = formatAnyChange;\nAnnotatedFormatter.prototype.format_textdiff = formatAnyChange;\n/* eslint-enable camelcase */\n\n/* jshint camelcase: true */\n\nexport default AnnotatedFormatter;\n\nlet defaultInstance;\n\nexport function format(delta, left) {\n  if (!defaultInstance) {\n    defaultInstance = new AnnotatedFormatter();\n  }\n  return defaultInstance.format(delta, left);\n}\n"],
	      names: ["BaseFormatter", "AnnotatedFormatter", "constructor", "includeMoveDestinations", "prepareContext", "context", "indent", "levels", "indentLevel", "indentPad", "Array", "join", "row", "json", "htmlNote", "out", "typeFormattterErrorFormatter", "err", "formatTextDiffString", "value", "lines", "parseTextDiff", "i", "l", "length", "line", "location", "chr", "pieces", "pieceIndex", "piecesLength", "piece", "type", "text", "rootBegin", "nodeType", "rootEnd", "nodeBegin", "key", "leftKey", "nodeEnd", "isLast", "format_unchanged", "format_movedestination", "format_node", "delta", "left", "formatDeltaChildren", "wrapPropertyName", "name", "deltaAnnotations", "added", "formatLegend", "modified", "deleted", "moved", "textdiff", "formatAnyChange", "deltaType", "getDeltaType", "annotator", "apply", "prototype", "slice", "call", "arguments", "JSON", "stringify", "split", "format_added", "format_modified", "format_deleted", "format_moved", "format_textdiff", "defaultInstance", "format"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "faa565abb59958ba52f34699e8df999b61a8faca"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_n1qx8kuqm = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_n1qx8kuqm();
	class AnnotatedFormatter extends BaseFormatter {
	  constructor() {
	    cov_n1qx8kuqm().f[0]++;
	    cov_n1qx8kuqm().s[0]++;
	    super();
	    cov_n1qx8kuqm().s[1]++;
	    this.includeMoveDestinations = false;
	  }
	  prepareContext(context) {
	    cov_n1qx8kuqm().f[1]++;
	    cov_n1qx8kuqm().s[2]++;
	    super.prepareContext(context);
	    cov_n1qx8kuqm().s[3]++;
	    context.indent = function (levels) {
	      cov_n1qx8kuqm().f[2]++;
	      cov_n1qx8kuqm().s[4]++;
	      this.indentLevel = ((cov_n1qx8kuqm().b[0][0]++, this.indentLevel) || (cov_n1qx8kuqm().b[0][1]++, 0)) + (typeof levels === 'undefined' ? (cov_n1qx8kuqm().b[1][0]++, 1) : (cov_n1qx8kuqm().b[1][1]++, levels));
	      cov_n1qx8kuqm().s[5]++;
	      this.indentPad = new Array(this.indentLevel + 1).join('&nbsp;&nbsp;');
	    };
	    cov_n1qx8kuqm().s[6]++;
	    context.row = (json, htmlNote) => {
	      cov_n1qx8kuqm().f[3]++;
	      cov_n1qx8kuqm().s[7]++;
	      context.out('<tr><td style="white-space: nowrap;">' + '<pre class="jsondiffpatch-annotated-indent"' + ' style="display: inline-block">');
	      cov_n1qx8kuqm().s[8]++;
	      context.out(context.indentPad);
	      cov_n1qx8kuqm().s[9]++;
	      context.out('</pre><pre style="display: inline-block">');
	      cov_n1qx8kuqm().s[10]++;
	      context.out(json);
	      cov_n1qx8kuqm().s[11]++;
	      context.out('</pre></td><td class="jsondiffpatch-delta-note"><div>');
	      cov_n1qx8kuqm().s[12]++;
	      context.out(htmlNote);
	      cov_n1qx8kuqm().s[13]++;
	      context.out('</div></td></tr>');
	    };
	  }
	  typeFormattterErrorFormatter(context, err) {
	    cov_n1qx8kuqm().f[4]++;
	    cov_n1qx8kuqm().s[14]++;
	    context.row('', `<pre class="jsondiffpatch-error">${err}</pre>`);
	  }
	  formatTextDiffString(context, value) {
	    cov_n1qx8kuqm().f[5]++;
	    const lines = (cov_n1qx8kuqm().s[15]++, this.parseTextDiff(value));
	    cov_n1qx8kuqm().s[16]++;
	    context.out('<ul class="jsondiffpatch-textdiff">');
	    cov_n1qx8kuqm().s[17]++;
	    for (let i = (cov_n1qx8kuqm().s[18]++, 0), l = (cov_n1qx8kuqm().s[19]++, lines.length); i < l; i++) {
	      const line = (cov_n1qx8kuqm().s[20]++, lines[i]);
	      cov_n1qx8kuqm().s[21]++;
	      context.out('<li><div class="jsondiffpatch-textdiff-location">' + `<span class="jsondiffpatch-textdiff-line-number">${line.location.line}</span><span class="jsondiffpatch-textdiff-char">${line.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`);
	      const pieces = (cov_n1qx8kuqm().s[22]++, line.pieces);
	      cov_n1qx8kuqm().s[23]++;
	      for (let pieceIndex = (cov_n1qx8kuqm().s[24]++, 0), piecesLength = (cov_n1qx8kuqm().s[25]++, pieces.length); pieceIndex < piecesLength; pieceIndex++) {
	        const piece = (cov_n1qx8kuqm().s[26]++, pieces[pieceIndex]);
	        cov_n1qx8kuqm().s[27]++;
	        context.out(`<span class="jsondiffpatch-textdiff-${piece.type}">${piece.text}</span>`);
	      }
	      cov_n1qx8kuqm().s[28]++;
	      context.out('</div></li>');
	    }
	    cov_n1qx8kuqm().s[29]++;
	    context.out('</ul>');
	  }
	  rootBegin(context, type, nodeType) {
	    cov_n1qx8kuqm().f[6]++;
	    cov_n1qx8kuqm().s[30]++;
	    context.out('<table class="jsondiffpatch-annotated-delta">');
	    cov_n1qx8kuqm().s[31]++;
	    if (type === 'node') {
	      cov_n1qx8kuqm().b[2][0]++;
	      cov_n1qx8kuqm().s[32]++;
	      context.row('{');
	      cov_n1qx8kuqm().s[33]++;
	      context.indent();
	    } else {
	      cov_n1qx8kuqm().b[2][1]++;
	    }
	    cov_n1qx8kuqm().s[34]++;
	    if (nodeType === 'array') {
	      cov_n1qx8kuqm().b[3][0]++;
	      cov_n1qx8kuqm().s[35]++;
	      context.row('"_t": "a",', 'Array delta (member names indicate array indices)');
	    } else {
	      cov_n1qx8kuqm().b[3][1]++;
	    }
	  }
	  rootEnd(context, type) {
	    cov_n1qx8kuqm().f[7]++;
	    cov_n1qx8kuqm().s[36]++;
	    if (type === 'node') {
	      cov_n1qx8kuqm().b[4][0]++;
	      cov_n1qx8kuqm().s[37]++;
	      context.indent(-1);
	      cov_n1qx8kuqm().s[38]++;
	      context.row('}');
	    } else {
	      cov_n1qx8kuqm().b[4][1]++;
	    }
	    cov_n1qx8kuqm().s[39]++;
	    context.out('</table>');
	  }
	  nodeBegin(context, key, leftKey, type, nodeType) {
	    cov_n1qx8kuqm().f[8]++;
	    cov_n1qx8kuqm().s[40]++;
	    context.row(`&quot;${key}&quot;: {`);
	    cov_n1qx8kuqm().s[41]++;
	    if (type === 'node') {
	      cov_n1qx8kuqm().b[5][0]++;
	      cov_n1qx8kuqm().s[42]++;
	      context.indent();
	    } else {
	      cov_n1qx8kuqm().b[5][1]++;
	    }
	    cov_n1qx8kuqm().s[43]++;
	    if (nodeType === 'array') {
	      cov_n1qx8kuqm().b[6][0]++;
	      cov_n1qx8kuqm().s[44]++;
	      context.row('"_t": "a",', 'Array delta (member names indicate array indices)');
	    } else {
	      cov_n1qx8kuqm().b[6][1]++;
	    }
	  }
	  nodeEnd(context, key, leftKey, type, nodeType, isLast) {
	    cov_n1qx8kuqm().f[9]++;
	    cov_n1qx8kuqm().s[45]++;
	    if (type === 'node') {
	      cov_n1qx8kuqm().b[7][0]++;
	      cov_n1qx8kuqm().s[46]++;
	      context.indent(-1);
	    } else {
	      cov_n1qx8kuqm().b[7][1]++;
	    }
	    cov_n1qx8kuqm().s[47]++;
	    context.row(`}${isLast ? (cov_n1qx8kuqm().b[8][0]++, '') : (cov_n1qx8kuqm().b[8][1]++, ',')}`);
	  } /* jshint camelcase: false */ /* eslint-disable camelcase */
	  format_unchanged() {
	    cov_n1qx8kuqm().f[10]++;
	  }
	  format_movedestination() {
	    cov_n1qx8kuqm().f[11]++;
	  }
	  format_node(context, delta, left) {
	    cov_n1qx8kuqm().f[12]++;
	    cov_n1qx8kuqm().s[48]++; // recurse
	    this.formatDeltaChildren(context, delta, left);
	  }
	} /* eslint-enable camelcase */
	cov_n1qx8kuqm().s[49]++;
	const wrapPropertyName = name => {
	  cov_n1qx8kuqm().f[13]++;
	  cov_n1qx8kuqm().s[50]++;
	  return `<pre style="display:inline-block">&quot;${name}&quot;</pre>`;
	};
	const deltaAnnotations = (cov_n1qx8kuqm().s[51]++, {
	  added(delta, left, key, leftKey) {
	    cov_n1qx8kuqm().f[14]++;
	    const formatLegend = (cov_n1qx8kuqm().s[52]++, ' <pre>([newValue])</pre>');
	    cov_n1qx8kuqm().s[53]++;
	    if (typeof leftKey === 'undefined') {
	      cov_n1qx8kuqm().b[9][0]++;
	      cov_n1qx8kuqm().s[54]++;
	      return `new value${formatLegend}`;
	    } else {
	      cov_n1qx8kuqm().b[9][1]++;
	    }
	    cov_n1qx8kuqm().s[55]++;
	    if (typeof leftKey === 'number') {
	      cov_n1qx8kuqm().b[10][0]++;
	      cov_n1qx8kuqm().s[56]++;
	      return `insert at index ${leftKey}${formatLegend}`;
	    } else {
	      cov_n1qx8kuqm().b[10][1]++;
	    }
	    cov_n1qx8kuqm().s[57]++;
	    return `add property ${wrapPropertyName(leftKey)}${formatLegend}`;
	  },
	  modified(delta, left, key, leftKey) {
	    cov_n1qx8kuqm().f[15]++;
	    const formatLegend = (cov_n1qx8kuqm().s[58]++, ' <pre>([previousValue, newValue])</pre>');
	    cov_n1qx8kuqm().s[59]++;
	    if (typeof leftKey === 'undefined') {
	      cov_n1qx8kuqm().b[11][0]++;
	      cov_n1qx8kuqm().s[60]++;
	      return `modify value${formatLegend}`;
	    } else {
	      cov_n1qx8kuqm().b[11][1]++;
	    }
	    cov_n1qx8kuqm().s[61]++;
	    if (typeof leftKey === 'number') {
	      cov_n1qx8kuqm().b[12][0]++;
	      cov_n1qx8kuqm().s[62]++;
	      return `modify at index ${leftKey}${formatLegend}`;
	    } else {
	      cov_n1qx8kuqm().b[12][1]++;
	    }
	    cov_n1qx8kuqm().s[63]++;
	    return `modify property ${wrapPropertyName(leftKey)}${formatLegend}`;
	  },
	  deleted(delta, left, key, leftKey) {
	    cov_n1qx8kuqm().f[16]++;
	    const formatLegend = (cov_n1qx8kuqm().s[64]++, ' <pre>([previousValue, 0, 0])</pre>');
	    cov_n1qx8kuqm().s[65]++;
	    if (typeof leftKey === 'undefined') {
	      cov_n1qx8kuqm().b[13][0]++;
	      cov_n1qx8kuqm().s[66]++;
	      return `delete value${formatLegend}`;
	    } else {
	      cov_n1qx8kuqm().b[13][1]++;
	    }
	    cov_n1qx8kuqm().s[67]++;
	    if (typeof leftKey === 'number') {
	      cov_n1qx8kuqm().b[14][0]++;
	      cov_n1qx8kuqm().s[68]++;
	      return `remove index ${leftKey}${formatLegend}`;
	    } else {
	      cov_n1qx8kuqm().b[14][1]++;
	    }
	    cov_n1qx8kuqm().s[69]++;
	    return `delete property ${wrapPropertyName(leftKey)}${formatLegend}`;
	  },
	  moved(delta, left, key, leftKey) {
	    cov_n1qx8kuqm().f[17]++;
	    cov_n1qx8kuqm().s[70]++;
	    return 'move from <span title="(position to remove at original state)">' + `index ${leftKey}</span> to <span title="(position to insert at final` + ` state)">index ${delta[1]}</span>`;
	  },
	  textdiff(delta, left, key, leftKey) {
	    cov_n1qx8kuqm().f[18]++;
	    const location = (cov_n1qx8kuqm().s[71]++, typeof leftKey === 'undefined' ? (cov_n1qx8kuqm().b[15][0]++, '') : (cov_n1qx8kuqm().b[15][1]++, typeof leftKey === 'number' ? (cov_n1qx8kuqm().b[16][0]++, ` at index ${leftKey}`) : (cov_n1qx8kuqm().b[16][1]++, ` at property ${wrapPropertyName(leftKey)}`)));
	    cov_n1qx8kuqm().s[72]++;
	    return `text diff${location}, format is <a href="https://code.google.com/` + 'p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>';
	  }
	});
	cov_n1qx8kuqm().s[73]++;
	const formatAnyChange = function (context, delta) {
	  cov_n1qx8kuqm().f[19]++;
	  const deltaType = (cov_n1qx8kuqm().s[74]++, this.getDeltaType(delta));
	  const annotator = (cov_n1qx8kuqm().s[75]++, deltaAnnotations[deltaType]);
	  const htmlNote = (cov_n1qx8kuqm().s[76]++, (cov_n1qx8kuqm().b[17][0]++, annotator) && (cov_n1qx8kuqm().b[17][1]++, annotator.apply(annotator, Array.prototype.slice.call(arguments, 1))));
	  let json = (cov_n1qx8kuqm().s[77]++, JSON.stringify(delta, null, 2));
	  cov_n1qx8kuqm().s[78]++;
	  if (deltaType === 'textdiff') {
	    cov_n1qx8kuqm().b[18][0]++;
	    cov_n1qx8kuqm().s[79]++; // split text diffs lines
	    json = json.split('\\n').join('\\n"+\n   "');
	  } else {
	    cov_n1qx8kuqm().b[18][1]++;
	  }
	  cov_n1qx8kuqm().s[80]++;
	  context.indent();
	  cov_n1qx8kuqm().s[81]++;
	  context.row(json, htmlNote);
	  cov_n1qx8kuqm().s[82]++;
	  context.indent(-1);
	}; /* eslint-disable camelcase */
	cov_n1qx8kuqm().s[83]++;
	AnnotatedFormatter.prototype.format_added = formatAnyChange;
	cov_n1qx8kuqm().s[84]++;
	AnnotatedFormatter.prototype.format_modified = formatAnyChange;
	cov_n1qx8kuqm().s[85]++;
	AnnotatedFormatter.prototype.format_deleted = formatAnyChange;
	cov_n1qx8kuqm().s[86]++;
	AnnotatedFormatter.prototype.format_moved = formatAnyChange;
	cov_n1qx8kuqm().s[87]++;
	AnnotatedFormatter.prototype.format_textdiff = formatAnyChange;
	let defaultInstance$3;
	function format$2(delta, left) {
	  cov_n1qx8kuqm().f[20]++;
	  cov_n1qx8kuqm().s[88]++;
	  if (!defaultInstance$3) {
	    cov_n1qx8kuqm().b[19][0]++;
	    cov_n1qx8kuqm().s[89]++;
	    defaultInstance$3 = new AnnotatedFormatter();
	  } else {
	    cov_n1qx8kuqm().b[19][1]++;
	  }
	  cov_n1qx8kuqm().s[90]++;
	  return defaultInstance$3.format(delta, left);
	}
	var annotated = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  default: AnnotatedFormatter,
	  format: format$2
	});
	function cov_13gc1trqn6() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/jsonpatch.js";
	  var hash = "a3409ce3c7b917888cf947874f199987f5a5be0d";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/jsonpatch.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 2,
	          column: 19
	        },
	        end: {
	          line: 7,
	          column: 1
	        }
	      },
	      "1": {
	        start: {
	          line: 10,
	          column: 4
	        },
	        end: {
	          line: 10,
	          column: 12
	        }
	      },
	      "2": {
	        start: {
	          line: 11,
	          column: 4
	        },
	        end: {
	          line: 11,
	          column: 40
	        }
	      },
	      "3": {
	        start: {
	          line: 14,
	          column: 4
	        },
	        end: {
	          line: 14,
	          column: 34
	        }
	      },
	      "4": {
	        start: {
	          line: 15,
	          column: 4
	        },
	        end: {
	          line: 15,
	          column: 24
	        }
	      },
	      "5": {
	        start: {
	          line: 16,
	          column: 4
	        },
	        end: {
	          line: 16,
	          column: 22
	        }
	      },
	      "6": {
	        start: {
	          line: 17,
	          column: 4
	        },
	        end: {
	          line: 30,
	          column: 6
	        }
	      },
	      "7": {
	        start: {
	          line: 21,
	          column: 10
	        },
	        end: {
	          line: 21,
	          column: 13
	        }
	      },
	      "8": {
	        start: {
	          line: 22,
	          column: 18
	        },
	        end: {
	          line: 25,
	          column: 7
	        }
	      },
	      "9": {
	        start: {
	          line: 26,
	          column: 6
	        },
	        end: {
	          line: 28,
	          column: 7
	        }
	      },
	      "10": {
	        start: {
	          line: 27,
	          column: 8
	        },
	        end: {
	          line: 27,
	          column: 26
	        }
	      },
	      "11": {
	        start: {
	          line: 29,
	          column: 6
	        },
	        end: {
	          line: 29,
	          column: 28
	        }
	      },
	      "12": {
	        start: {
	          line: 31,
	          column: 4
	        },
	        end: {
	          line: 38,
	          column: 6
	        }
	      },
	      "13": {
	        start: {
	          line: 32,
	          column: 19
	        },
	        end: {
	          line: 32,
	          column: 37
	        }
	      },
	      "14": {
	        start: {
	          line: 33,
	          column: 6
	        },
	        end: {
	          line: 37,
	          column: 9
	        }
	      },
	      "15": {
	        start: {
	          line: 39,
	          column: 4
	        },
	        end: {
	          line: 41,
	          column: 6
	        }
	      },
	      "16": {
	        start: {
	          line: 40,
	          column: 6
	        },
	        end: {
	          line: 40,
	          column: 39
	        }
	      },
	      "17": {
	        start: {
	          line: 42,
	          column: 4
	        },
	        end: {
	          line: 46,
	          column: 6
	        }
	      },
	      "18": {
	        start: {
	          line: 43,
	          column: 17
	        },
	        end: {
	          line: 43,
	          column: 34
	        }
	      },
	      "19": {
	        start: {
	          line: 44,
	          column: 6
	        },
	        end: {
	          line: 44,
	          column: 33
	        }
	      },
	      "20": {
	        start: {
	          line: 45,
	          column: 6
	        },
	        end: {
	          line: 45,
	          column: 32
	        }
	      },
	      "21": {
	        start: {
	          line: 49,
	          column: 4
	        },
	        end: {
	          line: 49,
	          column: 34
	        }
	      },
	      "22": {
	        start: {
	          line: 56,
	          column: 8
	        },
	        end: {
	          line: 56,
	          column: 12
	        }
	      },
	      "23": {
	        start: {
	          line: 57,
	          column: 4
	        },
	        end: {
	          line: 57,
	          column: 23
	        }
	      },
	      "24": {
	        start: {
	          line: 62,
	          column: 8
	        },
	        end: {
	          line: 62,
	          column: 13
	        }
	      },
	      "25": {
	        start: {
	          line: 63,
	          column: 4
	        },
	        end: {
	          line: 63,
	          column: 15
	        }
	      },
	      "26": {
	        start: {
	          line: 72,
	          column: 4
	        },
	        end: {
	          line: 72,
	          column: 51
	        }
	      },
	      "27": {
	        start: {
	          line: 75,
	          column: 4
	        },
	        end: {
	          line: 78,
	          column: 7
	        }
	      },
	      "28": {
	        start: {
	          line: 81,
	          column: 4
	        },
	        end: {
	          line: 84,
	          column: 7
	        }
	      },
	      "29": {
	        start: {
	          line: 87,
	          column: 4
	        },
	        end: {
	          line: 89,
	          column: 7
	        }
	      },
	      "30": {
	        start: {
	          line: 92,
	          column: 15
	        },
	        end: {
	          line: 92,
	          column: 23
	        }
	      },
	      "31": {
	        start: {
	          line: 93,
	          column: 4
	        },
	        end: {
	          line: 93,
	          column: 27
	        }
	      },
	      "32": {
	        start: {
	          line: 96,
	          column: 4
	        },
	        end: {
	          line: 96,
	          column: 39
	        }
	      },
	      "33": {
	        start: {
	          line: 99,
	          column: 20
	        },
	        end: {
	          line: 99,
	          column: 22
	        }
	      },
	      "34": {
	        start: {
	          line: 100,
	          column: 4
	        },
	        end: {
	          line: 100,
	          column: 33
	        }
	      },
	      "35": {
	        start: {
	          line: 101,
	          column: 4
	        },
	        end: {
	          line: 101,
	          column: 39
	        }
	      },
	      "36": {
	        start: {
	          line: 102,
	          column: 4
	        },
	        end: {
	          line: 102,
	          column: 26
	        }
	      },
	      "37": {
	        start: {
	          line: 110,
	          column: 13
	        },
	        end: {
	          line: 110,
	          column: 39
	        }
	      },
	      "38": {
	        start: {
	          line: 110,
	          column: 20
	        },
	        end: {
	          line: 110,
	          column: 39
	        }
	      },
	      "39": {
	        start: {
	          line: 111,
	          column: 15
	        },
	        end: {
	          line: 114,
	          column: 1
	        }
	      },
	      "40": {
	        start: {
	          line: 112,
	          column: 2
	        },
	        end: {
	          line: 112,
	          column: 17
	        }
	      },
	      "41": {
	        start: {
	          line: 113,
	          column: 2
	        },
	        end: {
	          line: 113,
	          column: 13
	        }
	      },
	      "42": {
	        start: {
	          line: 115,
	          column: 27
	        },
	        end: {
	          line: 123,
	          column: 1
	        }
	      },
	      "43": {
	        start: {
	          line: 116,
	          column: 16
	        },
	        end: {
	          line: 116,
	          column: 36
	        }
	      },
	      "44": {
	        start: {
	          line: 117,
	          column: 16
	        },
	        end: {
	          line: 117,
	          column: 36
	        }
	      },
	      "45": {
	        start: {
	          line: 118,
	          column: 2
	        },
	        end: {
	          line: 122,
	          column: 3
	        }
	      },
	      "46": {
	        start: {
	          line: 119,
	          column: 4
	        },
	        end: {
	          line: 119,
	          column: 25
	        }
	      },
	      "47": {
	        start: {
	          line: 121,
	          column: 4
	        },
	        end: {
	          line: 121,
	          column: 13
	        }
	      },
	      "48": {
	        start: {
	          line: 124,
	          column: 29
	        },
	        end: {
	          line: 132,
	          column: 2
	        }
	      },
	      "49": {
	        start: {
	          line: 124,
	          column: 42
	        },
	        end: {
	          line: 132,
	          column: 2
	        }
	      },
	      "50": {
	        start: {
	          line: 125,
	          column: 17
	        },
	        end: {
	          line: 125,
	          column: 34
	        }
	      },
	      "51": {
	        start: {
	          line: 126,
	          column: 17
	        },
	        end: {
	          line: 126,
	          column: 34
	        }
	      },
	      "52": {
	        start: {
	          line: 127,
	          column: 2
	        },
	        end: {
	          line: 131,
	          column: 3
	        }
	      },
	      "53": {
	        start: {
	          line: 128,
	          column: 4
	        },
	        end: {
	          line: 128,
	          column: 41
	        }
	      },
	      "54": {
	        start: {
	          line: 130,
	          column: 4
	        },
	        end: {
	          line: 130,
	          column: 58
	        }
	      },
	      "55": {
	        start: {
	          line: 133,
	          column: 28
	        },
	        end: {
	          line: 148,
	          column: 1
	        }
	      },
	      "56": {
	        start: {
	          line: 134,
	          column: 18
	        },
	        end: {
	          line: 134,
	          column: 60
	        }
	      },
	      "57": {
	        start: {
	          line: 134,
	          column: 57
	        },
	        end: {
	          line: 134,
	          column: 59
	        }
	      },
	      "58": {
	        start: {
	          line: 135,
	          column: 2
	        },
	        end: {
	          line: 147,
	          column: 14
	        }
	      },
	      "59": {
	        start: {
	          line: 136,
	          column: 19
	        },
	        end: {
	          line: 136,
	          column: 56
	        }
	      },
	      "60": {
	        start: {
	          line: 136,
	          column: 33
	        },
	        end: {
	          line: 136,
	          column: 41
	        }
	      },
	      "61": {
	        start: {
	          line: 137,
	          column: 4
	        },
	        end: {
	          line: 139,
	          column: 5
	        }
	      },
	      "62": {
	        start: {
	          line: 138,
	          column: 6
	        },
	        end: {
	          line: 138,
	          column: 28
	        }
	      },
	      "63": {
	        start: {
	          line: 140,
	          column: 4
	        },
	        end: {
	          line: 143,
	          column: 6
	        }
	      },
	      "64": {
	        start: {
	          line: 145,
	          column: 4
	        },
	        end: {
	          line: 145,
	          column: 39
	        }
	      },
	      "65": {
	        start: {
	          line: 146,
	          column: 4
	        },
	        end: {
	          line: 146,
	          column: 15
	        }
	      },
	      "66": {
	        start: {
	          line: 149,
	          column: 17
	        },
	        end: {
	          line: 154,
	          column: 1
	        }
	      },
	      "67": {
	        start: {
	          line: 152,
	          column: 6
	        },
	        end: {
	          line: 152,
	          column: 11
	        }
	      },
	      "68": {
	        start: {
	          line: 153,
	          column: 2
	        },
	        end: {
	          line: 153,
	          column: 23
	        }
	      },
	      "69": {
	        start: {
	          line: 155,
	          column: 19
	        },
	        end: {
	          line: 160,
	          column: 1
	        }
	      },
	      "70": {
	        start: {
	          line: 158,
	          column: 6
	        },
	        end: {
	          line: 158,
	          column: 11
	        }
	      },
	      "71": {
	        start: {
	          line: 159,
	          column: 2
	        },
	        end: {
	          line: 159,
	          column: 25
	        }
	      },
	      "72": {
	        start: {
	          line: 161,
	          column: 19
	        },
	        end: {
	          line: 165,
	          column: 1
	        }
	      },
	      "73": {
	        start: {
	          line: 162,
	          column: 41
	        },
	        end: {
	          line: 162,
	          column: 83
	        }
	      },
	      "74": {
	        start: {
	          line: 163,
	          column: 27
	        },
	        end: {
	          line: 163,
	          column: 59
	        }
	      },
	      "75": {
	        start: {
	          line: 164,
	          column: 2
	        },
	        end: {
	          line: 164,
	          column: 55
	        }
	      },
	      "76": {
	        start: {
	          line: 167,
	          column: 22
	        },
	        end: {
	          line: 172,
	          column: 1
	        }
	      },
	      "77": {
	        start: {
	          line: 168,
	          column: 2
	        },
	        end: {
	          line: 170,
	          column: 3
	        }
	      },
	      "78": {
	        start: {
	          line: 169,
	          column: 4
	        },
	        end: {
	          line: 169,
	          column: 42
	        }
	      },
	      "79": {
	        start: {
	          line: 171,
	          column: 2
	        },
	        end: {
	          line: 171,
	          column: 57
	        }
	      },
	      "80": {
	        start: {
	          line: 173,
	          column: 19
	        },
	        end: {
	          line: 175,
	          column: 1
	        }
	      },
	      "81": {
	        start: {
	          line: 174,
	          column: 2
	        },
	        end: {
	          line: 174,
	          column: 35
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "(anonymous_0)",
	        decl: {
	          start: {
	            line: 9,
	            column: 2
	          },
	          end: {
	            line: 9,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 9,
	            column: 16
	          },
	          end: {
	            line: 12,
	            column: 3
	          }
	        },
	        line: 9
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 13,
	            column: 2
	          },
	          end: {
	            line: 13,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 13,
	            column: 26
	          },
	          end: {
	            line: 47,
	            column: 3
	          }
	        },
	        line: 13
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 17,
	            column: 28
	          },
	          end: {
	            line: 17,
	            column: 29
	          }
	        },
	        loc: {
	          start: {
	            line: 17,
	            column: 43
	          },
	          end: {
	            line: 30,
	            column: 5
	          }
	        },
	        line: 17
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 31,
	            column: 25
	          },
	          end: {
	            line: 31,
	            column: 26
	          }
	        },
	        loc: {
	          start: {
	            line: 31,
	            column: 39
	          },
	          end: {
	            line: 38,
	            column: 5
	          }
	        },
	        line: 31
	      },
	      "4": {
	        name: "(anonymous_4)",
	        decl: {
	          start: {
	            line: 39,
	            column: 26
	          },
	          end: {
	            line: 39,
	            column: 27
	          }
	        },
	        loc: {
	          start: {
	            line: 39,
	            column: 38
	          },
	          end: {
	            line: 41,
	            column: 5
	          }
	        },
	        line: 39
	      },
	      "5": {
	        name: "(anonymous_5)",
	        decl: {
	          start: {
	            line: 42,
	            column: 21
	          },
	          end: {
	            line: 42,
	            column: 22
	          }
	        },
	        loc: {
	          start: {
	            line: 42,
	            column: 39
	          },
	          end: {
	            line: 46,
	            column: 5
	          }
	        },
	        line: 42
	      },
	      "6": {
	        name: "(anonymous_6)",
	        decl: {
	          start: {
	            line: 48,
	            column: 2
	          },
	          end: {
	            line: 48,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 48,
	            column: 45
	          },
	          end: {
	            line: 50,
	            column: 3
	          }
	        },
	        line: 48
	      },
	      "7": {
	        name: "(anonymous_7)",
	        decl: {
	          start: {
	            line: 51,
	            column: 2
	          },
	          end: {
	            line: 51,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 51,
	            column: 14
	          },
	          end: {
	            line: 51,
	            column: 16
	          }
	        },
	        line: 51
	      },
	      "8": {
	        name: "(anonymous_8)",
	        decl: {
	          start: {
	            line: 52,
	            column: 2
	          },
	          end: {
	            line: 52,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 52,
	            column: 12
	          },
	          end: {
	            line: 52,
	            column: 14
	          }
	        },
	        line: 52
	      },
	      "9": {
	        name: "(anonymous_9)",
	        decl: {
	          start: {
	            line: 53,
	            column: 2
	          },
	          end: {
	            line: 53,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 53,
	            column: 32
	          },
	          end: {
	            line: 58,
	            column: 3
	          }
	        },
	        line: 53
	      },
	      "10": {
	        name: "(anonymous_10)",
	        decl: {
	          start: {
	            line: 59,
	            column: 2
	          },
	          end: {
	            line: 59,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 59,
	            column: 17
	          },
	          end: {
	            line: 64,
	            column: 3
	          }
	        },
	        line: 59
	      },
	      "11": {
	        name: "(anonymous_11)",
	        decl: {
	          start: {
	            line: 69,
	            column: 2
	          },
	          end: {
	            line: 69,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 69,
	            column: 21
	          },
	          end: {
	            line: 69,
	            column: 23
	          }
	        },
	        line: 69
	      },
	      "12": {
	        name: "(anonymous_12)",
	        decl: {
	          start: {
	            line: 70,
	            column: 2
	          },
	          end: {
	            line: 70,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 70,
	            column: 27
	          },
	          end: {
	            line: 70,
	            column: 29
	          }
	        },
	        line: 70
	      },
	      "13": {
	        name: "(anonymous_13)",
	        decl: {
	          start: {
	            line: 71,
	            column: 2
	          },
	          end: {
	            line: 71,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 71,
	            column: 36
	          },
	          end: {
	            line: 73,
	            column: 3
	          }
	        },
	        line: 71
	      },
	      "14": {
	        name: "(anonymous_14)",
	        decl: {
	          start: {
	            line: 74,
	            column: 2
	          },
	          end: {
	            line: 74,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 74,
	            column: 31
	          },
	          end: {
	            line: 79,
	            column: 3
	          }
	        },
	        line: 74
	      },
	      "15": {
	        name: "(anonymous_15)",
	        decl: {
	          start: {
	            line: 80,
	            column: 2
	          },
	          end: {
	            line: 80,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 80,
	            column: 34
	          },
	          end: {
	            line: 85,
	            column: 3
	          }
	        },
	        line: 80
	      },
	      "16": {
	        name: "(anonymous_16)",
	        decl: {
	          start: {
	            line: 86,
	            column: 2
	          },
	          end: {
	            line: 86,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 86,
	            column: 26
	          },
	          end: {
	            line: 90,
	            column: 3
	          }
	        },
	        line: 86
	      },
	      "17": {
	        name: "(anonymous_17)",
	        decl: {
	          start: {
	            line: 91,
	            column: 2
	          },
	          end: {
	            line: 91,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 91,
	            column: 31
	          },
	          end: {
	            line: 94,
	            column: 3
	          }
	        },
	        line: 91
	      },
	      "18": {
	        name: "(anonymous_18)",
	        decl: {
	          start: {
	            line: 95,
	            column: 2
	          },
	          end: {
	            line: 95,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 95,
	            column: 20
	          },
	          end: {
	            line: 97,
	            column: 3
	          }
	        },
	        line: 95
	      },
	      "19": {
	        name: "(anonymous_19)",
	        decl: {
	          start: {
	            line: 98,
	            column: 2
	          },
	          end: {
	            line: 98,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 98,
	            column: 22
	          },
	          end: {
	            line: 103,
	            column: 3
	          }
	        },
	        line: 98
	      },
	      "20": {
	        name: "(anonymous_20)",
	        decl: {
	          start: {
	            line: 110,
	            column: 13
	          },
	          end: {
	            line: 110,
	            column: 14
	          }
	        },
	        loc: {
	          start: {
	            line: 110,
	            column: 20
	          },
	          end: {
	            line: 110,
	            column: 39
	          }
	        },
	        line: 110
	      },
	      "21": {
	        name: "(anonymous_21)",
	        decl: {
	          start: {
	            line: 111,
	            column: 15
	          },
	          end: {
	            line: 111,
	            column: 16
	          }
	        },
	        loc: {
	          start: {
	            line: 111,
	            column: 30
	          },
	          end: {
	            line: 114,
	            column: 1
	          }
	        },
	        line: 111
	      },
	      "22": {
	        name: "(anonymous_22)",
	        decl: {
	          start: {
	            line: 115,
	            column: 27
	          },
	          end: {
	            line: 115,
	            column: 28
	          }
	        },
	        loc: {
	          start: {
	            line: 115,
	            column: 47
	          },
	          end: {
	            line: 123,
	            column: 1
	          }
	        },
	        line: 115
	      },
	      "23": {
	        name: "(anonymous_23)",
	        decl: {
	          start: {
	            line: 124,
	            column: 29
	          },
	          end: {
	            line: 124,
	            column: 30
	          }
	        },
	        loc: {
	          start: {
	            line: 124,
	            column: 42
	          },
	          end: {
	            line: 132,
	            column: 2
	          }
	        },
	        line: 124
	      },
	      "24": {
	        name: "(anonymous_24)",
	        decl: {
	          start: {
	            line: 124,
	            column: 60
	          },
	          end: {
	            line: 124,
	            column: 61
	          }
	        },
	        loc: {
	          start: {
	            line: 124,
	            column: 70
	          },
	          end: {
	            line: 132,
	            column: 1
	          }
	        },
	        line: 124
	      },
	      "25": {
	        name: "(anonymous_25)",
	        decl: {
	          start: {
	            line: 133,
	            column: 28
	          },
	          end: {
	            line: 133,
	            column: 29
	          }
	        },
	        loc: {
	          start: {
	            line: 133,
	            column: 42
	          },
	          end: {
	            line: 148,
	            column: 1
	          }
	        },
	        line: 133
	      },
	      "26": {
	        name: "(anonymous_26)",
	        decl: {
	          start: {
	            line: 134,
	            column: 51
	          },
	          end: {
	            line: 134,
	            column: 52
	          }
	        },
	        loc: {
	          start: {
	            line: 134,
	            column: 57
	          },
	          end: {
	            line: 134,
	            column: 59
	          }
	        },
	        line: 134
	      },
	      "27": {
	        name: "(anonymous_27)",
	        decl: {
	          start: {
	            line: 135,
	            column: 17
	          },
	          end: {
	            line: 135,
	            column: 18
	          }
	        },
	        loc: {
	          start: {
	            line: 135,
	            column: 25
	          },
	          end: {
	            line: 144,
	            column: 3
	          }
	        },
	        line: 135
	      },
	      "28": {
	        name: "(anonymous_28)",
	        decl: {
	          start: {
	            line: 136,
	            column: 27
	          },
	          end: {
	            line: 136,
	            column: 28
	          }
	        },
	        loc: {
	          start: {
	            line: 136,
	            column: 33
	          },
	          end: {
	            line: 136,
	            column: 41
	          }
	        },
	        line: 136
	      },
	      "29": {
	        name: "(anonymous_29)",
	        decl: {
	          start: {
	            line: 144,
	            column: 12
	          },
	          end: {
	            line: 144,
	            column: 13
	          }
	        },
	        loc: {
	          start: {
	            line: 144,
	            column: 27
	          },
	          end: {
	            line: 147,
	            column: 3
	          }
	        },
	        line: 144
	      },
	      "30": {
	        name: "(anonymous_30)",
	        decl: {
	          start: {
	            line: 149,
	            column: 17
	          },
	          end: {
	            line: 149,
	            column: 18
	          }
	        },
	        loc: {
	          start: {
	            line: 149,
	            column: 26
	          },
	          end: {
	            line: 154,
	            column: 1
	          }
	        },
	        line: 149
	      },
	      "31": {
	        name: "(anonymous_31)",
	        decl: {
	          start: {
	            line: 155,
	            column: 19
	          },
	          end: {
	            line: 155,
	            column: 20
	          }
	        },
	        loc: {
	          start: {
	            line: 155,
	            column: 28
	          },
	          end: {
	            line: 160,
	            column: 1
	          }
	        },
	        line: 155
	      },
	      "32": {
	        name: "(anonymous_32)",
	        decl: {
	          start: {
	            line: 161,
	            column: 19
	          },
	          end: {
	            line: 161,
	            column: 20
	          }
	        },
	        loc: {
	          start: {
	            line: 161,
	            column: 27
	          },
	          end: {
	            line: 165,
	            column: 1
	          }
	        },
	        line: 161
	      },
	      "33": {
	        name: "(anonymous_33)",
	        decl: {
	          start: {
	            line: 167,
	            column: 22
	          },
	          end: {
	            line: 167,
	            column: 23
	          }
	        },
	        loc: {
	          start: {
	            line: 167,
	            column: 39
	          },
	          end: {
	            line: 172,
	            column: 1
	          }
	        },
	        line: 167
	      },
	      "34": {
	        name: "(anonymous_34)",
	        decl: {
	          start: {
	            line: 173,
	            column: 19
	          },
	          end: {
	            line: 173,
	            column: 20
	          }
	        },
	        loc: {
	          start: {
	            line: 173,
	            column: 36
	          },
	          end: {
	            line: 175,
	            column: 1
	          }
	        },
	        line: 173
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 26,
	            column: 6
	          },
	          end: {
	            line: 28,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 26,
	            column: 6
	          },
	          end: {
	            line: 28,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 26
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 118,
	            column: 2
	          },
	          end: {
	            line: 122,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 118,
	            column: 2
	          },
	          end: {
	            line: 122,
	            column: 3
	          }
	        }, {
	          start: {
	            line: 120,
	            column: 9
	          },
	          end: {
	            line: 122,
	            column: 3
	          }
	        }],
	        line: 118
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 118,
	            column: 8
	          },
	          end: {
	            line: 118,
	            column: 36
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 118,
	            column: 8
	          },
	          end: {
	            line: 118,
	            column: 20
	          }
	        }, {
	          start: {
	            line: 118,
	            column: 24
	          },
	          end: {
	            line: 118,
	            column: 36
	          }
	        }],
	        line: 118
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 127,
	            column: 2
	          },
	          end: {
	            line: 131,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 127,
	            column: 2
	          },
	          end: {
	            line: 131,
	            column: 3
	          }
	        }, {
	          start: {
	            line: 129,
	            column: 9
	          },
	          end: {
	            line: 131,
	            column: 3
	          }
	        }],
	        line: 127
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 137,
	            column: 4
	          },
	          end: {
	            line: 139,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 137,
	            column: 4
	          },
	          end: {
	            line: 139,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 137
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 168,
	            column: 2
	          },
	          end: {
	            line: 170,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 168,
	            column: 2
	          },
	          end: {
	            line: 170,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 168
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0,
	      "72": 0,
	      "73": 0,
	      "74": 0,
	      "75": 0,
	      "76": 0,
	      "77": 0,
	      "78": 0,
	      "79": 0,
	      "80": 0,
	      "81": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/jsonpatch.js"],
	      sourcesContent: ["import BaseFormatter from './base';\n\nconst OPERATIONS = {\n  add: 'add',\n  remove: 'remove',\n  replace: 'replace',\n  move: 'move',\n};\n\nclass JSONFormatter extends BaseFormatter {\n  constructor() {\n    super();\n    this.includeMoveDestinations = true;\n  }\n\n  prepareContext(context) {\n    super.prepareContext(context);\n    context.result = [];\n    context.path = [];\n    context.pushCurrentOp = function(obj) {\n      const { op, value } = obj;\n      const val = {\n        op,\n        path: this.currentPath(),\n      };\n      if (typeof value !== 'undefined') {\n        val.value = value;\n      }\n      this.result.push(val);\n    };\n\n    context.pushMoveOp = function(to) {\n      const from = this.currentPath();\n      this.result.push({\n        op: OPERATIONS.move,\n        from,\n        path: this.toPath(to),\n      });\n    };\n\n    context.currentPath = function() {\n      return `/${this.path.join('/')}`;\n    };\n\n    context.toPath = function(toPath) {\n      const to = this.path.slice();\n      to[to.length - 1] = toPath;\n      return `/${to.join('/')}`;\n    };\n  }\n\n  typeFormattterErrorFormatter(context, err) {\n    context.out(`[ERROR] ${err}`);\n  }\n\n  rootBegin() {}\n  rootEnd() {}\n\n  nodeBegin({ path }, key, leftKey) {\n    path.push(leftKey);\n  }\n\n  nodeEnd({ path }) {\n    path.pop();\n  }\n\n  /* jshint camelcase: false */\n  /* eslint-disable camelcase */\n\n  format_unchanged() {}\n\n  format_movedestination() {}\n\n  format_node(context, delta, left) {\n    this.formatDeltaChildren(context, delta, left);\n  }\n\n  format_added(context, delta) {\n    context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });\n  }\n\n  format_modified(context, delta) {\n    context.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });\n  }\n\n  format_deleted(context) {\n    context.pushCurrentOp({ op: OPERATIONS.remove });\n  }\n\n  format_moved(context, delta) {\n    const to = delta[1];\n    context.pushMoveOp(to);\n  }\n\n  format_textdiff() {\n    throw new Error('Not implemented');\n  }\n\n  format(delta, left) {\n    const context = {};\n    this.prepareContext(context);\n    this.recurse(context, delta, left);\n    return context.result;\n  }\n}\n\n/* jshint camelcase: true */\n/* eslint-enable camelcase */\n\nexport default JSONFormatter;\n\nconst last = arr => arr[arr.length - 1];\n\nconst sortBy = (arr, pred) => {\n  arr.sort(pred);\n  return arr;\n};\n\nconst compareByIndexDesc = (indexA, indexB) => {\n  const lastA = parseInt(indexA, 10);\n  const lastB = parseInt(indexB, 10);\n  if (!(isNaN(lastA) || isNaN(lastB))) {\n    return lastB - lastA;\n  } else {\n    return 0;\n  }\n};\n\nconst opsByDescendingOrder = removeOps => sortBy(removeOps, (a, b) => {\n  const splitA = a.path.split('/');\n  const splitB = b.path.split('/');\n  if (splitA.length !== splitB.length) {\n    return splitA.length - splitB.length;\n  } else {\n    return compareByIndexDesc(last(splitA), last(splitB));\n  }\n});\n\nexport const partitionOps = (arr, fns) => {\n  const initArr = Array(fns.length + 1).fill().map(() => []);\n  return arr\n    .map(item => {\n      let position = fns.map(fn => fn(item)).indexOf(true);\n      if (position < 0) {\n        position = fns.length;\n      }\n      return { item, position };\n    })\n    .reduce((acc, item) => {\n      acc[item.position].push(item.item);\n      return acc;\n    }, initArr);\n};\nconst isMoveOp = ({ op }) => op === 'move';\nconst isRemoveOp = ({ op }) => op === 'remove';\n\nconst reorderOps = diff => {\n  const [moveOps, removedOps, restOps] =\n    partitionOps(diff, [isMoveOp, isRemoveOp]);\n  const removeOpsReverse = opsByDescendingOrder(removedOps);\n  return [...removeOpsReverse, ...moveOps, ...restOps];\n};\n\nlet defaultInstance;\n\nexport const format = (delta, left) => {\n  if (!defaultInstance) {\n    defaultInstance = new JSONFormatter();\n  }\n  return reorderOps(defaultInstance.format(delta, left));\n};\n\nexport const log = (delta, left) => {\n  console.log(format(delta, left));\n};\n"],
	      names: ["BaseFormatter", "OPERATIONS", "add", "remove", "replace", "move", "JSONFormatter", "constructor", "includeMoveDestinations", "prepareContext", "context", "result", "path", "pushCurrentOp", "obj", "op", "value", "val", "currentPath", "push", "pushMoveOp", "to", "from", "toPath", "join", "slice", "length", "typeFormattterErrorFormatter", "err", "out", "rootBegin", "rootEnd", "nodeBegin", "_ref", "key", "leftKey", "nodeEnd", "_ref2", "pop", "format_unchanged", "format_movedestination", "format_node", "delta", "left", "formatDeltaChildren", "format_added", "format_modified", "format_deleted", "format_moved", "format_textdiff", "Error", "format", "recurse", "last", "arr", "sortBy", "pred", "sort", "compareByIndexDesc", "indexA", "indexB", "lastA", "parseInt", "lastB", "isNaN", "opsByDescendingOrder", "removeOps", "a", "b", "splitA", "split", "splitB", "partitionOps", "fns", "initArr", "Array", "fill", "map", "item", "position", "fn", "indexOf", "reduce", "acc", "isMoveOp", "_ref3", "isRemoveOp", "_ref4", "reorderOps", "diff", "moveOps", "removedOps", "restOps", "removeOpsReverse", "defaultInstance", "log", "console"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "a3409ce3c7b917888cf947874f199987f5a5be0d"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_13gc1trqn6 = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_13gc1trqn6();
	const OPERATIONS = (cov_13gc1trqn6().s[0]++, {
	  add: 'add',
	  remove: 'remove',
	  replace: 'replace',
	  move: 'move'
	});
	class JSONFormatter extends BaseFormatter {
	  constructor() {
	    cov_13gc1trqn6().f[0]++;
	    cov_13gc1trqn6().s[1]++;
	    super();
	    cov_13gc1trqn6().s[2]++;
	    this.includeMoveDestinations = true;
	  }
	  prepareContext(context) {
	    cov_13gc1trqn6().f[1]++;
	    cov_13gc1trqn6().s[3]++;
	    super.prepareContext(context);
	    cov_13gc1trqn6().s[4]++;
	    context.result = [];
	    cov_13gc1trqn6().s[5]++;
	    context.path = [];
	    cov_13gc1trqn6().s[6]++;
	    context.pushCurrentOp = function (obj) {
	      cov_13gc1trqn6().f[2]++;
	      const {
	        op,
	        value
	      } = (cov_13gc1trqn6().s[7]++, obj);
	      const val = (cov_13gc1trqn6().s[8]++, {
	        op,
	        path: this.currentPath()
	      });
	      cov_13gc1trqn6().s[9]++;
	      if (typeof value !== 'undefined') {
	        cov_13gc1trqn6().b[0][0]++;
	        cov_13gc1trqn6().s[10]++;
	        val.value = value;
	      } else {
	        cov_13gc1trqn6().b[0][1]++;
	      }
	      cov_13gc1trqn6().s[11]++;
	      this.result.push(val);
	    };
	    cov_13gc1trqn6().s[12]++;
	    context.pushMoveOp = function (to) {
	      cov_13gc1trqn6().f[3]++;
	      const from = (cov_13gc1trqn6().s[13]++, this.currentPath());
	      cov_13gc1trqn6().s[14]++;
	      this.result.push({
	        op: OPERATIONS.move,
	        from,
	        path: this.toPath(to)
	      });
	    };
	    cov_13gc1trqn6().s[15]++;
	    context.currentPath = function () {
	      cov_13gc1trqn6().f[4]++;
	      cov_13gc1trqn6().s[16]++;
	      return `/${this.path.join('/')}`;
	    };
	    cov_13gc1trqn6().s[17]++;
	    context.toPath = function (toPath) {
	      cov_13gc1trqn6().f[5]++;
	      const to = (cov_13gc1trqn6().s[18]++, this.path.slice());
	      cov_13gc1trqn6().s[19]++;
	      to[to.length - 1] = toPath;
	      cov_13gc1trqn6().s[20]++;
	      return `/${to.join('/')}`;
	    };
	  }
	  typeFormattterErrorFormatter(context, err) {
	    cov_13gc1trqn6().f[6]++;
	    cov_13gc1trqn6().s[21]++;
	    context.out(`[ERROR] ${err}`);
	  }
	  rootBegin() {
	    cov_13gc1trqn6().f[7]++;
	  }
	  rootEnd() {
	    cov_13gc1trqn6().f[8]++;
	  }
	  nodeBegin(_ref, key, leftKey) {
	    cov_13gc1trqn6().f[9]++;
	    let {
	      path
	    } = (cov_13gc1trqn6().s[22]++, _ref);
	    cov_13gc1trqn6().s[23]++;
	    path.push(leftKey);
	  }
	  nodeEnd(_ref2) {
	    cov_13gc1trqn6().f[10]++;
	    let {
	      path
	    } = (cov_13gc1trqn6().s[24]++, _ref2);
	    cov_13gc1trqn6().s[25]++;
	    path.pop();
	  } /* jshint camelcase: false */ /* eslint-disable camelcase */
	  format_unchanged() {
	    cov_13gc1trqn6().f[11]++;
	  }
	  format_movedestination() {
	    cov_13gc1trqn6().f[12]++;
	  }
	  format_node(context, delta, left) {
	    cov_13gc1trqn6().f[13]++;
	    cov_13gc1trqn6().s[26]++;
	    this.formatDeltaChildren(context, delta, left);
	  }
	  format_added(context, delta) {
	    cov_13gc1trqn6().f[14]++;
	    cov_13gc1trqn6().s[27]++;
	    context.pushCurrentOp({
	      op: OPERATIONS.add,
	      value: delta[0]
	    });
	  }
	  format_modified(context, delta) {
	    cov_13gc1trqn6().f[15]++;
	    cov_13gc1trqn6().s[28]++;
	    context.pushCurrentOp({
	      op: OPERATIONS.replace,
	      value: delta[1]
	    });
	  }
	  format_deleted(context) {
	    cov_13gc1trqn6().f[16]++;
	    cov_13gc1trqn6().s[29]++;
	    context.pushCurrentOp({
	      op: OPERATIONS.remove
	    });
	  }
	  format_moved(context, delta) {
	    cov_13gc1trqn6().f[17]++;
	    const to = (cov_13gc1trqn6().s[30]++, delta[1]);
	    cov_13gc1trqn6().s[31]++;
	    context.pushMoveOp(to);
	  }
	  format_textdiff() {
	    cov_13gc1trqn6().f[18]++;
	    cov_13gc1trqn6().s[32]++;
	    throw new Error('Not implemented');
	  }
	  format(delta, left) {
	    cov_13gc1trqn6().f[19]++;
	    const context = (cov_13gc1trqn6().s[33]++, {});
	    cov_13gc1trqn6().s[34]++;
	    this.prepareContext(context);
	    cov_13gc1trqn6().s[35]++;
	    this.recurse(context, delta, left);
	    cov_13gc1trqn6().s[36]++;
	    return context.result;
	  }
	}
	cov_13gc1trqn6().s[37]++;
	const last = arr => {
	  cov_13gc1trqn6().f[20]++;
	  cov_13gc1trqn6().s[38]++;
	  return arr[arr.length - 1];
	};
	cov_13gc1trqn6().s[39]++;
	const sortBy = (arr, pred) => {
	  cov_13gc1trqn6().f[21]++;
	  cov_13gc1trqn6().s[40]++;
	  arr.sort(pred);
	  cov_13gc1trqn6().s[41]++;
	  return arr;
	};
	cov_13gc1trqn6().s[42]++;
	const compareByIndexDesc = (indexA, indexB) => {
	  cov_13gc1trqn6().f[22]++;
	  const lastA = (cov_13gc1trqn6().s[43]++, parseInt(indexA, 10));
	  const lastB = (cov_13gc1trqn6().s[44]++, parseInt(indexB, 10));
	  cov_13gc1trqn6().s[45]++;
	  if (!((cov_13gc1trqn6().b[2][0]++, isNaN(lastA)) || (cov_13gc1trqn6().b[2][1]++, isNaN(lastB)))) {
	    cov_13gc1trqn6().b[1][0]++;
	    cov_13gc1trqn6().s[46]++;
	    return lastB - lastA;
	  } else {
	    cov_13gc1trqn6().b[1][1]++;
	    cov_13gc1trqn6().s[47]++;
	    return 0;
	  }
	};
	cov_13gc1trqn6().s[48]++;
	const opsByDescendingOrder = removeOps => {
	  cov_13gc1trqn6().f[23]++;
	  cov_13gc1trqn6().s[49]++;
	  return sortBy(removeOps, (a, b) => {
	    cov_13gc1trqn6().f[24]++;
	    const splitA = (cov_13gc1trqn6().s[50]++, a.path.split('/'));
	    const splitB = (cov_13gc1trqn6().s[51]++, b.path.split('/'));
	    cov_13gc1trqn6().s[52]++;
	    if (splitA.length !== splitB.length) {
	      cov_13gc1trqn6().b[3][0]++;
	      cov_13gc1trqn6().s[53]++;
	      return splitA.length - splitB.length;
	    } else {
	      cov_13gc1trqn6().b[3][1]++;
	      cov_13gc1trqn6().s[54]++;
	      return compareByIndexDesc(last(splitA), last(splitB));
	    }
	  });
	};
	cov_13gc1trqn6().s[55]++;
	const partitionOps = (arr, fns) => {
	  cov_13gc1trqn6().f[25]++;
	  const initArr = (cov_13gc1trqn6().s[56]++, Array(fns.length + 1).fill().map(() => {
	    cov_13gc1trqn6().f[26]++;
	    cov_13gc1trqn6().s[57]++;
	    return [];
	  }));
	  cov_13gc1trqn6().s[58]++;
	  return arr.map(item => {
	    cov_13gc1trqn6().f[27]++;
	    let position = (cov_13gc1trqn6().s[59]++, fns.map(fn => {
	      cov_13gc1trqn6().f[28]++;
	      cov_13gc1trqn6().s[60]++;
	      return fn(item);
	    }).indexOf(true));
	    cov_13gc1trqn6().s[61]++;
	    if (position < 0) {
	      cov_13gc1trqn6().b[4][0]++;
	      cov_13gc1trqn6().s[62]++;
	      position = fns.length;
	    } else {
	      cov_13gc1trqn6().b[4][1]++;
	    }
	    cov_13gc1trqn6().s[63]++;
	    return {
	      item,
	      position
	    };
	  }).reduce((acc, item) => {
	    cov_13gc1trqn6().f[29]++;
	    cov_13gc1trqn6().s[64]++;
	    acc[item.position].push(item.item);
	    cov_13gc1trqn6().s[65]++;
	    return acc;
	  }, initArr);
	};
	cov_13gc1trqn6().s[66]++;
	const isMoveOp = _ref3 => {
	  cov_13gc1trqn6().f[30]++;
	  let {
	    op
	  } = (cov_13gc1trqn6().s[67]++, _ref3);
	  cov_13gc1trqn6().s[68]++;
	  return op === 'move';
	};
	cov_13gc1trqn6().s[69]++;
	const isRemoveOp = _ref4 => {
	  cov_13gc1trqn6().f[31]++;
	  let {
	    op
	  } = (cov_13gc1trqn6().s[70]++, _ref4);
	  cov_13gc1trqn6().s[71]++;
	  return op === 'remove';
	};
	cov_13gc1trqn6().s[72]++;
	const reorderOps = diff => {
	  cov_13gc1trqn6().f[32]++;
	  const [moveOps, removedOps, restOps] = (cov_13gc1trqn6().s[73]++, partitionOps(diff, [isMoveOp, isRemoveOp]));
	  const removeOpsReverse = (cov_13gc1trqn6().s[74]++, opsByDescendingOrder(removedOps));
	  cov_13gc1trqn6().s[75]++;
	  return [...removeOpsReverse, ...moveOps, ...restOps];
	};
	let defaultInstance$2;
	cov_13gc1trqn6().s[76]++;
	const format$1 = (delta, left) => {
	  cov_13gc1trqn6().f[33]++;
	  cov_13gc1trqn6().s[77]++;
	  if (!defaultInstance$2) {
	    cov_13gc1trqn6().b[5][0]++;
	    cov_13gc1trqn6().s[78]++;
	    defaultInstance$2 = new JSONFormatter();
	  } else {
	    cov_13gc1trqn6().b[5][1]++;
	  }
	  cov_13gc1trqn6().s[79]++;
	  return reorderOps(defaultInstance$2.format(delta, left));
	};
	cov_13gc1trqn6().s[80]++;
	const log$1 = (delta, left) => {
	  cov_13gc1trqn6().f[34]++;
	  cov_13gc1trqn6().s[81]++;
	  console.log(format$1(delta, left));
	};
	var jsonpatch = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  default: JSONFormatter,
	  format: format$1,
	  log: log$1,
	  partitionOps: partitionOps
	});
	function cov_2dbruxk6di() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/console.js";
	  var hash = "6beebf5377d27c90029d029e5bc90b8fefd320c2";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/console.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 4,
	          column: 2
	        },
	        end: {
	          line: 9,
	          column: 4
	        }
	      },
	      "1": {
	        start: {
	          line: 5,
	          column: 4
	        },
	        end: {
	          line: 7,
	          column: 5
	        }
	      },
	      "2": {
	        start: {
	          line: 5,
	          column: 20
	        },
	        end: {
	          line: 5,
	          column: 36
	        }
	      },
	      "3": {
	        start: {
	          line: 5,
	          column: 45
	        },
	        end: {
	          line: 5,
	          column: 60
	        }
	      },
	      "4": {
	        start: {
	          line: 5,
	          column: 69
	        },
	        end: {
	          line: 5,
	          column: 70
	        }
	      },
	      "5": {
	        start: {
	          line: 6,
	          column: 6
	        },
	        end: {
	          line: 6,
	          column: 35
	        }
	      },
	      "6": {
	        start: {
	          line: 8,
	          column: 4
	        },
	        end: {
	          line: 8,
	          column: 16
	        }
	      },
	      "7": {
	        start: {
	          line: 11,
	          column: 15
	        },
	        end: {
	          line: 19,
	          column: 1
	        }
	      },
	      "8": {
	        start: {
	          line: 22,
	          column: 4
	        },
	        end: {
	          line: 22,
	          column: 12
	        }
	      },
	      "9": {
	        start: {
	          line: 23,
	          column: 4
	        },
	        end: {
	          line: 23,
	          column: 41
	        }
	      },
	      "10": {
	        start: {
	          line: 26,
	          column: 4
	        },
	        end: {
	          line: 26,
	          column: 34
	        }
	      },
	      "11": {
	        start: {
	          line: 27,
	          column: 4
	        },
	        end: {
	          line: 31,
	          column: 6
	        }
	      },
	      "12": {
	        start: {
	          line: 28,
	          column: 6
	        },
	        end: {
	          line: 28,
	          column: 96
	        }
	      },
	      "13": {
	        start: {
	          line: 29,
	          column: 6
	        },
	        end: {
	          line: 29,
	          column: 66
	        }
	      },
	      "14": {
	        start: {
	          line: 30,
	          column: 6
	        },
	        end: {
	          line: 30,
	          column: 21
	        }
	      },
	      "15": {
	        start: {
	          line: 32,
	          column: 4
	        },
	        end: {
	          line: 34,
	          column: 6
	        }
	      },
	      "16": {
	        start: {
	          line: 33,
	          column: 6
	        },
	        end: {
	          line: 33,
	          column: 52
	        }
	      },
	      "17": {
	        start: {
	          line: 35,
	          column: 4
	        },
	        end: {
	          line: 47,
	          column: 6
	        }
	      },
	      "18": {
	        start: {
	          line: 36,
	          column: 6
	        },
	        end: {
	          line: 38,
	          column: 7
	        }
	      },
	      "19": {
	        start: {
	          line: 36,
	          column: 23
	        },
	        end: {
	          line: 36,
	          column: 39
	        }
	      },
	      "20": {
	        start: {
	          line: 36,
	          column: 48
	        },
	        end: {
	          line: 36,
	          column: 64
	        }
	      },
	      "21": {
	        start: {
	          line: 36,
	          column: 74
	        },
	        end: {
	          line: 36,
	          column: 75
	        }
	      },
	      "22": {
	        start: {
	          line: 37,
	          column: 8
	        },
	        end: {
	          line: 37,
	          column: 39
	        }
	      },
	      "23": {
	        start: {
	          line: 39,
	          column: 6
	        },
	        end: {
	          line: 46,
	          column: 7
	        }
	      },
	      "24": {
	        start: {
	          line: 39,
	          column: 19
	        },
	        end: {
	          line: 39,
	          column: 20
	        }
	      },
	      "25": {
	        start: {
	          line: 39,
	          column: 26
	        },
	        end: {
	          line: 39,
	          column: 37
	        }
	      },
	      "26": {
	        start: {
	          line: 40,
	          column: 22
	        },
	        end: {
	          line: 40,
	          column: 41
	        }
	      },
	      "27": {
	        start: {
	          line: 41,
	          column: 19
	        },
	        end: {
	          line: 41,
	          column: 58
	        }
	      },
	      "28": {
	        start: {
	          line: 42,
	          column: 8
	        },
	        end: {
	          line: 44,
	          column: 9
	        }
	      },
	      "29": {
	        start: {
	          line: 43,
	          column: 10
	        },
	        end: {
	          line: 43,
	          column: 37
	        }
	      },
	      "30": {
	        start: {
	          line: 45,
	          column: 8
	        },
	        end: {
	          line: 45,
	          column: 31
	        }
	      },
	      "31": {
	        start: {
	          line: 48,
	          column: 4
	        },
	        end: {
	          line: 51,
	          column: 6
	        }
	      },
	      "32": {
	        start: {
	          line: 49,
	          column: 6
	        },
	        end: {
	          line: 49,
	          column: 36
	        }
	      },
	      "33": {
	        start: {
	          line: 50,
	          column: 6
	        },
	        end: {
	          line: 50,
	          column: 32
	        }
	      },
	      "34": {
	        start: {
	          line: 52,
	          column: 4
	        },
	        end: {
	          line: 55,
	          column: 6
	        }
	      },
	      "35": {
	        start: {
	          line: 53,
	          column: 6
	        },
	        end: {
	          line: 53,
	          column: 36
	        }
	      },
	      "36": {
	        start: {
	          line: 54,
	          column: 6
	        },
	        end: {
	          line: 54,
	          column: 25
	        }
	      },
	      "37": {
	        start: {
	          line: 58,
	          column: 4
	        },
	        end: {
	          line: 58,
	          column: 36
	        }
	      },
	      "38": {
	        start: {
	          line: 59,
	          column: 4
	        },
	        end: {
	          line: 59,
	          column: 33
	        }
	      },
	      "39": {
	        start: {
	          line: 60,
	          column: 4
	        },
	        end: {
	          line: 60,
	          column: 23
	        }
	      },
	      "40": {
	        start: {
	          line: 63,
	          column: 4
	        },
	        end: {
	          line: 63,
	          column: 48
	        }
	      },
	      "41": {
	        start: {
	          line: 66,
	          column: 18
	        },
	        end: {
	          line: 66,
	          column: 43
	        }
	      },
	      "42": {
	        start: {
	          line: 67,
	          column: 4
	        },
	        end: {
	          line: 67,
	          column: 21
	        }
	      },
	      "43": {
	        start: {
	          line: 68,
	          column: 4
	        },
	        end: {
	          line: 83,
	          column: 5
	        }
	      },
	      "44": {
	        start: {
	          line: 68,
	          column: 17
	        },
	        end: {
	          line: 68,
	          column: 18
	        }
	      },
	      "45": {
	        start: {
	          line: 68,
	          column: 24
	        },
	        end: {
	          line: 68,
	          column: 36
	        }
	      },
	      "46": {
	        start: {
	          line: 69,
	          column: 19
	        },
	        end: {
	          line: 69,
	          column: 27
	        }
	      },
	      "47": {
	        start: {
	          line: 70,
	          column: 6
	        },
	        end: {
	          line: 70,
	          column: 45
	        }
	      },
	      "48": {
	        start: {
	          line: 71,
	          column: 6
	        },
	        end: {
	          line: 71,
	          column: 65
	        }
	      },
	      "49": {
	        start: {
	          line: 72,
	          column: 6
	        },
	        end: {
	          line: 72,
	          column: 25
	        }
	      },
	      "50": {
	        start: {
	          line: 73,
	          column: 21
	        },
	        end: {
	          line: 73,
	          column: 32
	        }
	      },
	      "51": {
	        start: {
	          line: 74,
	          column: 6
	        },
	        end: {
	          line: 79,
	          column: 7
	        }
	      },
	      "52": {
	        start: {
	          line: 74,
	          column: 28
	        },
	        end: {
	          line: 74,
	          column: 29
	        }
	      },
	      "53": {
	        start: {
	          line: 74,
	          column: 46
	        },
	        end: {
	          line: 74,
	          column: 59
	        }
	      },
	      "54": {
	        start: {
	          line: 75,
	          column: 22
	        },
	        end: {
	          line: 75,
	          column: 40
	        }
	      },
	      "55": {
	        start: {
	          line: 76,
	          column: 8
	        },
	        end: {
	          line: 76,
	          column: 46
	        }
	      },
	      "56": {
	        start: {
	          line: 77,
	          column: 8
	        },
	        end: {
	          line: 77,
	          column: 32
	        }
	      },
	      "57": {
	        start: {
	          line: 78,
	          column: 8
	        },
	        end: {
	          line: 78,
	          column: 27
	        }
	      },
	      "58": {
	        start: {
	          line: 80,
	          column: 6
	        },
	        end: {
	          line: 82,
	          column: 7
	        }
	      },
	      "59": {
	        start: {
	          line: 81,
	          column: 8
	        },
	        end: {
	          line: 81,
	          column: 26
	        }
	      },
	      "60": {
	        start: {
	          line: 84,
	          column: 4
	        },
	        end: {
	          line: 84,
	          column: 23
	        }
	      },
	      "61": {
	        start: {
	          line: 87,
	          column: 4
	        },
	        end: {
	          line: 87,
	          column: 36
	        }
	      },
	      "62": {
	        start: {
	          line: 88,
	          column: 4
	        },
	        end: {
	          line: 91,
	          column: 5
	        }
	      },
	      "63": {
	        start: {
	          line: 89,
	          column: 6
	        },
	        end: {
	          line: 89,
	          column: 52
	        }
	      },
	      "64": {
	        start: {
	          line: 90,
	          column: 6
	        },
	        end: {
	          line: 90,
	          column: 23
	        }
	      },
	      "65": {
	        start: {
	          line: 94,
	          column: 4
	        },
	        end: {
	          line: 97,
	          column: 5
	        }
	      },
	      "66": {
	        start: {
	          line: 95,
	          column: 6
	        },
	        end: {
	          line: 95,
	          column: 25
	        }
	      },
	      "67": {
	        start: {
	          line: 96,
	          column: 6
	        },
	        end: {
	          line: 96,
	          column: 52
	        }
	      },
	      "68": {
	        start: {
	          line: 98,
	          column: 4
	        },
	        end: {
	          line: 98,
	          column: 23
	        }
	      },
	      "69": {
	        start: {
	          line: 101,
	          column: 4
	        },
	        end: {
	          line: 101,
	          column: 36
	        }
	      },
	      "70": {
	        start: {
	          line: 102,
	          column: 4
	        },
	        end: {
	          line: 102,
	          column: 32
	        }
	      },
	      "71": {
	        start: {
	          line: 103,
	          column: 4
	        },
	        end: {
	          line: 106,
	          column: 5
	        }
	      },
	      "72": {
	        start: {
	          line: 104,
	          column: 6
	        },
	        end: {
	          line: 104,
	          column: 52
	        }
	      },
	      "73": {
	        start: {
	          line: 105,
	          column: 6
	        },
	        end: {
	          line: 105,
	          column: 23
	        }
	      },
	      "74": {
	        start: {
	          line: 109,
	          column: 4
	        },
	        end: {
	          line: 112,
	          column: 5
	        }
	      },
	      "75": {
	        start: {
	          line: 110,
	          column: 6
	        },
	        end: {
	          line: 110,
	          column: 25
	        }
	      },
	      "76": {
	        start: {
	          line: 111,
	          column: 6
	        },
	        end: {
	          line: 111,
	          column: 72
	        }
	      },
	      "77": {
	        start: {
	          line: 113,
	          column: 4
	        },
	        end: {
	          line: 115,
	          column: 5
	        }
	      },
	      "78": {
	        start: {
	          line: 114,
	          column: 6
	        },
	        end: {
	          line: 114,
	          column: 24
	        }
	      },
	      "79": {
	        start: {
	          line: 116,
	          column: 4
	        },
	        end: {
	          line: 116,
	          column: 23
	        }
	      },
	      "80": {
	        start: {
	          line: 123,
	          column: 4
	        },
	        end: {
	          line: 125,
	          column: 5
	        }
	      },
	      "81": {
	        start: {
	          line: 124,
	          column: 6
	        },
	        end: {
	          line: 124,
	          column: 13
	        }
	      },
	      "82": {
	        start: {
	          line: 126,
	          column: 4
	        },
	        end: {
	          line: 126,
	          column: 36
	        }
	      },
	      "83": {
	        start: {
	          line: 129,
	          column: 4
	        },
	        end: {
	          line: 131,
	          column: 5
	        }
	      },
	      "84": {
	        start: {
	          line: 130,
	          column: 6
	        },
	        end: {
	          line: 130,
	          column: 13
	        }
	      },
	      "85": {
	        start: {
	          line: 132,
	          column: 4
	        },
	        end: {
	          line: 132,
	          column: 36
	        }
	      },
	      "86": {
	        start: {
	          line: 136,
	          column: 4
	        },
	        end: {
	          line: 136,
	          column: 51
	        }
	      },
	      "87": {
	        start: {
	          line: 139,
	          column: 4
	        },
	        end: {
	          line: 139,
	          column: 40
	        }
	      },
	      "88": {
	        start: {
	          line: 142,
	          column: 4
	        },
	        end: {
	          line: 142,
	          column: 38
	        }
	      },
	      "89": {
	        start: {
	          line: 143,
	          column: 4
	        },
	        end: {
	          line: 143,
	          column: 40
	        }
	      },
	      "90": {
	        start: {
	          line: 144,
	          column: 4
	        },
	        end: {
	          line: 144,
	          column: 23
	        }
	      },
	      "91": {
	        start: {
	          line: 145,
	          column: 4
	        },
	        end: {
	          line: 145,
	          column: 24
	        }
	      },
	      "92": {
	        start: {
	          line: 146,
	          column: 4
	        },
	        end: {
	          line: 146,
	          column: 36
	        }
	      },
	      "93": {
	        start: {
	          line: 147,
	          column: 4
	        },
	        end: {
	          line: 147,
	          column: 40
	        }
	      },
	      "94": {
	        start: {
	          line: 148,
	          column: 4
	        },
	        end: {
	          line: 148,
	          column: 23
	        }
	      },
	      "95": {
	        start: {
	          line: 151,
	          column: 4
	        },
	        end: {
	          line: 151,
	          column: 40
	        }
	      },
	      "96": {
	        start: {
	          line: 154,
	          column: 4
	        },
	        end: {
	          line: 154,
	          column: 35
	        }
	      },
	      "97": {
	        start: {
	          line: 157,
	          column: 4
	        },
	        end: {
	          line: 157,
	          column: 49
	        }
	      },
	      "98": {
	        start: {
	          line: 167,
	          column: 22
	        },
	        end: {
	          line: 172,
	          column: 1
	        }
	      },
	      "99": {
	        start: {
	          line: 168,
	          column: 2
	        },
	        end: {
	          line: 170,
	          column: 3
	        }
	      },
	      "100": {
	        start: {
	          line: 169,
	          column: 4
	        },
	        end: {
	          line: 169,
	          column: 45
	        }
	      },
	      "101": {
	        start: {
	          line: 171,
	          column: 2
	        },
	        end: {
	          line: 171,
	          column: 45
	        }
	      },
	      "102": {
	        start: {
	          line: 174,
	          column: 2
	        },
	        end: {
	          line: 174,
	          column: 35
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "chalkColor",
	        decl: {
	          start: {
	            line: 3,
	            column: 9
	          },
	          end: {
	            line: 3,
	            column: 19
	          }
	        },
	        loc: {
	          start: {
	            line: 3,
	            column: 26
	          },
	          end: {
	            line: 10,
	            column: 1
	          }
	        },
	        line: 3
	      },
	      "1": {
	        name: "(anonymous_1)",
	        decl: {
	          start: {
	            line: 4,
	            column: 33
	          },
	          end: {
	            line: 4,
	            column: 34
	          }
	        },
	        loc: {
	          start: {
	            line: 4,
	            column: 45
	          },
	          end: {
	            line: 9,
	            column: 3
	          }
	        },
	        line: 4
	      },
	      "2": {
	        name: "(anonymous_2)",
	        decl: {
	          start: {
	            line: 21,
	            column: 2
	          },
	          end: {
	            line: 21,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 21,
	            column: 16
	          },
	          end: {
	            line: 24,
	            column: 3
	          }
	        },
	        line: 21
	      },
	      "3": {
	        name: "(anonymous_3)",
	        decl: {
	          start: {
	            line: 25,
	            column: 2
	          },
	          end: {
	            line: 25,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 25,
	            column: 26
	          },
	          end: {
	            line: 56,
	            column: 3
	          }
	        },
	        line: 25
	      },
	      "4": {
	        name: "(anonymous_4)",
	        decl: {
	          start: {
	            line: 27,
	            column: 21
	          },
	          end: {
	            line: 27,
	            column: 22
	          }
	        },
	        loc: {
	          start: {
	            line: 27,
	            column: 39
	          },
	          end: {
	            line: 31,
	            column: 5
	          }
	        },
	        line: 27
	      },
	      "5": {
	        name: "(anonymous_5)",
	        decl: {
	          start: {
	            line: 32,
	            column: 22
	          },
	          end: {
	            line: 32,
	            column: 23
	          }
	        },
	        loc: {
	          start: {
	            line: 32,
	            column: 34
	          },
	          end: {
	            line: 34,
	            column: 5
	          }
	        },
	        line: 32
	      },
	      "6": {
	        name: "(anonymous_6)",
	        decl: {
	          start: {
	            line: 35,
	            column: 18
	          },
	          end: {
	            line: 35,
	            column: 19
	          }
	        },
	        loc: {
	          start: {
	            line: 35,
	            column: 30
	          },
	          end: {
	            line: 47,
	            column: 5
	          }
	        },
	        line: 35
	      },
	      "7": {
	        name: "(anonymous_7)",
	        decl: {
	          start: {
	            line: 48,
	            column: 24
	          },
	          end: {
	            line: 48,
	            column: 25
	          }
	        },
	        loc: {
	          start: {
	            line: 48,
	            column: 41
	          },
	          end: {
	            line: 51,
	            column: 5
	          }
	        },
	        line: 48
	      },
	      "8": {
	        name: "(anonymous_8)",
	        decl: {
	          start: {
	            line: 52,
	            column: 23
	          },
	          end: {
	            line: 52,
	            column: 24
	          }
	        },
	        loc: {
	          start: {
	            line: 52,
	            column: 35
	          },
	          end: {
	            line: 55,
	            column: 5
	          }
	        },
	        line: 52
	      },
	      "9": {
	        name: "(anonymous_9)",
	        decl: {
	          start: {
	            line: 57,
	            column: 2
	          },
	          end: {
	            line: 57,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 57,
	            column: 45
	          },
	          end: {
	            line: 61,
	            column: 3
	          }
	        },
	        line: 57
	      },
	      "10": {
	        name: "(anonymous_10)",
	        decl: {
	          start: {
	            line: 62,
	            column: 2
	          },
	          end: {
	            line: 62,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 62,
	            column: 30
	          },
	          end: {
	            line: 64,
	            column: 3
	          }
	        },
	        line: 62
	      },
	      "11": {
	        name: "(anonymous_11)",
	        decl: {
	          start: {
	            line: 65,
	            column: 2
	          },
	          end: {
	            line: 65,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 65,
	            column: 39
	          },
	          end: {
	            line: 85,
	            column: 3
	          }
	        },
	        line: 65
	      },
	      "12": {
	        name: "(anonymous_12)",
	        decl: {
	          start: {
	            line: 86,
	            column: 2
	          },
	          end: {
	            line: 86,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 86,
	            column: 37
	          },
	          end: {
	            line: 92,
	            column: 3
	          }
	        },
	        line: 86
	      },
	      "13": {
	        name: "(anonymous_13)",
	        decl: {
	          start: {
	            line: 93,
	            column: 2
	          },
	          end: {
	            line: 93,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 93,
	            column: 35
	          },
	          end: {
	            line: 99,
	            column: 3
	          }
	        },
	        line: 93
	      },
	      "14": {
	        name: "(anonymous_14)",
	        decl: {
	          start: {
	            line: 100,
	            column: 2
	          },
	          end: {
	            line: 100,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 100,
	            column: 51
	          },
	          end: {
	            line: 107,
	            column: 3
	          }
	        },
	        line: 100
	      },
	      "15": {
	        name: "(anonymous_15)",
	        decl: {
	          start: {
	            line: 108,
	            column: 2
	          },
	          end: {
	            line: 108,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 108,
	            column: 57
	          },
	          end: {
	            line: 117,
	            column: 3
	          }
	        },
	        line: 108
	      },
	      "16": {
	        name: "(anonymous_16)",
	        decl: {
	          start: {
	            line: 122,
	            column: 2
	          },
	          end: {
	            line: 122,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 122,
	            column: 41
	          },
	          end: {
	            line: 127,
	            column: 3
	          }
	        },
	        line: 122
	      },
	      "17": {
	        name: "(anonymous_17)",
	        decl: {
	          start: {
	            line: 128,
	            column: 2
	          },
	          end: {
	            line: 128,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 128,
	            column: 47
	          },
	          end: {
	            line: 133,
	            column: 3
	          }
	        },
	        line: 128
	      },
	      "18": {
	        name: "(anonymous_18)",
	        decl: {
	          start: {
	            line: 134,
	            column: 2
	          },
	          end: {
	            line: 134,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 134,
	            column: 36
	          },
	          end: {
	            line: 137,
	            column: 3
	          }
	        },
	        line: 134
	      },
	      "19": {
	        name: "(anonymous_19)",
	        decl: {
	          start: {
	            line: 138,
	            column: 2
	          },
	          end: {
	            line: 138,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 138,
	            column: 31
	          },
	          end: {
	            line: 140,
	            column: 3
	          }
	        },
	        line: 138
	      },
	      "20": {
	        name: "(anonymous_20)",
	        decl: {
	          start: {
	            line: 141,
	            column: 2
	          },
	          end: {
	            line: 141,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 141,
	            column: 34
	          },
	          end: {
	            line: 149,
	            column: 3
	          }
	        },
	        line: 141
	      },
	      "21": {
	        name: "(anonymous_21)",
	        decl: {
	          start: {
	            line: 150,
	            column: 2
	          },
	          end: {
	            line: 150,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 150,
	            column: 33
	          },
	          end: {
	            line: 152,
	            column: 3
	          }
	        },
	        line: 150
	      },
	      "22": {
	        name: "(anonymous_22)",
	        decl: {
	          start: {
	            line: 153,
	            column: 2
	          },
	          end: {
	            line: 153,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 153,
	            column: 31
	          },
	          end: {
	            line: 155,
	            column: 3
	          }
	        },
	        line: 153
	      },
	      "23": {
	        name: "(anonymous_23)",
	        decl: {
	          start: {
	            line: 156,
	            column: 2
	          },
	          end: {
	            line: 156,
	            column: 3
	          }
	        },
	        loc: {
	          start: {
	            line: 156,
	            column: 34
	          },
	          end: {
	            line: 158,
	            column: 3
	          }
	        },
	        line: 156
	      },
	      "24": {
	        name: "(anonymous_24)",
	        decl: {
	          start: {
	            line: 167,
	            column: 22
	          },
	          end: {
	            line: 167,
	            column: 23
	          }
	        },
	        loc: {
	          start: {
	            line: 167,
	            column: 39
	          },
	          end: {
	            line: 172,
	            column: 1
	          }
	        },
	        line: 167
	      },
	      "25": {
	        name: "log",
	        decl: {
	          start: {
	            line: 173,
	            column: 16
	          },
	          end: {
	            line: 173,
	            column: 19
	          }
	        },
	        loc: {
	          start: {
	            line: 173,
	            column: 33
	          },
	          end: {
	            line: 175,
	            column: 1
	          }
	        },
	        line: 173
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 4,
	            column: 9
	          },
	          end: {
	            line: 9,
	            column: 3
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 4,
	            column: 9
	          },
	          end: {
	            line: 4,
	            column: 14
	          }
	        }, {
	          start: {
	            line: 4,
	            column: 18
	          },
	          end: {
	            line: 4,
	            column: 29
	          }
	        }, {
	          start: {
	            line: 4,
	            column: 33
	          },
	          end: {
	            line: 9,
	            column: 3
	          }
	        }],
	        line: 4
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 28,
	            column: 26
	          },
	          end: {
	            line: 28,
	            column: 47
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 28,
	            column: 26
	          },
	          end: {
	            line: 28,
	            column: 42
	          }
	        }, {
	          start: {
	            line: 28,
	            column: 46
	          },
	          end: {
	            line: 28,
	            column: 47
	          }
	        }],
	        line: 28
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 28,
	            column: 52
	          },
	          end: {
	            line: 28,
	            column: 94
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 28,
	            column: 84
	          },
	          end: {
	            line: 28,
	            column: 85
	          }
	        }, {
	          start: {
	            line: 28,
	            column: 88
	          },
	          end: {
	            line: 28,
	            column: 94
	          }
	        }],
	        line: 28
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 33,
	            column: 28
	          },
	          end: {
	            line: 33,
	            column: 48
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 33,
	            column: 28
	          },
	          end: {
	            line: 33,
	            column: 42
	          }
	        }, {
	          start: {
	            line: 33,
	            column: 46
	          },
	          end: {
	            line: 33,
	            column: 48
	          }
	        }],
	        line: 33
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 41,
	            column: 35
	          },
	          end: {
	            line: 41,
	            column: 55
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 41,
	            column: 35
	          },
	          end: {
	            line: 41,
	            column: 49
	          }
	        }, {
	          start: {
	            line: 41,
	            column: 53
	          },
	          end: {
	            line: 41,
	            column: 55
	          }
	        }],
	        line: 41
	      },
	      "5": {
	        loc: {
	          start: {
	            line: 42,
	            column: 8
	          },
	          end: {
	            line: 44,
	            column: 9
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 42,
	            column: 8
	          },
	          end: {
	            line: 44,
	            column: 9
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 42
	      },
	      "6": {
	        loc: {
	          start: {
	            line: 42,
	            column: 12
	          },
	          end: {
	            line: 42,
	            column: 39
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 42,
	            column: 12
	          },
	          end: {
	            line: 42,
	            column: 22
	          }
	        }, {
	          start: {
	            line: 42,
	            column: 26
	          },
	          end: {
	            line: 42,
	            column: 39
	          }
	        }],
	        line: 42
	      },
	      "7": {
	        loc: {
	          start: {
	            line: 49,
	            column: 19
	          },
	          end: {
	            line: 49,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 49,
	            column: 19
	          },
	          end: {
	            line: 49,
	            column: 29
	          }
	        }, {
	          start: {
	            line: 49,
	            column: 33
	          },
	          end: {
	            line: 49,
	            column: 35
	          }
	        }],
	        line: 49
	      },
	      "8": {
	        loc: {
	          start: {
	            line: 53,
	            column: 19
	          },
	          end: {
	            line: 53,
	            column: 35
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 53,
	            column: 19
	          },
	          end: {
	            line: 53,
	            column: 29
	          }
	        }, {
	          start: {
	            line: 53,
	            column: 33
	          },
	          end: {
	            line: 53,
	            column: 35
	          }
	        }],
	        line: 53
	      },
	      "9": {
	        loc: {
	          start: {
	            line: 80,
	            column: 6
	          },
	          end: {
	            line: 82,
	            column: 7
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 80,
	            column: 6
	          },
	          end: {
	            line: 82,
	            column: 7
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 80
	      },
	      "10": {
	        loc: {
	          start: {
	            line: 88,
	            column: 4
	          },
	          end: {
	            line: 91,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 88,
	            column: 4
	          },
	          end: {
	            line: 91,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 88
	      },
	      "11": {
	        loc: {
	          start: {
	            line: 89,
	            column: 18
	          },
	          end: {
	            line: 89,
	            column: 50
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 89,
	            column: 41
	          },
	          end: {
	            line: 89,
	            column: 44
	          }
	        }, {
	          start: {
	            line: 89,
	            column: 47
	          },
	          end: {
	            line: 89,
	            column: 50
	          }
	        }],
	        line: 89
	      },
	      "12": {
	        loc: {
	          start: {
	            line: 94,
	            column: 4
	          },
	          end: {
	            line: 97,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 94,
	            column: 4
	          },
	          end: {
	            line: 97,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 94
	      },
	      "13": {
	        loc: {
	          start: {
	            line: 96,
	            column: 18
	          },
	          end: {
	            line: 96,
	            column: 50
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 96,
	            column: 41
	          },
	          end: {
	            line: 96,
	            column: 44
	          }
	        }, {
	          start: {
	            line: 96,
	            column: 47
	          },
	          end: {
	            line: 96,
	            column: 50
	          }
	        }],
	        line: 96
	      },
	      "14": {
	        loc: {
	          start: {
	            line: 103,
	            column: 4
	          },
	          end: {
	            line: 106,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 103,
	            column: 4
	          },
	          end: {
	            line: 106,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 103
	      },
	      "15": {
	        loc: {
	          start: {
	            line: 104,
	            column: 18
	          },
	          end: {
	            line: 104,
	            column: 50
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 104,
	            column: 41
	          },
	          end: {
	            line: 104,
	            column: 44
	          }
	        }, {
	          start: {
	            line: 104,
	            column: 47
	          },
	          end: {
	            line: 104,
	            column: 50
	          }
	        }],
	        line: 104
	      },
	      "16": {
	        loc: {
	          start: {
	            line: 109,
	            column: 4
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 109,
	            column: 4
	          },
	          end: {
	            line: 112,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 109
	      },
	      "17": {
	        loc: {
	          start: {
	            line: 111,
	            column: 18
	          },
	          end: {
	            line: 111,
	            column: 70
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 111,
	            column: 41
	          },
	          end: {
	            line: 111,
	            column: 44
	          }
	        }, {
	          start: {
	            line: 111,
	            column: 47
	          },
	          end: {
	            line: 111,
	            column: 70
	          }
	        }],
	        line: 111
	      },
	      "18": {
	        loc: {
	          start: {
	            line: 111,
	            column: 51
	          },
	          end: {
	            line: 111,
	            column: 68
	          }
	        },
	        type: "cond-expr",
	        locations: [{
	          start: {
	            line: 111,
	            column: 60
	          },
	          end: {
	            line: 111,
	            column: 62
	          }
	        }, {
	          start: {
	            line: 111,
	            column: 65
	          },
	          end: {
	            line: 111,
	            column: 68
	          }
	        }],
	        line: 111
	      },
	      "19": {
	        loc: {
	          start: {
	            line: 113,
	            column: 4
	          },
	          end: {
	            line: 115,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 113,
	            column: 4
	          },
	          end: {
	            line: 115,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 113
	      },
	      "20": {
	        loc: {
	          start: {
	            line: 123,
	            column: 4
	          },
	          end: {
	            line: 125,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 123,
	            column: 4
	          },
	          end: {
	            line: 125,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 123
	      },
	      "21": {
	        loc: {
	          start: {
	            line: 129,
	            column: 4
	          },
	          end: {
	            line: 131,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 129,
	            column: 4
	          },
	          end: {
	            line: 131,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 129
	      },
	      "22": {
	        loc: {
	          start: {
	            line: 168,
	            column: 2
	          },
	          end: {
	            line: 170,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 168,
	            column: 2
	          },
	          end: {
	            line: 170,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 168
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0,
	      "26": 0,
	      "27": 0,
	      "28": 0,
	      "29": 0,
	      "30": 0,
	      "31": 0,
	      "32": 0,
	      "33": 0,
	      "34": 0,
	      "35": 0,
	      "36": 0,
	      "37": 0,
	      "38": 0,
	      "39": 0,
	      "40": 0,
	      "41": 0,
	      "42": 0,
	      "43": 0,
	      "44": 0,
	      "45": 0,
	      "46": 0,
	      "47": 0,
	      "48": 0,
	      "49": 0,
	      "50": 0,
	      "51": 0,
	      "52": 0,
	      "53": 0,
	      "54": 0,
	      "55": 0,
	      "56": 0,
	      "57": 0,
	      "58": 0,
	      "59": 0,
	      "60": 0,
	      "61": 0,
	      "62": 0,
	      "63": 0,
	      "64": 0,
	      "65": 0,
	      "66": 0,
	      "67": 0,
	      "68": 0,
	      "69": 0,
	      "70": 0,
	      "71": 0,
	      "72": 0,
	      "73": 0,
	      "74": 0,
	      "75": 0,
	      "76": 0,
	      "77": 0,
	      "78": 0,
	      "79": 0,
	      "80": 0,
	      "81": 0,
	      "82": 0,
	      "83": 0,
	      "84": 0,
	      "85": 0,
	      "86": 0,
	      "87": 0,
	      "88": 0,
	      "89": 0,
	      "90": 0,
	      "91": 0,
	      "92": 0,
	      "93": 0,
	      "94": 0,
	      "95": 0,
	      "96": 0,
	      "97": 0,
	      "98": 0,
	      "99": 0,
	      "100": 0,
	      "101": 0,
	      "102": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0,
	      "16": 0,
	      "17": 0,
	      "18": 0,
	      "19": 0,
	      "20": 0,
	      "21": 0,
	      "22": 0,
	      "23": 0,
	      "24": 0,
	      "25": 0
	    },
	    b: {
	      "0": [0, 0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0],
	      "5": [0, 0],
	      "6": [0, 0],
	      "7": [0, 0],
	      "8": [0, 0],
	      "9": [0, 0],
	      "10": [0, 0],
	      "11": [0, 0],
	      "12": [0, 0],
	      "13": [0, 0],
	      "14": [0, 0],
	      "15": [0, 0],
	      "16": [0, 0],
	      "17": [0, 0],
	      "18": [0, 0],
	      "19": [0, 0],
	      "20": [0, 0],
	      "21": [0, 0],
	      "22": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/console.js"],
	      sourcesContent: ["import chalk from 'chalk';\nimport BaseFormatter from './base';\n\nfunction chalkColor(name) {\n  return (\n    (chalk && chalk[name]) ||\n    function(...args) {\n      return args;\n    }\n  );\n}\n\nconst colors = {\n  added: chalkColor('green'),\n  deleted: chalkColor('red'),\n  movedestination: chalkColor('gray'),\n  moved: chalkColor('yellow'),\n  unchanged: chalkColor('gray'),\n  error: chalkColor('white.bgRed'),\n  textDiffLine: chalkColor('gray'),\n};\n\nclass ConsoleFormatter extends BaseFormatter {\n  constructor() {\n    super();\n    this.includeMoveDestinations = false;\n  }\n\n  prepareContext(context) {\n    super.prepareContext(context);\n    context.indent = function(levels) {\n      this.indentLevel =\n        (this.indentLevel || 0) + (typeof levels === 'undefined' ? 1 : levels);\n      this.indentPad = new Array(this.indentLevel + 1).join('  ');\n      this.outLine();\n    };\n    context.outLine = function() {\n      this.buffer.push(`\\n${this.indentPad || ''}`);\n    };\n    context.out = function(...args) {\n      for (let i = 0, l = args.length; i < l; i++) {\n        const lines = args[i].split('\\n');\n        let text = lines.join(`\\n${this.indentPad || ''}`);\n        if (this.color && this.color[0]) {\n          text = this.color[0](text);\n        }\n        this.buffer.push(text);\n      }\n    };\n    context.pushColor = function(color) {\n      this.color = this.color || [];\n      this.color.unshift(color);\n    };\n    context.popColor = function() {\n      this.color = this.color || [];\n      this.color.shift();\n    };\n  }\n\n  typeFormattterErrorFormatter(context, err) {\n    context.pushColor(colors.error);\n    context.out(`[ERROR]${err}`);\n    context.popColor();\n  }\n\n  formatValue(context, value) {\n    context.out(JSON.stringify(value, null, 2));\n  }\n\n  formatTextDiffString(context, value) {\n    const lines = this.parseTextDiff(value);\n    context.indent();\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      context.pushColor(colors.textDiffLine);\n      context.out(`${line.location.line},${line.location.chr} `);\n      context.popColor();\n      const pieces = line.pieces;\n      for (\n        let pieceIndex = 0, piecesLength = pieces.length;\n        pieceIndex < piecesLength;\n        pieceIndex++\n      ) {\n        const piece = pieces[pieceIndex];\n        context.pushColor(colors[piece.type]);\n        context.out(piece.text);\n        context.popColor();\n      }\n      if (i < l - 1) {\n        context.outLine();\n      }\n    }\n    context.indent(-1);\n  }\n\n  rootBegin(context, type, nodeType) {\n    context.pushColor(colors[type]);\n    if (type === 'node') {\n      context.out(nodeType === 'array' ? '[' : '{');\n      context.indent();\n    }\n  }\n\n  rootEnd(context, type, nodeType) {\n    if (type === 'node') {\n      context.indent(-1);\n      context.out(nodeType === 'array' ? ']' : '}');\n    }\n    context.popColor();\n  }\n\n  nodeBegin(context, key, leftKey, type, nodeType) {\n    context.pushColor(colors[type]);\n    context.out(`${leftKey}: `);\n    if (type === 'node') {\n      context.out(nodeType === 'array' ? '[' : '{');\n      context.indent();\n    }\n  }\n\n  nodeEnd(context, key, leftKey, type, nodeType, isLast) {\n    if (type === 'node') {\n      context.indent(-1);\n      context.out(nodeType === 'array' ? ']' : `}${isLast ? '' : ','}`);\n    }\n    if (!isLast) {\n      context.outLine();\n    }\n    context.popColor();\n  }\n\n  /* jshint camelcase: false */\n  /* eslint-disable camelcase */\n\n  format_unchanged(context, delta, left) {\n    if (typeof left === 'undefined') {\n      return;\n    }\n    this.formatValue(context, left);\n  }\n\n  format_movedestination(context, delta, left) {\n    if (typeof left === 'undefined') {\n      return;\n    }\n    this.formatValue(context, left);\n  }\n\n  format_node(context, delta, left) {\n    // recurse\n    this.formatDeltaChildren(context, delta, left);\n  }\n\n  format_added(context, delta) {\n    this.formatValue(context, delta[0]);\n  }\n\n  format_modified(context, delta) {\n    context.pushColor(colors.deleted);\n    this.formatValue(context, delta[0]);\n    context.popColor();\n    context.out(' => ');\n    context.pushColor(colors.added);\n    this.formatValue(context, delta[1]);\n    context.popColor();\n  }\n\n  format_deleted(context, delta) {\n    this.formatValue(context, delta[0]);\n  }\n\n  format_moved(context, delta) {\n    context.out(`==> ${delta[1]}`);\n  }\n\n  format_textdiff(context, delta) {\n    this.formatTextDiffString(context, delta[0]);\n  }\n}\n\n/* eslint-enable camelcase */\n\n/* jshint camelcase: true */\n\nexport default ConsoleFormatter;\n\nlet defaultInstance;\n\nexport const format = (delta, left) => {\n  if (!defaultInstance) {\n    defaultInstance = new ConsoleFormatter();\n  }\n  return defaultInstance.format(delta, left);\n};\n\nexport function log(delta, left) {\n  console.log(format(delta, left));\n}\n"],
	      names: ["chalk", "BaseFormatter", "chalkColor", "name", "_len", "arguments", "length", "args", "Array", "_key", "colors", "added", "deleted", "movedestination", "moved", "unchanged", "error", "textDiffLine", "ConsoleFormatter", "constructor", "includeMoveDestinations", "prepareContext", "context", "indent", "levels", "indentLevel", "indentPad", "join", "outLine", "buffer", "push", "out", "_len2", "_key2", "i", "l", "lines", "split", "text", "color", "pushColor", "unshift", "popColor", "shift", "typeFormattterErrorFormatter", "err", "formatValue", "value", "JSON", "stringify", "formatTextDiffString", "parseTextDiff", "line", "location", "chr", "pieces", "pieceIndex", "piecesLength", "piece", "type", "rootBegin", "nodeType", "rootEnd", "nodeBegin", "key", "leftKey", "nodeEnd", "isLast", "format_unchanged", "delta", "left", "format_movedestination", "format_node", "formatDeltaChildren", "format_added", "format_modified", "format_deleted", "format_moved", "format_textdiff", "defaultInstance", "format", "log", "console"],
	      mappings: "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",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "6beebf5377d27c90029d029e5bc90b8fefd320c2"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_2dbruxk6di = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_2dbruxk6di();
	function chalkColor(name) {
	  cov_2dbruxk6di().f[0]++;
	  cov_2dbruxk6di().s[0]++;
	  return (cov_2dbruxk6di().b[0][0]++, chalk) && (cov_2dbruxk6di().b[0][1]++, chalk[name]) || (cov_2dbruxk6di().b[0][2]++, function () {
	    cov_2dbruxk6di().f[1]++;
	    cov_2dbruxk6di().s[1]++;
	    for (var _len = (cov_2dbruxk6di().s[2]++, arguments.length), args = (cov_2dbruxk6di().s[3]++, new Array(_len)), _key = (cov_2dbruxk6di().s[4]++, 0); _key < _len; _key++) {
	      cov_2dbruxk6di().s[5]++;
	      args[_key] = arguments[_key];
	    }
	    cov_2dbruxk6di().s[6]++;
	    return args;
	  });
	}
	const colors = (cov_2dbruxk6di().s[7]++, {
	  added: chalkColor('green'),
	  deleted: chalkColor('red'),
	  movedestination: chalkColor('gray'),
	  moved: chalkColor('yellow'),
	  unchanged: chalkColor('gray'),
	  error: chalkColor('white.bgRed'),
	  textDiffLine: chalkColor('gray')
	});
	class ConsoleFormatter extends BaseFormatter {
	  constructor() {
	    cov_2dbruxk6di().f[2]++;
	    cov_2dbruxk6di().s[8]++;
	    super();
	    cov_2dbruxk6di().s[9]++;
	    this.includeMoveDestinations = false;
	  }
	  prepareContext(context) {
	    cov_2dbruxk6di().f[3]++;
	    cov_2dbruxk6di().s[10]++;
	    super.prepareContext(context);
	    cov_2dbruxk6di().s[11]++;
	    context.indent = function (levels) {
	      cov_2dbruxk6di().f[4]++;
	      cov_2dbruxk6di().s[12]++;
	      this.indentLevel = ((cov_2dbruxk6di().b[1][0]++, this.indentLevel) || (cov_2dbruxk6di().b[1][1]++, 0)) + (typeof levels === 'undefined' ? (cov_2dbruxk6di().b[2][0]++, 1) : (cov_2dbruxk6di().b[2][1]++, levels));
	      cov_2dbruxk6di().s[13]++;
	      this.indentPad = new Array(this.indentLevel + 1).join('  ');
	      cov_2dbruxk6di().s[14]++;
	      this.outLine();
	    };
	    cov_2dbruxk6di().s[15]++;
	    context.outLine = function () {
	      cov_2dbruxk6di().f[5]++;
	      cov_2dbruxk6di().s[16]++;
	      this.buffer.push(`\n${(cov_2dbruxk6di().b[3][0]++, this.indentPad) || (cov_2dbruxk6di().b[3][1]++, '')}`);
	    };
	    cov_2dbruxk6di().s[17]++;
	    context.out = function () {
	      cov_2dbruxk6di().f[6]++;
	      cov_2dbruxk6di().s[18]++;
	      for (var _len2 = (cov_2dbruxk6di().s[19]++, arguments.length), args = (cov_2dbruxk6di().s[20]++, new Array(_len2)), _key2 = (cov_2dbruxk6di().s[21]++, 0); _key2 < _len2; _key2++) {
	        cov_2dbruxk6di().s[22]++;
	        args[_key2] = arguments[_key2];
	      }
	      cov_2dbruxk6di().s[23]++;
	      for (let i = (cov_2dbruxk6di().s[24]++, 0), l = (cov_2dbruxk6di().s[25]++, args.length); i < l; i++) {
	        const lines = (cov_2dbruxk6di().s[26]++, args[i].split('\n'));
	        let text = (cov_2dbruxk6di().s[27]++, lines.join(`\n${(cov_2dbruxk6di().b[4][0]++, this.indentPad) || (cov_2dbruxk6di().b[4][1]++, '')}`));
	        cov_2dbruxk6di().s[28]++;
	        if ((cov_2dbruxk6di().b[6][0]++, this.color) && (cov_2dbruxk6di().b[6][1]++, this.color[0])) {
	          cov_2dbruxk6di().b[5][0]++;
	          cov_2dbruxk6di().s[29]++;
	          text = this.color[0](text);
	        } else {
	          cov_2dbruxk6di().b[5][1]++;
	        }
	        cov_2dbruxk6di().s[30]++;
	        this.buffer.push(text);
	      }
	    };
	    cov_2dbruxk6di().s[31]++;
	    context.pushColor = function (color) {
	      cov_2dbruxk6di().f[7]++;
	      cov_2dbruxk6di().s[32]++;
	      this.color = (cov_2dbruxk6di().b[7][0]++, this.color) || (cov_2dbruxk6di().b[7][1]++, []);
	      cov_2dbruxk6di().s[33]++;
	      this.color.unshift(color);
	    };
	    cov_2dbruxk6di().s[34]++;
	    context.popColor = function () {
	      cov_2dbruxk6di().f[8]++;
	      cov_2dbruxk6di().s[35]++;
	      this.color = (cov_2dbruxk6di().b[8][0]++, this.color) || (cov_2dbruxk6di().b[8][1]++, []);
	      cov_2dbruxk6di().s[36]++;
	      this.color.shift();
	    };
	  }
	  typeFormattterErrorFormatter(context, err) {
	    cov_2dbruxk6di().f[9]++;
	    cov_2dbruxk6di().s[37]++;
	    context.pushColor(colors.error);
	    cov_2dbruxk6di().s[38]++;
	    context.out(`[ERROR]${err}`);
	    cov_2dbruxk6di().s[39]++;
	    context.popColor();
	  }
	  formatValue(context, value) {
	    cov_2dbruxk6di().f[10]++;
	    cov_2dbruxk6di().s[40]++;
	    context.out(JSON.stringify(value, null, 2));
	  }
	  formatTextDiffString(context, value) {
	    cov_2dbruxk6di().f[11]++;
	    const lines = (cov_2dbruxk6di().s[41]++, this.parseTextDiff(value));
	    cov_2dbruxk6di().s[42]++;
	    context.indent();
	    cov_2dbruxk6di().s[43]++;
	    for (let i = (cov_2dbruxk6di().s[44]++, 0), l = (cov_2dbruxk6di().s[45]++, lines.length); i < l; i++) {
	      const line = (cov_2dbruxk6di().s[46]++, lines[i]);
	      cov_2dbruxk6di().s[47]++;
	      context.pushColor(colors.textDiffLine);
	      cov_2dbruxk6di().s[48]++;
	      context.out(`${line.location.line},${line.location.chr} `);
	      cov_2dbruxk6di().s[49]++;
	      context.popColor();
	      const pieces = (cov_2dbruxk6di().s[50]++, line.pieces);
	      cov_2dbruxk6di().s[51]++;
	      for (let pieceIndex = (cov_2dbruxk6di().s[52]++, 0), piecesLength = (cov_2dbruxk6di().s[53]++, pieces.length); pieceIndex < piecesLength; pieceIndex++) {
	        const piece = (cov_2dbruxk6di().s[54]++, pieces[pieceIndex]);
	        cov_2dbruxk6di().s[55]++;
	        context.pushColor(colors[piece.type]);
	        cov_2dbruxk6di().s[56]++;
	        context.out(piece.text);
	        cov_2dbruxk6di().s[57]++;
	        context.popColor();
	      }
	      cov_2dbruxk6di().s[58]++;
	      if (i < l - 1) {
	        cov_2dbruxk6di().b[9][0]++;
	        cov_2dbruxk6di().s[59]++;
	        context.outLine();
	      } else {
	        cov_2dbruxk6di().b[9][1]++;
	      }
	    }
	    cov_2dbruxk6di().s[60]++;
	    context.indent(-1);
	  }
	  rootBegin(context, type, nodeType) {
	    cov_2dbruxk6di().f[12]++;
	    cov_2dbruxk6di().s[61]++;
	    context.pushColor(colors[type]);
	    cov_2dbruxk6di().s[62]++;
	    if (type === 'node') {
	      cov_2dbruxk6di().b[10][0]++;
	      cov_2dbruxk6di().s[63]++;
	      context.out(nodeType === 'array' ? (cov_2dbruxk6di().b[11][0]++, '[') : (cov_2dbruxk6di().b[11][1]++, '{'));
	      cov_2dbruxk6di().s[64]++;
	      context.indent();
	    } else {
	      cov_2dbruxk6di().b[10][1]++;
	    }
	  }
	  rootEnd(context, type, nodeType) {
	    cov_2dbruxk6di().f[13]++;
	    cov_2dbruxk6di().s[65]++;
	    if (type === 'node') {
	      cov_2dbruxk6di().b[12][0]++;
	      cov_2dbruxk6di().s[66]++;
	      context.indent(-1);
	      cov_2dbruxk6di().s[67]++;
	      context.out(nodeType === 'array' ? (cov_2dbruxk6di().b[13][0]++, ']') : (cov_2dbruxk6di().b[13][1]++, '}'));
	    } else {
	      cov_2dbruxk6di().b[12][1]++;
	    }
	    cov_2dbruxk6di().s[68]++;
	    context.popColor();
	  }
	  nodeBegin(context, key, leftKey, type, nodeType) {
	    cov_2dbruxk6di().f[14]++;
	    cov_2dbruxk6di().s[69]++;
	    context.pushColor(colors[type]);
	    cov_2dbruxk6di().s[70]++;
	    context.out(`${leftKey}: `);
	    cov_2dbruxk6di().s[71]++;
	    if (type === 'node') {
	      cov_2dbruxk6di().b[14][0]++;
	      cov_2dbruxk6di().s[72]++;
	      context.out(nodeType === 'array' ? (cov_2dbruxk6di().b[15][0]++, '[') : (cov_2dbruxk6di().b[15][1]++, '{'));
	      cov_2dbruxk6di().s[73]++;
	      context.indent();
	    } else {
	      cov_2dbruxk6di().b[14][1]++;
	    }
	  }
	  nodeEnd(context, key, leftKey, type, nodeType, isLast) {
	    cov_2dbruxk6di().f[15]++;
	    cov_2dbruxk6di().s[74]++;
	    if (type === 'node') {
	      cov_2dbruxk6di().b[16][0]++;
	      cov_2dbruxk6di().s[75]++;
	      context.indent(-1);
	      cov_2dbruxk6di().s[76]++;
	      context.out(nodeType === 'array' ? (cov_2dbruxk6di().b[17][0]++, ']') : (cov_2dbruxk6di().b[17][1]++, `}${isLast ? (cov_2dbruxk6di().b[18][0]++, '') : (cov_2dbruxk6di().b[18][1]++, ',')}`));
	    } else {
	      cov_2dbruxk6di().b[16][1]++;
	    }
	    cov_2dbruxk6di().s[77]++;
	    if (!isLast) {
	      cov_2dbruxk6di().b[19][0]++;
	      cov_2dbruxk6di().s[78]++;
	      context.outLine();
	    } else {
	      cov_2dbruxk6di().b[19][1]++;
	    }
	    cov_2dbruxk6di().s[79]++;
	    context.popColor();
	  } /* jshint camelcase: false */ /* eslint-disable camelcase */
	  format_unchanged(context, delta, left) {
	    cov_2dbruxk6di().f[16]++;
	    cov_2dbruxk6di().s[80]++;
	    if (typeof left === 'undefined') {
	      cov_2dbruxk6di().b[20][0]++;
	      cov_2dbruxk6di().s[81]++;
	      return;
	    } else {
	      cov_2dbruxk6di().b[20][1]++;
	    }
	    cov_2dbruxk6di().s[82]++;
	    this.formatValue(context, left);
	  }
	  format_movedestination(context, delta, left) {
	    cov_2dbruxk6di().f[17]++;
	    cov_2dbruxk6di().s[83]++;
	    if (typeof left === 'undefined') {
	      cov_2dbruxk6di().b[21][0]++;
	      cov_2dbruxk6di().s[84]++;
	      return;
	    } else {
	      cov_2dbruxk6di().b[21][1]++;
	    }
	    cov_2dbruxk6di().s[85]++;
	    this.formatValue(context, left);
	  }
	  format_node(context, delta, left) {
	    cov_2dbruxk6di().f[18]++;
	    cov_2dbruxk6di().s[86]++; // recurse
	    this.formatDeltaChildren(context, delta, left);
	  }
	  format_added(context, delta) {
	    cov_2dbruxk6di().f[19]++;
	    cov_2dbruxk6di().s[87]++;
	    this.formatValue(context, delta[0]);
	  }
	  format_modified(context, delta) {
	    cov_2dbruxk6di().f[20]++;
	    cov_2dbruxk6di().s[88]++;
	    context.pushColor(colors.deleted);
	    cov_2dbruxk6di().s[89]++;
	    this.formatValue(context, delta[0]);
	    cov_2dbruxk6di().s[90]++;
	    context.popColor();
	    cov_2dbruxk6di().s[91]++;
	    context.out(' => ');
	    cov_2dbruxk6di().s[92]++;
	    context.pushColor(colors.added);
	    cov_2dbruxk6di().s[93]++;
	    this.formatValue(context, delta[1]);
	    cov_2dbruxk6di().s[94]++;
	    context.popColor();
	  }
	  format_deleted(context, delta) {
	    cov_2dbruxk6di().f[21]++;
	    cov_2dbruxk6di().s[95]++;
	    this.formatValue(context, delta[0]);
	  }
	  format_moved(context, delta) {
	    cov_2dbruxk6di().f[22]++;
	    cov_2dbruxk6di().s[96]++;
	    context.out(`==> ${delta[1]}`);
	  }
	  format_textdiff(context, delta) {
	    cov_2dbruxk6di().f[23]++;
	    cov_2dbruxk6di().s[97]++;
	    this.formatTextDiffString(context, delta[0]);
	  }
	}
	let defaultInstance$1;
	cov_2dbruxk6di().s[98]++;
	const format = (delta, left) => {
	  cov_2dbruxk6di().f[24]++;
	  cov_2dbruxk6di().s[99]++;
	  if (!defaultInstance$1) {
	    cov_2dbruxk6di().b[22][0]++;
	    cov_2dbruxk6di().s[100]++;
	    defaultInstance$1 = new ConsoleFormatter();
	  } else {
	    cov_2dbruxk6di().b[22][1]++;
	  }
	  cov_2dbruxk6di().s[101]++;
	  return defaultInstance$1.format(delta, left);
	};
	function log(delta, left) {
	  cov_2dbruxk6di().f[25]++;
	  cov_2dbruxk6di().s[102]++;
	  console.log(format(delta, left));
	}
	var console$1 = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  default: ConsoleFormatter,
	  format: format,
	  log: log
	});
	function cov_ct5dxca37() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/index.js";
	  var hash = "5d1ad91882cc3c41314a28445907d71053f3a590";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/index.js",
	    statementMap: {},
	    fnMap: {},
	    branchMap: {},
	    s: {},
	    f: {},
	    b: {},
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/formatters/index.js"],
	      sourcesContent: ["export * as base from './base';\nexport * as html from './html';\nexport * as annotated from './annotated';\nexport * as jsonpatch from './jsonpatch';\nexport * as console from './console';\n"],
	      names: ["base", "html", "annotated", "jsonpatch", "console"],
	      mappings: "AAAA,OAAO,KAAKA,IAAI,MAAM,QAAQ;AAC9B,OAAO,KAAKC,IAAI,MAAM,QAAQ;AAC9B,OAAO,KAAKC,SAAS,MAAM,aAAa;AACxC,OAAO,KAAKC,SAAS,MAAM,aAAa;AACxC,OAAO,KAAKC,OAAO,MAAM,WAAW",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "5d1ad91882cc3c41314a28445907d71053f3a590"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_ct5dxca37 = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_ct5dxca37();
	var index = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  annotated: annotated,
	  base: base,
	  console: console$1,
	  html: html,
	  jsonpatch: jsonpatch
	});
	function cov_4uxkhjjt6() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/date-reviver.js";
	  var hash = "d6a0c64ca5639763e71fabfc3118f9bd7daa44ef";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/date-reviver.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 4,
	          column: 2
	        },
	        end: {
	          line: 10,
	          column: 3
	        }
	      },
	      "1": {
	        start: {
	          line: 6,
	          column: 4
	        },
	        end: {
	          line: 6,
	          column: 113
	        }
	      },
	      "2": {
	        start: {
	          line: 7,
	          column: 4
	        },
	        end: {
	          line: 9,
	          column: 5
	        }
	      },
	      "3": {
	        start: {
	          line: 8,
	          column: 6
	        },
	        end: {
	          line: 8,
	          column: 120
	        }
	      },
	      "4": {
	        start: {
	          line: 11,
	          column: 2
	        },
	        end: {
	          line: 11,
	          column: 15
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "dateReviver",
	        decl: {
	          start: {
	            line: 2,
	            column: 24
	          },
	          end: {
	            line: 2,
	            column: 35
	          }
	        },
	        loc: {
	          start: {
	            line: 2,
	            column: 48
	          },
	          end: {
	            line: 12,
	            column: 1
	          }
	        },
	        line: 2
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 4,
	            column: 2
	          },
	          end: {
	            line: 10,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 4,
	            column: 2
	          },
	          end: {
	            line: 10,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 4
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 7,
	            column: 4
	          },
	          end: {
	            line: 9,
	            column: 5
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 7,
	            column: 4
	          },
	          end: {
	            line: 9,
	            column: 5
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 7
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 8,
	            column: 103
	          },
	          end: {
	            line: 8,
	            column: 116
	          }
	        },
	        type: "binary-expr",
	        locations: [{
	          start: {
	            line: 8,
	            column: 103
	          },
	          end: {
	            line: 8,
	            column: 111
	          }
	        }, {
	          start: {
	            line: 8,
	            column: 115
	          },
	          end: {
	            line: 8,
	            column: 116
	          }
	        }],
	        line: 8
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0
	    },
	    f: {
	      "0": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/date-reviver.js"],
	      sourcesContent: ["// use as 2nd parameter for JSON.parse to revive Date instances\nexport default function dateReviver(key, value) {\n  let parts;\n  if (typeof value === 'string') {\n    // eslint-disable-next-line max-len\n    parts = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d*))?(Z|([+-])(\\d{2}):(\\d{2}))$/.exec(\n      value,\n    );\n    if (parts) {\n      return new Date(\n        Date.UTC(\n          +parts[1],\n          +parts[2] - 1,\n          +parts[3],\n          +parts[4],\n          +parts[5],\n          +parts[6],\n          +(parts[7] || 0),\n        ),\n      );\n    }\n  }\n  return value;\n}\n"],
	      names: ["dateReviver", "key", "value", "parts", "exec", "Date", "UTC"],
	      mappings: "AAAA;AACA,eAAe,SAASA,WAAWA,CAACC,GAAG,EAAEC,KAAK,EAAE;EAC9C,IAAIC,KAAK;EACT,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAAE;IAC7B;IACAC,KAAK,GAAG,wFAAwF,CAACC,IAAI,CACnGF,KACF,CAAC;IACD,IAAIC,KAAK,EAAE;MACT,OAAO,IAAIE,IAAI,CACbA,IAAI,CAACC,GAAG,CACN,CAACH,KAAK,CAAC,CAAC,CAAC,EACT,CAACA,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,EACb,CAACA,KAAK,CAAC,CAAC,CAAC,EACT,CAACA,KAAK,CAAC,CAAC,CAAC,EACT,CAACA,KAAK,CAAC,CAAC,CAAC,EACT,CAACA,KAAK,CAAC,CAAC,CAAC,EACT,EAAEA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CACjB,CACF,CAAC;IACH;EACF;EACA,OAAOD,KAAK;AACd",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "d6a0c64ca5639763e71fabfc3118f9bd7daa44ef"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_4uxkhjjt6 = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_4uxkhjjt6(); // use as 2nd parameter for JSON.parse to revive Date instances
	function cov_12nkxf3s86() {
	  var path = "/home/runner/work/jsondiffpatch/jsondiffpatch/src/main.js";
	  var hash = "8cd6953bc969da4a67ae95f33a644966340ef7ee";
	  var global = new Function("return this")();
	  var gcv = "__coverage__";
	  var coverageData = {
	    path: "/home/runner/work/jsondiffpatch/jsondiffpatch/src/main.js",
	    statementMap: {
	      "0": {
	        start: {
	          line: 6,
	          column: 2
	        },
	        end: {
	          line: 6,
	          column: 34
	        }
	      },
	      "1": {
	        start: {
	          line: 11,
	          column: 2
	        },
	        end: {
	          line: 13,
	          column: 3
	        }
	      },
	      "2": {
	        start: {
	          line: 12,
	          column: 4
	        },
	        end: {
	          line: 12,
	          column: 40
	        }
	      },
	      "3": {
	        start: {
	          line: 14,
	          column: 2
	        },
	        end: {
	          line: 14,
	          column: 64
	        }
	      },
	      "4": {
	        start: {
	          line: 17,
	          column: 2
	        },
	        end: {
	          line: 19,
	          column: 3
	        }
	      },
	      "5": {
	        start: {
	          line: 18,
	          column: 4
	        },
	        end: {
	          line: 18,
	          column: 40
	        }
	      },
	      "6": {
	        start: {
	          line: 20,
	          column: 2
	        },
	        end: {
	          line: 20,
	          column: 65
	        }
	      },
	      "7": {
	        start: {
	          line: 23,
	          column: 2
	        },
	        end: {
	          line: 25,
	          column: 3
	        }
	      },
	      "8": {
	        start: {
	          line: 24,
	          column: 4
	        },
	        end: {
	          line: 24,
	          column: 40
	        }
	      },
	      "9": {
	        start: {
	          line: 26,
	          column: 2
	        },
	        end: {
	          line: 26,
	          column: 67
	        }
	      },
	      "10": {
	        start: {
	          line: 29,
	          column: 2
	        },
	        end: {
	          line: 31,
	          column: 3
	        }
	      },
	      "11": {
	        start: {
	          line: 30,
	          column: 4
	        },
	        end: {
	          line: 30,
	          column: 40
	        }
	      },
	      "12": {
	        start: {
	          line: 32,
	          column: 2
	        },
	        end: {
	          line: 32,
	          column: 67
	        }
	      },
	      "13": {
	        start: {
	          line: 35,
	          column: 2
	        },
	        end: {
	          line: 37,
	          column: 3
	        }
	      },
	      "14": {
	        start: {
	          line: 36,
	          column: 4
	        },
	        end: {
	          line: 36,
	          column: 40
	        }
	      },
	      "15": {
	        start: {
	          line: 38,
	          column: 2
	        },
	        end: {
	          line: 38,
	          column: 65
	        }
	      }
	    },
	    fnMap: {
	      "0": {
	        name: "create",
	        decl: {
	          start: {
	            line: 5,
	            column: 16
	          },
	          end: {
	            line: 5,
	            column: 22
	          }
	        },
	        loc: {
	          start: {
	            line: 5,
	            column: 32
	          },
	          end: {
	            line: 7,
	            column: 1
	          }
	        },
	        line: 5
	      },
	      "1": {
	        name: "diff",
	        decl: {
	          start: {
	            line: 10,
	            column: 16
	          },
	          end: {
	            line: 10,
	            column: 20
	          }
	        },
	        loc: {
	          start: {
	            line: 10,
	            column: 23
	          },
	          end: {
	            line: 15,
	            column: 1
	          }
	        },
	        line: 10
	      },
	      "2": {
	        name: "patch",
	        decl: {
	          start: {
	            line: 16,
	            column: 16
	          },
	          end: {
	            line: 16,
	            column: 21
	          }
	        },
	        loc: {
	          start: {
	            line: 16,
	            column: 24
	          },
	          end: {
	            line: 21,
	            column: 1
	          }
	        },
	        line: 16
	      },
	      "3": {
	        name: "unpatch",
	        decl: {
	          start: {
	            line: 22,
	            column: 16
	          },
	          end: {
	            line: 22,
	            column: 23
	          }
	        },
	        loc: {
	          start: {
	            line: 22,
	            column: 26
	          },
	          end: {
	            line: 27,
	            column: 1
	          }
	        },
	        line: 22
	      },
	      "4": {
	        name: "reverse",
	        decl: {
	          start: {
	            line: 28,
	            column: 16
	          },
	          end: {
	            line: 28,
	            column: 23
	          }
	        },
	        loc: {
	          start: {
	            line: 28,
	            column: 26
	          },
	          end: {
	            line: 33,
	            column: 1
	          }
	        },
	        line: 28
	      },
	      "5": {
	        name: "clone",
	        decl: {
	          start: {
	            line: 34,
	            column: 16
	          },
	          end: {
	            line: 34,
	            column: 21
	          }
	        },
	        loc: {
	          start: {
	            line: 34,
	            column: 24
	          },
	          end: {
	            line: 39,
	            column: 1
	          }
	        },
	        line: 34
	      }
	    },
	    branchMap: {
	      "0": {
	        loc: {
	          start: {
	            line: 11,
	            column: 2
	          },
	          end: {
	            line: 13,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 11,
	            column: 2
	          },
	          end: {
	            line: 13,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 11
	      },
	      "1": {
	        loc: {
	          start: {
	            line: 17,
	            column: 2
	          },
	          end: {
	            line: 19,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 17,
	            column: 2
	          },
	          end: {
	            line: 19,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 17
	      },
	      "2": {
	        loc: {
	          start: {
	            line: 23,
	            column: 2
	          },
	          end: {
	            line: 25,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 23,
	            column: 2
	          },
	          end: {
	            line: 25,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 23
	      },
	      "3": {
	        loc: {
	          start: {
	            line: 29,
	            column: 2
	          },
	          end: {
	            line: 31,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 29,
	            column: 2
	          },
	          end: {
	            line: 31,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 29
	      },
	      "4": {
	        loc: {
	          start: {
	            line: 35,
	            column: 2
	          },
	          end: {
	            line: 37,
	            column: 3
	          }
	        },
	        type: "if",
	        locations: [{
	          start: {
	            line: 35,
	            column: 2
	          },
	          end: {
	            line: 37,
	            column: 3
	          }
	        }, {
	          start: {
	            line: undefined,
	            column: undefined
	          },
	          end: {
	            line: undefined,
	            column: undefined
	          }
	        }],
	        line: 35
	      }
	    },
	    s: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0,
	      "6": 0,
	      "7": 0,
	      "8": 0,
	      "9": 0,
	      "10": 0,
	      "11": 0,
	      "12": 0,
	      "13": 0,
	      "14": 0,
	      "15": 0
	    },
	    f: {
	      "0": 0,
	      "1": 0,
	      "2": 0,
	      "3": 0,
	      "4": 0,
	      "5": 0
	    },
	    b: {
	      "0": [0, 0],
	      "1": [0, 0],
	      "2": [0, 0],
	      "3": [0, 0],
	      "4": [0, 0]
	    },
	    inputSourceMap: {
	      version: 3,
	      sources: ["/home/runner/work/jsondiffpatch/jsondiffpatch/src/main.js"],
	      sourcesContent: ["import DiffPatcher from './diffpatcher';\nexport DiffPatcher from './diffpatcher';\n\nexport * as formatters from './formatters/index';\n\nexport * as console from './formatters/console';\n\nexport function create(options) {\n  return new DiffPatcher(options);\n}\n\nexport dateReviver from './date-reviver';\n\nlet defaultInstance;\n\nexport function diff() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.diff.apply(defaultInstance, arguments);\n}\n\nexport function patch() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.patch.apply(defaultInstance, arguments);\n}\n\nexport function unpatch() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.unpatch.apply(defaultInstance, arguments);\n}\n\nexport function reverse() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.reverse.apply(defaultInstance, arguments);\n}\n\nexport function clone() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.clone.apply(defaultInstance, arguments);\n}\n"],
	      names: ["DiffPatcher", "default", "formatters", "console", "create", "options", "dateReviver", "defaultInstance", "diff", "apply", "arguments", "patch", "unpatch", "reverse", "clone"],
	      mappings: "AAAA,OAAOA,WAAW,MAAM,eAAe;AACvC,SAAAC,OAAA,IAAOD,WAAW,QAAM,eAAe;AAEvC,OAAO,KAAKE,UAAU,MAAM,oBAAoB;AAEhD,OAAO,KAAKC,OAAO,MAAM,sBAAsB;AAE/C,OAAO,SAASC,MAAMA,CAACC,OAAO,EAAE;EAC9B,OAAO,IAAIL,WAAW,CAACK,OAAO,CAAC;AACjC;AAEA,SAAAJ,OAAA,IAAOK,WAAW,QAAM,gBAAgB;AAExC,IAAIC,eAAe;AAEnB,OAAO,SAASC,IAAIA,CAAA,EAAG;EACrB,IAAI,CAACD,eAAe,EAAE;IACpBA,eAAe,GAAG,IAAIP,WAAW,CAAC,CAAC;EACrC;EACA,OAAOO,eAAe,CAACC,IAAI,CAACC,KAAK,CAACF,eAAe,EAAEG,SAAS,CAAC;AAC/D;AAEA,OAAO,SAASC,KAAKA,CAAA,EAAG;EACtB,IAAI,CAACJ,eAAe,EAAE;IACpBA,eAAe,GAAG,IAAIP,WAAW,CAAC,CAAC;EACrC;EACA,OAAOO,eAAe,CAACI,KAAK,CAACF,KAAK,CAACF,eAAe,EAAEG,SAAS,CAAC;AAChE;AAEA,OAAO,SAASE,OAAOA,CAAA,EAAG;EACxB,IAAI,CAACL,eAAe,EAAE;IACpBA,eAAe,GAAG,IAAIP,WAAW,CAAC,CAAC;EACrC;EACA,OAAOO,eAAe,CAACK,OAAO,CAACH,KAAK,CAACF,eAAe,EAAEG,SAAS,CAAC;AAClE;AAEA,OAAO,SAASG,OAAOA,CAAA,EAAG;EACxB,IAAI,CAACN,eAAe,EAAE;IACpBA,eAAe,GAAG,IAAIP,WAAW,CAAC,CAAC;EACrC;EACA,OAAOO,eAAe,CAACM,OAAO,CAACJ,KAAK,CAACF,eAAe,EAAEG,SAAS,CAAC;AAClE;AAEA,OAAO,SAASI,KAAKA,CAAA,EAAG;EACtB,IAAI,CAACP,eAAe,EAAE;IACpBA,eAAe,GAAG,IAAIP,WAAW,CAAC,CAAC;EACrC;EACA,OAAOO,eAAe,CAACO,KAAK,CAACL,KAAK,CAACF,eAAe,EAAEG,SAAS,CAAC;AAChE",
	      file: null
	    },
	    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
	    hash: "8cd6953bc969da4a67ae95f33a644966340ef7ee"
	  };
	  var coverage = global[gcv] || (global[gcv] = {});
	  if (!coverage[path] || coverage[path].hash !== hash) {
	    coverage[path] = coverageData;
	  }
	  var actualCoverage = coverage[path];
	  {
	    // @ts-ignore
	    cov_12nkxf3s86 = function () {
	      return actualCoverage;
	    };
	  }
	  return actualCoverage;
	}
	cov_12nkxf3s86();
	let defaultInstance;
	function diff() {
	  cov_12nkxf3s86().f[1]++;
	  cov_12nkxf3s86().s[1]++;
	  if (!defaultInstance) {
	    cov_12nkxf3s86().b[0][0]++;
	    cov_12nkxf3s86().s[2]++;
	    defaultInstance = new DiffPatcher$1();
	  } else {
	    cov_12nkxf3s86().b[0][1]++;
	  }
	  cov_12nkxf3s86().s[3]++;
	  return defaultInstance.diff.apply(defaultInstance, arguments);
	}
	function patch() {
	  cov_12nkxf3s86().f[2]++;
	  cov_12nkxf3s86().s[4]++;
	  if (!defaultInstance) {
	    cov_12nkxf3s86().b[1][0]++;
	    cov_12nkxf3s86().s[5]++;
	    defaultInstance = new DiffPatcher$1();
	  } else {
	    cov_12nkxf3s86().b[1][1]++;
	  }
	  cov_12nkxf3s86().s[6]++;
	  return defaultInstance.patch.apply(defaultInstance, arguments);
	}
	function unpatch() {
	  cov_12nkxf3s86().f[3]++;
	  cov_12nkxf3s86().s[7]++;
	  if (!defaultInstance) {
	    cov_12nkxf3s86().b[2][0]++;
	    cov_12nkxf3s86().s[8]++;
	    defaultInstance = new DiffPatcher$1();
	  } else {
	    cov_12nkxf3s86().b[2][1]++;
	  }
	  cov_12nkxf3s86().s[9]++;
	  return defaultInstance.unpatch.apply(defaultInstance, arguments);
	}
	function reverse() {
	  cov_12nkxf3s86().f[4]++;
	  cov_12nkxf3s86().s[10]++;
	  if (!defaultInstance) {
	    cov_12nkxf3s86().b[3][0]++;
	    cov_12nkxf3s86().s[11]++;
	    defaultInstance = new DiffPatcher$1();
	  } else {
	    cov_12nkxf3s86().b[3][1]++;
	  }
	  cov_12nkxf3s86().s[12]++;
	  return defaultInstance.reverse.apply(defaultInstance, arguments);
	}
	function clone() {
	  cov_12nkxf3s86().f[5]++;
	  cov_12nkxf3s86().s[13]++;
	  if (!defaultInstance) {
	    cov_12nkxf3s86().b[4][0]++;
	    cov_12nkxf3s86().s[14]++;
	    defaultInstance = new DiffPatcher$1();
	  } else {
	    cov_12nkxf3s86().b[4][1]++;
	  }
	  cov_12nkxf3s86().s[15]++;
	  return defaultInstance.clone.apply(defaultInstance, arguments);
	}

	const examples = {};
	const exampleDate = () => new Date(2020, 10, 30, 15, 10, 3);

	/* jshint camelcase: false */
	/* jshint multistr: true */

	examples.atomicValues = [
	// undefined
	{
	  left: undefined,
	  right: undefined,
	  delta: undefined,
	  reverse: undefined
	}, {
	  left: undefined,
	  right: null,
	  delta: [null],
	  reverse: [null, 0, 0]
	}, {
	  left: undefined,
	  right: false,
	  delta: [false],
	  reverse: [false, 0, 0]
	}, {
	  left: undefined,
	  right: true,
	  delta: [true],
	  reverse: [true, 0, 0]
	}, {
	  left: undefined,
	  right: 42,
	  delta: [42],
	  reverse: [42, 0, 0]
	}, {
	  left: undefined,
	  right: 'some text',
	  delta: ['some text'],
	  reverse: ['some text', 0, 0]
	}, {
	  left: undefined,
	  right: exampleDate(),
	  delta: [exampleDate()],
	  reverse: [exampleDate(), 0, 0]
	}, {
	  left: undefined,
	  right: {
	    a: 1,
	    b: 2
	  },
	  delta: [{
	    a: 1,
	    b: 2
	  }],
	  reverse: [{
	    a: 1,
	    b: 2
	  }, 0, 0]
	}, {
	  left: undefined,
	  right: [1, 2, 3],
	  delta: [[1, 2, 3]],
	  reverse: [[1, 2, 3], 0, 0]
	}, {
	  left: undefined,
	  right(x) {
	    return x * x;
	  },
	  error: /not supported/
	},
	// null
	{
	  left: null,
	  right: null,
	  delta: undefined,
	  reverse: undefined
	}, {
	  left: null,
	  right: false,
	  delta: [null, false],
	  reverse: [false, null]
	}, {
	  left: null,
	  right: true,
	  delta: [null, true],
	  reverse: [true, null]
	}, {
	  left: null,
	  right: 42,
	  delta: [null, 42],
	  reverse: [42, null]
	}, {
	  left: null,
	  right: 'some text',
	  delta: [null, 'some text'],
	  reverse: ['some text', null]
	}, {
	  left: null,
	  right: exampleDate(),
	  delta: [null, exampleDate()],
	  reverse: [exampleDate(), null]
	}, {
	  left: null,
	  right: {
	    a: 1,
	    b: 2
	  },
	  delta: [null, {
	    a: 1,
	    b: 2
	  }],
	  reverse: [{
	    a: 1,
	    b: 2
	  }, null]
	}, {
	  left: null,
	  right(x) {
	    return x * x;
	  },
	  error: /not supported/
	},
	// false
	{
	  left: false,
	  right: false,
	  delta: undefined,
	  reverse: undefined
	}, {
	  left: false,
	  right: true,
	  delta: [false, true],
	  reverse: [true, false]
	}, {
	  left: false,
	  right: 42,
	  delta: [false, 42],
	  reverse: [42, false]
	}, {
	  left: false,
	  right: 'some text',
	  delta: [false, 'some text'],
	  reverse: ['some text', false]
	}, {
	  left: false,
	  right: exampleDate(),
	  delta: [false, exampleDate()],
	  reverse: [exampleDate(), false]
	}, {
	  left: false,
	  right: {
	    a: 1,
	    b: 2
	  },
	  delta: [false, {
	    a: 1,
	    b: 2
	  }],
	  reverse: [{
	    a: 1,
	    b: 2
	  }, false]
	}, {
	  left: false,
	  right: [1, 2, 3],
	  delta: [false, [1, 2, 3]],
	  reverse: [[1, 2, 3], false]
	}, {
	  left: false,
	  right(x) {
	    return x * x;
	  },
	  error: /not supported/
	},
	// true
	{
	  left: true,
	  right: true,
	  delta: undefined,
	  reverse: undefined
	}, {
	  left: true,
	  right: 42,
	  delta: [true, 42],
	  reverse: [42, true]
	}, {
	  left: true,
	  right: 'some text',
	  delta: [true, 'some text'],
	  reverse: ['some text', true]
	}, {
	  left: true,
	  right: exampleDate(),
	  delta: [true, exampleDate()],
	  reverse: [exampleDate(), true]
	}, {
	  left: true,
	  right: {
	    a: 1,
	    b: 2
	  },
	  delta: [true, {
	    a: 1,
	    b: 2
	  }],
	  reverse: [{
	    a: 1,
	    b: 2
	  }, true]
	}, {
	  left: true,
	  right: [1, 2, 3],
	  delta: [true, [1, 2, 3]],
	  reverse: [[1, 2, 3], true]
	}, {
	  left: true,
	  right(x) {
	    return x * x;
	  },
	  error: /not supported/
	},
	// number
	{
	  name: 'number -> same number',
	  left: 42,
	  right: 42,
	  delta: undefined,
	  reverse: undefined
	}, {
	  left: 42,
	  right: -1,
	  delta: [42, -1],
	  reverse: [-1, 42]
	}, {
	  left: 42,
	  right: 'some text',
	  delta: [42, 'some text'],
	  reverse: ['some text', 42]
	}, {
	  left: 42,
	  right: exampleDate(),
	  delta: [42, exampleDate()],
	  reverse: [exampleDate(), 42]
	}, {
	  left: 42,
	  right: {
	    a: 1,
	    b: 2
	  },
	  delta: [42, {
	    a: 1,
	    b: 2
	  }],
	  reverse: [{
	    a: 1,
	    b: 2
	  }, 42]
	}, {
	  left: 42,
	  right: [1, 2, 3],
	  delta: [42, [1, 2, 3]],
	  reverse: [[1, 2, 3], 42]
	}, {
	  left: 42,
	  right(x) {
	    return x * x;
	  },
	  error: /not supported/
	},
	// string
	{
	  name: 'string -> same string',
	  left: 'some text',
	  right: 'some text',
	  delta: undefined,
	  reverse: undefined
	}, {
	  left: 'some text',
	  right: 'some fext',
	  delta: ['some text', 'some fext'],
	  reverse: ['some fext', 'some text']
	}, {
	  left: 'some text',
	  right: exampleDate(),
	  delta: ['some text', exampleDate()],
	  reverse: [exampleDate(), 'some text']
	}, {
	  left: 'some text',
	  right: {
	    a: 1,
	    b: 2
	  },
	  delta: ['some text', {
	    a: 1,
	    b: 2
	  }],
	  reverse: [{
	    a: 1,
	    b: 2
	  }, 'some text']
	}, {
	  left: 'some text',
	  right: [1, 2, 3],
	  delta: ['some text', [1, 2, 3]],
	  reverse: [[1, 2, 3], 'some text']
	},
	// Date
	{
	  name: 'Date -> same Date',
	  left: exampleDate(),
	  right: exampleDate(),
	  delta: undefined,
	  reverse: undefined
	}, {
	  left: exampleDate(),
	  right: new Date(2020, 5, 31, 15, 12, 30),
	  delta: [exampleDate(), new Date(2020, 5, 31, 15, 12, 30)],
	  reverse: [new Date(2020, 5, 31, 15, 12, 30), exampleDate()]
	}, {
	  left: exampleDate(),
	  right: {
	    a: 1,
	    b: 2
	  },
	  delta: [exampleDate(), {
	    a: 1,
	    b: 2
	  }],
	  reverse: [{
	    a: 1,
	    b: 2
	  }, exampleDate()]
	}, {
	  left: exampleDate(),
	  right: [1, 2, 3],
	  delta: [exampleDate(), [1, 2, 3]],
	  reverse: [[1, 2, 3], exampleDate()]
	}, {
	  left: exampleDate(),
	  right(x) {
	    return x * x;
	  },
	  error: /not supported/
	},
	// Function
	{
	  name: 'string -> Function',
	  left: 'some text',
	  right(x) {
	    return x * x;
	  },
	  error: /not supported/
	},
	// RegExp
	{
	  name: 'RegExp -> RegExp',
	  left: /regex/g,
	  right: /another regex/gi,
	  delta: ['/regex/g', '/another regex/gi'],
	  reverse: ['/another regex/gi', '/regex/g']
	},
	// object
	{
	  name: 'object -> same object',
	  left: {
	    a: 1,
	    b: 2
	  },
	  right: {
	    a: 1,
	    b: 2
	  },
	  delta: undefined,
	  reverse: undefined
	}, {
	  left: {
	    a: 1,
	    b: 2
	  },
	  right: [1, 2, 3],
	  delta: [{
	    a: 1,
	    b: 2
	  }, [1, 2, 3]],
	  reverse: [[1, 2, 3], {
	    a: 1,
	    b: 2
	  }]
	}, {
	  left: {
	    a: 1,
	    b: 2
	  },
	  right(x) {
	    return x * x;
	  },
	  error: /not supported/
	},
	// array
	{
	  name: 'array -> same array',
	  left: [1, 2, 3],
	  right: [1, 2, 3],
	  delta: undefined,
	  reverse: undefined
	}, {
	  left: [1, 2, 3],
	  right(x) {
	    return x * x;
	  },
	  error: /not supported/
	}, 0];
	const shortText = `Madre,
cuando yo sea grande
quisiera hacer versos`;
	const largeText = `-Madre,
cuando yo sea grande
ser marinero.

Ahora estoy jugando
que aquello es un puerto
y que ste es un barco
y stos son dos remos
y por ese ro
navego y navego.

(Agua, arena, piedras
y dos palos viejos:
un ro y un barco,
un puerto y dos remos).

-Madre,
cuando yo sea grande
ser jardinero.

Ahora estoy jugando
que esto es un cantero,
aqul un rosal,
ste un jazminero
y se es un camino
que va por el medio.

(Tierra, flores, hojas
y unos tallos secos:
cantero, camino,
rosal, jazminero).

-Madre,
cuando yo sea grande
quisiera hacer versos.

-Con qu ests jugando?

-Madre, miro el cielo.

(En dos ojos claros
todo el Universo).`;
	examples.text = [{
	  left: shortText,
	  right: largeText,
	  delta: [shortText, largeText],
	  reverse: [largeText, shortText]
	}, {
	  left: largeText,
	  right: largeText.replace(/jazminero/g, 'rosal'),
	  delta: ['@@ -360,25 +360,21 @@\n %C3%A9ste un \n-jazminero\n+rosal' + '\n %0Ay %C3%A9se e\n@@ -479,17 +479,13 @@\n' + ' al, \n-jazminero\n+rosal\n ).%0A%0A\n', 0, 2],
	  reverse: ['@@ -360,21 +360,25 @@\n %C3%A9ste un \n-rosal\n+jazminero\n %0Ay' + ' %C3%A9se e\n@@ -479,21 +479,25 @@\n %0Arosal,' + ' \n-rosal\n+jazminero\n ).%0A%0A-Mad\n', 0, 2],
	  exactReverse: false
	}, {
	  name: 'larger than min length',
	  options: {
	    textDiff: {
	      minLength: 10
	    }
	  },
	  left: largeText.substr(0, 10),
	  right: largeText.substr(0, 11).replace(/Madre/g, 'Padre'),
	  delta: ['@@ -1,10 +1,11 @@\n -\n-M\n+P\n adre,%0Acu\n+a\n', 0, 2],
	  reverse: ['@@ -1,11 +1,10 @@\n -\n-P\n+M\n adre,%0Acu\n-a\n', 0, 2],
	  exactReverse: false
	}, {
	  name: 'shorter than min length',
	  options: {
	    textDiff: {
	      minLength: 10
	    }
	  },
	  left: largeText.substr(0, 9),
	  right: largeText.substr(0, 11).replace(/Madre/g, 'Padre'),
	  delta: ['-Madre,\nc', '-Padre,\ncua'],
	  reverse: ['-Padre,\ncua', '-Madre,\nc'],
	  exactReverse: false
	}, 0];
	examples.objects = [{
	  name: 'first level',
	  left: {
	    a: 1,
	    b: 2
	  },
	  right: {
	    a: 42,
	    b: 2
	  },
	  delta: {
	    a: [1, 42]
	  },
	  reverse: {
	    a: [42, 1]
	  }
	}, {
	  name: 'deep level',
	  left: {
	    a: {
	      j: {
	        k: {
	          l: {
	            m: {
	              n: {
	                o: 3
	              }
	            }
	          }
	        }
	      }
	    },
	    b: 2
	  },
	  right: {
	    a: {
	      j: {
	        k: {
	          l: {
	            m: {
	              n: {
	                o: true
	              }
	            }
	          }
	        }
	      }
	    },
	    b: 2
	  },
	  delta: {
	    a: {
	      j: {
	        k: {
	          l: {
	            m: {
	              n: {
	                o: [3, true]
	              }
	            }
	          }
	        }
	      }
	    }
	  },
	  reverse: {
	    a: {
	      j: {
	        k: {
	          l: {
	            m: {
	              n: {
	                o: [true, 3]
	              }
	            }
	          }
	        }
	      }
	    }
	  }
	}, {
	  name: 'multiple changes',
	  left: {
	    a: {
	      j: {
	        k: {
	          l: {
	            m: {
	              n: {
	                o: 3
	              }
	            }
	          }
	        }
	      }
	    },
	    b: 2,
	    c: 5
	  },
	  right: {
	    a: {
	      j: {
	        k: {
	          l: {
	            m: {
	              n: {
	                o: 5,
	                w: 12
	              }
	            }
	          }
	        }
	      }
	    },
	    b: 2
	  },
	  delta: {
	    a: {
	      j: {
	        k: {
	          l: {
	            m: {
	              n: {
	                o: [3, 5],
	                w: [12]
	              }
	            }
	          }
	        }
	      }
	    },
	    c: [5, 0, 0]
	  },
	  reverse: {
	    a: {
	      j: {
	        k: {
	          l: {
	            m: {
	              n: {
	                o: [5, 3],
	                w: [12, 0, 0]
	              }
	            }
	          }
	        }
	      }
	    },
	    c: [5]
	  }
	}, {
	  name: 'key removed',
	  left: {
	    a: 1,
	    b: 2
	  },
	  right: {
	    a: 1
	  },
	  delta: {
	    b: [2, 0, 0]
	  },
	  reverse: {
	    b: [2]
	  }
	}, {
	  name: 'hasOwnProperty',
	  /* jshint ignore:start */
	  left: {
	    hasOwnProperty: true
	  },
	  right: {
	    hasOwnProperty: true
	  }
	  /* jshint ignore:end */
	}, 0];
	examples.arrays = [{
	  name: 'simple values',
	  left: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
	  right: [1, 3, 4, 5, 8, 9, 9.1, 10],
	  delta: {
	    _t: 'a',
	    _1: [2, 0, 0],
	    _5: [6, 0, 0],
	    _6: [7, 0, 0],
	    6: [9.1]
	  },
	  reverse: {
	    _t: 'a',
	    1: [2],
	    5: [6],
	    6: [7],
	    _6: [9.1, 0, 0]
	  }
	}, {
	  name: 'added block',
	  left: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
	  right: [1, 2, 3, 4, 5, 5.1, 5.2, 5.3, 6, 7, 8, 9, 10],
	  delta: {
	    _t: 'a',
	    5: [5.1],
	    6: [5.2],
	    7: [5.3]
	  },
	  reverse: {
	    _t: 'a',
	    _5: [5.1, 0, 0],
	    _6: [5.2, 0, 0],
	    _7: [5.3, 0, 0]
	  }
	}, {
	  name: 'movements',
	  left: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
	  right: [1, 2, 3, 7, 5, 6, 8, 9, 4, 10],
	  delta: {
	    _t: 'a',
	    _3: ['', 8, 3],
	    _6: ['', 3, 3]
	  },
	  reverse: {
	    _t: 'a',
	    _3: ['', 6, 3],
	    _8: ['', 3, 3]
	  }
	}, {
	  name: 'movements(2)',
	  left: [1, 2, 3, 4],
	  right: [2, 4, 1, 3],
	  delta: {
	    _t: 'a',
	    _1: ['', 0, 3],
	    _3: ['', 1, 3]
	  },
	  reverse: {
	    _t: 'a',
	    _2: ['', 0, 3],
	    _3: ['', 2, 3]
	  },
	  exactReverse: false
	}, {
	  name: 'nested',
	  options: {
	    objectHash(obj) {
	      if (obj && obj.id) {
	        return obj.id;
	      }
	    }
	  },
	  left: [1, 2, {
	    id: 4,
	    width: 10
	  }, 4, {
	    id: 'five',
	    width: 4
	  }, 6, 7, 8, 9, 10],
	  right: [1, 2, {
	    id: 4,
	    width: 12
	  }, 4, {
	    id: 'five',
	    width: 4
	  }, 6, 7, 8, 9, 10],
	  delta: {
	    _t: 'a',
	    2: {
	      width: [10, 12]
	    }
	  },
	  reverse: {
	    _t: 'a',
	    2: {
	      width: [12, 10]
	    }
	  }
	}, {
	  name: 'nested with movement',
	  options: {
	    objectHash(obj) {
	      if (obj && obj.id) {
	        return obj.id;
	      }
	    }
	  },
	  left: [1, 2, 4, {
	    id: 'five',
	    width: 4
	  }, 6, 7, 8, {
	    id: 4,
	    width: 10,
	    height: 3
	  }, 9, 10],
	  right: [1, 2, {
	    id: 4,
	    width: 12
	  }, 4, {
	    id: 'five',
	    width: 4
	  }, 6, 7, 8, 9, 10],
	  delta: {
	    _t: 'a',
	    2: {
	      width: [10, 12],
	      height: [3, 0, 0]
	    },
	    _7: ['', 2, 3]
	  },
	  reverse: {
	    _t: 'a',
	    7: {
	      width: [12, 10],
	      height: [3]
	    },
	    _2: ['', 7, 3]
	  }
	}, {
	  name: 'nested changes among array insertions and deletions',
	  options: {
	    objectHash(obj) {
	      if (obj && obj.id) {
	        return obj.id;
	      }
	    }
	  },
	  left: [{
	    id: 1
	  }, {
	    id: 2
	  }, {
	    id: 4
	  }, {
	    id: 5
	  }, {
	    id: 6,
	    inner: {
	      property: 'abc'
	    }
	  }, {
	    id: 7
	  }, {
	    id: 8
	  }, {
	    id: 10
	  }, {
	    id: 11
	  }, {
	    id: 12
	  }],
	  right: [{
	    id: 3
	  }, {
	    id: 4
	  }, {
	    id: 6,
	    inner: {
	      property: 'abcd'
	    }
	  }, {
	    id: 9
	  }],
	  delta: {
	    _t: 'a',
	    0: [{
	      id: 3
	    }],
	    2: {
	      inner: {
	        property: ['abc', 'abcd']
	      }
	    },
	    3: [{
	      id: 9
	    }],
	    _0: [{
	      id: 1
	    }, 0, 0],
	    _1: [{
	      id: 2
	    }, 0, 0],
	    _3: [{
	      id: 5
	    }, 0, 0],
	    _5: [{
	      id: 7
	    }, 0, 0],
	    _6: [{
	      id: 8
	    }, 0, 0],
	    _7: [{
	      id: 10
	    }, 0, 0],
	    _8: [{
	      id: 11
	    }, 0, 0],
	    _9: [{
	      id: 12
	    }, 0, 0]
	  },
	  reverse: {
	    _t: 'a',
	    0: [{
	      id: 1
	    }],
	    1: [{
	      id: 2
	    }],
	    3: [{
	      id: 5
	    }],
	    4: {
	      inner: {
	        property: ['abcd', 'abc']
	      }
	    },
	    5: [{
	      id: 7
	    }],
	    6: [{
	      id: 8
	    }],
	    7: [{
	      id: 10
	    }],
	    8: [{
	      id: 11
	    }],
	    9: [{
	      id: 12
	    }],
	    _0: [{
	      id: 3
	    }, 0, 0],
	    _3: [{
	      id: 9
	    }, 0, 0]
	  }
	}, {
	  name: 'nested change with item moved above',
	  options: {
	    objectHash(obj) {
	      if (obj && obj.id) {
	        return obj.id;
	      }
	    }
	  },
	  left: [{
	    id: 1
	  }, {
	    id: 2
	  }, {
	    id: 3,
	    inner: {
	      property: 'abc'
	    }
	  }, {
	    id: 4
	  }, {
	    id: 5
	  }, {
	    id: 6
	  }],
	  right: [{
	    id: 1
	  }, {
	    id: 2
	  }, {
	    id: 6
	  }, {
	    id: 3,
	    inner: {
	      property: 'abcd'
	    }
	  }, {
	    id: 4
	  }, {
	    id: 5
	  }],
	  delta: {
	    _t: 'a',
	    3: {
	      inner: {
	        property: ['abc', 'abcd']
	      }
	    },
	    _5: ['', 2, 3]
	  },
	  reverse: {
	    _t: 'a',
	    2: {
	      inner: {
	        property: ['abcd', 'abc']
	      }
	    },
	    _2: ['', 5, 3]
	  }
	}, {
	  name: 'nested change with item moved right above',
	  options: {
	    objectHash(obj) {
	      if (obj && obj.id) {
	        return obj.id;
	      }
	    }
	  },
	  left: [{
	    id: 1
	  }, {
	    id: 2,
	    inner: {
	      property: 'abc'
	    }
	  }, {
	    id: 3
	  }],
	  right: [{
	    id: 1
	  }, {
	    id: 3
	  }, {
	    id: 2,
	    inner: {
	      property: 'abcd'
	    }
	  }],
	  delta: {
	    _t: 'a',
	    2: {
	      inner: {
	        property: ['abc', 'abcd']
	      }
	    },
	    _2: ['', 1, 3]
	  },
	  reverse: {
	    _t: 'a',
	    1: {
	      inner: {
	        property: ['abcd', 'abc']
	      }
	    },
	    _2: ['', 1, 3]
	  },
	  exactReverse: false
	}, {
	  name: 'nested change with item moved right below',
	  options: {
	    objectHash(obj) {
	      if (obj && obj.id) {
	        return obj.id;
	      }
	    }
	  },
	  left: [{
	    id: 1
	  }, {
	    id: 2
	  }, {
	    id: 3,
	    inner: {
	      property: 'abc'
	    }
	  }, {
	    id: 4
	  }],
	  right: [{
	    id: 2
	  }, {
	    id: 3,
	    inner: {
	      property: 'abcd'
	    }
	  }, {
	    id: 1
	  }, {
	    id: 4
	  }],
	  delta: {
	    _t: 'a',
	    1: {
	      inner: {
	        property: ['abc', 'abcd']
	      }
	    },
	    _0: ['', 2, 3]
	  },
	  reverse: {
	    _t: 'a',
	    2: {
	      inner: {
	        property: ['abcd', 'abc']
	      }
	    },
	    _2: ['', 0, 3]
	  }
	}, {
	  name: 'nested with movements using custom objectHash',
	  options: {
	    objectHash(obj) {
	      if (obj && obj.itemKey) {
	        return obj.itemKey;
	      }
	    }
	  },
	  left: [1, 2, 4, {
	    itemKey: 'five',
	    width: 4
	  }, 6, 7, 8, {
	    itemKey: 4,
	    width: 10,
	    height: 3
	  }, 9, 10],
	  right: [1, 2, {
	    itemKey: 4,
	    width: 12
	  }, 4, {
	    itemKey: 'five',
	    width: 4
	  }, 6, 7, 8, 9, 10],
	  delta: {
	    _t: 'a',
	    2: {
	      width: [10, 12],
	      height: [3, 0, 0]
	    },
	    _7: ['', 2, 3]
	  },
	  reverse: {
	    _t: 'a',
	    7: {
	      width: [12, 10],
	      height: [3]
	    },
	    _2: ['', 7, 3]
	  }
	}, {
	  name: 'using property filter',
	  options: {
	    propertyFilter(name /*, context */) {
	      return name.slice(0, 1) !== '$';
	    }
	  },
	  left: {
	    inner: {
	      $volatileData: 345,
	      $oldVolatileData: 422,
	      nonVolatile: 432
	    }
	  },
	  right: {
	    inner: {
	      $volatileData: 346,
	      $newVolatileData: 32,
	      nonVolatile: 431
	    }
	  },
	  delta: {
	    inner: {
	      nonVolatile: [432, 431]
	    }
	  },
	  reverse: {
	    inner: {
	      nonVolatile: [431, 432]
	    }
	  },
	  noPatch: true
	}, 0];

	var chai$2 = {};

	/*!
	 * assertion-error
	 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
	 * MIT Licensed
	 */

	/*!
	 * Return a function that will copy properties from
	 * one object to another excluding any originally
	 * listed. Returned function will create a new `{}`.
	 *
	 * @param {String} excluded properties ...
	 * @return {Function}
	 */

	function exclude () {
	  var excludes = [].slice.call(arguments);

	  function excludeProps (res, obj) {
	    Object.keys(obj).forEach(function (key) {
	      if (!~excludes.indexOf(key)) res[key] = obj[key];
	    });
	  }

	  return function extendExclude () {
	    var args = [].slice.call(arguments)
	      , i = 0
	      , res = {};

	    for (; i < args.length; i++) {
	      excludeProps(res, args[i]);
	    }

	    return res;
	  };
	}
	/*!
	 * Primary Exports
	 */

	var assertionError = AssertionError$1;

	/**
	 * ### AssertionError
	 *
	 * An extension of the JavaScript `Error` constructor for
	 * assertion and validation scenarios.
	 *
	 * @param {String} message
	 * @param {Object} properties to include (optional)
	 * @param {callee} start stack function (optional)
	 */

	function AssertionError$1 (message, _props, ssf) {
	  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
	    , props = extend(_props || {});

	  // default values
	  this.message = message || 'Unspecified AssertionError';
	  this.showDiff = false;

	  // copy from properties
	  for (var key in props) {
	    this[key] = props[key];
	  }

	  // capture stack trace
	  ssf = ssf || AssertionError$1;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, ssf);
	  } else {
	    try {
	      throw new Error();
	    } catch(e) {
	      this.stack = e.stack;
	    }
	  }
	}

	/*!
	 * Inherit from Error.prototype
	 */

	AssertionError$1.prototype = Object.create(Error.prototype);

	/*!
	 * Statically set name
	 */

	AssertionError$1.prototype.name = 'AssertionError';

	/*!
	 * Ensure correct constructor
	 */

	AssertionError$1.prototype.constructor = AssertionError$1;

	/**
	 * Allow errors to be converted to JSON for static transfer.
	 *
	 * @param {Boolean} include stack (default: `true`)
	 * @return {Object} object that can be `JSON.stringify`
	 */

	AssertionError$1.prototype.toJSON = function (stack) {
	  var extend = exclude('constructor', 'toJSON', 'stack')
	    , props = extend({ name: this.name }, this);

	  // include stack if exists and not turned off
	  if (false !== stack && this.stack) {
	    props.stack = this.stack;
	  }

	  return props;
	};

	var utils = {};

	/* !
	 * Chai - pathval utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * @see https://github.com/logicalparadox/filtr
	 * MIT Licensed
	 */

	/**
	 * ### .hasProperty(object, name)
	 *
	 * This allows checking whether an object has own
	 * or inherited from prototype chain named property.
	 *
	 * Basically does the same thing as the `in`
	 * operator but works properly with null/undefined values
	 * and other primitives.
	 *
	 *     var obj = {
	 *         arr: ['a', 'b', 'c']
	 *       , str: 'Hello'
	 *     }
	 *
	 * The following would be the results.
	 *
	 *     hasProperty(obj, 'str');  // true
	 *     hasProperty(obj, 'constructor');  // true
	 *     hasProperty(obj, 'bar');  // false
	 *
	 *     hasProperty(obj.str, 'length'); // true
	 *     hasProperty(obj.str, 1);  // true
	 *     hasProperty(obj.str, 5);  // false
	 *
	 *     hasProperty(obj.arr, 'length');  // true
	 *     hasProperty(obj.arr, 2);  // true
	 *     hasProperty(obj.arr, 3);  // false
	 *
	 * @param {Object} object
	 * @param {String|Symbol} name
	 * @returns {Boolean} whether it exists
	 * @namespace Utils
	 * @name hasProperty
	 * @api public
	 */

	function hasProperty(obj, name) {
	  if (typeof obj === 'undefined' || obj === null) {
	    return false;
	  }

	  // The `in` operator does not work with primitives.
	  return name in Object(obj);
	}

	/* !
	 * ## parsePath(path)
	 *
	 * Helper function used to parse string object
	 * paths. Use in conjunction with `internalGetPathValue`.
	 *
	 *      var parsed = parsePath('myobject.property.subprop');
	 *
	 * ### Paths:
	 *
	 * * Can be infinitely deep and nested.
	 * * Arrays are also valid using the formal `myobject.document[3].property`.
	 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
	 *
	 * @param {String} path
	 * @returns {Object} parsed
	 * @api private
	 */

	function parsePath(path) {
	  var str = path.replace(/([^\\])\[/g, '$1.[');
	  var parts = str.match(/(\\\.|[^.]+?)+/g);
	  return parts.map(function mapMatches(value) {
	    if (
	      value === 'constructor' ||
	      value === '__proto__' ||
	      value === 'prototype'
	    ) {
	      return {};
	    }
	    var regexp = /^\[(\d+)\]$/;
	    var mArr = regexp.exec(value);
	    var parsed = null;
	    if (mArr) {
	      parsed = { i: parseFloat(mArr[1]) };
	    } else {
	      parsed = { p: value.replace(/\\([.[\]])/g, '$1') };
	    }

	    return parsed;
	  });
	}

	/* !
	 * ## internalGetPathValue(obj, parsed[, pathDepth])
	 *
	 * Helper companion function for `.parsePath` that returns
	 * the value located at the parsed address.
	 *
	 *      var value = getPathValue(obj, parsed);
	 *
	 * @param {Object} object to search against
	 * @param {Object} parsed definition from `parsePath`.
	 * @param {Number} depth (nesting level) of the property we want to retrieve
	 * @returns {Object|Undefined} value
	 * @api private
	 */

	function internalGetPathValue(obj, parsed, pathDepth) {
	  var temporaryValue = obj;
	  var res = null;
	  pathDepth = typeof pathDepth === 'undefined' ? parsed.length : pathDepth;

	  for (var i = 0; i < pathDepth; i++) {
	    var part = parsed[i];
	    if (temporaryValue) {
	      if (typeof part.p === 'undefined') {
	        temporaryValue = temporaryValue[part.i];
	      } else {
	        temporaryValue = temporaryValue[part.p];
	      }

	      if (i === pathDepth - 1) {
	        res = temporaryValue;
	      }
	    }
	  }

	  return res;
	}

	/* !
	 * ## internalSetPathValue(obj, value, parsed)
	 *
	 * Companion function for `parsePath` that sets
	 * the value located at a parsed address.
	 *
	 *  internalSetPathValue(obj, 'value', parsed);
	 *
	 * @param {Object} object to search and define on
	 * @param {*} value to use upon set
	 * @param {Object} parsed definition from `parsePath`
	 * @api private
	 */

	function internalSetPathValue(obj, val, parsed) {
	  var tempObj = obj;
	  var pathDepth = parsed.length;
	  var part = null;
	  // Here we iterate through every part of the path
	  for (var i = 0; i < pathDepth; i++) {
	    var propName = null;
	    var propVal = null;
	    part = parsed[i];

	    // If it's the last part of the path, we set the 'propName' value with the property name
	    if (i === pathDepth - 1) {
	      propName = typeof part.p === 'undefined' ? part.i : part.p;
	      // Now we set the property with the name held by 'propName' on object with the desired val
	      tempObj[propName] = val;
	    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
	      tempObj = tempObj[part.p];
	    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
	      tempObj = tempObj[part.i];
	    } else {
	      // If the obj doesn't have the property we create one with that name to define it
	      var next = parsed[i + 1];
	      // Here we set the name of the property which will be defined
	      propName = typeof part.p === 'undefined' ? part.i : part.p;
	      // Here we decide if this property will be an array or a new object
	      propVal = typeof next.p === 'undefined' ? [] : {};
	      tempObj[propName] = propVal;
	      tempObj = tempObj[propName];
	    }
	  }
	}

	/**
	 * ### .getPathInfo(object, path)
	 *
	 * This allows the retrieval of property info in an
	 * object given a string path.
	 *
	 * The path info consists of an object with the
	 * following properties:
	 *
	 * * parent - The parent object of the property referenced by `path`
	 * * name - The name of the final property, a number if it was an array indexer
	 * * value - The value of the property, if it exists, otherwise `undefined`
	 * * exists - Whether the property exists or not
	 *
	 * @param {Object} object
	 * @param {String} path
	 * @returns {Object} info
	 * @namespace Utils
	 * @name getPathInfo
	 * @api public
	 */

	function getPathInfo(obj, path) {
	  var parsed = parsePath(path);
	  var last = parsed[parsed.length - 1];
	  var info = {
	    parent:
	      parsed.length > 1 ?
	        internalGetPathValue(obj, parsed, parsed.length - 1) :
	        obj,
	    name: last.p || last.i,
	    value: internalGetPathValue(obj, parsed),
	  };
	  info.exists = hasProperty(info.parent, info.name);

	  return info;
	}

	/**
	 * ### .getPathValue(object, path)
	 *
	 * This allows the retrieval of values in an
	 * object given a string path.
	 *
	 *     var obj = {
	 *         prop1: {
	 *             arr: ['a', 'b', 'c']
	 *           , str: 'Hello'
	 *         }
	 *       , prop2: {
	 *             arr: [ { nested: 'Universe' } ]
	 *           , str: 'Hello again!'
	 *         }
	 *     }
	 *
	 * The following would be the results.
	 *
	 *     getPathValue(obj, 'prop1.str'); // Hello
	 *     getPathValue(obj, 'prop1.att[2]'); // b
	 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
	 *
	 * @param {Object} object
	 * @param {String} path
	 * @returns {Object} value or `undefined`
	 * @namespace Utils
	 * @name getPathValue
	 * @api public
	 */

	function getPathValue(obj, path) {
	  var info = getPathInfo(obj, path);
	  return info.value;
	}

	/**
	 * ### .setPathValue(object, path, value)
	 *
	 * Define the value in an object at a given string path.
	 *
	 * ```js
	 * var obj = {
	 *     prop1: {
	 *         arr: ['a', 'b', 'c']
	 *       , str: 'Hello'
	 *     }
	 *   , prop2: {
	 *         arr: [ { nested: 'Universe' } ]
	 *       , str: 'Hello again!'
	 *     }
	 * };
	 * ```
	 *
	 * The following would be acceptable.
	 *
	 * ```js
	 * var properties = require('tea-properties');
	 * properties.set(obj, 'prop1.str', 'Hello Universe!');
	 * properties.set(obj, 'prop1.arr[2]', 'B');
	 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
	 * ```
	 *
	 * @param {Object} object
	 * @param {String} path
	 * @param {Mixed} value
	 * @api private
	 */

	function setPathValue(obj, path, val) {
	  var parsed = parsePath(path);
	  internalSetPathValue(obj, val, parsed);
	  return obj;
	}

	var pathval = {
	  hasProperty: hasProperty,
	  getPathInfo: getPathInfo,
	  getPathValue: getPathValue,
	  setPathValue: setPathValue,
	};

	/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .flag(object, key, [value])
	 *
	 * Get or set a flag value on an object. If a
	 * value is provided it will be set, else it will
	 * return the currently set value or `undefined` if
	 * the value is not set.
	 *
	 *     utils.flag(this, 'foo', 'bar'); // setter
	 *     utils.flag(this, 'foo'); // getter, returns `bar`
	 *
	 * @param {Object} object constructed Assertion
	 * @param {String} key
	 * @param {Mixed} value (optional)
	 * @namespace Utils
	 * @name flag
	 * @api private
	 */

	var flag$5 = function flag(obj, key, value) {
	  var flags = obj.__flags || (obj.__flags = Object.create(null));
	  if (arguments.length === 3) {
	    flags[key] = value;
	  } else {
	    return flags[key];
	  }
	};

	/*!
	 * Chai - test utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependencies
	 */

	var flag$4 = flag$5;

	/**
	 * ### .test(object, expression)
	 *
	 * Test and object for expression.
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 * @namespace Utils
	 * @name test
	 */

	var test = function test(obj, args) {
	  var negate = flag$4(obj, 'negate')
	    , expr = args[0];
	  return negate ? !expr : expr;
	};

	var typeDetect = {exports: {}};

	(function (module, exports) {
		(function (global, factory) {
			module.exports = factory() ;
		}(commonjsGlobal, (function () {
		/* !
		 * type-detect
		 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
		 * MIT Licensed
		 */
		var promiseExists = typeof Promise === 'function';

		/* eslint-disable no-undef */
		var globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

		var symbolExists = typeof Symbol !== 'undefined';
		var mapExists = typeof Map !== 'undefined';
		var setExists = typeof Set !== 'undefined';
		var weakMapExists = typeof WeakMap !== 'undefined';
		var weakSetExists = typeof WeakSet !== 'undefined';
		var dataViewExists = typeof DataView !== 'undefined';
		var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
		var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
		var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
		var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
		var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
		var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
		var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
		var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
		var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
		var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
		var toStringLeftSliceLength = 8;
		var toStringRightSliceLength = -1;
		/**
		 * ### typeOf (obj)
		 *
		 * Uses `Object.prototype.toString` to determine the type of an object,
		 * normalising behaviour across engine versions & well optimised.
		 *
		 * @param {Mixed} object
		 * @return {String} object type
		 * @api public
		 */
		function typeDetect(obj) {
		  /* ! Speed optimisation
		   * Pre:
		   *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)
		   *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)
		   *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)
		   *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)
		   *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)
		   * Post:
		   *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)
		   *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)
		   *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)
		   *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)
		   *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)
		   */
		  var typeofObj = typeof obj;
		  if (typeofObj !== 'object') {
		    return typeofObj;
		  }

		  /* ! Speed optimisation
		   * Pre:
		   *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)
		   * Post:
		   *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)
		   */
		  if (obj === null) {
		    return 'null';
		  }

		  /* ! Spec Conformance
		   * Test: `Object.prototype.toString.call(window)``
		   *  - Node === "[object global]"
		   *  - Chrome === "[object global]"
		   *  - Firefox === "[object Window]"
		   *  - PhantomJS === "[object Window]"
		   *  - Safari === "[object Window]"
		   *  - IE 11 === "[object Window]"
		   *  - IE Edge === "[object Window]"
		   * Test: `Object.prototype.toString.call(this)``
		   *  - Chrome Worker === "[object global]"
		   *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
		   *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
		   *  - IE 11 Worker === "[object WorkerGlobalScope]"
		   *  - IE Edge Worker === "[object WorkerGlobalScope]"
		   */
		  if (obj === globalObject) {
		    return 'global';
		  }

		  /* ! Speed optimisation
		   * Pre:
		   *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)
		   * Post:
		   *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)
		   */
		  if (
		    Array.isArray(obj) &&
		    (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))
		  ) {
		    return 'Array';
		  }

		  // Not caching existence of `window` and related properties due to potential
		  // for `window` to be unset before tests in quasi-browser environments.
		  if (typeof window === 'object' && window !== null) {
		    /* ! Spec Conformance
		     * (https://html.spec.whatwg.org/multipage/browsers.html#location)
		     * WhatWG HTML$7.7.3 - The `Location` interface
		     * Test: `Object.prototype.toString.call(window.location)``
		     *  - IE <=11 === "[object Object]"
		     *  - IE Edge <=13 === "[object Object]"
		     */
		    if (typeof window.location === 'object' && obj === window.location) {
		      return 'Location';
		    }

		    /* ! Spec Conformance
		     * (https://html.spec.whatwg.org/#document)
		     * WhatWG HTML$3.1.1 - The `Document` object
		     * Note: Most browsers currently adher to the W3C DOM Level 2 spec
		     *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
		     *       which suggests that browsers should use HTMLTableCellElement for
		     *       both TD and TH elements. WhatWG separates these.
		     *       WhatWG HTML states:
		     *         > For historical reasons, Window objects must also have a
		     *         > writable, configurable, non-enumerable property named
		     *         > HTMLDocument whose value is the Document interface object.
		     * Test: `Object.prototype.toString.call(document)``
		     *  - Chrome === "[object HTMLDocument]"
		     *  - Firefox === "[object HTMLDocument]"
		     *  - Safari === "[object HTMLDocument]"
		     *  - IE <=10 === "[object Document]"
		     *  - IE 11 === "[object HTMLDocument]"
		     *  - IE Edge <=13 === "[object HTMLDocument]"
		     */
		    if (typeof window.document === 'object' && obj === window.document) {
		      return 'Document';
		    }

		    if (typeof window.navigator === 'object') {
		      /* ! Spec Conformance
		       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
		       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
		       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
		       *  - IE <=10 === "[object MSMimeTypesCollection]"
		       */
		      if (typeof window.navigator.mimeTypes === 'object' &&
		          obj === window.navigator.mimeTypes) {
		        return 'MimeTypeArray';
		      }

		      /* ! Spec Conformance
		       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
		       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
		       * Test: `Object.prototype.toString.call(navigator.plugins)``
		       *  - IE <=10 === "[object MSPluginsCollection]"
		       */
		      if (typeof window.navigator.plugins === 'object' &&
		          obj === window.navigator.plugins) {
		        return 'PluginArray';
		      }
		    }

		    if ((typeof window.HTMLElement === 'function' ||
		        typeof window.HTMLElement === 'object') &&
		        obj instanceof window.HTMLElement) {
		      /* ! Spec Conformance
		      * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
		      * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
		      * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
		      *  - IE <=10 === "[object HTMLBlockElement]"
		      */
		      if (obj.tagName === 'BLOCKQUOTE') {
		        return 'HTMLQuoteElement';
		      }

		      /* ! Spec Conformance
		       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
		       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
		       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
		       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
		       *       which suggests that browsers should use HTMLTableCellElement for
		       *       both TD and TH elements. WhatWG separates these.
		       * Test: Object.prototype.toString.call(document.createElement('td'))
		       *  - Chrome === "[object HTMLTableCellElement]"
		       *  - Firefox === "[object HTMLTableCellElement]"
		       *  - Safari === "[object HTMLTableCellElement]"
		       */
		      if (obj.tagName === 'TD') {
		        return 'HTMLTableDataCellElement';
		      }

		      /* ! Spec Conformance
		       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
		       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
		       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
		       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
		       *       which suggests that browsers should use HTMLTableCellElement for
		       *       both TD and TH elements. WhatWG separates these.
		       * Test: Object.prototype.toString.call(document.createElement('th'))
		       *  - Chrome === "[object HTMLTableCellElement]"
		       *  - Firefox === "[object HTMLTableCellElement]"
		       *  - Safari === "[object HTMLTableCellElement]"
		       */
		      if (obj.tagName === 'TH') {
		        return 'HTMLTableHeaderCellElement';
		      }
		    }
		  }

		  /* ! Speed optimisation
		  * Pre:
		  *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)
		  *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)
		  *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)
		  *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)
		  *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)
		  *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)
		  *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)
		  *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)
		  *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)
		  * Post:
		  *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)
		  *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)
		  *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)
		  *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)
		  *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)
		  *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)
		  *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)
		  *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)
		  *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)
		  */
		  var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);
		  if (typeof stringTag === 'string') {
		    return stringTag;
		  }

		  var objPrototype = Object.getPrototypeOf(obj);
		  /* ! Speed optimisation
		  * Pre:
		  *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)
		  *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)
		  * Post:
		  *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)
		  *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)
		  */
		  if (objPrototype === RegExp.prototype) {
		    return 'RegExp';
		  }

		  /* ! Speed optimisation
		  * Pre:
		  *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)
		  * Post:
		  *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)
		  */
		  if (objPrototype === Date.prototype) {
		    return 'Date';
		  }

		  /* ! Spec Conformance
		   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
		   * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
		   * Test: `Object.prototype.toString.call(Promise.resolve())``
		   *  - Chrome <=47 === "[object Object]"
		   *  - Edge <=20 === "[object Object]"
		   *  - Firefox 29-Latest === "[object Promise]"
		   *  - Safari 7.1-Latest === "[object Promise]"
		   */
		  if (promiseExists && objPrototype === Promise.prototype) {
		    return 'Promise';
		  }

		  /* ! Speed optimisation
		  * Pre:
		  *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)
		  * Post:
		  *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)
		  */
		  if (setExists && objPrototype === Set.prototype) {
		    return 'Set';
		  }

		  /* ! Speed optimisation
		  * Pre:
		  *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)
		  * Post:
		  *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)
		  */
		  if (mapExists && objPrototype === Map.prototype) {
		    return 'Map';
		  }

		  /* ! Speed optimisation
		  * Pre:
		  *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)
		  * Post:
		  *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)
		  */
		  if (weakSetExists && objPrototype === WeakSet.prototype) {
		    return 'WeakSet';
		  }

		  /* ! Speed optimisation
		  * Pre:
		  *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)
		  * Post:
		  *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)
		  */
		  if (weakMapExists && objPrototype === WeakMap.prototype) {
		    return 'WeakMap';
		  }

		  /* ! Spec Conformance
		   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
		   * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
		   * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
		   *  - Edge <=13 === "[object Object]"
		   */
		  if (dataViewExists && objPrototype === DataView.prototype) {
		    return 'DataView';
		  }

		  /* ! Spec Conformance
		   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
		   * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
		   * Test: `Object.prototype.toString.call(new Map().entries())``
		   *  - Edge <=13 === "[object Object]"
		   */
		  if (mapExists && objPrototype === mapIteratorPrototype) {
		    return 'Map Iterator';
		  }

		  /* ! Spec Conformance
		   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
		   * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
		   * Test: `Object.prototype.toString.call(new Set().entries())``
		   *  - Edge <=13 === "[object Object]"
		   */
		  if (setExists && objPrototype === setIteratorPrototype) {
		    return 'Set Iterator';
		  }

		  /* ! Spec Conformance
		   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
		   * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
		   * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
		   *  - Edge <=13 === "[object Object]"
		   */
		  if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
		    return 'Array Iterator';
		  }

		  /* ! Spec Conformance
		   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
		   * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
		   * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
		   *  - Edge <=13 === "[object Object]"
		   */
		  if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
		    return 'String Iterator';
		  }

		  /* ! Speed optimisation
		  * Pre:
		  *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)
		  * Post:
		  *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)
		  */
		  if (objPrototype === null) {
		    return 'Object';
		  }

		  return Object
		    .prototype
		    .toString
		    .call(obj)
		    .slice(toStringLeftSliceLength, toStringRightSliceLength);
		}

		return typeDetect;

		}))); 
	} (typeDetect));

	var typeDetectExports = typeDetect.exports;

	/*!
	 * Chai - expectTypes utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .expectTypes(obj, types)
	 *
	 * Ensures that the object being tested against is of a valid type.
	 *
	 *     utils.expectTypes(this, ['array', 'object', 'string']);
	 *
	 * @param {Mixed} obj constructed Assertion
	 * @param {Array} type A list of allowed types for this assertion
	 * @namespace Utils
	 * @name expectTypes
	 * @api public
	 */

	var AssertionError = assertionError;
	var flag$3 = flag$5;
	var type$2 = typeDetectExports;

	var expectTypes = function expectTypes(obj, types) {
	  var flagMsg = flag$3(obj, 'message');
	  var ssfi = flag$3(obj, 'ssfi');

	  flagMsg = flagMsg ? flagMsg + ': ' : '';

	  obj = flag$3(obj, 'object');
	  types = types.map(function (t) { return t.toLowerCase(); });
	  types.sort();

	  // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'
	  var str = types.map(function (t, index) {
	    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';
	    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
	    return or + art + ' ' + t;
	  }).join(', ');

	  var objType = type$2(obj).toLowerCase();

	  if (!types.some(function (expected) { return objType === expected; })) {
	    throw new AssertionError(
	      flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given',
	      undefined,
	      ssfi
	    );
	  }
	};

	/*!
	 * Chai - getActual utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .getActual(object, [actual])
	 *
	 * Returns the `actual` value for an Assertion.
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 * @namespace Utils
	 * @name getActual
	 */

	var getActual$1 = function getActual(obj, args) {
	  return args.length > 4 ? args[4] : obj._obj;
	};

	/* !
	 * Chai - getFuncName utility
	 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .getFuncName(constructorFn)
	 *
	 * Returns the name of a function.
	 * When a non-function instance is passed, returns `null`.
	 * This also includes a polyfill function if `aFunc.name` is not defined.
	 *
	 * @name getFuncName
	 * @param {Function} funct
	 * @namespace Utils
	 * @api public
	 */

	var toString$1 = Function.prototype.toString;
	var functionNameMatch$1 = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
	function getFuncName(aFunc) {
	  if (typeof aFunc !== 'function') {
	    return null;
	  }

	  var name = '';
	  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
	    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
	    var match = toString$1.call(aFunc).match(functionNameMatch$1);
	    if (match) {
	      name = match[1];
	    }
	  } else {
	    // If we've got a `name` property we just use it
	    name = aFunc.name;
	  }

	  return name;
	}

	var getFuncName_1 = getFuncName;

	var getFuncName$1 = /*@__PURE__*/getDefaultExportFromCjs(getFuncName_1);

	const ansiColors = {
	  bold: ['1', '22'],
	  dim: ['2', '22'],
	  italic: ['3', '23'],
	  underline: ['4', '24'],
	  // 5 & 6 are blinking
	  inverse: ['7', '27'],
	  hidden: ['8', '28'],
	  strike: ['9', '29'],
	  // 10-20 are fonts
	  // 21-29 are resets for 1-9
	  black: ['30', '39'],
	  red: ['31', '39'],
	  green: ['32', '39'],
	  yellow: ['33', '39'],
	  blue: ['34', '39'],
	  magenta: ['35', '39'],
	  cyan: ['36', '39'],
	  white: ['37', '39'],

	  brightblack: ['30;1', '39'],
	  brightred: ['31;1', '39'],
	  brightgreen: ['32;1', '39'],
	  brightyellow: ['33;1', '39'],
	  brightblue: ['34;1', '39'],
	  brightmagenta: ['35;1', '39'],
	  brightcyan: ['36;1', '39'],
	  brightwhite: ['37;1', '39'],

	  grey: ['90', '39'],
	};

	const styles = {
	  special: 'cyan',
	  number: 'yellow',
	  bigint: 'yellow',
	  boolean: 'yellow',
	  undefined: 'grey',
	  null: 'bold',
	  string: 'green',
	  symbol: 'green',
	  date: 'magenta',
	  regexp: 'red',
	};

	const truncator = '';

	function colorise(value, styleType) {
	  const color = ansiColors[styles[styleType]] || ansiColors[styleType];
	  if (!color) {
	    return String(value)
	  }
	  return `\u001b[${color[0]}m${String(value)}\u001b[${color[1]}m`
	}

	function normaliseOptions({
	  showHidden = false,
	  depth = 2,
	  colors = false,
	  customInspect = true,
	  showProxy = false,
	  maxArrayLength = Infinity,
	  breakLength = Infinity,
	  seen = [],
	  // eslint-disable-next-line no-shadow
	  truncate = Infinity,
	  stylize = String,
	} = {}) {
	  const options = {
	    showHidden: Boolean(showHidden),
	    depth: Number(depth),
	    colors: Boolean(colors),
	    customInspect: Boolean(customInspect),
	    showProxy: Boolean(showProxy),
	    maxArrayLength: Number(maxArrayLength),
	    breakLength: Number(breakLength),
	    truncate: Number(truncate),
	    seen,
	    stylize,
	  };
	  if (options.colors) {
	    options.stylize = colorise;
	  }
	  return options
	}

	function truncate(string, length, tail = truncator) {
	  string = String(string);
	  const tailLength = tail.length;
	  const stringLength = string.length;
	  if (tailLength > length && stringLength > tailLength) {
	    return tail
	  }
	  if (stringLength > length && stringLength > tailLength) {
	    return `${string.slice(0, length - tailLength)}${tail}`
	  }
	  return string
	}

	// eslint-disable-next-line complexity
	function inspectList(list, options, inspectItem, separator = ', ') {
	  inspectItem = inspectItem || options.inspect;
	  const size = list.length;
	  if (size === 0) return ''
	  const originalLength = options.truncate;
	  let output = '';
	  let peek = '';
	  let truncated = '';
	  for (let i = 0; i < size; i += 1) {
	    const last = i + 1 === list.length;
	    const secondToLast = i + 2 === list.length;
	    truncated = `${truncator}(${list.length - i})`;
	    const value = list[i];

	    // If there is more than one remaining we need to account for a separator of `, `
	    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
	    const string = peek || inspectItem(value, options) + (last ? '' : separator);
	    const nextLength = output.length + string.length;
	    const truncatedLength = nextLength + truncated.length;

	    // If this is the last element, and adding it would
	    // take us over length, but adding the truncator wouldn't - then break now
	    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
	      break
	    }

	    // If this isn't the last or second to last element to scan,
	    // but the string is already over length then break here
	    if (!last && !secondToLast && truncatedLength > originalLength) {
	      break
	    }

	    // Peek at the next string to determine if we should
	    // break early before adding this item to the output
	    peek = last ? '' : inspectItem(list[i + 1], options) + (secondToLast ? '' : separator);

	    // If we have one element left, but this element and
	    // the next takes over length, the break early
	    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
	      break
	    }

	    output += string;

	    // If the next element takes us to length -
	    // but there are more after that, then we should truncate now
	    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
	      truncated = `${truncator}(${list.length - i - 1})`;
	      break
	    }

	    truncated = '';
	  }
	  return `${output}${truncated}`
	}

	function quoteComplexKey(key) {
	  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
	    return key
	  }
	  return JSON.stringify(key)
	    .replace(/'/g, "\\'")
	    .replace(/\\"/g, '"')
	    .replace(/(^"|"$)/g, "'")
	}

	function inspectProperty([key, value], options) {
	  options.truncate -= 2;
	  if (typeof key === 'string') {
	    key = quoteComplexKey(key);
	  } else if (typeof key !== 'number') {
	    key = `[${options.inspect(key, options)}]`;
	  }
	  options.truncate -= key.length;
	  value = options.inspect(value, options);
	  return `${key}: ${value}`
	}

	function inspectArray(array, options) {
	  // Object.keys will always output the Array indices first, so we can slice by
	  // `array.length` to get non-index properties
	  const nonIndexProperties = Object.keys(array).slice(array.length);
	  if (!array.length && !nonIndexProperties.length) return '[]'
	  options.truncate -= 4;
	  const listContents = inspectList(array, options);
	  options.truncate -= listContents.length;
	  let propertyContents = '';
	  if (nonIndexProperties.length) {
	    propertyContents = inspectList(
	      nonIndexProperties.map(key => [key, array[key]]),
	      options,
	      inspectProperty
	    );
	  }
	  return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ''} ]`
	}

	const getArrayName = array => {
	  // We need to special case Node.js' Buffers, which report to be Uint8Array
	  if (typeof Buffer === 'function' && array instanceof Buffer) {
	    return 'Buffer'
	  }
	  if (array[Symbol.toStringTag]) {
	    return array[Symbol.toStringTag]
	  }
	  return getFuncName$1(array.constructor)
	};

	function inspectTypedArray(array, options) {
	  const name = getArrayName(array);
	  options.truncate -= name.length + 4;
	  // Object.keys will always output the Array indices first, so we can slice by
	  // `array.length` to get non-index properties
	  const nonIndexProperties = Object.keys(array).slice(array.length);
	  if (!array.length && !nonIndexProperties.length) return `${name}[]`
	  // As we know TypedArrays only contain Unsigned Integers, we can skip inspecting each one and simply
	  // stylise the toString() value of them
	  let output = '';
	  for (let i = 0; i < array.length; i++) {
	    const string = `${options.stylize(truncate(array[i], options.truncate), 'number')}${
      i === array.length - 1 ? '' : ', '
    }`;
	    options.truncate -= string.length;
	    if (array[i] !== array.length && options.truncate <= 3) {
	      output += `${truncator}(${array.length - array[i] + 1})`;
	      break
	    }
	    output += string;
	  }
	  let propertyContents = '';
	  if (nonIndexProperties.length) {
	    propertyContents = inspectList(
	      nonIndexProperties.map(key => [key, array[key]]),
	      options,
	      inspectProperty
	    );
	  }
	  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ''} ]`
	}

	function inspectDate(dateObject, options) {
	  const stringRepresentation = dateObject.toJSON();

	  if (stringRepresentation === null) {
	    return 'Invalid Date'
	  }

	  const split = stringRepresentation.split('T');
	  const date = split[0];
	  // If we need to - truncate the time portion, but never the date
	  return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, 'date')
	}

	function inspectFunction(func, options) {
	  const name = getFuncName$1(func);
	  if (!name) {
	    return options.stylize('[Function]', 'special')
	  }
	  return options.stylize(`[Function ${truncate(name, options.truncate - 11)}]`, 'special')
	}

	function inspectMapEntry([key, value], options) {
	  options.truncate -= 4;
	  key = options.inspect(key, options);
	  options.truncate -= key.length;
	  value = options.inspect(value, options);
	  return `${key} => ${value}`
	}

	// IE11 doesn't support `map.entries()`
	function mapToEntries(map) {
	  const entries = [];
	  map.forEach((value, key) => {
	    entries.push([key, value]);
	  });
	  return entries
	}

	function inspectMap(map, options) {
	  const size = map.size - 1;
	  if (size <= 0) {
	    return 'Map{}'
	  }
	  options.truncate -= 7;
	  return `Map{ ${inspectList(mapToEntries(map), options, inspectMapEntry)} }`
	}

	const isNaN$2 = Number.isNaN || (i => i !== i); // eslint-disable-line no-self-compare
	function inspectNumber(number, options) {
	  if (isNaN$2(number)) {
	    return options.stylize('NaN', 'number')
	  }
	  if (number === Infinity) {
	    return options.stylize('Infinity', 'number')
	  }
	  if (number === -Infinity) {
	    return options.stylize('-Infinity', 'number')
	  }
	  if (number === 0) {
	    return options.stylize(1 / number === Infinity ? '+0' : '-0', 'number')
	  }
	  return options.stylize(truncate(number, options.truncate), 'number')
	}

	function inspectBigInt(number, options) {
	  let nums = truncate(number.toString(), options.truncate - 1);
	  if (nums !== truncator) nums += 'n';
	  return options.stylize(nums, 'bigint')
	}

	function inspectRegExp(value, options) {
	  const flags = value.toString().split('/')[2];
	  const sourceLength = options.truncate - (2 + flags.length);
	  const source = value.source;
	  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, 'regexp')
	}

	// IE11 doesn't support `Array.from(set)`
	function arrayFromSet(set) {
	  const values = [];
	  set.forEach(value => {
	    values.push(value);
	  });
	  return values
	}

	function inspectSet(set, options) {
	  if (set.size === 0) return 'Set{}'
	  options.truncate -= 7;
	  return `Set{ ${inspectList(arrayFromSet(set), options)} }`
	}

	const stringEscapeChars = new RegExp(
	  "['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5" +
	    '\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]',
	  'g'
	);

	const escapeCharacters = {
	  '\b': '\\b',
	  '\t': '\\t',
	  '\n': '\\n',
	  '\f': '\\f',
	  '\r': '\\r',
	  "'": "\\'",
	  '\\': '\\\\',
	};
	const hex = 16;
	const unicodeLength = 4;
	function escape(char) {
	  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`
	}

	function inspectString(string, options) {
	  if (stringEscapeChars.test(string)) {
	    string = string.replace(stringEscapeChars, escape);
	  }
	  return options.stylize(`'${truncate(string, options.truncate - 2)}'`, 'string')
	}

	function inspectSymbol(value) {
	  if ('description' in Symbol.prototype) {
	    return value.description ? `Symbol(${value.description})` : 'Symbol()'
	  }
	  return value.toString()
	}

	let getPromiseValue = () => 'Promise{}';
	try {
	  const { getPromiseDetails, kPending, kRejected } = process.binding('util');
	  if (Array.isArray(getPromiseDetails(Promise.resolve()))) {
	    getPromiseValue = (value, options) => {
	      const [state, innerValue] = getPromiseDetails(value);
	      if (state === kPending) {
	        return 'Promise{<pending>}'
	      }
	      return `Promise${state === kRejected ? '!' : ''}{${options.inspect(innerValue, options)}}`
	    };
	  }
	} catch (notNode) {
	  /* ignore */
	}
	var inspectPromise = getPromiseValue;

	function inspectObject$1(object, options) {
	  const properties = Object.getOwnPropertyNames(object);
	  const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
	  if (properties.length === 0 && symbols.length === 0) {
	    return '{}'
	  }
	  options.truncate -= 4;
	  options.seen = options.seen || [];
	  if (options.seen.indexOf(object) >= 0) {
	    return '[Circular]'
	  }
	  options.seen.push(object);
	  const propertyContents = inspectList(
	    properties.map(key => [key, object[key]]),
	    options,
	    inspectProperty
	  );
	  const symbolContents = inspectList(
	    symbols.map(key => [key, object[key]]),
	    options,
	    inspectProperty
	  );
	  options.seen.pop();
	  let sep = '';
	  if (propertyContents && symbolContents) {
	    sep = ', ';
	  }
	  return `{ ${propertyContents}${sep}${symbolContents} }`
	}

	const toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag ? Symbol.toStringTag : false;

	function inspectClass(value, options) {
	  let name = '';
	  if (toStringTag && toStringTag in value) {
	    name = value[toStringTag];
	  }
	  name = name || getFuncName$1(value.constructor);
	  // Babel transforms anonymous classes to the name `_class`
	  if (!name || name === '_class') {
	    name = '<Anonymous Class>';
	  }
	  options.truncate -= name.length;
	  return `${name}${inspectObject$1(value, options)}`
	}

	function inspectArguments(args, options) {
	  if (args.length === 0) return 'Arguments[]'
	  options.truncate -= 13;
	  return `Arguments[ ${inspectList(args, options)} ]`
	}

	const errorKeys = [
	  'stack',
	  'line',
	  'column',
	  'name',
	  'message',
	  'fileName',
	  'lineNumber',
	  'columnNumber',
	  'number',
	  'description',
	];

	function inspectObject(error, options) {
	  const properties = Object.getOwnPropertyNames(error).filter(key => errorKeys.indexOf(key) === -1);
	  const name = error.name;
	  options.truncate -= name.length;
	  let message = '';
	  if (typeof error.message === 'string') {
	    message = truncate(error.message, options.truncate);
	  } else {
	    properties.unshift('message');
	  }
	  message = message ? `: ${message}` : '';
	  options.truncate -= message.length + 5;
	  const propertyContents = inspectList(
	    properties.map(key => [key, error[key]]),
	    options,
	    inspectProperty
	  );
	  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ''}`
	}

	function inspectAttribute([key, value], options) {
	  options.truncate -= 3;
	  if (!value) {
	    return `${options.stylize(key, 'yellow')}`
	  }
	  return `${options.stylize(key, 'yellow')}=${options.stylize(`"${value}"`, 'string')}`
	}

	function inspectHTMLCollection(collection, options) {
	  // eslint-disable-next-line no-use-before-define
	  return inspectList(collection, options, inspectHTML, '\n')
	}

	function inspectHTML(element, options) {
	  const properties = element.getAttributeNames();
	  const name = element.tagName.toLowerCase();
	  const head = options.stylize(`<${name}`, 'special');
	  const headClose = options.stylize(`>`, 'special');
	  const tail = options.stylize(`</${name}>`, 'special');
	  options.truncate -= name.length * 2 + 5;
	  let propertyContents = '';
	  if (properties.length > 0) {
	    propertyContents += ' ';
	    propertyContents += inspectList(
	      properties.map(key => [key, element.getAttribute(key)]),
	      options,
	      inspectAttribute,
	      ' '
	    );
	  }
	  options.truncate -= propertyContents.length;
	  const truncate = options.truncate;
	  let children = inspectHTMLCollection(element.children, options);
	  if (children && children.length > truncate) {
	    children = `${truncator}(${element.children.length})`;
	  }
	  return `${head}${propertyContents}${headClose}${children}${tail}`
	}

	/* !
	 * loupe
	 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */


	const symbolsSupported = typeof Symbol === 'function' && typeof Symbol.for === 'function';
	const chaiInspect = symbolsSupported ? Symbol.for('chai/inspect') : '@@chai/inspect';
	let nodeInspect = false;
	try {
	  // eslint-disable-next-line global-require
	  const nodeUtil = require('util');
	  nodeInspect = nodeUtil.inspect ? nodeUtil.inspect.custom : false;
	} catch (noNodeInspect) {
	  nodeInspect = false;
	}

	function FakeMap$1() {
	  // eslint-disable-next-line prefer-template
	  this.key = 'chai/loupe__' + Math.random() + Date.now();
	}
	FakeMap$1.prototype = {
	  // eslint-disable-next-line object-shorthand
	  get: function get(key) {
	    return key[this.key]
	  },
	  // eslint-disable-next-line object-shorthand
	  has: function has(key) {
	    return this.key in key
	  },
	  // eslint-disable-next-line object-shorthand
	  set: function set(key, value) {
	    if (Object.isExtensible(key)) {
	      Object.defineProperty(key, this.key, {
	        // eslint-disable-next-line object-shorthand
	        value: value,
	        configurable: true,
	      });
	    }
	  },
	};
	const constructorMap = new (typeof WeakMap === 'function' ? WeakMap : FakeMap$1)();
	const stringTagMap = {};
	const baseTypesMap = {
	  undefined: (value, options) => options.stylize('undefined', 'undefined'),
	  null: (value, options) => options.stylize(null, 'null'),

	  boolean: (value, options) => options.stylize(value, 'boolean'),
	  Boolean: (value, options) => options.stylize(value, 'boolean'),

	  number: inspectNumber,
	  Number: inspectNumber,

	  bigint: inspectBigInt,
	  BigInt: inspectBigInt,

	  string: inspectString,
	  String: inspectString,

	  function: inspectFunction,
	  Function: inspectFunction,

	  symbol: inspectSymbol,
	  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
	  Symbol: inspectSymbol,

	  Array: inspectArray,
	  Date: inspectDate,
	  Map: inspectMap,
	  Set: inspectSet,
	  RegExp: inspectRegExp,
	  Promise: inspectPromise,

	  // WeakSet, WeakMap are totally opaque to us
	  WeakSet: (value, options) => options.stylize('WeakSet{}', 'special'),
	  WeakMap: (value, options) => options.stylize('WeakMap{}', 'special'),

	  Arguments: inspectArguments,
	  Int8Array: inspectTypedArray,
	  Uint8Array: inspectTypedArray,
	  Uint8ClampedArray: inspectTypedArray,
	  Int16Array: inspectTypedArray,
	  Uint16Array: inspectTypedArray,
	  Int32Array: inspectTypedArray,
	  Uint32Array: inspectTypedArray,
	  Float32Array: inspectTypedArray,
	  Float64Array: inspectTypedArray,

	  Generator: () => '',
	  DataView: () => '',
	  ArrayBuffer: () => '',

	  Error: inspectObject,

	  HTMLCollection: inspectHTMLCollection,
	  NodeList: inspectHTMLCollection,
	};

	// eslint-disable-next-line complexity
	const inspectCustom = (value, options, type) => {
	  if (chaiInspect in value && typeof value[chaiInspect] === 'function') {
	    return value[chaiInspect](options)
	  }

	  if (nodeInspect && nodeInspect in value && typeof value[nodeInspect] === 'function') {
	    return value[nodeInspect](options.depth, options)
	  }

	  if ('inspect' in value && typeof value.inspect === 'function') {
	    return value.inspect(options.depth, options)
	  }

	  if ('constructor' in value && constructorMap.has(value.constructor)) {
	    return constructorMap.get(value.constructor)(value, options)
	  }

	  if (stringTagMap[type]) {
	    return stringTagMap[type](value, options)
	  }

	  return ''
	};

	const toString = Object.prototype.toString;

	// eslint-disable-next-line complexity
	function inspect$3(value, options) {
	  options = normaliseOptions(options);
	  options.inspect = inspect$3;
	  const { customInspect } = options;
	  let type = value === null ? 'null' : typeof value;
	  if (type === 'object') {
	    type = toString.call(value).slice(8, -1);
	  }

	  // If it is a base value that we already support, then use Loupe's inspector
	  if (baseTypesMap[type]) {
	    return baseTypesMap[type](value, options)
	  }

	  // If `options.customInspect` is set to true then try to use the custom inspector
	  if (customInspect && value) {
	    const output = inspectCustom(value, options, type);
	    if (output) {
	      if (typeof output === 'string') return output
	      return inspect$3(output, options)
	    }
	  }

	  const proto = value ? Object.getPrototypeOf(value) : false;
	  // If it's a plain Object then use Loupe's inspector
	  if (proto === Object.prototype || proto === null) {
	    return inspectObject$1(value, options)
	  }

	  // Specifically account for HTMLElements
	  // eslint-disable-next-line no-undef
	  if (value && typeof HTMLElement === 'function' && value instanceof HTMLElement) {
	    return inspectHTML(value, options)
	  }

	  if ('constructor' in value) {
	    // If it is a class, inspect it like an object but add the constructor name
	    if (value.constructor !== Object) {
	      return inspectClass(value, options)
	    }

	    // If it is an object with an anonymous prototype, display it as an object.
	    return inspectObject$1(value, options)
	  }

	  // last chance to check if it's an object
	  if (value === Object(value)) {
	    return inspectObject$1(value, options)
	  }

	  // We have run out of options! Just stringify the value
	  return options.stylize(String(value), type)
	}

	function registerConstructor(constructor, inspector) {
	  if (constructorMap.has(constructor)) {
	    return false
	  }
	  constructorMap.set(constructor, inspector);
	  return true
	}

	function registerStringTag(stringTag, inspector) {
	  if (stringTag in stringTagMap) {
	    return false
	  }
	  stringTagMap[stringTag] = inspector;
	  return true
	}

	const custom = chaiInspect;

	var loupe$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		custom: custom,
		default: inspect$3,
		inspect: inspect$3,
		registerConstructor: registerConstructor,
		registerStringTag: registerStringTag
	});

	var require$$1 = /*@__PURE__*/getAugmentedNamespace(loupe$1);

	var config$5 = {

	  /**
	   * ### config.includeStack
	   *
	   * User configurable property, influences whether stack trace
	   * is included in Assertion error message. Default of false
	   * suppresses stack trace in the error message.
	   *
	   *     chai.config.includeStack = true;  // enable stack on error
	   *
	   * @param {Boolean}
	   * @api public
	   */

	  includeStack: false,

	  /**
	   * ### config.showDiff
	   *
	   * User configurable property, influences whether or not
	   * the `showDiff` flag should be included in the thrown
	   * AssertionErrors. `false` will always be `false`; `true`
	   * will be true when the assertion has requested a diff
	   * be shown.
	   *
	   * @param {Boolean}
	   * @api public
	   */

	  showDiff: true,

	  /**
	   * ### config.truncateThreshold
	   *
	   * User configurable property, sets length threshold for actual and
	   * expected values in assertion errors. If this threshold is exceeded, for
	   * example for large data structures, the value is replaced with something
	   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
	   *
	   * Set it to zero if you want to disable truncating altogether.
	   *
	   * This is especially userful when doing assertions on arrays: having this
	   * set to a reasonable large value makes the failure messages readily
	   * inspectable.
	   *
	   *     chai.config.truncateThreshold = 0;  // disable truncating
	   *
	   * @param {Number}
	   * @api public
	   */

	  truncateThreshold: 40,

	  /**
	   * ### config.useProxy
	   *
	   * User configurable property, defines if chai will use a Proxy to throw
	   * an error when a non-existent property is read, which protects users
	   * from typos when using property-based assertions.
	   *
	   * Set it to false if you want to disable this feature.
	   *
	   *     chai.config.useProxy = false;  // disable use of Proxy
	   *
	   * This feature is automatically disabled regardless of this config value
	   * in environments that don't support proxies.
	   *
	   * @param {Boolean}
	   * @api public
	   */

	  useProxy: true,

	  /**
	   * ### config.proxyExcludedKeys
	   *
	   * User configurable property, defines which properties should be ignored
	   * instead of throwing an error if they do not exist on the assertion.
	   * This is only applied if the environment Chai is running in supports proxies and
	   * if the `useProxy` configuration setting is enabled.
	   * By default, `then` and `inspect` will not throw an error if they do not exist on the
	   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
	   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
	   *
	   *     // By default these keys will not throw an error if they do not exist on the assertion object
	   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
	   *
	   * @param {Array}
	   * @api public
	   */

	  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']
	};

	var loupe = require$$1;
	var config$4 = config$5;

	var inspect_1 = inspect$2;

	/**
	 * ### .inspect(obj, [showHidden], [depth], [colors])
	 *
	 * Echoes the value of a value. Tries to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
	 *    properties of objects. Default is false.
	 * @param {Number} depth Depth in which to descend in object. Default is 2.
	 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
	 *    output. Default is false (no coloring).
	 * @namespace Utils
	 * @name inspect
	 */
	function inspect$2(obj, showHidden, depth, colors) {
	  var options = {
	    colors: colors,
	    depth: (typeof depth === 'undefined' ? 2 : depth),
	    showHidden: showHidden,
	    truncate: config$4.truncateThreshold ? config$4.truncateThreshold : Infinity,
	  };
	  return loupe.inspect(obj, options);
	}

	/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependencies
	 */

	var inspect$1 = inspect_1;
	var config$3 = config$5;

	/**
	 * ### .objDisplay(object)
	 *
	 * Determines if an object or an array matches
	 * criteria to be inspected in-line for error
	 * messages or should be truncated.
	 *
	 * @param {Mixed} javascript object to inspect
	 * @name objDisplay
	 * @namespace Utils
	 * @api public
	 */

	var objDisplay$1 = function objDisplay(obj) {
	  var str = inspect$1(obj)
	    , type = Object.prototype.toString.call(obj);

	  if (config$3.truncateThreshold && str.length >= config$3.truncateThreshold) {
	    if (type === '[object Function]') {
	      return !obj.name || obj.name === ''
	        ? '[Function]'
	        : '[Function: ' + obj.name + ']';
	    } else if (type === '[object Array]') {
	      return '[ Array(' + obj.length + ') ]';
	    } else if (type === '[object Object]') {
	      var keys = Object.keys(obj)
	        , kstr = keys.length > 2
	          ? keys.splice(0, 2).join(', ') + ', ...'
	          : keys.join(', ');
	      return '{ Object (' + kstr + ') }';
	    } else {
	      return str;
	    }
	  } else {
	    return str;
	  }
	};

	/*!
	 * Chai - message composition utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependencies
	 */

	var flag$2 = flag$5
	  , getActual = getActual$1
	  , objDisplay = objDisplay$1;

	/**
	 * ### .getMessage(object, message, negateMessage)
	 *
	 * Construct the error message based on flags
	 * and template tags. Template tags will return
	 * a stringified inspection of the object referenced.
	 *
	 * Message template tags:
	 * - `#{this}` current asserted object
	 * - `#{act}` actual value
	 * - `#{exp}` expected value
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 * @namespace Utils
	 * @name getMessage
	 * @api public
	 */

	var getMessage$1 = function getMessage(obj, args) {
	  var negate = flag$2(obj, 'negate')
	    , val = flag$2(obj, 'object')
	    , expected = args[3]
	    , actual = getActual(obj, args)
	    , msg = negate ? args[2] : args[1]
	    , flagMsg = flag$2(obj, 'message');

	  if(typeof msg === "function") msg = msg();
	  msg = msg || '';
	  msg = msg
	    .replace(/#\{this\}/g, function () { return objDisplay(val); })
	    .replace(/#\{act\}/g, function () { return objDisplay(actual); })
	    .replace(/#\{exp\}/g, function () { return objDisplay(expected); });

	  return flagMsg ? flagMsg + ': ' + msg : msg;
	};

	/*!
	 * Chai - transferFlags utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .transferFlags(assertion, object, includeAll = true)
	 *
	 * Transfer all the flags for `assertion` to `object`. If
	 * `includeAll` is set to `false`, then the base Chai
	 * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
	 * and `message`) will not be transferred.
	 *
	 *
	 *     var newAssertion = new Assertion();
	 *     utils.transferFlags(assertion, newAssertion);
	 *
	 *     var anotherAssertion = new Assertion(myObj);
	 *     utils.transferFlags(assertion, anotherAssertion, false);
	 *
	 * @param {Assertion} assertion the assertion to transfer the flags from
	 * @param {Object} object the object to transfer the flags to; usually a new assertion
	 * @param {Boolean} includeAll
	 * @namespace Utils
	 * @name transferFlags
	 * @api private
	 */

	var transferFlags = function transferFlags(assertion, object, includeAll) {
	  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

	  if (!object.__flags) {
	    object.__flags = Object.create(null);
	  }

	  includeAll = arguments.length === 3 ? includeAll : true;

	  for (var flag in flags) {
	    if (includeAll ||
	        (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {
	      object.__flags[flag] = flags[flag];
	    }
	  }
	};

	var deepEql = {exports: {}};

	/* globals Symbol: false, Uint8Array: false, WeakMap: false */
	/*!
	 * deep-eql
	 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var type$1 = typeDetectExports;
	function FakeMap() {
	  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
	}

	FakeMap.prototype = {
	  get: function get(key) {
	    return key[this._key];
	  },
	  set: function set(key, value) {
	    if (Object.isExtensible(key)) {
	      Object.defineProperty(key, this._key, {
	        value: value,
	        configurable: true,
	      });
	    }
	  },
	};

	var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
	/*!
	 * Check to see if the MemoizeMap has recorded a result of the two operands
	 *
	 * @param {Mixed} leftHandOperand
	 * @param {Mixed} rightHandOperand
	 * @param {MemoizeMap} memoizeMap
	 * @returns {Boolean|null} result
	*/
	function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
	  // Technically, WeakMap keys can *only* be objects, not primitives.
	  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
	    return null;
	  }
	  var leftHandMap = memoizeMap.get(leftHandOperand);
	  if (leftHandMap) {
	    var result = leftHandMap.get(rightHandOperand);
	    if (typeof result === 'boolean') {
	      return result;
	    }
	  }
	  return null;
	}

	/*!
	 * Set the result of the equality into the MemoizeMap
	 *
	 * @param {Mixed} leftHandOperand
	 * @param {Mixed} rightHandOperand
	 * @param {MemoizeMap} memoizeMap
	 * @param {Boolean} result
	*/
	function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
	  // Technically, WeakMap keys can *only* be objects, not primitives.
	  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
	    return;
	  }
	  var leftHandMap = memoizeMap.get(leftHandOperand);
	  if (leftHandMap) {
	    leftHandMap.set(rightHandOperand, result);
	  } else {
	    leftHandMap = new MemoizeMap();
	    leftHandMap.set(rightHandOperand, result);
	    memoizeMap.set(leftHandOperand, leftHandMap);
	  }
	}

	/*!
	 * Primary Export
	 */

	deepEql.exports = deepEqual;
	deepEql.exports.MemoizeMap = MemoizeMap;

	/**
	 * Assert deeply nested sameValue equality between two objects of any type.
	 *
	 * @param {Mixed} leftHandOperand
	 * @param {Mixed} rightHandOperand
	 * @param {Object} [options] (optional) Additional options
	 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
	 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
	    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
	    references to blow the stack.
	 * @return {Boolean} equal match
	 */
	function deepEqual(leftHandOperand, rightHandOperand, options) {
	  // If we have a comparator, we can't assume anything; so bail to its check first.
	  if (options && options.comparator) {
	    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
	  }

	  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
	  if (simpleResult !== null) {
	    return simpleResult;
	  }

	  // Deeper comparisons are pushed through to a larger function
	  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
	}

	/**
	 * Many comparisons can be canceled out early via simple equality or primitive checks.
	 * @param {Mixed} leftHandOperand
	 * @param {Mixed} rightHandOperand
	 * @return {Boolean|null} equal match
	 */
	function simpleEqual(leftHandOperand, rightHandOperand) {
	  // Equal references (except for Numbers) can be returned early
	  if (leftHandOperand === rightHandOperand) {
	    // Handle +-0 cases
	    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
	  }

	  // handle NaN cases
	  if (
	    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
	    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
	  ) {
	    return true;
	  }

	  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
	  // strings, and undefined, can be compared by reference.
	  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
	    // Easy out b/c it would have passed the first equality check
	    return false;
	  }
	  return null;
	}

	/*!
	 * The main logic of the `deepEqual` function.
	 *
	 * @param {Mixed} leftHandOperand
	 * @param {Mixed} rightHandOperand
	 * @param {Object} [options] (optional) Additional options
	 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
	 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
	    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
	    references to blow the stack.
	 * @return {Boolean} equal match
	*/
	function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
	  options = options || {};
	  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
	  var comparator = options && options.comparator;

	  // Check if a memoized result exists.
	  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
	  if (memoizeResultLeft !== null) {
	    return memoizeResultLeft;
	  }
	  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
	  if (memoizeResultRight !== null) {
	    return memoizeResultRight;
	  }

	  // If a comparator is present, use it.
	  if (comparator) {
	    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
	    // Comparators may return null, in which case we want to go back to default behavior.
	    if (comparatorResult === false || comparatorResult === true) {
	      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
	      return comparatorResult;
	    }
	    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
	    // what to do, we need to make sure to return the basic tests first before we move on.
	    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
	    if (simpleResult !== null) {
	      // Don't memoize this, it takes longer to set/retrieve than to just compare.
	      return simpleResult;
	    }
	  }

	  var leftHandType = type$1(leftHandOperand);
	  if (leftHandType !== type$1(rightHandOperand)) {
	    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
	    return false;
	  }

	  // Temporarily set the operands in the memoize object to prevent blowing the stack
	  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);

	  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
	  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
	  return result;
	}

	function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
	  switch (leftHandType) {
	    case 'String':
	    case 'Number':
	    case 'Boolean':
	    case 'Date':
	      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
	      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
	    case 'Promise':
	    case 'Symbol':
	    case 'function':
	    case 'WeakMap':
	    case 'WeakSet':
	      return leftHandOperand === rightHandOperand;
	    case 'Error':
	      return keysEqual(leftHandOperand, rightHandOperand, [ 'name', 'message', 'code' ], options);
	    case 'Arguments':
	    case 'Int8Array':
	    case 'Uint8Array':
	    case 'Uint8ClampedArray':
	    case 'Int16Array':
	    case 'Uint16Array':
	    case 'Int32Array':
	    case 'Uint32Array':
	    case 'Float32Array':
	    case 'Float64Array':
	    case 'Array':
	      return iterableEqual(leftHandOperand, rightHandOperand, options);
	    case 'RegExp':
	      return regexpEqual(leftHandOperand, rightHandOperand);
	    case 'Generator':
	      return generatorEqual(leftHandOperand, rightHandOperand, options);
	    case 'DataView':
	      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
	    case 'ArrayBuffer':
	      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
	    case 'Set':
	      return entriesEqual(leftHandOperand, rightHandOperand, options);
	    case 'Map':
	      return entriesEqual(leftHandOperand, rightHandOperand, options);
	    case 'Temporal.PlainDate':
	    case 'Temporal.PlainTime':
	    case 'Temporal.PlainDateTime':
	    case 'Temporal.Instant':
	    case 'Temporal.ZonedDateTime':
	    case 'Temporal.PlainYearMonth':
	    case 'Temporal.PlainMonthDay':
	      return leftHandOperand.equals(rightHandOperand);
	    case 'Temporal.Duration':
	      return leftHandOperand.total('nanoseconds') === rightHandOperand.total('nanoseconds');
	    case 'Temporal.TimeZone':
	    case 'Temporal.Calendar':
	      return leftHandOperand.toString() === rightHandOperand.toString();
	    default:
	      return objectEqual(leftHandOperand, rightHandOperand, options);
	  }
	}

	/*!
	 * Compare two Regular Expressions for equality.
	 *
	 * @param {RegExp} leftHandOperand
	 * @param {RegExp} rightHandOperand
	 * @return {Boolean} result
	 */

	function regexpEqual(leftHandOperand, rightHandOperand) {
	  return leftHandOperand.toString() === rightHandOperand.toString();
	}

	/*!
	 * Compare two Sets/Maps for equality. Faster than other equality functions.
	 *
	 * @param {Set} leftHandOperand
	 * @param {Set} rightHandOperand
	 * @param {Object} [options] (Optional)
	 * @return {Boolean} result
	 */

	function entriesEqual(leftHandOperand, rightHandOperand, options) {
	  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
	  if (leftHandOperand.size !== rightHandOperand.size) {
	    return false;
	  }
	  if (leftHandOperand.size === 0) {
	    return true;
	  }
	  var leftHandItems = [];
	  var rightHandItems = [];
	  leftHandOperand.forEach(function gatherEntries(key, value) {
	    leftHandItems.push([ key, value ]);
	  });
	  rightHandOperand.forEach(function gatherEntries(key, value) {
	    rightHandItems.push([ key, value ]);
	  });
	  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
	}

	/*!
	 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
	 *
	 * @param {Iterable} leftHandOperand
	 * @param {Iterable} rightHandOperand
	 * @param {Object} [options] (Optional)
	 * @return {Boolean} result
	 */

	function iterableEqual(leftHandOperand, rightHandOperand, options) {
	  var length = leftHandOperand.length;
	  if (length !== rightHandOperand.length) {
	    return false;
	  }
	  if (length === 0) {
	    return true;
	  }
	  var index = -1;
	  while (++index < length) {
	    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
	      return false;
	    }
	  }
	  return true;
	}

	/*!
	 * Simple equality for generator objects such as those returned by generator functions.
	 *
	 * @param {Iterable} leftHandOperand
	 * @param {Iterable} rightHandOperand
	 * @param {Object} [options] (Optional)
	 * @return {Boolean} result
	 */

	function generatorEqual(leftHandOperand, rightHandOperand, options) {
	  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
	}

	/*!
	 * Determine if the given object has an @@iterator function.
	 *
	 * @param {Object} target
	 * @return {Boolean} `true` if the object has an @@iterator function.
	 */
	function hasIteratorFunction(target) {
	  return typeof Symbol !== 'undefined' &&
	    typeof target === 'object' &&
	    typeof Symbol.iterator !== 'undefined' &&
	    typeof target[Symbol.iterator] === 'function';
	}

	/*!
	 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
	 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
	 *
	 * @param {Object} target
	 * @returns {Array} an array of entries from the @@iterator function
	 */
	function getIteratorEntries(target) {
	  if (hasIteratorFunction(target)) {
	    try {
	      return getGeneratorEntries(target[Symbol.iterator]());
	    } catch (iteratorError) {
	      return [];
	    }
	  }
	  return [];
	}

	/*!
	 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
	 *
	 * @param {Generator} target
	 * @returns {Array} an array of entries from the Generator.
	 */
	function getGeneratorEntries(generator) {
	  var generatorResult = generator.next();
	  var accumulator = [ generatorResult.value ];
	  while (generatorResult.done === false) {
	    generatorResult = generator.next();
	    accumulator.push(generatorResult.value);
	  }
	  return accumulator;
	}

	/*!
	 * Gets all own and inherited enumerable keys from a target.
	 *
	 * @param {Object} target
	 * @returns {Array} an array of own and inherited enumerable keys from the target.
	 */
	function getEnumerableKeys(target) {
	  var keys = [];
	  for (var key in target) {
	    keys.push(key);
	  }
	  return keys;
	}

	function getEnumerableSymbols(target) {
	  var keys = [];
	  var allKeys = Object.getOwnPropertySymbols(target);
	  for (var i = 0; i < allKeys.length; i += 1) {
	    var key = allKeys[i];
	    if (Object.getOwnPropertyDescriptor(target, key).enumerable) {
	      keys.push(key);
	    }
	  }
	  return keys;
	}

	/*!
	 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
	 * each key. If any value of the given key is not equal, the function will return false (early).
	 *
	 * @param {Mixed} leftHandOperand
	 * @param {Mixed} rightHandOperand
	 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
	 * @param {Object} [options] (Optional)
	 * @return {Boolean} result
	 */
	function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
	  var length = keys.length;
	  if (length === 0) {
	    return true;
	  }
	  for (var i = 0; i < length; i += 1) {
	    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
	      return false;
	    }
	  }
	  return true;
	}

	/*!
	 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
	 * for each enumerable key in the object.
	 *
	 * @param {Mixed} leftHandOperand
	 * @param {Mixed} rightHandOperand
	 * @param {Object} [options] (Optional)
	 * @return {Boolean} result
	 */
	function objectEqual(leftHandOperand, rightHandOperand, options) {
	  var leftHandKeys = getEnumerableKeys(leftHandOperand);
	  var rightHandKeys = getEnumerableKeys(rightHandOperand);
	  var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
	  var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
	  leftHandKeys = leftHandKeys.concat(leftHandSymbols);
	  rightHandKeys = rightHandKeys.concat(rightHandSymbols);

	  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
	    if (iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false) {
	      return false;
	    }
	    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
	  }

	  var leftHandEntries = getIteratorEntries(leftHandOperand);
	  var rightHandEntries = getIteratorEntries(rightHandOperand);
	  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
	    leftHandEntries.sort();
	    rightHandEntries.sort();
	    return iterableEqual(leftHandEntries, rightHandEntries, options);
	  }

	  if (leftHandKeys.length === 0 &&
	      leftHandEntries.length === 0 &&
	      rightHandKeys.length === 0 &&
	      rightHandEntries.length === 0) {
	    return true;
	  }

	  return false;
	}

	/*!
	 * Returns true if the argument is a primitive.
	 *
	 * This intentionally returns true for all objects that can be compared by reference,
	 * including functions and symbols.
	 *
	 * @param {Mixed} value
	 * @return {Boolean} result
	 */
	function isPrimitive(value) {
	  return value === null || typeof value !== 'object';
	}

	function mapSymbols(arr) {
	  return arr.map(function mapSymbol(entry) {
	    if (typeof entry === 'symbol') {
	      return entry.toString();
	    }

	    return entry;
	  });
	}

	var deepEqlExports = deepEql.exports;

	var config$2 = config$5;

	/*!
	 * Chai - isProxyEnabled helper
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .isProxyEnabled()
	 *
	 * Helper function to check if Chai's proxy protection feature is enabled. If
	 * proxies are unsupported or disabled via the user's Chai config, then return
	 * false. Otherwise, return true.
	 *
	 * @namespace Utils
	 * @name isProxyEnabled
	 */

	var isProxyEnabled$1 = function isProxyEnabled() {
	  return config$2.useProxy &&
	    typeof Proxy !== 'undefined' &&
	    typeof Reflect !== 'undefined';
	};

	/*!
	 * Chai - addProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var addProperty;
	var hasRequiredAddProperty;

	function requireAddProperty () {
		if (hasRequiredAddProperty) return addProperty;
		hasRequiredAddProperty = 1;
		var chai = requireChai();
		var flag = flag$5;
		var isProxyEnabled = isProxyEnabled$1;
		var transferFlags$1 = transferFlags;

		/**
		 * ### .addProperty(ctx, name, getter)
		 *
		 * Adds a property to the prototype of an object.
		 *
		 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
		 *       var obj = utils.flag(this, 'object');
		 *       new chai.Assertion(obj).to.be.instanceof(Foo);
		 *     });
		 *
		 * Can also be accessed directly from `chai.Assertion`.
		 *
		 *     chai.Assertion.addProperty('foo', fn);
		 *
		 * Then can be used as any other assertion.
		 *
		 *     expect(myFoo).to.be.foo;
		 *
		 * @param {Object} ctx object to which the property is added
		 * @param {String} name of property to add
		 * @param {Function} getter function to be used for name
		 * @namespace Utils
		 * @name addProperty
		 * @api public
		 */

		addProperty = function addProperty(ctx, name, getter) {
		  getter = getter === undefined ? function () {} : getter;

		  Object.defineProperty(ctx, name,
		    { get: function propertyGetter() {
		        // Setting the `ssfi` flag to `propertyGetter` causes this function to
		        // be the starting point for removing implementation frames from the
		        // stack trace of a failed assertion.
		        //
		        // However, we only want to use this function as the starting point if
		        // the `lockSsfi` flag isn't set and proxy protection is disabled.
		        //
		        // If the `lockSsfi` flag is set, then either this assertion has been
		        // overwritten by another assertion, or this assertion is being invoked
		        // from inside of another assertion. In the first case, the `ssfi` flag
		        // has already been set by the overwriting assertion. In the second
		        // case, the `ssfi` flag has already been set by the outer assertion.
		        //
		        // If proxy protection is enabled, then the `ssfi` flag has already been
		        // set by the proxy getter.
		        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
		          flag(this, 'ssfi', propertyGetter);
		        }

		        var result = getter.call(this);
		        if (result !== undefined)
		          return result;

		        var newAssertion = new chai.Assertion();
		        transferFlags$1(this, newAssertion);
		        return newAssertion;
		      }
		    , configurable: true
		  });
		};
		return addProperty;
	}

	var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');

	/*!
	 * Chai - addLengthGuard utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .addLengthGuard(fn, assertionName, isChainable)
	 *
	 * Define `length` as a getter on the given uninvoked method assertion. The
	 * getter acts as a guard against chaining `length` directly off of an uninvoked
	 * method assertion, which is a problem because it references `function`'s
	 * built-in `length` property instead of Chai's `length` assertion. When the
	 * getter catches the user making this mistake, it throws an error with a
	 * helpful message.
	 *
	 * There are two ways in which this mistake can be made. The first way is by
	 * chaining the `length` assertion directly off of an uninvoked chainable
	 * method. In this case, Chai suggests that the user use `lengthOf` instead. The
	 * second way is by chaining the `length` assertion directly off of an uninvoked
	 * non-chainable method. Non-chainable methods must be invoked prior to
	 * chaining. In this case, Chai suggests that the user consult the docs for the
	 * given assertion.
	 *
	 * If the `length` property of functions is unconfigurable, then return `fn`
	 * without modification.
	 *
	 * Note that in ES6, the function's `length` property is configurable, so once
	 * support for legacy environments is dropped, Chai's `length` property can
	 * replace the built-in function's `length` property, and this length guard will
	 * no longer be necessary. In the mean time, maintaining consistency across all
	 * environments is the priority.
	 *
	 * @param {Function} fn
	 * @param {String} assertionName
	 * @param {Boolean} isChainable
	 * @namespace Utils
	 * @name addLengthGuard
	 */

	var addLengthGuard = function addLengthGuard (fn, assertionName, isChainable) {
	  if (!fnLengthDesc.configurable) return fn;

	  Object.defineProperty(fn, 'length', {
	    get: function () {
	      if (isChainable) {
	        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' +
	          ' to a compatibility issue, "length" cannot directly follow "' +
	          assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
	      }

	      throw Error('Invalid Chai property: ' + assertionName + '.length. See' +
	        ' docs for proper usage of "' + assertionName + '".');
	    }
	  });

	  return fn;
	};

	/*!
	 * Chai - getProperties utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .getProperties(object)
	 *
	 * This allows the retrieval of property names of an object, enumerable or not,
	 * inherited or not.
	 *
	 * @param {Object} object
	 * @returns {Array}
	 * @namespace Utils
	 * @name getProperties
	 * @api public
	 */

	var getProperties$1 = function getProperties(object) {
	  var result = Object.getOwnPropertyNames(object);

	  function addProperty(property) {
	    if (result.indexOf(property) === -1) {
	      result.push(property);
	    }
	  }

	  var proto = Object.getPrototypeOf(object);
	  while (proto !== null) {
	    Object.getOwnPropertyNames(proto).forEach(addProperty);
	    proto = Object.getPrototypeOf(proto);
	  }

	  return result;
	};

	var config$1 = config$5;
	var flag$1 = flag$5;
	var getProperties = getProperties$1;
	var isProxyEnabled = isProxyEnabled$1;

	/*!
	 * Chai - proxify utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .proxify(object)
	 *
	 * Return a proxy of given object that throws an error when a non-existent
	 * property is read. By default, the root cause is assumed to be a misspelled
	 * property, and thus an attempt is made to offer a reasonable suggestion from
	 * the list of existing properties. However, if a nonChainableMethodName is
	 * provided, then the root cause is instead a failure to invoke a non-chainable
	 * method prior to reading the non-existent property.
	 *
	 * If proxies are unsupported or disabled via the user's Chai config, then
	 * return object without modification.
	 *
	 * @param {Object} obj
	 * @param {String} nonChainableMethodName
	 * @namespace Utils
	 * @name proxify
	 */

	var builtins = ['__flags', '__methods', '_obj', 'assert'];

	var proxify = function proxify(obj, nonChainableMethodName) {
	  if (!isProxyEnabled()) return obj;

	  return new Proxy(obj, {
	    get: function proxyGetter(target, property) {
	      // This check is here because we should not throw errors on Symbol properties
	      // such as `Symbol.toStringTag`.
	      // The values for which an error should be thrown can be configured using
	      // the `config.proxyExcludedKeys` setting.
	      if (typeof property === 'string' &&
	          config$1.proxyExcludedKeys.indexOf(property) === -1 &&
	          !Reflect.has(target, property)) {
	        // Special message for invalid property access of non-chainable methods.
	        if (nonChainableMethodName) {
	          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' +
	            property + '. See docs for proper usage of "' +
	            nonChainableMethodName + '".');
	        }

	        // If the property is reasonably close to an existing Chai property,
	        // suggest that property to the user. Only suggest properties with a
	        // distance less than 4.
	        var suggestion = null;
	        var suggestionDistance = 4;
	        getProperties(target).forEach(function(prop) {
	          if (
	            !Object.prototype.hasOwnProperty(prop) &&
	            builtins.indexOf(prop) === -1
	          ) {
	            var dist = stringDistanceCapped(
	              property,
	              prop,
	              suggestionDistance
	            );
	            if (dist < suggestionDistance) {
	              suggestion = prop;
	              suggestionDistance = dist;
	            }
	          }
	        });

	        if (suggestion !== null) {
	          throw Error('Invalid Chai property: ' + property +
	            '. Did you mean "' + suggestion + '"?');
	        } else {
	          throw Error('Invalid Chai property: ' + property);
	        }
	      }

	      // Use this proxy getter as the starting point for removing implementation
	      // frames from the stack trace of a failed assertion. For property
	      // assertions, this prevents the proxy getter from showing up in the stack
	      // trace since it's invoked before the property getter. For method and
	      // chainable method assertions, this flag will end up getting changed to
	      // the method wrapper, which is good since this frame will no longer be in
	      // the stack once the method is invoked. Note that Chai builtin assertion
	      // properties such as `__flags` are skipped since this is only meant to
	      // capture the starting point of an assertion. This step is also skipped
	      // if the `lockSsfi` flag is set, thus indicating that this assertion is
	      // being called from within another assertion. In that case, the `ssfi`
	      // flag is already set to the outer assertion's starting point.
	      if (builtins.indexOf(property) === -1 && !flag$1(target, 'lockSsfi')) {
	        flag$1(target, 'ssfi', proxyGetter);
	      }

	      return Reflect.get(target, property);
	    }
	  });
	};

	/**
	 * # stringDistanceCapped(strA, strB, cap)
	 * Return the Levenshtein distance between two strings, but no more than cap.
	 * @param {string} strA
	 * @param {string} strB
	 * @param {number} number
	 * @return {number} min(string distance between strA and strB, cap)
	 * @api private
	 */

	function stringDistanceCapped(strA, strB, cap) {
	  if (Math.abs(strA.length - strB.length) >= cap) {
	    return cap;
	  }

	  var memo = [];
	  // `memo` is a two-dimensional array containing distances.
	  // memo[i][j] is the distance between strA.slice(0, i) and
	  // strB.slice(0, j).
	  for (var i = 0; i <= strA.length; i++) {
	    memo[i] = Array(strB.length + 1).fill(0);
	    memo[i][0] = i;
	  }
	  for (var j = 0; j < strB.length; j++) {
	    memo[0][j] = j;
	  }

	  for (var i = 1; i <= strA.length; i++) {
	    var ch = strA.charCodeAt(i - 1);
	    for (var j = 1; j <= strB.length; j++) {
	      if (Math.abs(i - j) >= cap) {
	        memo[i][j] = cap;
	        continue;
	      }
	      memo[i][j] = Math.min(
	        memo[i - 1][j] + 1,
	        memo[i][j - 1] + 1,
	        memo[i - 1][j - 1] +
	          (ch === strB.charCodeAt(j - 1) ? 0 : 1)
	      );
	    }
	  }

	  return memo[strA.length][strB.length];
	}

	/*!
	 * Chai - addMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var addMethod;
	var hasRequiredAddMethod;

	function requireAddMethod () {
		if (hasRequiredAddMethod) return addMethod;
		hasRequiredAddMethod = 1;
		var addLengthGuard$1 = addLengthGuard;
		var chai = requireChai();
		var flag = flag$5;
		var proxify$1 = proxify;
		var transferFlags$1 = transferFlags;

		/**
		 * ### .addMethod(ctx, name, method)
		 *
		 * Adds a method to the prototype of an object.
		 *
		 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
		 *       var obj = utils.flag(this, 'object');
		 *       new chai.Assertion(obj).to.be.equal(str);
		 *     });
		 *
		 * Can also be accessed directly from `chai.Assertion`.
		 *
		 *     chai.Assertion.addMethod('foo', fn);
		 *
		 * Then can be used as any other assertion.
		 *
		 *     expect(fooStr).to.be.foo('bar');
		 *
		 * @param {Object} ctx object to which the method is added
		 * @param {String} name of method to add
		 * @param {Function} method function to be used for name
		 * @namespace Utils
		 * @name addMethod
		 * @api public
		 */

		addMethod = function addMethod(ctx, name, method) {
		  var methodWrapper = function () {
		    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
		    // starting point for removing implementation frames from the stack trace of
		    // a failed assertion.
		    //
		    // However, we only want to use this function as the starting point if the
		    // `lockSsfi` flag isn't set.
		    //
		    // If the `lockSsfi` flag is set, then either this assertion has been
		    // overwritten by another assertion, or this assertion is being invoked from
		    // inside of another assertion. In the first case, the `ssfi` flag has
		    // already been set by the overwriting assertion. In the second case, the
		    // `ssfi` flag has already been set by the outer assertion.
		    if (!flag(this, 'lockSsfi')) {
		      flag(this, 'ssfi', methodWrapper);
		    }

		    var result = method.apply(this, arguments);
		    if (result !== undefined)
		      return result;

		    var newAssertion = new chai.Assertion();
		    transferFlags$1(this, newAssertion);
		    return newAssertion;
		  };

		  addLengthGuard$1(methodWrapper, name, false);
		  ctx[name] = proxify$1(methodWrapper, name);
		};
		return addMethod;
	}

	/*!
	 * Chai - overwriteProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var overwriteProperty;
	var hasRequiredOverwriteProperty;

	function requireOverwriteProperty () {
		if (hasRequiredOverwriteProperty) return overwriteProperty;
		hasRequiredOverwriteProperty = 1;
		var chai = requireChai();
		var flag = flag$5;
		var isProxyEnabled = isProxyEnabled$1;
		var transferFlags$1 = transferFlags;

		/**
		 * ### .overwriteProperty(ctx, name, fn)
		 *
		 * Overwrites an already existing property getter and provides
		 * access to previous value. Must return function to use as getter.
		 *
		 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
		 *       return function () {
		 *         var obj = utils.flag(this, 'object');
		 *         if (obj instanceof Foo) {
		 *           new chai.Assertion(obj.name).to.equal('bar');
		 *         } else {
		 *           _super.call(this);
		 *         }
		 *       }
		 *     });
		 *
		 *
		 * Can also be accessed directly from `chai.Assertion`.
		 *
		 *     chai.Assertion.overwriteProperty('foo', fn);
		 *
		 * Then can be used as any other assertion.
		 *
		 *     expect(myFoo).to.be.ok;
		 *
		 * @param {Object} ctx object whose property is to be overwritten
		 * @param {String} name of property to overwrite
		 * @param {Function} getter function that returns a getter function to be used for name
		 * @namespace Utils
		 * @name overwriteProperty
		 * @api public
		 */

		overwriteProperty = function overwriteProperty(ctx, name, getter) {
		  var _get = Object.getOwnPropertyDescriptor(ctx, name)
		    , _super = function () {};

		  if (_get && 'function' === typeof _get.get)
		    _super = _get.get;

		  Object.defineProperty(ctx, name,
		    { get: function overwritingPropertyGetter() {
		        // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
		        // function to be the starting point for removing implementation frames
		        // from the stack trace of a failed assertion.
		        //
		        // However, we only want to use this function as the starting point if
		        // the `lockSsfi` flag isn't set and proxy protection is disabled.
		        //
		        // If the `lockSsfi` flag is set, then either this assertion has been
		        // overwritten by another assertion, or this assertion is being invoked
		        // from inside of another assertion. In the first case, the `ssfi` flag
		        // has already been set by the overwriting assertion. In the second
		        // case, the `ssfi` flag has already been set by the outer assertion.
		        //
		        // If proxy protection is enabled, then the `ssfi` flag has already been
		        // set by the proxy getter.
		        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
		          flag(this, 'ssfi', overwritingPropertyGetter);
		        }

		        // Setting the `lockSsfi` flag to `true` prevents the overwritten
		        // assertion from changing the `ssfi` flag. By this point, the `ssfi`
		        // flag is already set to the correct starting point for this assertion.
		        var origLockSsfi = flag(this, 'lockSsfi');
		        flag(this, 'lockSsfi', true);
		        var result = getter(_super).call(this);
		        flag(this, 'lockSsfi', origLockSsfi);

		        if (result !== undefined) {
		          return result;
		        }

		        var newAssertion = new chai.Assertion();
		        transferFlags$1(this, newAssertion);
		        return newAssertion;
		      }
		    , configurable: true
		  });
		};
		return overwriteProperty;
	}

	/*!
	 * Chai - overwriteMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var overwriteMethod;
	var hasRequiredOverwriteMethod;

	function requireOverwriteMethod () {
		if (hasRequiredOverwriteMethod) return overwriteMethod;
		hasRequiredOverwriteMethod = 1;
		var addLengthGuard$1 = addLengthGuard;
		var chai = requireChai();
		var flag = flag$5;
		var proxify$1 = proxify;
		var transferFlags$1 = transferFlags;

		/**
		 * ### .overwriteMethod(ctx, name, fn)
		 *
		 * Overwrites an already existing method and provides
		 * access to previous function. Must return function
		 * to be used for name.
		 *
		 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
		 *       return function (str) {
		 *         var obj = utils.flag(this, 'object');
		 *         if (obj instanceof Foo) {
		 *           new chai.Assertion(obj.value).to.equal(str);
		 *         } else {
		 *           _super.apply(this, arguments);
		 *         }
		 *       }
		 *     });
		 *
		 * Can also be accessed directly from `chai.Assertion`.
		 *
		 *     chai.Assertion.overwriteMethod('foo', fn);
		 *
		 * Then can be used as any other assertion.
		 *
		 *     expect(myFoo).to.equal('bar');
		 *
		 * @param {Object} ctx object whose method is to be overwritten
		 * @param {String} name of method to overwrite
		 * @param {Function} method function that returns a function to be used for name
		 * @namespace Utils
		 * @name overwriteMethod
		 * @api public
		 */

		overwriteMethod = function overwriteMethod(ctx, name, method) {
		  var _method = ctx[name]
		    , _super = function () {
		      throw new Error(name + ' is not a function');
		    };

		  if (_method && 'function' === typeof _method)
		    _super = _method;

		  var overwritingMethodWrapper = function () {
		    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
		    // function to be the starting point for removing implementation frames from
		    // the stack trace of a failed assertion.
		    //
		    // However, we only want to use this function as the starting point if the
		    // `lockSsfi` flag isn't set.
		    //
		    // If the `lockSsfi` flag is set, then either this assertion has been
		    // overwritten by another assertion, or this assertion is being invoked from
		    // inside of another assertion. In the first case, the `ssfi` flag has
		    // already been set by the overwriting assertion. In the second case, the
		    // `ssfi` flag has already been set by the outer assertion.
		    if (!flag(this, 'lockSsfi')) {
		      flag(this, 'ssfi', overwritingMethodWrapper);
		    }

		    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
		    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
		    // set to the correct starting point for this assertion.
		    var origLockSsfi = flag(this, 'lockSsfi');
		    flag(this, 'lockSsfi', true);
		    var result = method(_super).apply(this, arguments);
		    flag(this, 'lockSsfi', origLockSsfi);

		    if (result !== undefined) {
		      return result;
		    }

		    var newAssertion = new chai.Assertion();
		    transferFlags$1(this, newAssertion);
		    return newAssertion;
		  };

		  addLengthGuard$1(overwritingMethodWrapper, name, false);
		  ctx[name] = proxify$1(overwritingMethodWrapper, name);
		};
		return overwriteMethod;
	}

	/*!
	 * Chai - addChainingMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var addChainableMethod;
	var hasRequiredAddChainableMethod;

	function requireAddChainableMethod () {
		if (hasRequiredAddChainableMethod) return addChainableMethod;
		hasRequiredAddChainableMethod = 1;
		/*!
		 * Module dependencies
		 */

		var addLengthGuard$1 = addLengthGuard;
		var chai = requireChai();
		var flag = flag$5;
		var proxify$1 = proxify;
		var transferFlags$1 = transferFlags;

		/*!
		 * Module variables
		 */

		// Check whether `Object.setPrototypeOf` is supported
		var canSetPrototype = typeof Object.setPrototypeOf === 'function';

		// Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
		// However, some of functions' own props are not configurable and should be skipped.
		var testFn = function() {};
		var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
		  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);

		  // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
		  // but then returns `undefined` as the property descriptor for `callee`. As a
		  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
		  // and then filter it out if it's not an object as it should be.
		  if (typeof propDesc !== 'object')
		    return true;

		  return !propDesc.configurable;
		});

		// Cache `Function` properties
		var call  = Function.prototype.call,
		    apply = Function.prototype.apply;

		/**
		 * ### .addChainableMethod(ctx, name, method, chainingBehavior)
		 *
		 * Adds a method to an object, such that the method can also be chained.
		 *
		 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
		 *       var obj = utils.flag(this, 'object');
		 *       new chai.Assertion(obj).to.be.equal(str);
		 *     });
		 *
		 * Can also be accessed directly from `chai.Assertion`.
		 *
		 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
		 *
		 * The result can then be used as both a method assertion, executing both `method` and
		 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
		 *
		 *     expect(fooStr).to.be.foo('bar');
		 *     expect(fooStr).to.be.foo.equal('foo');
		 *
		 * @param {Object} ctx object to which the method is added
		 * @param {String} name of method to add
		 * @param {Function} method function to be used for `name`, when called
		 * @param {Function} chainingBehavior function to be called every time the property is accessed
		 * @namespace Utils
		 * @name addChainableMethod
		 * @api public
		 */

		addChainableMethod = function addChainableMethod(ctx, name, method, chainingBehavior) {
		  if (typeof chainingBehavior !== 'function') {
		    chainingBehavior = function () { };
		  }

		  var chainableBehavior = {
		      method: method
		    , chainingBehavior: chainingBehavior
		  };

		  // save the methods so we can overwrite them later, if we need to.
		  if (!ctx.__methods) {
		    ctx.__methods = {};
		  }
		  ctx.__methods[name] = chainableBehavior;

		  Object.defineProperty(ctx, name,
		    { get: function chainableMethodGetter() {
		        chainableBehavior.chainingBehavior.call(this);

		        var chainableMethodWrapper = function () {
		          // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
		          // function to be the starting point for removing implementation
		          // frames from the stack trace of a failed assertion.
		          //
		          // However, we only want to use this function as the starting point if
		          // the `lockSsfi` flag isn't set.
		          //
		          // If the `lockSsfi` flag is set, then this assertion is being
		          // invoked from inside of another assertion. In this case, the `ssfi`
		          // flag has already been set by the outer assertion.
		          //
		          // Note that overwriting a chainable method merely replaces the saved
		          // methods in `ctx.__methods` instead of completely replacing the
		          // overwritten assertion. Therefore, an overwriting assertion won't
		          // set the `ssfi` or `lockSsfi` flags.
		          if (!flag(this, 'lockSsfi')) {
		            flag(this, 'ssfi', chainableMethodWrapper);
		          }

		          var result = chainableBehavior.method.apply(this, arguments);
		          if (result !== undefined) {
		            return result;
		          }

		          var newAssertion = new chai.Assertion();
		          transferFlags$1(this, newAssertion);
		          return newAssertion;
		        };

		        addLengthGuard$1(chainableMethodWrapper, name, true);

		        // Use `Object.setPrototypeOf` if available
		        if (canSetPrototype) {
		          // Inherit all properties from the object by replacing the `Function` prototype
		          var prototype = Object.create(this);
		          // Restore the `call` and `apply` methods from `Function`
		          prototype.call = call;
		          prototype.apply = apply;
		          Object.setPrototypeOf(chainableMethodWrapper, prototype);
		        }
		        // Otherwise, redefine all properties (slow!)
		        else {
		          var asserterNames = Object.getOwnPropertyNames(ctx);
		          asserterNames.forEach(function (asserterName) {
		            if (excludeNames.indexOf(asserterName) !== -1) {
		              return;
		            }

		            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
		            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
		          });
		        }

		        transferFlags$1(this, chainableMethodWrapper);
		        return proxify$1(chainableMethodWrapper);
		      }
		    , configurable: true
		  });
		};
		return addChainableMethod;
	}

	/*!
	 * Chai - overwriteChainableMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var overwriteChainableMethod;
	var hasRequiredOverwriteChainableMethod;

	function requireOverwriteChainableMethod () {
		if (hasRequiredOverwriteChainableMethod) return overwriteChainableMethod;
		hasRequiredOverwriteChainableMethod = 1;
		var chai = requireChai();
		var transferFlags$1 = transferFlags;

		/**
		 * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
		 *
		 * Overwrites an already existing chainable method
		 * and provides access to the previous function or
		 * property.  Must return functions to be used for
		 * name.
		 *
		 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
		 *       function (_super) {
		 *       }
		 *     , function (_super) {
		 *       }
		 *     );
		 *
		 * Can also be accessed directly from `chai.Assertion`.
		 *
		 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
		 *
		 * Then can be used as any other assertion.
		 *
		 *     expect(myFoo).to.have.lengthOf(3);
		 *     expect(myFoo).to.have.lengthOf.above(3);
		 *
		 * @param {Object} ctx object whose method / property is to be overwritten
		 * @param {String} name of method / property to overwrite
		 * @param {Function} method function that returns a function to be used for name
		 * @param {Function} chainingBehavior function that returns a function to be used for property
		 * @namespace Utils
		 * @name overwriteChainableMethod
		 * @api public
		 */

		overwriteChainableMethod = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
		  var chainableBehavior = ctx.__methods[name];

		  var _chainingBehavior = chainableBehavior.chainingBehavior;
		  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
		    var result = chainingBehavior(_chainingBehavior).call(this);
		    if (result !== undefined) {
		      return result;
		    }

		    var newAssertion = new chai.Assertion();
		    transferFlags$1(this, newAssertion);
		    return newAssertion;
		  };

		  var _method = chainableBehavior.method;
		  chainableBehavior.method = function overwritingChainableMethodWrapper() {
		    var result = method(_method).apply(this, arguments);
		    if (result !== undefined) {
		      return result;
		    }

		    var newAssertion = new chai.Assertion();
		    transferFlags$1(this, newAssertion);
		    return newAssertion;
		  };
		};
		return overwriteChainableMethod;
	}

	/*!
	 * Chai - compareByInspect utility
	 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependencies
	 */

	var inspect = inspect_1;

	/**
	 * ### .compareByInspect(mixed, mixed)
	 *
	 * To be used as a compareFunction with Array.prototype.sort. Compares elements
	 * using inspect instead of default behavior of using toString so that Symbols
	 * and objects with irregular/missing toString can still be sorted without a
	 * TypeError.
	 *
	 * @param {Mixed} first element to compare
	 * @param {Mixed} second element to compare
	 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1
	 * @name compareByInspect
	 * @namespace Utils
	 * @api public
	 */

	var compareByInspect = function compareByInspect(a, b) {
	  return inspect(a) < inspect(b) ? -1 : 1;
	};

	/*!
	 * Chai - getOwnEnumerablePropertySymbols utility
	 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .getOwnEnumerablePropertySymbols(object)
	 *
	 * This allows the retrieval of directly-owned enumerable property symbols of an
	 * object. This function is necessary because Object.getOwnPropertySymbols
	 * returns both enumerable and non-enumerable property symbols.
	 *
	 * @param {Object} object
	 * @returns {Array}
	 * @namespace Utils
	 * @name getOwnEnumerablePropertySymbols
	 * @api public
	 */

	var getOwnEnumerablePropertySymbols$1 = function getOwnEnumerablePropertySymbols(obj) {
	  if (typeof Object.getOwnPropertySymbols !== 'function') return [];

	  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
	    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
	  });
	};

	/*!
	 * Chai - getOwnEnumerableProperties utility
	 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependencies
	 */

	var getOwnEnumerablePropertySymbols = getOwnEnumerablePropertySymbols$1;

	/**
	 * ### .getOwnEnumerableProperties(object)
	 *
	 * This allows the retrieval of directly-owned enumerable property names and
	 * symbols of an object. This function is necessary because Object.keys only
	 * returns enumerable property names, not enumerable property symbols.
	 *
	 * @param {Object} object
	 * @returns {Array}
	 * @namespace Utils
	 * @name getOwnEnumerableProperties
	 * @api public
	 */

	var getOwnEnumerableProperties = function getOwnEnumerableProperties(obj) {
	  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
	};

	/* !
	 * Chai - checkError utility
	 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .checkError
	 *
	 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
	 *
	 * @api public
	 */

	/**
	 * ### .compatibleInstance(thrown, errorLike)
	 *
	 * Checks if two instances are compatible (strict equal).
	 * Returns false if errorLike is not an instance of Error, because instances
	 * can only be compatible if they're both error instances.
	 *
	 * @name compatibleInstance
	 * @param {Error} thrown error
	 * @param {Error|ErrorConstructor} errorLike object to compare against
	 * @namespace Utils
	 * @api public
	 */

	function compatibleInstance(thrown, errorLike) {
	  return errorLike instanceof Error && thrown === errorLike;
	}

	/**
	 * ### .compatibleConstructor(thrown, errorLike)
	 *
	 * Checks if two constructors are compatible.
	 * This function can receive either an error constructor or
	 * an error instance as the `errorLike` argument.
	 * Constructors are compatible if they're the same or if one is
	 * an instance of another.
	 *
	 * @name compatibleConstructor
	 * @param {Error} thrown error
	 * @param {Error|ErrorConstructor} errorLike object to compare against
	 * @namespace Utils
	 * @api public
	 */

	function compatibleConstructor(thrown, errorLike) {
	  if (errorLike instanceof Error) {
	    // If `errorLike` is an instance of any error we compare their constructors
	    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
	  } else if (errorLike.prototype instanceof Error || errorLike === Error) {
	    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
	    return thrown.constructor === errorLike || thrown instanceof errorLike;
	  }

	  return false;
	}

	/**
	 * ### .compatibleMessage(thrown, errMatcher)
	 *
	 * Checks if an error's message is compatible with a matcher (String or RegExp).
	 * If the message contains the String or passes the RegExp test,
	 * it is considered compatible.
	 *
	 * @name compatibleMessage
	 * @param {Error} thrown error
	 * @param {String|RegExp} errMatcher to look for into the message
	 * @namespace Utils
	 * @api public
	 */

	function compatibleMessage(thrown, errMatcher) {
	  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;
	  if (errMatcher instanceof RegExp) {
	    return errMatcher.test(comparisonString);
	  } else if (typeof errMatcher === 'string') {
	    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
	  }

	  return false;
	}

	/**
	 * ### .getFunctionName(constructorFn)
	 *
	 * Returns the name of a function.
	 * This also includes a polyfill function if `constructorFn.name` is not defined.
	 *
	 * @name getFunctionName
	 * @param {Function} constructorFn
	 * @namespace Utils
	 * @api private
	 */

	var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;
	function getFunctionName(constructorFn) {
	  var name = '';
	  if (typeof constructorFn.name === 'undefined') {
	    // Here we run a polyfill if constructorFn.name is not defined
	    var match = String(constructorFn).match(functionNameMatch);
	    if (match) {
	      name = match[1];
	    }
	  } else {
	    name = constructorFn.name;
	  }

	  return name;
	}

	/**
	 * ### .getConstructorName(errorLike)
	 *
	 * Gets the constructor name for an Error instance or constructor itself.
	 *
	 * @name getConstructorName
	 * @param {Error|ErrorConstructor} errorLike
	 * @namespace Utils
	 * @api public
	 */

	function getConstructorName(errorLike) {
	  var constructorName = errorLike;
	  if (errorLike instanceof Error) {
	    constructorName = getFunctionName(errorLike.constructor);
	  } else if (typeof errorLike === 'function') {
	    // If `err` is not an instance of Error it is an error constructor itself or another function.
	    // If we've got a common function we get its name, otherwise we may need to create a new instance
	    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
	    constructorName = getFunctionName(errorLike).trim() ||
	        getFunctionName(new errorLike()); // eslint-disable-line new-cap
	  }

	  return constructorName;
	}

	/**
	 * ### .getMessage(errorLike)
	 *
	 * Gets the error message from an error.
	 * If `err` is a String itself, we return it.
	 * If the error has no message, we return an empty string.
	 *
	 * @name getMessage
	 * @param {Error|String} errorLike
	 * @namespace Utils
	 * @api public
	 */

	function getMessage(errorLike) {
	  var msg = '';
	  if (errorLike && errorLike.message) {
	    msg = errorLike.message;
	  } else if (typeof errorLike === 'string') {
	    msg = errorLike;
	  }

	  return msg;
	}

	var checkError = {
	  compatibleInstance: compatibleInstance,
	  compatibleConstructor: compatibleConstructor,
	  compatibleMessage: compatibleMessage,
	  getMessage: getMessage,
	  getConstructorName: getConstructorName,
	};

	/*!
	 * Chai - isNaN utility
	 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
	 * MIT Licensed
	 */

	/**
	 * ### .isNaN(value)
	 *
	 * Checks if the given value is NaN or not.
	 *
	 *     utils.isNaN(NaN); // true
	 *
	 * @param {Value} The value which has to be checked if it is NaN
	 * @name isNaN
	 * @api private
	 */

	function isNaN$1(value) {
	  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
	  // section's NOTE.
	  return value !== value;
	}

	// If ECMAScript 6's Number.isNaN is present, prefer that.
	var _isNaN = Number.isNaN || isNaN$1;

	var type = typeDetectExports;

	var flag = flag$5;

	function isObjectType(obj) {
	  var objectType = type(obj);
	  var objectTypes = ['Array', 'Object', 'function'];

	  return objectTypes.indexOf(objectType) !== -1;
	}

	/**
	 * ### .getOperator(message)
	 *
	 * Extract the operator from error message.
	 * Operator defined is based on below link
	 * https://nodejs.org/api/assert.html#assert_assert.
	 *
	 * Returns the `operator` or `undefined` value for an Assertion.
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 * @namespace Utils
	 * @name getOperator
	 * @api public
	 */

	var getOperator = function getOperator(obj, args) {
	  var operator = flag(obj, 'operator');
	  var negate = flag(obj, 'negate');
	  var expected = args[3];
	  var msg = negate ? args[2] : args[1];

	  if (operator) {
	    return operator;
	  }

	  if (typeof msg === 'function') msg = msg();

	  msg = msg || '';
	  if (!msg) {
	    return undefined;
	  }

	  if (/\shave\s/.test(msg)) {
	    return undefined;
	  }

	  var isObject = isObjectType(expected);
	  if (/\snot\s/.test(msg)) {
	    return isObject ? 'notDeepStrictEqual' : 'notStrictEqual';
	  }

	  return isObject ? 'deepStrictEqual' : 'strictEqual';
	};

	/*!
	 * chai
	 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var hasRequiredUtils;

	function requireUtils () {
		if (hasRequiredUtils) return utils;
		hasRequiredUtils = 1;
		/*!
		 * Dependencies that are used for multiple exports are required here only once
		 */

		var pathval$1 = pathval;

		/*!
		 * test utility
		 */

		utils.test = test;

		/*!
		 * type utility
		 */

		utils.type = typeDetectExports;

		/*!
		 * expectTypes utility
		 */
		utils.expectTypes = expectTypes;

		/*!
		 * message utility
		 */

		utils.getMessage = getMessage$1;

		/*!
		 * actual utility
		 */

		utils.getActual = getActual$1;

		/*!
		 * Inspect util
		 */

		utils.inspect = inspect_1;

		/*!
		 * Object Display util
		 */

		utils.objDisplay = objDisplay$1;

		/*!
		 * Flag utility
		 */

		utils.flag = flag$5;

		/*!
		 * Flag transferring utility
		 */

		utils.transferFlags = transferFlags;

		/*!
		 * Deep equal utility
		 */

		utils.eql = deepEqlExports;

		/*!
		 * Deep path info
		 */

		utils.getPathInfo = pathval$1.getPathInfo;

		/*!
		 * Check if a property exists
		 */

		utils.hasProperty = pathval$1.hasProperty;

		/*!
		 * Function name
		 */

		utils.getName = getFuncName_1;

		/*!
		 * add Property
		 */

		utils.addProperty = requireAddProperty();

		/*!
		 * add Method
		 */

		utils.addMethod = requireAddMethod();

		/*!
		 * overwrite Property
		 */

		utils.overwriteProperty = requireOverwriteProperty();

		/*!
		 * overwrite Method
		 */

		utils.overwriteMethod = requireOverwriteMethod();

		/*!
		 * Add a chainable method
		 */

		utils.addChainableMethod = requireAddChainableMethod();

		/*!
		 * Overwrite chainable method
		 */

		utils.overwriteChainableMethod = requireOverwriteChainableMethod();

		/*!
		 * Compare by inspect method
		 */

		utils.compareByInspect = compareByInspect;

		/*!
		 * Get own enumerable property symbols method
		 */

		utils.getOwnEnumerablePropertySymbols = getOwnEnumerablePropertySymbols$1;

		/*!
		 * Get own enumerable properties method
		 */

		utils.getOwnEnumerableProperties = getOwnEnumerableProperties;

		/*!
		 * Checks error against a given set of criteria
		 */

		utils.checkError = checkError;

		/*!
		 * Proxify util
		 */

		utils.proxify = proxify;

		/*!
		 * addLengthGuard util
		 */

		utils.addLengthGuard = addLengthGuard;

		/*!
		 * isProxyEnabled helper
		 */

		utils.isProxyEnabled = isProxyEnabled$1;

		/*!
		 * isNaN method
		 */

		utils.isNaN = _isNaN;

		/*!
		 * getOperator method
		 */

		utils.getOperator = getOperator;
		return utils;
	}

	/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var config = config$5;

	var assertion = function (_chai, util) {
	  /*!
	   * Module dependencies.
	   */

	  var AssertionError = _chai.AssertionError
	    , flag = util.flag;

	  /*!
	   * Module export.
	   */

	  _chai.Assertion = Assertion;

	  /*!
	   * Assertion Constructor
	   *
	   * Creates object for chaining.
	   *
	   * `Assertion` objects contain metadata in the form of flags. Three flags can
	   * be assigned during instantiation by passing arguments to this constructor:
	   *
	   * - `object`: This flag contains the target of the assertion. For example, in
	   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
	   *   contain `numKittens` so that the `equal` assertion can reference it when
	   *   needed.
	   *
	   * - `message`: This flag contains an optional custom error message to be
	   *   prepended to the error message that's generated by the assertion when it
	   *   fails.
	   *
	   * - `ssfi`: This flag stands for "start stack function indicator". It
	   *   contains a function reference that serves as the starting point for
	   *   removing frames from the stack trace of the error that's created by the
	   *   assertion when it fails. The goal is to provide a cleaner stack trace to
	   *   end users by removing Chai's internal functions. Note that it only works
	   *   in environments that support `Error.captureStackTrace`, and only when
	   *   `Chai.config.includeStack` hasn't been set to `false`.
	   *
	   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
	   *   should retain its current value, even as assertions are chained off of
	   *   this object. This is usually set to `true` when creating a new assertion
	   *   from within another assertion. It's also temporarily set to `true` before
	   *   an overwritten assertion gets called by the overwriting assertion.
	   *
	   * @param {Mixed} obj target of the assertion
	   * @param {String} msg (optional) custom error message
	   * @param {Function} ssfi (optional) starting point for removing stack frames
	   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
	   * @api private
	   */

	  function Assertion (obj, msg, ssfi, lockSsfi) {
	    flag(this, 'ssfi', ssfi || Assertion);
	    flag(this, 'lockSsfi', lockSsfi);
	    flag(this, 'object', obj);
	    flag(this, 'message', msg);

	    return util.proxify(this);
	  }

	  Object.defineProperty(Assertion, 'includeStack', {
	    get: function() {
	      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
	      return config.includeStack;
	    },
	    set: function(value) {
	      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
	      config.includeStack = value;
	    }
	  });

	  Object.defineProperty(Assertion, 'showDiff', {
	    get: function() {
	      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
	      return config.showDiff;
	    },
	    set: function(value) {
	      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
	      config.showDiff = value;
	    }
	  });

	  Assertion.addProperty = function (name, fn) {
	    util.addProperty(this.prototype, name, fn);
	  };

	  Assertion.addMethod = function (name, fn) {
	    util.addMethod(this.prototype, name, fn);
	  };

	  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
	    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
	  };

	  Assertion.overwriteProperty = function (name, fn) {
	    util.overwriteProperty(this.prototype, name, fn);
	  };

	  Assertion.overwriteMethod = function (name, fn) {
	    util.overwriteMethod(this.prototype, name, fn);
	  };

	  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
	    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
	  };

	  /**
	   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
	   *
	   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
	   *
	   * @name assert
	   * @param {Philosophical} expression to be tested
	   * @param {String|Function} message or function that returns message to display if expression fails
	   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
	   * @param {Mixed} expected value (remember to check for negation)
	   * @param {Mixed} actual (optional) will default to `this.obj`
	   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
	   * @api private
	   */

	  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
	    var ok = util.test(this, arguments);
	    if (false !== showDiff) showDiff = true;
	    if (undefined === expected && undefined === _actual) showDiff = false;
	    if (true !== config.showDiff) showDiff = false;

	    if (!ok) {
	      msg = util.getMessage(this, arguments);
	      var actual = util.getActual(this, arguments);
	      var assertionErrorObjectProperties = {
	          actual: actual
	        , expected: expected
	        , showDiff: showDiff
	      };

	      var operator = util.getOperator(this, arguments);
	      if (operator) {
	        assertionErrorObjectProperties.operator = operator;
	      }

	      throw new AssertionError(
	        msg,
	        assertionErrorObjectProperties,
	        (config.includeStack) ? this.assert : flag(this, 'ssfi'));
	    }
	  };

	  /*!
	   * ### ._obj
	   *
	   * Quick reference to stored `actual` value for plugin developers.
	   *
	   * @api private
	   */

	  Object.defineProperty(Assertion.prototype, '_obj',
	    { get: function () {
	        return flag(this, 'object');
	      }
	    , set: function (val) {
	        flag(this, 'object', val);
	      }
	  });
	};

	/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var assertions = function (chai, _) {
	  var Assertion = chai.Assertion
	    , AssertionError = chai.AssertionError
	    , flag = _.flag;

	  /**
	   * ### Language Chains
	   *
	   * The following are provided as chainable getters to improve the readability
	   * of your assertions.
	   *
	   * **Chains**
	   *
	   * - to
	   * - be
	   * - been
	   * - is
	   * - that
	   * - which
	   * - and
	   * - has
	   * - have
	   * - with
	   * - at
	   * - of
	   * - same
	   * - but
	   * - does
	   * - still
	   * - also
	   *
	   * @name language chains
	   * @namespace BDD
	   * @api public
	   */

	  [ 'to', 'be', 'been', 'is'
	  , 'and', 'has', 'have', 'with'
	  , 'that', 'which', 'at', 'of'
	  , 'same', 'but', 'does', 'still', "also" ].forEach(function (chain) {
	    Assertion.addProperty(chain);
	  });

	  /**
	   * ### .not
	   *
	   * Negates all assertions that follow in the chain.
	   *
	   *     expect(function () {}).to.not.throw();
	   *     expect({a: 1}).to.not.have.property('b');
	   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
	   *
	   * Just because you can negate any assertion with `.not` doesn't mean you
	   * should. With great power comes great responsibility. It's often best to
	   * assert that the one expected output was produced, rather than asserting
	   * that one of countless unexpected outputs wasn't produced. See individual
	   * assertions for specific guidance.
	   *
	   *     expect(2).to.equal(2); // Recommended
	   *     expect(2).to.not.equal(1); // Not recommended
	   *
	   * @name not
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('not', function () {
	    flag(this, 'negate', true);
	  });

	  /**
	   * ### .deep
	   *
	   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
	   * assertions that follow in the chain to use deep equality instead of strict
	   * (`===`) equality. See the `deep-eql` project page for info on the deep
	   * equality algorithm: https://github.com/chaijs/deep-eql.
	   *
	   *     // Target object deeply (but not strictly) equals `{a: 1}`
	   *     expect({a: 1}).to.deep.equal({a: 1});
	   *     expect({a: 1}).to.not.equal({a: 1});
	   *
	   *     // Target array deeply (but not strictly) includes `{a: 1}`
	   *     expect([{a: 1}]).to.deep.include({a: 1});
	   *     expect([{a: 1}]).to.not.include({a: 1});
	   *
	   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
	   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
	   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
	   *
	   *     // Target array deeply (but not strictly) has member `{a: 1}`
	   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
	   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
	   *
	   *     // Target set deeply (but not strictly) has key `{a: 1}`
	   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
	   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
	   *
	   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
	   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
	   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
	   *
	   * @name deep
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('deep', function () {
	    flag(this, 'deep', true);
	  });

	  /**
	   * ### .nested
	   *
	   * Enables dot- and bracket-notation in all `.property` and `.include`
	   * assertions that follow in the chain.
	   *
	   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
	   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
	   *
	   * If `.` or `[]` are part of an actual property name, they can be escaped by
	   * adding two backslashes before them.
	   *
	   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
	   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
	   *
	   * `.nested` cannot be combined with `.own`.
	   *
	   * @name nested
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('nested', function () {
	    flag(this, 'nested', true);
	  });

	  /**
	   * ### .own
	   *
	   * Causes all `.property` and `.include` assertions that follow in the chain
	   * to ignore inherited properties.
	   *
	   *     Object.prototype.b = 2;
	   *
	   *     expect({a: 1}).to.have.own.property('a');
	   *     expect({a: 1}).to.have.property('b');
	   *     expect({a: 1}).to.not.have.own.property('b');
	   *
	   *     expect({a: 1}).to.own.include({a: 1});
	   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
	   *
	   * `.own` cannot be combined with `.nested`.
	   *
	   * @name own
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('own', function () {
	    flag(this, 'own', true);
	  });

	  /**
	   * ### .ordered
	   *
	   * Causes all `.members` assertions that follow in the chain to require that
	   * members be in the same order.
	   *
	   *     expect([1, 2]).to.have.ordered.members([1, 2])
	   *       .but.not.have.ordered.members([2, 1]);
	   *
	   * When `.include` and `.ordered` are combined, the ordering begins at the
	   * start of both arrays.
	   *
	   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
	   *       .but.not.include.ordered.members([2, 3]);
	   *
	   * @name ordered
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('ordered', function () {
	    flag(this, 'ordered', true);
	  });

	  /**
	   * ### .any
	   *
	   * Causes all `.keys` assertions that follow in the chain to only require that
	   * the target have at least one of the given keys. This is the opposite of
	   * `.all`, which requires that the target have all of the given keys.
	   *
	   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
	   *
	   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
	   *
	   * @name any
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('any', function () {
	    flag(this, 'any', true);
	    flag(this, 'all', false);
	  });

	  /**
	   * ### .all
	   *
	   * Causes all `.keys` assertions that follow in the chain to require that the
	   * target have all of the given keys. This is the opposite of `.any`, which
	   * only requires that the target have at least one of the given keys.
	   *
	   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
	   *
	   * Note that `.all` is used by default when neither `.all` nor `.any` are
	   * added earlier in the chain. However, it's often best to add `.all` anyway
	   * because it improves readability.
	   *
	   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
	   *
	   * @name all
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('all', function () {
	    flag(this, 'all', true);
	    flag(this, 'any', false);
	  });

	  /**
	   * ### .a(type[, msg])
	   *
	   * Asserts that the target's type is equal to the given string `type`. Types
	   * are case insensitive. See the `type-detect` project page for info on the
	   * type detection algorithm: https://github.com/chaijs/type-detect.
	   *
	   *     expect('foo').to.be.a('string');
	   *     expect({a: 1}).to.be.an('object');
	   *     expect(null).to.be.a('null');
	   *     expect(undefined).to.be.an('undefined');
	   *     expect(new Error).to.be.an('error');
	   *     expect(Promise.resolve()).to.be.a('promise');
	   *     expect(new Float32Array).to.be.a('float32array');
	   *     expect(Symbol()).to.be.a('symbol');
	   *
	   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
	   *
	   *     var myObj = {
	   *       [Symbol.toStringTag]: 'myCustomType'
	   *     };
	   *
	   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
	   *
	   * It's often best to use `.a` to check a target's type before making more
	   * assertions on the same target. That way, you avoid unexpected behavior from
	   * any assertion that does different things based on the target's type.
	   *
	   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
	   *     expect([]).to.be.an('array').that.is.empty;
	   *
	   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
	   * assert that the target is the expected type, rather than asserting that it
	   * isn't one of many unexpected types.
	   *
	   *     expect('foo').to.be.a('string'); // Recommended
	   *     expect('foo').to.not.be.an('array'); // Not recommended
	   *
	   * `.a` accepts an optional `msg` argument which is a custom error message to
	   * show when the assertion fails. The message can also be given as the second
	   * argument to `expect`.
	   *
	   *     expect(1).to.be.a('string', 'nooo why fail??');
	   *     expect(1, 'nooo why fail??').to.be.a('string');
	   *
	   * `.a` can also be used as a language chain to improve the readability of
	   * your assertions.
	   *
	   *     expect({b: 2}).to.have.a.property('b');
	   *
	   * The alias `.an` can be used interchangeably with `.a`.
	   *
	   * @name a
	   * @alias an
	   * @param {String} type
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function an (type, msg) {
	    if (msg) flag(this, 'message', msg);
	    type = type.toLowerCase();
	    var obj = flag(this, 'object')
	      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

	    this.assert(
	        type === _.type(obj).toLowerCase()
	      , 'expected #{this} to be ' + article + type
	      , 'expected #{this} not to be ' + article + type
	    );
	  }

	  Assertion.addChainableMethod('an', an);
	  Assertion.addChainableMethod('a', an);

	  /**
	   * ### .include(val[, msg])
	   *
	   * When the target is a string, `.include` asserts that the given string `val`
	   * is a substring of the target.
	   *
	   *     expect('foobar').to.include('foo');
	   *
	   * When the target is an array, `.include` asserts that the given `val` is a
	   * member of the target.
	   *
	   *     expect([1, 2, 3]).to.include(2);
	   *
	   * When the target is an object, `.include` asserts that the given object
	   * `val`'s properties are a subset of the target's properties.
	   *
	   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
	   *
	   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
	   * member of the target. SameValueZero equality algorithm is used.
	   *
	   *     expect(new Set([1, 2])).to.include(2);
	   *
	   * When the target is a Map, `.include` asserts that the given `val` is one of
	   * the values of the target. SameValueZero equality algorithm is used.
	   *
	   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
	   *
	   * Because `.include` does different things based on the target's type, it's
	   * important to check the target's type before using `.include`. See the `.a`
	   * doc for info on testing a target's type.
	   *
	   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
	   *
	   * By default, strict (`===`) equality is used to compare array members and
	   * object properties. Add `.deep` earlier in the chain to use deep equality
	   * instead (WeakSet targets are not supported). See the `deep-eql` project
	   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
	   *
	   *     // Target array deeply (but not strictly) includes `{a: 1}`
	   *     expect([{a: 1}]).to.deep.include({a: 1});
	   *     expect([{a: 1}]).to.not.include({a: 1});
	   *
	   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
	   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
	   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
	   *
	   * By default, all of the target's properties are searched when working with
	   * objects. This includes properties that are inherited and/or non-enumerable.
	   * Add `.own` earlier in the chain to exclude the target's inherited
	   * properties from the search.
	   *
	   *     Object.prototype.b = 2;
	   *
	   *     expect({a: 1}).to.own.include({a: 1});
	   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
	   *
	   * Note that a target object is always only searched for `val`'s own
	   * enumerable properties.
	   *
	   * `.deep` and `.own` can be combined.
	   *
	   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
	   *
	   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
	   * referencing nested properties.
	   *
	   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
	   *
	   * If `.` or `[]` are part of an actual property name, they can be escaped by
	   * adding two backslashes before them.
	   *
	   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
	   *
	   * `.deep` and `.nested` can be combined.
	   *
	   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
	   *
	   * `.own` and `.nested` cannot be combined.
	   *
	   * Add `.not` earlier in the chain to negate `.include`.
	   *
	   *     expect('foobar').to.not.include('taco');
	   *     expect([1, 2, 3]).to.not.include(4);
	   *
	   * However, it's dangerous to negate `.include` when the target is an object.
	   * The problem is that it creates uncertain expectations by asserting that the
	   * target object doesn't have all of `val`'s key/value pairs but may or may
	   * not have some of them. It's often best to identify the exact output that's
	   * expected, and then write an assertion that only accepts that exact output.
	   *
	   * When the target object isn't even expected to have `val`'s keys, it's
	   * often best to assert exactly that.
	   *
	   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
	   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
	   *
	   * When the target object is expected to have `val`'s keys, it's often best to
	   * assert that each of the properties has its expected value, rather than
	   * asserting that each property doesn't have one of many unexpected values.
	   *
	   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
	   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
	   *
	   * `.include` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`.
	   *
	   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
	   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
	   *
	   * `.include` can also be used as a language chain, causing all `.members` and
	   * `.keys` assertions that follow in the chain to require the target to be a
	   * superset of the expected set, rather than an identical set. Note that
	   * `.members` ignores duplicates in the subset when `.include` is added.
	   *
	   *     // Target object's keys are a superset of ['a', 'b'] but not identical
	   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
	   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
	   *
	   *     // Target array is a superset of [1, 2] but not identical
	   *     expect([1, 2, 3]).to.include.members([1, 2]);
	   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
	   *
	   *     // Duplicates in the subset are ignored
	   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
	   *
	   * Note that adding `.any` earlier in the chain causes the `.keys` assertion
	   * to ignore `.include`.
	   *
	   *     // Both assertions are identical
	   *     expect({a: 1}).to.include.any.keys('a', 'b');
	   *     expect({a: 1}).to.have.any.keys('a', 'b');
	   *
	   * The aliases `.includes`, `.contain`, and `.contains` can be used
	   * interchangeably with `.include`.
	   *
	   * @name include
	   * @alias contain
	   * @alias includes
	   * @alias contains
	   * @param {Mixed} val
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function SameValueZero(a, b) {
	    return (_.isNaN(a) && _.isNaN(b)) || a === b;
	  }

	  function includeChainingBehavior () {
	    flag(this, 'contains', true);
	  }

	  function include (val, msg) {
	    if (msg) flag(this, 'message', msg);

	    var obj = flag(this, 'object')
	      , objType = _.type(obj).toLowerCase()
	      , flagMsg = flag(this, 'message')
	      , negate = flag(this, 'negate')
	      , ssfi = flag(this, 'ssfi')
	      , isDeep = flag(this, 'deep')
	      , descriptor = isDeep ? 'deep ' : '';

	    flagMsg = flagMsg ? flagMsg + ': ' : '';

	    var included = false;

	    switch (objType) {
	      case 'string':
	        included = obj.indexOf(val) !== -1;
	        break;

	      case 'weakset':
	        if (isDeep) {
	          throw new AssertionError(
	            flagMsg + 'unable to use .deep.include with WeakSet',
	            undefined,
	            ssfi
	          );
	        }

	        included = obj.has(val);
	        break;

	      case 'map':
	        var isEql = isDeep ? _.eql : SameValueZero;
	        obj.forEach(function (item) {
	          included = included || isEql(item, val);
	        });
	        break;

	      case 'set':
	        if (isDeep) {
	          obj.forEach(function (item) {
	            included = included || _.eql(item, val);
	          });
	        } else {
	          included = obj.has(val);
	        }
	        break;

	      case 'array':
	        if (isDeep) {
	          included = obj.some(function (item) {
	            return _.eql(item, val);
	          });
	        } else {
	          included = obj.indexOf(val) !== -1;
	        }
	        break;

	      default:
	        // This block is for asserting a subset of properties in an object.
	        // `_.expectTypes` isn't used here because `.include` should work with
	        // objects with a custom `@@toStringTag`.
	        if (val !== Object(val)) {
	          throw new AssertionError(
	            flagMsg + 'the given combination of arguments ('
	            + objType + ' and '
	            + _.type(val).toLowerCase() + ')'
	            + ' is invalid for this assertion. '
	            + 'You can use an array, a map, an object, a set, a string, '
	            + 'or a weakset instead of a '
	            + _.type(val).toLowerCase(),
	            undefined,
	            ssfi
	          );
	        }

	        var props = Object.keys(val)
	          , firstErr = null
	          , numErrs = 0;

	        props.forEach(function (prop) {
	          var propAssertion = new Assertion(obj);
	          _.transferFlags(this, propAssertion, true);
	          flag(propAssertion, 'lockSsfi', true);

	          if (!negate || props.length === 1) {
	            propAssertion.property(prop, val[prop]);
	            return;
	          }

	          try {
	            propAssertion.property(prop, val[prop]);
	          } catch (err) {
	            if (!_.checkError.compatibleConstructor(err, AssertionError)) {
	              throw err;
	            }
	            if (firstErr === null) firstErr = err;
	            numErrs++;
	          }
	        }, this);

	        // When validating .not.include with multiple properties, we only want
	        // to throw an assertion error if all of the properties are included,
	        // in which case we throw the first property assertion error that we
	        // encountered.
	        if (negate && props.length > 1 && numErrs === props.length) {
	          throw firstErr;
	        }
	        return;
	    }

	    // Assert inclusion in collection or substring in a string.
	    this.assert(
	      included
	      , 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val)
	      , 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
	  }

	  Assertion.addChainableMethod('include', include, includeChainingBehavior);
	  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
	  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
	  Assertion.addChainableMethod('includes', include, includeChainingBehavior);

	  /**
	   * ### .ok
	   *
	   * Asserts that the target is a truthy value (considered `true` in boolean context).
	   * However, it's often best to assert that the target is strictly (`===`) or
	   * deeply equal to its expected value.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.be.ok; // Not recommended
	   *
	   *     expect(true).to.be.true; // Recommended
	   *     expect(true).to.be.ok; // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.ok`.
	   *
	   *     expect(0).to.equal(0); // Recommended
	   *     expect(0).to.not.be.ok; // Not recommended
	   *
	   *     expect(false).to.be.false; // Recommended
	   *     expect(false).to.not.be.ok; // Not recommended
	   *
	   *     expect(null).to.be.null; // Recommended
	   *     expect(null).to.not.be.ok; // Not recommended
	   *
	   *     expect(undefined).to.be.undefined; // Recommended
	   *     expect(undefined).to.not.be.ok; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect(false, 'nooo why fail??').to.be.ok;
	   *
	   * @name ok
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('ok', function () {
	    this.assert(
	        flag(this, 'object')
	      , 'expected #{this} to be truthy'
	      , 'expected #{this} to be falsy');
	  });

	  /**
	   * ### .true
	   *
	   * Asserts that the target is strictly (`===`) equal to `true`.
	   *
	   *     expect(true).to.be.true;
	   *
	   * Add `.not` earlier in the chain to negate `.true`. However, it's often best
	   * to assert that the target is equal to its expected value, rather than not
	   * equal to `true`.
	   *
	   *     expect(false).to.be.false; // Recommended
	   *     expect(false).to.not.be.true; // Not recommended
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.not.be.true; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect(false, 'nooo why fail??').to.be.true;
	   *
	   * @name true
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('true', function () {
	    this.assert(
	        true === flag(this, 'object')
	      , 'expected #{this} to be true'
	      , 'expected #{this} to be false'
	      , flag(this, 'negate') ? false : true
	    );
	  });

	  /**
	   * ### .false
	   *
	   * Asserts that the target is strictly (`===`) equal to `false`.
	   *
	   *     expect(false).to.be.false;
	   *
	   * Add `.not` earlier in the chain to negate `.false`. However, it's often
	   * best to assert that the target is equal to its expected value, rather than
	   * not equal to `false`.
	   *
	   *     expect(true).to.be.true; // Recommended
	   *     expect(true).to.not.be.false; // Not recommended
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.not.be.false; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect(true, 'nooo why fail??').to.be.false;
	   *
	   * @name false
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('false', function () {
	    this.assert(
	        false === flag(this, 'object')
	      , 'expected #{this} to be false'
	      , 'expected #{this} to be true'
	      , flag(this, 'negate') ? true : false
	    );
	  });

	  /**
	   * ### .null
	   *
	   * Asserts that the target is strictly (`===`) equal to `null`.
	   *
	   *     expect(null).to.be.null;
	   *
	   * Add `.not` earlier in the chain to negate `.null`. However, it's often best
	   * to assert that the target is equal to its expected value, rather than not
	   * equal to `null`.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.not.be.null; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect(42, 'nooo why fail??').to.be.null;
	   *
	   * @name null
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('null', function () {
	    this.assert(
	        null === flag(this, 'object')
	      , 'expected #{this} to be null'
	      , 'expected #{this} not to be null'
	    );
	  });

	  /**
	   * ### .undefined
	   *
	   * Asserts that the target is strictly (`===`) equal to `undefined`.
	   *
	   *     expect(undefined).to.be.undefined;
	   *
	   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
	   * best to assert that the target is equal to its expected value, rather than
	   * not equal to `undefined`.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.not.be.undefined; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect(42, 'nooo why fail??').to.be.undefined;
	   *
	   * @name undefined
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('undefined', function () {
	    this.assert(
	        undefined === flag(this, 'object')
	      , 'expected #{this} to be undefined'
	      , 'expected #{this} not to be undefined'
	    );
	  });

	  /**
	   * ### .NaN
	   *
	   * Asserts that the target is exactly `NaN`.
	   *
	   *     expect(NaN).to.be.NaN;
	   *
	   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
	   * to assert that the target is equal to its expected value, rather than not
	   * equal to `NaN`.
	   *
	   *     expect('foo').to.equal('foo'); // Recommended
	   *     expect('foo').to.not.be.NaN; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect(42, 'nooo why fail??').to.be.NaN;
	   *
	   * @name NaN
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('NaN', function () {
	    this.assert(
	        _.isNaN(flag(this, 'object'))
	        , 'expected #{this} to be NaN'
	        , 'expected #{this} not to be NaN'
	    );
	  });

	  /**
	   * ### .exist
	   *
	   * Asserts that the target is not strictly (`===`) equal to either `null` or
	   * `undefined`. However, it's often best to assert that the target is equal to
	   * its expected value.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.exist; // Not recommended
	   *
	   *     expect(0).to.equal(0); // Recommended
	   *     expect(0).to.exist; // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.exist`.
	   *
	   *     expect(null).to.be.null; // Recommended
	   *     expect(null).to.not.exist; // Not recommended
	   *
	   *     expect(undefined).to.be.undefined; // Recommended
	   *     expect(undefined).to.not.exist; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect(null, 'nooo why fail??').to.exist;
	   *
	   * The alias `.exists` can be used interchangeably with `.exist`.
	   *
	   * @name exist
	   * @alias exists
	   * @namespace BDD
	   * @api public
	   */

	  function assertExist () {
	    var val = flag(this, 'object');
	    this.assert(
	        val !== null && val !== undefined
	      , 'expected #{this} to exist'
	      , 'expected #{this} to not exist'
	    );
	  }

	  Assertion.addProperty('exist', assertExist);
	  Assertion.addProperty('exists', assertExist);

	  /**
	   * ### .empty
	   *
	   * When the target is a string or array, `.empty` asserts that the target's
	   * `length` property is strictly (`===`) equal to `0`.
	   *
	   *     expect([]).to.be.empty;
	   *     expect('').to.be.empty;
	   *
	   * When the target is a map or set, `.empty` asserts that the target's `size`
	   * property is strictly equal to `0`.
	   *
	   *     expect(new Set()).to.be.empty;
	   *     expect(new Map()).to.be.empty;
	   *
	   * When the target is a non-function object, `.empty` asserts that the target
	   * doesn't have any own enumerable properties. Properties with Symbol-based
	   * keys are excluded from the count.
	   *
	   *     expect({}).to.be.empty;
	   *
	   * Because `.empty` does different things based on the target's type, it's
	   * important to check the target's type before using `.empty`. See the `.a`
	   * doc for info on testing a target's type.
	   *
	   *     expect([]).to.be.an('array').that.is.empty;
	   *
	   * Add `.not` earlier in the chain to negate `.empty`. However, it's often
	   * best to assert that the target contains its expected number of values,
	   * rather than asserting that it's not empty.
	   *
	   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
	   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
	   *
	   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
	   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
	   *
	   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
	   *     expect({a: 1}).to.not.be.empty; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
	   *
	   * @name empty
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('empty', function () {
	    var val = flag(this, 'object')
	      , ssfi = flag(this, 'ssfi')
	      , flagMsg = flag(this, 'message')
	      , itemsCount;

	    flagMsg = flagMsg ? flagMsg + ': ' : '';

	    switch (_.type(val).toLowerCase()) {
	      case 'array':
	      case 'string':
	        itemsCount = val.length;
	        break;
	      case 'map':
	      case 'set':
	        itemsCount = val.size;
	        break;
	      case 'weakmap':
	      case 'weakset':
	        throw new AssertionError(
	          flagMsg + '.empty was passed a weak collection',
	          undefined,
	          ssfi
	        );
	      case 'function':
	        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);
	        throw new AssertionError(msg.trim(), undefined, ssfi);
	      default:
	        if (val !== Object(val)) {
	          throw new AssertionError(
	            flagMsg + '.empty was passed non-string primitive ' + _.inspect(val),
	            undefined,
	            ssfi
	          );
	        }
	        itemsCount = Object.keys(val).length;
	    }

	    this.assert(
	        0 === itemsCount
	      , 'expected #{this} to be empty'
	      , 'expected #{this} not to be empty'
	    );
	  });

	  /**
	   * ### .arguments
	   *
	   * Asserts that the target is an `arguments` object.
	   *
	   *     function test () {
	   *       expect(arguments).to.be.arguments;
	   *     }
	   *
	   *     test();
	   *
	   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
	   * best to assert which type the target is expected to be, rather than
	   * asserting that its not an `arguments` object.
	   *
	   *     expect('foo').to.be.a('string'); // Recommended
	   *     expect('foo').to.not.be.arguments; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect({}, 'nooo why fail??').to.be.arguments;
	   *
	   * The alias `.Arguments` can be used interchangeably with `.arguments`.
	   *
	   * @name arguments
	   * @alias Arguments
	   * @namespace BDD
	   * @api public
	   */

	  function checkArguments () {
	    var obj = flag(this, 'object')
	      , type = _.type(obj);
	    this.assert(
	        'Arguments' === type
	      , 'expected #{this} to be arguments but got ' + type
	      , 'expected #{this} to not be arguments'
	    );
	  }

	  Assertion.addProperty('arguments', checkArguments);
	  Assertion.addProperty('Arguments', checkArguments);

	  /**
	   * ### .equal(val[, msg])
	   *
	   * Asserts that the target is strictly (`===`) equal to the given `val`.
	   *
	   *     expect(1).to.equal(1);
	   *     expect('foo').to.equal('foo');
	   *
	   * Add `.deep` earlier in the chain to use deep equality instead. See the
	   * `deep-eql` project page for info on the deep equality algorithm:
	   * https://github.com/chaijs/deep-eql.
	   *
	   *     // Target object deeply (but not strictly) equals `{a: 1}`
	   *     expect({a: 1}).to.deep.equal({a: 1});
	   *     expect({a: 1}).to.not.equal({a: 1});
	   *
	   *     // Target array deeply (but not strictly) equals `[1, 2]`
	   *     expect([1, 2]).to.deep.equal([1, 2]);
	   *     expect([1, 2]).to.not.equal([1, 2]);
	   *
	   * Add `.not` earlier in the chain to negate `.equal`. However, it's often
	   * best to assert that the target is equal to its expected value, rather than
	   * not equal to one of countless unexpected values.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.not.equal(2); // Not recommended
	   *
	   * `.equal` accepts an optional `msg` argument which is a custom error message
	   * to show when the assertion fails. The message can also be given as the
	   * second argument to `expect`.
	   *
	   *     expect(1).to.equal(2, 'nooo why fail??');
	   *     expect(1, 'nooo why fail??').to.equal(2);
	   *
	   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
	   *
	   * @name equal
	   * @alias equals
	   * @alias eq
	   * @param {Mixed} val
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertEqual (val, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'deep')) {
	      var prevLockSsfi = flag(this, 'lockSsfi');
	      flag(this, 'lockSsfi', true);
	      this.eql(val);
	      flag(this, 'lockSsfi', prevLockSsfi);
	    } else {
	      this.assert(
	          val === obj
	        , 'expected #{this} to equal #{exp}'
	        , 'expected #{this} to not equal #{exp}'
	        , val
	        , this._obj
	        , true
	      );
	    }
	  }

	  Assertion.addMethod('equal', assertEqual);
	  Assertion.addMethod('equals', assertEqual);
	  Assertion.addMethod('eq', assertEqual);

	  /**
	   * ### .eql(obj[, msg])
	   *
	   * Asserts that the target is deeply equal to the given `obj`. See the
	   * `deep-eql` project page for info on the deep equality algorithm:
	   * https://github.com/chaijs/deep-eql.
	   *
	   *     // Target object is deeply (but not strictly) equal to {a: 1}
	   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
	   *
	   *     // Target array is deeply (but not strictly) equal to [1, 2]
	   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
	   *
	   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
	   * to assert that the target is deeply equal to its expected value, rather
	   * than not deeply equal to one of countless unexpected values.
	   *
	   *     expect({a: 1}).to.eql({a: 1}); // Recommended
	   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
	   *
	   * `.eql` accepts an optional `msg` argument which is a custom error message
	   * to show when the assertion fails. The message can also be given as the
	   * second argument to `expect`.
	   *
	   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
	   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
	   *
	   * The alias `.eqls` can be used interchangeably with `.eql`.
	   *
	   * The `.deep.equal` assertion is almost identical to `.eql` but with one
	   * difference: `.deep.equal` causes deep equality comparisons to also be used
	   * for any other assertions that follow in the chain.
	   *
	   * @name eql
	   * @alias eqls
	   * @param {Mixed} obj
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertEql(obj, msg) {
	    if (msg) flag(this, 'message', msg);
	    this.assert(
	        _.eql(obj, flag(this, 'object'))
	      , 'expected #{this} to deeply equal #{exp}'
	      , 'expected #{this} to not deeply equal #{exp}'
	      , obj
	      , this._obj
	      , true
	    );
	  }

	  Assertion.addMethod('eql', assertEql);
	  Assertion.addMethod('eqls', assertEql);

	  /**
	   * ### .above(n[, msg])
	   *
	   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
	   * However, it's often best to assert that the target is equal to its expected
	   * value.
	   *
	   *     expect(2).to.equal(2); // Recommended
	   *     expect(2).to.be.above(1); // Not recommended
	   *
	   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
	   * or `size` is greater than the given number `n`.
	   *
	   *     expect('foo').to.have.lengthOf(3); // Recommended
	   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
	   *
	   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
	   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.above`.
	   *
	   *     expect(2).to.equal(2); // Recommended
	   *     expect(1).to.not.be.above(2); // Not recommended
	   *
	   * `.above` accepts an optional `msg` argument which is a custom error message
	   * to show when the assertion fails. The message can also be given as the
	   * second argument to `expect`.
	   *
	   *     expect(1).to.be.above(2, 'nooo why fail??');
	   *     expect(1, 'nooo why fail??').to.be.above(2);
	   *
	   * The aliases `.gt` and `.greaterThan` can be used interchangeably with
	   * `.above`.
	   *
	   * @name above
	   * @alias gt
	   * @alias greaterThan
	   * @param {Number} n
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertAbove (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , doLength = flag(this, 'doLength')
	      , flagMsg = flag(this, 'message')
	      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
	      , ssfi = flag(this, 'ssfi')
	      , objType = _.type(obj).toLowerCase()
	      , nType = _.type(n).toLowerCase()
	      , errorMessage
	      , shouldThrow = true;

	    if (doLength && objType !== 'map' && objType !== 'set') {
	      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
	    }

	    if (!doLength && (objType === 'date' && nType !== 'date')) {
	      errorMessage = msgPrefix + 'the argument to above must be a date';
	    } else if (nType !== 'number' && (doLength || objType === 'number')) {
	      errorMessage = msgPrefix + 'the argument to above must be a number';
	    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
	      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
	      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
	    } else {
	      shouldThrow = false;
	    }

	    if (shouldThrow) {
	      throw new AssertionError(errorMessage, undefined, ssfi);
	    }

	    if (doLength) {
	      var descriptor = 'length'
	        , itemsCount;
	      if (objType === 'map' || objType === 'set') {
	        descriptor = 'size';
	        itemsCount = obj.size;
	      } else {
	        itemsCount = obj.length;
	      }
	      this.assert(
	          itemsCount > n
	        , 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}'
	        , 'expected #{this} to not have a ' + descriptor + ' above #{exp}'
	        , n
	        , itemsCount
	      );
	    } else {
	      this.assert(
	          obj > n
	        , 'expected #{this} to be above #{exp}'
	        , 'expected #{this} to be at most #{exp}'
	        , n
	      );
	    }
	  }

	  Assertion.addMethod('above', assertAbove);
	  Assertion.addMethod('gt', assertAbove);
	  Assertion.addMethod('greaterThan', assertAbove);

	  /**
	   * ### .least(n[, msg])
	   *
	   * Asserts that the target is a number or a date greater than or equal to the given
	   * number or date `n` respectively. However, it's often best to assert that the target is equal to
	   * its expected value.
	   *
	   *     expect(2).to.equal(2); // Recommended
	   *     expect(2).to.be.at.least(1); // Not recommended
	   *     expect(2).to.be.at.least(2); // Not recommended
	   *
	   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
	   * or `size` is greater than or equal to the given number `n`.
	   *
	   *     expect('foo').to.have.lengthOf(3); // Recommended
	   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
	   *
	   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
	   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.least`.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.not.be.at.least(2); // Not recommended
	   *
	   * `.least` accepts an optional `msg` argument which is a custom error message
	   * to show when the assertion fails. The message can also be given as the
	   * second argument to `expect`.
	   *
	   *     expect(1).to.be.at.least(2, 'nooo why fail??');
	   *     expect(1, 'nooo why fail??').to.be.at.least(2);
	   *
	   * The aliases `.gte` and `.greaterThanOrEqual` can be used interchangeably with
	   * `.least`.
	   *
	   * @name least
	   * @alias gte
	   * @alias greaterThanOrEqual
	   * @param {Number} n
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertLeast (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , doLength = flag(this, 'doLength')
	      , flagMsg = flag(this, 'message')
	      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
	      , ssfi = flag(this, 'ssfi')
	      , objType = _.type(obj).toLowerCase()
	      , nType = _.type(n).toLowerCase()
	      , errorMessage
	      , shouldThrow = true;

	    if (doLength && objType !== 'map' && objType !== 'set') {
	      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
	    }

	    if (!doLength && (objType === 'date' && nType !== 'date')) {
	      errorMessage = msgPrefix + 'the argument to least must be a date';
	    } else if (nType !== 'number' && (doLength || objType === 'number')) {
	      errorMessage = msgPrefix + 'the argument to least must be a number';
	    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
	      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
	      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
	    } else {
	      shouldThrow = false;
	    }

	    if (shouldThrow) {
	      throw new AssertionError(errorMessage, undefined, ssfi);
	    }

	    if (doLength) {
	      var descriptor = 'length'
	        , itemsCount;
	      if (objType === 'map' || objType === 'set') {
	        descriptor = 'size';
	        itemsCount = obj.size;
	      } else {
	        itemsCount = obj.length;
	      }
	      this.assert(
	          itemsCount >= n
	        , 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}'
	        , 'expected #{this} to have a ' + descriptor + ' below #{exp}'
	        , n
	        , itemsCount
	      );
	    } else {
	      this.assert(
	          obj >= n
	        , 'expected #{this} to be at least #{exp}'
	        , 'expected #{this} to be below #{exp}'
	        , n
	      );
	    }
	  }

	  Assertion.addMethod('least', assertLeast);
	  Assertion.addMethod('gte', assertLeast);
	  Assertion.addMethod('greaterThanOrEqual', assertLeast);

	  /**
	   * ### .below(n[, msg])
	   *
	   * Asserts that the target is a number or a date less than the given number or date `n` respectively.
	   * However, it's often best to assert that the target is equal to its expected
	   * value.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.be.below(2); // Not recommended
	   *
	   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
	   * or `size` is less than the given number `n`.
	   *
	   *     expect('foo').to.have.lengthOf(3); // Recommended
	   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
	   *
	   *     expect([1, 2, 3]).to.have.length(3); // Recommended
	   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.below`.
	   *
	   *     expect(2).to.equal(2); // Recommended
	   *     expect(2).to.not.be.below(1); // Not recommended
	   *
	   * `.below` accepts an optional `msg` argument which is a custom error message
	   * to show when the assertion fails. The message can also be given as the
	   * second argument to `expect`.
	   *
	   *     expect(2).to.be.below(1, 'nooo why fail??');
	   *     expect(2, 'nooo why fail??').to.be.below(1);
	   *
	   * The aliases `.lt` and `.lessThan` can be used interchangeably with
	   * `.below`.
	   *
	   * @name below
	   * @alias lt
	   * @alias lessThan
	   * @param {Number} n
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertBelow (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , doLength = flag(this, 'doLength')
	      , flagMsg = flag(this, 'message')
	      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
	      , ssfi = flag(this, 'ssfi')
	      , objType = _.type(obj).toLowerCase()
	      , nType = _.type(n).toLowerCase()
	      , errorMessage
	      , shouldThrow = true;

	    if (doLength && objType !== 'map' && objType !== 'set') {
	      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
	    }

	    if (!doLength && (objType === 'date' && nType !== 'date')) {
	      errorMessage = msgPrefix + 'the argument to below must be a date';
	    } else if (nType !== 'number' && (doLength || objType === 'number')) {
	      errorMessage = msgPrefix + 'the argument to below must be a number';
	    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
	      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
	      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
	    } else {
	      shouldThrow = false;
	    }

	    if (shouldThrow) {
	      throw new AssertionError(errorMessage, undefined, ssfi);
	    }

	    if (doLength) {
	      var descriptor = 'length'
	        , itemsCount;
	      if (objType === 'map' || objType === 'set') {
	        descriptor = 'size';
	        itemsCount = obj.size;
	      } else {
	        itemsCount = obj.length;
	      }
	      this.assert(
	          itemsCount < n
	        , 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}'
	        , 'expected #{this} to not have a ' + descriptor + ' below #{exp}'
	        , n
	        , itemsCount
	      );
	    } else {
	      this.assert(
	          obj < n
	        , 'expected #{this} to be below #{exp}'
	        , 'expected #{this} to be at least #{exp}'
	        , n
	      );
	    }
	  }

	  Assertion.addMethod('below', assertBelow);
	  Assertion.addMethod('lt', assertBelow);
	  Assertion.addMethod('lessThan', assertBelow);

	  /**
	   * ### .most(n[, msg])
	   *
	   * Asserts that the target is a number or a date less than or equal to the given number
	   * or date `n` respectively. However, it's often best to assert that the target is equal to its
	   * expected value.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.be.at.most(2); // Not recommended
	   *     expect(1).to.be.at.most(1); // Not recommended
	   *
	   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
	   * or `size` is less than or equal to the given number `n`.
	   *
	   *     expect('foo').to.have.lengthOf(3); // Recommended
	   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
	   *
	   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
	   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.most`.
	   *
	   *     expect(2).to.equal(2); // Recommended
	   *     expect(2).to.not.be.at.most(1); // Not recommended
	   *
	   * `.most` accepts an optional `msg` argument which is a custom error message
	   * to show when the assertion fails. The message can also be given as the
	   * second argument to `expect`.
	   *
	   *     expect(2).to.be.at.most(1, 'nooo why fail??');
	   *     expect(2, 'nooo why fail??').to.be.at.most(1);
	   *
	   * The aliases `.lte` and `.lessThanOrEqual` can be used interchangeably with
	   * `.most`.
	   *
	   * @name most
	   * @alias lte
	   * @alias lessThanOrEqual
	   * @param {Number} n
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertMost (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , doLength = flag(this, 'doLength')
	      , flagMsg = flag(this, 'message')
	      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
	      , ssfi = flag(this, 'ssfi')
	      , objType = _.type(obj).toLowerCase()
	      , nType = _.type(n).toLowerCase()
	      , errorMessage
	      , shouldThrow = true;

	    if (doLength && objType !== 'map' && objType !== 'set') {
	      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
	    }

	    if (!doLength && (objType === 'date' && nType !== 'date')) {
	      errorMessage = msgPrefix + 'the argument to most must be a date';
	    } else if (nType !== 'number' && (doLength || objType === 'number')) {
	      errorMessage = msgPrefix + 'the argument to most must be a number';
	    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
	      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
	      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
	    } else {
	      shouldThrow = false;
	    }

	    if (shouldThrow) {
	      throw new AssertionError(errorMessage, undefined, ssfi);
	    }

	    if (doLength) {
	      var descriptor = 'length'
	        , itemsCount;
	      if (objType === 'map' || objType === 'set') {
	        descriptor = 'size';
	        itemsCount = obj.size;
	      } else {
	        itemsCount = obj.length;
	      }
	      this.assert(
	          itemsCount <= n
	        , 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}'
	        , 'expected #{this} to have a ' + descriptor + ' above #{exp}'
	        , n
	        , itemsCount
	      );
	    } else {
	      this.assert(
	          obj <= n
	        , 'expected #{this} to be at most #{exp}'
	        , 'expected #{this} to be above #{exp}'
	        , n
	      );
	    }
	  }

	  Assertion.addMethod('most', assertMost);
	  Assertion.addMethod('lte', assertMost);
	  Assertion.addMethod('lessThanOrEqual', assertMost);

	  /**
	   * ### .within(start, finish[, msg])
	   *
	   * Asserts that the target is a number or a date greater than or equal to the given
	   * number or date `start`, and less than or equal to the given number or date `finish` respectively.
	   * However, it's often best to assert that the target is equal to its expected
	   * value.
	   *
	   *     expect(2).to.equal(2); // Recommended
	   *     expect(2).to.be.within(1, 3); // Not recommended
	   *     expect(2).to.be.within(2, 3); // Not recommended
	   *     expect(2).to.be.within(1, 2); // Not recommended
	   *
	   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
	   * or `size` is greater than or equal to the given number `start`, and less
	   * than or equal to the given number `finish`.
	   *
	   *     expect('foo').to.have.lengthOf(3); // Recommended
	   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
	   *
	   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
	   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.within`.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.not.be.within(2, 4); // Not recommended
	   *
	   * `.within` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`.
	   *
	   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
	   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
	   *
	   * @name within
	   * @param {Number} start lower bound inclusive
	   * @param {Number} finish upper bound inclusive
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addMethod('within', function (start, finish, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , doLength = flag(this, 'doLength')
	      , flagMsg = flag(this, 'message')
	      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
	      , ssfi = flag(this, 'ssfi')
	      , objType = _.type(obj).toLowerCase()
	      , startType = _.type(start).toLowerCase()
	      , finishType = _.type(finish).toLowerCase()
	      , errorMessage
	      , shouldThrow = true
	      , range = (startType === 'date' && finishType === 'date')
	          ? start.toISOString() + '..' + finish.toISOString()
	          : start + '..' + finish;

	    if (doLength && objType !== 'map' && objType !== 'set') {
	      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
	    }

	    if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {
	      errorMessage = msgPrefix + 'the arguments to within must be dates';
	    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
	      errorMessage = msgPrefix + 'the arguments to within must be numbers';
	    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
	      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
	      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
	    } else {
	      shouldThrow = false;
	    }

	    if (shouldThrow) {
	      throw new AssertionError(errorMessage, undefined, ssfi);
	    }

	    if (doLength) {
	      var descriptor = 'length'
	        , itemsCount;
	      if (objType === 'map' || objType === 'set') {
	        descriptor = 'size';
	        itemsCount = obj.size;
	      } else {
	        itemsCount = obj.length;
	      }
	      this.assert(
	          itemsCount >= start && itemsCount <= finish
	        , 'expected #{this} to have a ' + descriptor + ' within ' + range
	        , 'expected #{this} to not have a ' + descriptor + ' within ' + range
	      );
	    } else {
	      this.assert(
	          obj >= start && obj <= finish
	        , 'expected #{this} to be within ' + range
	        , 'expected #{this} to not be within ' + range
	      );
	    }
	  });

	  /**
	   * ### .instanceof(constructor[, msg])
	   *
	   * Asserts that the target is an instance of the given `constructor`.
	   *
	   *     function Cat () { }
	   *
	   *     expect(new Cat()).to.be.an.instanceof(Cat);
	   *     expect([1, 2]).to.be.an.instanceof(Array);
	   *
	   * Add `.not` earlier in the chain to negate `.instanceof`.
	   *
	   *     expect({a: 1}).to.not.be.an.instanceof(Array);
	   *
	   * `.instanceof` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`.
	   *
	   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
	   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
	   *
	   * Due to limitations in ES5, `.instanceof` may not always work as expected
	   * when using a transpiler such as Babel or TypeScript. In particular, it may
	   * produce unexpected results when subclassing built-in object such as
	   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
	   *
	   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
	   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
	   *
	   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
	   *
	   * @name instanceof
	   * @param {Constructor} constructor
	   * @param {String} msg _optional_
	   * @alias instanceOf
	   * @namespace BDD
	   * @api public
	   */

	  function assertInstanceOf (constructor, msg) {
	    if (msg) flag(this, 'message', msg);

	    var target = flag(this, 'object');
	    var ssfi = flag(this, 'ssfi');
	    var flagMsg = flag(this, 'message');

	    try {
	      var isInstanceOf = target instanceof constructor;
	    } catch (err) {
	      if (err instanceof TypeError) {
	        flagMsg = flagMsg ? flagMsg + ': ' : '';
	        throw new AssertionError(
	          flagMsg + 'The instanceof assertion needs a constructor but '
	            + _.type(constructor) + ' was given.',
	          undefined,
	          ssfi
	        );
	      }
	      throw err;
	    }

	    var name = _.getName(constructor);
	    if (name === null) {
	      name = 'an unnamed constructor';
	    }

	    this.assert(
	        isInstanceOf
	      , 'expected #{this} to be an instance of ' + name
	      , 'expected #{this} to not be an instance of ' + name
	    );
	  }
	  Assertion.addMethod('instanceof', assertInstanceOf);
	  Assertion.addMethod('instanceOf', assertInstanceOf);

	  /**
	   * ### .property(name[, val[, msg]])
	   *
	   * Asserts that the target has a property with the given key `name`.
	   *
	   *     expect({a: 1}).to.have.property('a');
	   *
	   * When `val` is provided, `.property` also asserts that the property's value
	   * is equal to the given `val`.
	   *
	   *     expect({a: 1}).to.have.property('a', 1);
	   *
	   * By default, strict (`===`) equality is used. Add `.deep` earlier in the
	   * chain to use deep equality instead. See the `deep-eql` project page for
	   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
	   *
	   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
	   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
	   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
	   *
	   * The target's enumerable and non-enumerable properties are always included
	   * in the search. By default, both own and inherited properties are included.
	   * Add `.own` earlier in the chain to exclude inherited properties from the
	   * search.
	   *
	   *     Object.prototype.b = 2;
	   *
	   *     expect({a: 1}).to.have.own.property('a');
	   *     expect({a: 1}).to.have.own.property('a', 1);
	   *     expect({a: 1}).to.have.property('b');
	   *     expect({a: 1}).to.not.have.own.property('b');
	   *
	   * `.deep` and `.own` can be combined.
	   *
	   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
	   *
	   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
	   * referencing nested properties.
	   *
	   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
	   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
	   *
	   * If `.` or `[]` are part of an actual property name, they can be escaped by
	   * adding two backslashes before them.
	   *
	   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
	   *
	   * `.deep` and `.nested` can be combined.
	   *
	   *     expect({a: {b: [{c: 3}]}})
	   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
	   *
	   * `.own` and `.nested` cannot be combined.
	   *
	   * Add `.not` earlier in the chain to negate `.property`.
	   *
	   *     expect({a: 1}).to.not.have.property('b');
	   *
	   * However, it's dangerous to negate `.property` when providing `val`. The
	   * problem is that it creates uncertain expectations by asserting that the
	   * target either doesn't have a property with the given key `name`, or that it
	   * does have a property with the given key `name` but its value isn't equal to
	   * the given `val`. It's often best to identify the exact output that's
	   * expected, and then write an assertion that only accepts that exact output.
	   *
	   * When the target isn't expected to have a property with the given key
	   * `name`, it's often best to assert exactly that.
	   *
	   *     expect({b: 2}).to.not.have.property('a'); // Recommended
	   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
	   *
	   * When the target is expected to have a property with the given key `name`,
	   * it's often best to assert that the property has its expected value, rather
	   * than asserting that it doesn't have one of many unexpected values.
	   *
	   *     expect({a: 3}).to.have.property('a', 3); // Recommended
	   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
	   *
	   * `.property` changes the target of any assertions that follow in the chain
	   * to be the value of the property from the original target object.
	   *
	   *     expect({a: 1}).to.have.property('a').that.is.a('number');
	   *
	   * `.property` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`. When not providing `val`, only use the
	   * second form.
	   *
	   *     // Recommended
	   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
	   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
	   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
	   *
	   *     // Not recommended
	   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
	   *
	   * The above assertion isn't the same thing as not providing `val`. Instead,
	   * it's asserting that the target object has a `b` property that's equal to
	   * `undefined`.
	   *
	   * The assertions `.ownProperty` and `.haveOwnProperty` can be used
	   * interchangeably with `.own.property`.
	   *
	   * @name property
	   * @param {String} name
	   * @param {Mixed} val (optional)
	   * @param {String} msg _optional_
	   * @returns value of property for chaining
	   * @namespace BDD
	   * @api public
	   */

	  function assertProperty (name, val, msg) {
	    if (msg) flag(this, 'message', msg);

	    var isNested = flag(this, 'nested')
	      , isOwn = flag(this, 'own')
	      , flagMsg = flag(this, 'message')
	      , obj = flag(this, 'object')
	      , ssfi = flag(this, 'ssfi')
	      , nameType = typeof name;

	    flagMsg = flagMsg ? flagMsg + ': ' : '';

	    if (isNested) {
	      if (nameType !== 'string') {
	        throw new AssertionError(
	          flagMsg + 'the argument to property must be a string when using nested syntax',
	          undefined,
	          ssfi
	        );
	      }
	    } else {
	      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {
	        throw new AssertionError(
	          flagMsg + 'the argument to property must be a string, number, or symbol',
	          undefined,
	          ssfi
	        );
	      }
	    }

	    if (isNested && isOwn) {
	      throw new AssertionError(
	        flagMsg + 'The "nested" and "own" flags cannot be combined.',
	        undefined,
	        ssfi
	      );
	    }

	    if (obj === null || obj === undefined) {
	      throw new AssertionError(
	        flagMsg + 'Target cannot be null or undefined.',
	        undefined,
	        ssfi
	      );
	    }

	    var isDeep = flag(this, 'deep')
	      , negate = flag(this, 'negate')
	      , pathInfo = isNested ? _.getPathInfo(obj, name) : null
	      , value = isNested ? pathInfo.value : obj[name];

	    var descriptor = '';
	    if (isDeep) descriptor += 'deep ';
	    if (isOwn) descriptor += 'own ';
	    if (isNested) descriptor += 'nested ';
	    descriptor += 'property ';

	    var hasProperty;
	    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);
	    else if (isNested) hasProperty = pathInfo.exists;
	    else hasProperty = _.hasProperty(obj, name);

	    // When performing a negated assertion for both name and val, merely having
	    // a property with the given name isn't enough to cause the assertion to
	    // fail. It must both have a property with the given name, and the value of
	    // that property must equal the given val. Therefore, skip this assertion in
	    // favor of the next.
	    if (!negate || arguments.length === 1) {
	      this.assert(
	          hasProperty
	        , 'expected #{this} to have ' + descriptor + _.inspect(name)
	        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
	    }

	    if (arguments.length > 1) {
	      this.assert(
	          hasProperty && (isDeep ? _.eql(val, value) : val === value)
	        , 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
	        , 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}'
	        , val
	        , value
	      );
	    }

	    flag(this, 'object', value);
	  }

	  Assertion.addMethod('property', assertProperty);

	  function assertOwnProperty (name, value, msg) {
	    flag(this, 'own', true);
	    assertProperty.apply(this, arguments);
	  }

	  Assertion.addMethod('ownProperty', assertOwnProperty);
	  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

	  /**
	   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
	   *
	   * Asserts that the target has its own property descriptor with the given key
	   * `name`. Enumerable and non-enumerable properties are included in the
	   * search.
	   *
	   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
	   *
	   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
	   * the property's descriptor is deeply equal to the given `descriptor`. See
	   * the `deep-eql` project page for info on the deep equality algorithm:
	   * https://github.com/chaijs/deep-eql.
	   *
	   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
	   *       configurable: true,
	   *       enumerable: true,
	   *       writable: true,
	   *       value: 1,
	   *     });
	   *
	   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
	   *
	   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
	   *
	   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
	   * a `descriptor`. The problem is that it creates uncertain expectations by
	   * asserting that the target either doesn't have a property descriptor with
	   * the given key `name`, or that it does have a property descriptor with the
	   * given key `name` but its not deeply equal to the given `descriptor`. It's
	   * often best to identify the exact output that's expected, and then write an
	   * assertion that only accepts that exact output.
	   *
	   * When the target isn't expected to have a property descriptor with the given
	   * key `name`, it's often best to assert exactly that.
	   *
	   *     // Recommended
	   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
	   *
	   *     // Not recommended
	   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
	   *       configurable: true,
	   *       enumerable: true,
	   *       writable: true,
	   *       value: 1,
	   *     });
	   *
	   * When the target is expected to have a property descriptor with the given
	   * key `name`, it's often best to assert that the property has its expected
	   * descriptor, rather than asserting that it doesn't have one of many
	   * unexpected descriptors.
	   *
	   *     // Recommended
	   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
	   *       configurable: true,
	   *       enumerable: true,
	   *       writable: true,
	   *       value: 3,
	   *     });
	   *
	   *     // Not recommended
	   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
	   *       configurable: true,
	   *       enumerable: true,
	   *       writable: true,
	   *       value: 1,
	   *     });
	   *
	   * `.ownPropertyDescriptor` changes the target of any assertions that follow
	   * in the chain to be the value of the property descriptor from the original
	   * target object.
	   *
	   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
	   *       .that.has.property('enumerable', true);
	   *
	   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
	   * custom error message to show when the assertion fails. The message can also
	   * be given as the second argument to `expect`. When not providing
	   * `descriptor`, only use the second form.
	   *
	   *     // Recommended
	   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
	   *       configurable: true,
	   *       enumerable: true,
	   *       writable: true,
	   *       value: 2,
	   *     }, 'nooo why fail??');
	   *
	   *     // Recommended
	   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
	   *       configurable: true,
	   *       enumerable: true,
	   *       writable: true,
	   *       value: 2,
	   *     });
	   *
	   *     // Recommended
	   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
	   *
	   *     // Not recommended
	   *     expect({a: 1})
	   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
	   *
	   * The above assertion isn't the same thing as not providing `descriptor`.
	   * Instead, it's asserting that the target object has a `b` property
	   * descriptor that's deeply equal to `undefined`.
	   *
	   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
	   * `.ownPropertyDescriptor`.
	   *
	   * @name ownPropertyDescriptor
	   * @alias haveOwnPropertyDescriptor
	   * @param {String} name
	   * @param {Object} descriptor _optional_
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertOwnPropertyDescriptor (name, descriptor, msg) {
	    if (typeof descriptor === 'string') {
	      msg = descriptor;
	      descriptor = null;
	    }
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
	    if (actualDescriptor && descriptor) {
	      this.assert(
	          _.eql(descriptor, actualDescriptor)
	        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
	        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
	        , descriptor
	        , actualDescriptor
	        , true
	      );
	    } else {
	      this.assert(
	          actualDescriptor
	        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
	        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
	      );
	    }
	    flag(this, 'object', actualDescriptor);
	  }

	  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
	  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

	  /**
	   * ### .lengthOf(n[, msg])
	   *
	   * Asserts that the target's `length` or `size` is equal to the given number
	   * `n`.
	   *
	   *     expect([1, 2, 3]).to.have.lengthOf(3);
	   *     expect('foo').to.have.lengthOf(3);
	   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);
	   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
	   *
	   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
	   * best to assert that the target's `length` property is equal to its expected
	   * value, rather than not equal to one of many unexpected values.
	   *
	   *     expect('foo').to.have.lengthOf(3); // Recommended
	   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
	   *
	   * `.lengthOf` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`.
	   *
	   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
	   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
	   *
	   * `.lengthOf` can also be used as a language chain, causing all `.above`,
	   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
	   * chain to use the target's `length` property as the target. However, it's
	   * often best to assert that the target's `length` property is equal to its
	   * expected length, rather than asserting that its `length` property falls
	   * within some range of values.
	   *
	   *     // Recommended
	   *     expect([1, 2, 3]).to.have.lengthOf(3);
	   *
	   *     // Not recommended
	   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
	   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
	   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
	   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
	   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
	   *
	   * Due to a compatibility issue, the alias `.length` can't be chained directly
	   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
	   * interchangeably with `.lengthOf` in every situation. It's recommended to
	   * always use `.lengthOf` instead of `.length`.
	   *
	   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
	   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
	   *
	   * @name lengthOf
	   * @alias length
	   * @param {Number} n
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertLengthChain () {
	    flag(this, 'doLength', true);
	  }

	  function assertLength (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , objType = _.type(obj).toLowerCase()
	      , flagMsg = flag(this, 'message')
	      , ssfi = flag(this, 'ssfi')
	      , descriptor = 'length'
	      , itemsCount;

	    switch (objType) {
	      case 'map':
	      case 'set':
	        descriptor = 'size';
	        itemsCount = obj.size;
	        break;
	      default:
	        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
	        itemsCount = obj.length;
	    }

	    this.assert(
	        itemsCount == n
	      , 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}'
	      , 'expected #{this} to not have a ' + descriptor + ' of #{act}'
	      , n
	      , itemsCount
	    );
	  }

	  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
	  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);

	  /**
	   * ### .match(re[, msg])
	   *
	   * Asserts that the target matches the given regular expression `re`.
	   *
	   *     expect('foobar').to.match(/^foo/);
	   *
	   * Add `.not` earlier in the chain to negate `.match`.
	   *
	   *     expect('foobar').to.not.match(/taco/);
	   *
	   * `.match` accepts an optional `msg` argument which is a custom error message
	   * to show when the assertion fails. The message can also be given as the
	   * second argument to `expect`.
	   *
	   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
	   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
	   *
	   * The alias `.matches` can be used interchangeably with `.match`.
	   *
	   * @name match
	   * @alias matches
	   * @param {RegExp} re
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */
	  function assertMatch(re, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    this.assert(
	        re.exec(obj)
	      , 'expected #{this} to match ' + re
	      , 'expected #{this} not to match ' + re
	    );
	  }

	  Assertion.addMethod('match', assertMatch);
	  Assertion.addMethod('matches', assertMatch);

	  /**
	   * ### .string(str[, msg])
	   *
	   * Asserts that the target string contains the given substring `str`.
	   *
	   *     expect('foobar').to.have.string('bar');
	   *
	   * Add `.not` earlier in the chain to negate `.string`.
	   *
	   *     expect('foobar').to.not.have.string('taco');
	   *
	   * `.string` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`.
	   *
	   *     expect('foobar').to.have.string('taco', 'nooo why fail??');
	   *     expect('foobar', 'nooo why fail??').to.have.string('taco');
	   *
	   * @name string
	   * @param {String} str
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addMethod('string', function (str, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , flagMsg = flag(this, 'message')
	      , ssfi = flag(this, 'ssfi');
	    new Assertion(obj, flagMsg, ssfi, true).is.a('string');

	    this.assert(
	        ~obj.indexOf(str)
	      , 'expected #{this} to contain ' + _.inspect(str)
	      , 'expected #{this} to not contain ' + _.inspect(str)
	    );
	  });

	  /**
	   * ### .keys(key1[, key2[, ...]])
	   *
	   * Asserts that the target object, array, map, or set has the given keys. Only
	   * the target's own inherited properties are included in the search.
	   *
	   * When the target is an object or array, keys can be provided as one or more
	   * string arguments, a single array argument, or a single object argument. In
	   * the latter case, only the keys in the given object matter; the values are
	   * ignored.
	   *
	   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
	   *     expect(['x', 'y']).to.have.all.keys(0, 1);
	   *
	   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
	   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
	   *
	   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
	   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
	   *
	   * When the target is a map or set, each key must be provided as a separate
	   * argument.
	   *
	   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
	   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
	   *
	   * Because `.keys` does different things based on the target's type, it's
	   * important to check the target's type before using `.keys`. See the `.a` doc
	   * for info on testing a target's type.
	   *
	   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
	   *
	   * By default, strict (`===`) equality is used to compare keys of maps and
	   * sets. Add `.deep` earlier in the chain to use deep equality instead. See
	   * the `deep-eql` project page for info on the deep equality algorithm:
	   * https://github.com/chaijs/deep-eql.
	   *
	   *     // Target set deeply (but not strictly) has key `{a: 1}`
	   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
	   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
	   *
	   * By default, the target must have all of the given keys and no more. Add
	   * `.any` earlier in the chain to only require that the target have at least
	   * one of the given keys. Also, add `.not` earlier in the chain to negate
	   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
	   * `.all` when asserting `.keys` without negation.
	   *
	   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
	   * exactly what's expected of the output, whereas `.not.all.keys` creates
	   * uncertain expectations.
	   *
	   *     // Recommended; asserts that target doesn't have any of the given keys
	   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
	   *
	   *     // Not recommended; asserts that target doesn't have all of the given
	   *     // keys but may or may not have some of them
	   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
	   *
	   * When asserting `.keys` without negation, `.all` is preferred because
	   * `.all.keys` asserts exactly what's expected of the output, whereas
	   * `.any.keys` creates uncertain expectations.
	   *
	   *     // Recommended; asserts that target has all the given keys
	   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
	   *
	   *     // Not recommended; asserts that target has at least one of the given
	   *     // keys but may or may not have more of them
	   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
	   *
	   * Note that `.all` is used by default when neither `.all` nor `.any` appear
	   * earlier in the chain. However, it's often best to add `.all` anyway because
	   * it improves readability.
	   *
	   *     // Both assertions are identical
	   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
	   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
	   *
	   * Add `.include` earlier in the chain to require that the target's keys be a
	   * superset of the expected keys, rather than identical sets.
	   *
	   *     // Target object's keys are a superset of ['a', 'b'] but not identical
	   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
	   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
	   *
	   * However, if `.any` and `.include` are combined, only the `.any` takes
	   * effect. The `.include` is ignored in this case.
	   *
	   *     // Both assertions are identical
	   *     expect({a: 1}).to.have.any.keys('a', 'b');
	   *     expect({a: 1}).to.include.any.keys('a', 'b');
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
	   *
	   * The alias `.key` can be used interchangeably with `.keys`.
	   *
	   * @name keys
	   * @alias key
	   * @param {...String|Array|Object} keys
	   * @namespace BDD
	   * @api public
	   */

	  function assertKeys (keys) {
	    var obj = flag(this, 'object')
	      , objType = _.type(obj)
	      , keysType = _.type(keys)
	      , ssfi = flag(this, 'ssfi')
	      , isDeep = flag(this, 'deep')
	      , str
	      , deepStr = ''
	      , actual
	      , ok = true
	      , flagMsg = flag(this, 'message');

	    flagMsg = flagMsg ? flagMsg + ': ' : '';
	    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

	    if (objType === 'Map' || objType === 'Set') {
	      deepStr = isDeep ? 'deeply ' : '';
	      actual = [];

	      // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.
	      obj.forEach(function (val, key) { actual.push(key); });

	      if (keysType !== 'Array') {
	        keys = Array.prototype.slice.call(arguments);
	      }
	    } else {
	      actual = _.getOwnEnumerableProperties(obj);

	      switch (keysType) {
	        case 'Array':
	          if (arguments.length > 1) {
	            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
	          }
	          break;
	        case 'Object':
	          if (arguments.length > 1) {
	            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
	          }
	          keys = Object.keys(keys);
	          break;
	        default:
	          keys = Array.prototype.slice.call(arguments);
	      }

	      // Only stringify non-Symbols because Symbols would become "Symbol()"
	      keys = keys.map(function (val) {
	        return typeof val === 'symbol' ? val : String(val);
	      });
	    }

	    if (!keys.length) {
	      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
	    }

	    var len = keys.length
	      , any = flag(this, 'any')
	      , all = flag(this, 'all')
	      , expected = keys;

	    if (!any && !all) {
	      all = true;
	    }

	    // Has any
	    if (any) {
	      ok = expected.some(function(expectedKey) {
	        return actual.some(function(actualKey) {
	          if (isDeep) {
	            return _.eql(expectedKey, actualKey);
	          } else {
	            return expectedKey === actualKey;
	          }
	        });
	      });
	    }

	    // Has all
	    if (all) {
	      ok = expected.every(function(expectedKey) {
	        return actual.some(function(actualKey) {
	          if (isDeep) {
	            return _.eql(expectedKey, actualKey);
	          } else {
	            return expectedKey === actualKey;
	          }
	        });
	      });

	      if (!flag(this, 'contains')) {
	        ok = ok && keys.length == actual.length;
	      }
	    }

	    // Key string
	    if (len > 1) {
	      keys = keys.map(function(key) {
	        return _.inspect(key);
	      });
	      var last = keys.pop();
	      if (all) {
	        str = keys.join(', ') + ', and ' + last;
	      }
	      if (any) {
	        str = keys.join(', ') + ', or ' + last;
	      }
	    } else {
	      str = _.inspect(keys[0]);
	    }

	    // Form
	    str = (len > 1 ? 'keys ' : 'key ') + str;

	    // Have / include
	    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

	    // Assertion
	    this.assert(
	        ok
	      , 'expected #{this} to ' + deepStr + str
	      , 'expected #{this} to not ' + deepStr + str
	      , expected.slice(0).sort(_.compareByInspect)
	      , actual.sort(_.compareByInspect)
	      , true
	    );
	  }

	  Assertion.addMethod('keys', assertKeys);
	  Assertion.addMethod('key', assertKeys);

	  /**
	   * ### .throw([errorLike], [errMsgMatcher], [msg])
	   *
	   * When no arguments are provided, `.throw` invokes the target function and
	   * asserts that an error is thrown.
	   *
	   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
	   *
	   *     expect(badFn).to.throw();
	   *
	   * When one argument is provided, and it's an error constructor, `.throw`
	   * invokes the target function and asserts that an error is thrown that's an
	   * instance of that error constructor.
	   *
	   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
	   *
	   *     expect(badFn).to.throw(TypeError);
	   *
	   * When one argument is provided, and it's an error instance, `.throw` invokes
	   * the target function and asserts that an error is thrown that's strictly
	   * (`===`) equal to that error instance.
	   *
	   *     var err = new TypeError('Illegal salmon!');
	   *     var badFn = function () { throw err; };
	   *
	   *     expect(badFn).to.throw(err);
	   *
	   * When one argument is provided, and it's a string, `.throw` invokes the
	   * target function and asserts that an error is thrown with a message that
	   * contains that string.
	   *
	   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
	   *
	   *     expect(badFn).to.throw('salmon');
	   *
	   * When one argument is provided, and it's a regular expression, `.throw`
	   * invokes the target function and asserts that an error is thrown with a
	   * message that matches that regular expression.
	   *
	   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
	   *
	   *     expect(badFn).to.throw(/salmon/);
	   *
	   * When two arguments are provided, and the first is an error instance or
	   * constructor, and the second is a string or regular expression, `.throw`
	   * invokes the function and asserts that an error is thrown that fulfills both
	   * conditions as described above.
	   *
	   *     var err = new TypeError('Illegal salmon!');
	   *     var badFn = function () { throw err; };
	   *
	   *     expect(badFn).to.throw(TypeError, 'salmon');
	   *     expect(badFn).to.throw(TypeError, /salmon/);
	   *     expect(badFn).to.throw(err, 'salmon');
	   *     expect(badFn).to.throw(err, /salmon/);
	   *
	   * Add `.not` earlier in the chain to negate `.throw`.
	   *
	   *     var goodFn = function () {};
	   *
	   *     expect(goodFn).to.not.throw();
	   *
	   * However, it's dangerous to negate `.throw` when providing any arguments.
	   * The problem is that it creates uncertain expectations by asserting that the
	   * target either doesn't throw an error, or that it throws an error but of a
	   * different type than the given type, or that it throws an error of the given
	   * type but with a message that doesn't include the given string. It's often
	   * best to identify the exact output that's expected, and then write an
	   * assertion that only accepts that exact output.
	   *
	   * When the target isn't expected to throw an error, it's often best to assert
	   * exactly that.
	   *
	   *     var goodFn = function () {};
	   *
	   *     expect(goodFn).to.not.throw(); // Recommended
	   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
	   *
	   * When the target is expected to throw an error, it's often best to assert
	   * that the error is of its expected type, and has a message that includes an
	   * expected string, rather than asserting that it doesn't have one of many
	   * unexpected types, and doesn't have a message that includes some string.
	   *
	   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
	   *
	   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
	   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
	   *
	   * `.throw` changes the target of any assertions that follow in the chain to
	   * be the error object that's thrown.
	   *
	   *     var err = new TypeError('Illegal salmon!');
	   *     err.code = 42;
	   *     var badFn = function () { throw err; };
	   *
	   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
	   *
	   * `.throw` accepts an optional `msg` argument which is a custom error message
	   * to show when the assertion fails. The message can also be given as the
	   * second argument to `expect`. When not providing two arguments, always use
	   * the second form.
	   *
	   *     var goodFn = function () {};
	   *
	   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
	   *     expect(goodFn, 'nooo why fail??').to.throw();
	   *
	   * Due to limitations in ES5, `.throw` may not always work as expected when
	   * using a transpiler such as Babel or TypeScript. In particular, it may
	   * produce unexpected results when subclassing the built-in `Error` object and
	   * then passing the subclassed constructor to `.throw`. See your transpiler's
	   * docs for details:
	   *
	   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
	   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
	   *
	   * Beware of some common mistakes when using the `throw` assertion. One common
	   * mistake is to accidentally invoke the function yourself instead of letting
	   * the `throw` assertion invoke the function for you. For example, when
	   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
	   * the target for the assertion.
	   *
	   *     expect(fn).to.throw();     // Good! Tests `fn` as desired
	   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
	   *
	   * If you need to assert that your function `fn` throws when passed certain
	   * arguments, then wrap a call to `fn` inside of another function.
	   *
	   *     expect(function () { fn(42); }).to.throw();  // Function expression
	   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
	   *
	   * Another common mistake is to provide an object method (or any stand-alone
	   * function that relies on `this`) as the target of the assertion. Doing so is
	   * problematic because the `this` context will be lost when the function is
	   * invoked by `.throw`; there's no way for it to know what `this` is supposed
	   * to be. There are two ways around this problem. One solution is to wrap the
	   * method or function call inside of another function. Another solution is to
	   * use `bind`.
	   *
	   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
	   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
	   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
	   *
	   * Finally, it's worth mentioning that it's a best practice in JavaScript to
	   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
	   * `TypeError`, and user-defined objects that extend `Error`. No other type of
	   * value will generate a stack trace when initialized. With that said, the
	   * `throw` assertion does technically support any type of value being thrown,
	   * not just `Error` and its derivatives.
	   *
	   * The aliases `.throws` and `.Throw` can be used interchangeably with
	   * `.throw`.
	   *
	   * @name throw
	   * @alias throws
	   * @alias Throw
	   * @param {Error|ErrorConstructor} errorLike
	   * @param {String|RegExp} errMsgMatcher error message
	   * @param {String} msg _optional_
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @returns error for chaining (null if no error)
	   * @namespace BDD
	   * @api public
	   */

	  function assertThrows (errorLike, errMsgMatcher, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , ssfi = flag(this, 'ssfi')
	      , flagMsg = flag(this, 'message')
	      , negate = flag(this, 'negate') || false;
	    new Assertion(obj, flagMsg, ssfi, true).is.a('function');

	    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
	      errMsgMatcher = errorLike;
	      errorLike = null;
	    }

	    var caughtErr;
	    try {
	      obj();
	    } catch (err) {
	      caughtErr = err;
	    }

	    // If we have the negate flag enabled and at least one valid argument it means we do expect an error
	    // but we want it to match a given set of criteria
	    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;

	    // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
	    // See Issue #551 and PR #683@GitHub
	    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
	    var errorLikeFail = false;
	    var errMsgMatcherFail = false;

	    // Checking if error was thrown
	    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
	      // We need this to display results correctly according to their types
	      var errorLikeString = 'an error';
	      if (errorLike instanceof Error) {
	        errorLikeString = '#{exp}';
	      } else if (errorLike) {
	        errorLikeString = _.checkError.getConstructorName(errorLike);
	      }

	      this.assert(
	          caughtErr
	        , 'expected #{this} to throw ' + errorLikeString
	        , 'expected #{this} to not throw an error but #{act} was thrown'
	        , errorLike && errorLike.toString()
	        , (caughtErr instanceof Error ?
	            caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr &&
	                                    _.checkError.getConstructorName(caughtErr)))
	      );
	    }

	    if (errorLike && caughtErr) {
	      // We should compare instances only if `errorLike` is an instance of `Error`
	      if (errorLike instanceof Error) {
	        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

	        if (isCompatibleInstance === negate) {
	          // These checks were created to ensure we won't fail too soon when we've got both args and a negate
	          // See Issue #551 and PR #683@GitHub
	          if (everyArgIsDefined && negate) {
	            errorLikeFail = true;
	          } else {
	            this.assert(
	                negate
	              , 'expected #{this} to throw #{exp} but #{act} was thrown'
	              , 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : '')
	              , errorLike.toString()
	              , caughtErr.toString()
	            );
	          }
	        }
	      }

	      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);
	      if (isCompatibleConstructor === negate) {
	        if (everyArgIsDefined && negate) {
	            errorLikeFail = true;
	        } else {
	          this.assert(
	              negate
	            , 'expected #{this} to throw #{exp} but #{act} was thrown'
	            , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')
	            , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))
	            , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))
	          );
	        }
	      }
	    }

	    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
	      // Here we check compatible messages
	      var placeholder = 'including';
	      if (errMsgMatcher instanceof RegExp) {
	        placeholder = 'matching';
	      }

	      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);
	      if (isCompatibleMessage === negate) {
	        if (everyArgIsDefined && negate) {
	            errMsgMatcherFail = true;
	        } else {
	          this.assert(
	            negate
	            , 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}'
	            , 'expected #{this} to throw error not ' + placeholder + ' #{exp}'
	            ,  errMsgMatcher
	            ,  _.checkError.getMessage(caughtErr)
	          );
	        }
	      }
	    }

	    // If both assertions failed and both should've matched we throw an error
	    if (errorLikeFail && errMsgMatcherFail) {
	      this.assert(
	        negate
	        , 'expected #{this} to throw #{exp} but #{act} was thrown'
	        , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')
	        , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))
	        , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))
	      );
	    }

	    flag(this, 'object', caughtErr);
	  }
	  Assertion.addMethod('throw', assertThrows);
	  Assertion.addMethod('throws', assertThrows);
	  Assertion.addMethod('Throw', assertThrows);

	  /**
	   * ### .respondTo(method[, msg])
	   *
	   * When the target is a non-function object, `.respondTo` asserts that the
	   * target has a method with the given name `method`. The method can be own or
	   * inherited, and it can be enumerable or non-enumerable.
	   *
	   *     function Cat () {}
	   *     Cat.prototype.meow = function () {};
	   *
	   *     expect(new Cat()).to.respondTo('meow');
	   *
	   * When the target is a function, `.respondTo` asserts that the target's
	   * `prototype` property has a method with the given name `method`. Again, the
	   * method can be own or inherited, and it can be enumerable or non-enumerable.
	   *
	   *     function Cat () {}
	   *     Cat.prototype.meow = function () {};
	   *
	   *     expect(Cat).to.respondTo('meow');
	   *
	   * Add `.itself` earlier in the chain to force `.respondTo` to treat the
	   * target as a non-function object, even if it's a function. Thus, it asserts
	   * that the target has a method with the given name `method`, rather than
	   * asserting that the target's `prototype` property has a method with the
	   * given name `method`.
	   *
	   *     function Cat () {}
	   *     Cat.prototype.meow = function () {};
	   *     Cat.hiss = function () {};
	   *
	   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
	   *
	   * When not adding `.itself`, it's important to check the target's type before
	   * using `.respondTo`. See the `.a` doc for info on checking a target's type.
	   *
	   *     function Cat () {}
	   *     Cat.prototype.meow = function () {};
	   *
	   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
	   *
	   * Add `.not` earlier in the chain to negate `.respondTo`.
	   *
	   *     function Dog () {}
	   *     Dog.prototype.bark = function () {};
	   *
	   *     expect(new Dog()).to.not.respondTo('meow');
	   *
	   * `.respondTo` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`.
	   *
	   *     expect({}).to.respondTo('meow', 'nooo why fail??');
	   *     expect({}, 'nooo why fail??').to.respondTo('meow');
	   *
	   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
	   *
	   * @name respondTo
	   * @alias respondsTo
	   * @param {String} method
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function respondTo (method, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , itself = flag(this, 'itself')
	      , context = ('function' === typeof obj && !itself)
	        ? obj.prototype[method]
	        : obj[method];

	    this.assert(
	        'function' === typeof context
	      , 'expected #{this} to respond to ' + _.inspect(method)
	      , 'expected #{this} to not respond to ' + _.inspect(method)
	    );
	  }

	  Assertion.addMethod('respondTo', respondTo);
	  Assertion.addMethod('respondsTo', respondTo);

	  /**
	   * ### .itself
	   *
	   * Forces all `.respondTo` assertions that follow in the chain to behave as if
	   * the target is a non-function object, even if it's a function. Thus, it
	   * causes `.respondTo` to assert that the target has a method with the given
	   * name, rather than asserting that the target's `prototype` property has a
	   * method with the given name.
	   *
	   *     function Cat () {}
	   *     Cat.prototype.meow = function () {};
	   *     Cat.hiss = function () {};
	   *
	   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
	   *
	   * @name itself
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('itself', function () {
	    flag(this, 'itself', true);
	  });

	  /**
	   * ### .satisfy(matcher[, msg])
	   *
	   * Invokes the given `matcher` function with the target being passed as the
	   * first argument, and asserts that the value returned is truthy.
	   *
	   *     expect(1).to.satisfy(function(num) {
	   *       return num > 0;
	   *     });
	   *
	   * Add `.not` earlier in the chain to negate `.satisfy`.
	   *
	   *     expect(1).to.not.satisfy(function(num) {
	   *       return num > 2;
	   *     });
	   *
	   * `.satisfy` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`.
	   *
	   *     expect(1).to.satisfy(function(num) {
	   *       return num > 2;
	   *     }, 'nooo why fail??');
	   *
	   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
	   *       return num > 2;
	   *     });
	   *
	   * The alias `.satisfies` can be used interchangeably with `.satisfy`.
	   *
	   * @name satisfy
	   * @alias satisfies
	   * @param {Function} matcher
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function satisfy (matcher, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var result = matcher(obj);
	    this.assert(
	        result
	      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
	      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
	      , flag(this, 'negate') ? false : true
	      , result
	    );
	  }

	  Assertion.addMethod('satisfy', satisfy);
	  Assertion.addMethod('satisfies', satisfy);

	  /**
	   * ### .closeTo(expected, delta[, msg])
	   *
	   * Asserts that the target is a number that's within a given +/- `delta` range
	   * of the given number `expected`. However, it's often best to assert that the
	   * target is equal to its expected value.
	   *
	   *     // Recommended
	   *     expect(1.5).to.equal(1.5);
	   *
	   *     // Not recommended
	   *     expect(1.5).to.be.closeTo(1, 0.5);
	   *     expect(1.5).to.be.closeTo(2, 0.5);
	   *     expect(1.5).to.be.closeTo(1, 1);
	   *
	   * Add `.not` earlier in the chain to negate `.closeTo`.
	   *
	   *     expect(1.5).to.equal(1.5); // Recommended
	   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
	   *
	   * `.closeTo` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`.
	   *
	   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
	   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
	   *
	   * The alias `.approximately` can be used interchangeably with `.closeTo`.
	   *
	   * @name closeTo
	   * @alias approximately
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function closeTo(expected, delta, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , flagMsg = flag(this, 'message')
	      , ssfi = flag(this, 'ssfi');

	    new Assertion(obj, flagMsg, ssfi, true).is.a('number');
	    if (typeof expected !== 'number' || typeof delta !== 'number') {
	      flagMsg = flagMsg ? flagMsg + ': ' : '';
	      var deltaMessage = delta === undefined ? ", and a delta is required" : "";
	      throw new AssertionError(
	          flagMsg + 'the arguments to closeTo or approximately must be numbers' + deltaMessage,
	          undefined,
	          ssfi
	      );
	    }

	    this.assert(
	        Math.abs(obj - expected) <= delta
	      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
	      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
	    );
	  }

	  Assertion.addMethod('closeTo', closeTo);
	  Assertion.addMethod('approximately', closeTo);

	  // Note: Duplicates are ignored if testing for inclusion instead of sameness.
	  function isSubsetOf(subset, superset, cmp, contains, ordered) {
	    if (!contains) {
	      if (subset.length !== superset.length) return false;
	      superset = superset.slice();
	    }

	    return subset.every(function(elem, idx) {
	      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

	      if (!cmp) {
	        var matchIdx = superset.indexOf(elem);
	        if (matchIdx === -1) return false;

	        // Remove match from superset so not counted twice if duplicate in subset.
	        if (!contains) superset.splice(matchIdx, 1);
	        return true;
	      }

	      return superset.some(function(elem2, matchIdx) {
	        if (!cmp(elem, elem2)) return false;

	        // Remove match from superset so not counted twice if duplicate in subset.
	        if (!contains) superset.splice(matchIdx, 1);
	        return true;
	      });
	    });
	  }

	  /**
	   * ### .members(set[, msg])
	   *
	   * Asserts that the target array has the same members as the given array
	   * `set`.
	   *
	   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
	   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
	   *
	   * By default, members are compared using strict (`===`) equality. Add `.deep`
	   * earlier in the chain to use deep equality instead. See the `deep-eql`
	   * project page for info on the deep equality algorithm:
	   * https://github.com/chaijs/deep-eql.
	   *
	   *     // Target array deeply (but not strictly) has member `{a: 1}`
	   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
	   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
	   *
	   * By default, order doesn't matter. Add `.ordered` earlier in the chain to
	   * require that members appear in the same order.
	   *
	   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
	   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
	   *       .but.not.ordered.members([2, 1, 3]);
	   *
	   * By default, both arrays must be the same size. Add `.include` earlier in
	   * the chain to require that the target's members be a superset of the
	   * expected members. Note that duplicates are ignored in the subset when
	   * `.include` is added.
	   *
	   *     // Target array is a superset of [1, 2] but not identical
	   *     expect([1, 2, 3]).to.include.members([1, 2]);
	   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
	   *
	   *     // Duplicates in the subset are ignored
	   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
	   *
	   * `.deep`, `.ordered`, and `.include` can all be combined. However, if
	   * `.include` and `.ordered` are combined, the ordering begins at the start of
	   * both arrays.
	   *
	   *     expect([{a: 1}, {b: 2}, {c: 3}])
	   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
	   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
	   *
	   * Add `.not` earlier in the chain to negate `.members`. However, it's
	   * dangerous to do so. The problem is that it creates uncertain expectations
	   * by asserting that the target array doesn't have all of the same members as
	   * the given array `set` but may or may not have some of them. It's often best
	   * to identify the exact output that's expected, and then write an assertion
	   * that only accepts that exact output.
	   *
	   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
	   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
	   *
	   * `.members` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`.
	   *
	   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
	   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
	   *
	   * @name members
	   * @param {Array} set
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addMethod('members', function (subset, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , flagMsg = flag(this, 'message')
	      , ssfi = flag(this, 'ssfi');

	    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
	    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');

	    var contains = flag(this, 'contains');
	    var ordered = flag(this, 'ordered');

	    var subject, failMsg, failNegateMsg;

	    if (contains) {
	      subject = ordered ? 'an ordered superset' : 'a superset';
	      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
	      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
	    } else {
	      subject = ordered ? 'ordered members' : 'members';
	      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
	      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
	    }

	    var cmp = flag(this, 'deep') ? _.eql : undefined;

	    this.assert(
	        isSubsetOf(subset, obj, cmp, contains, ordered)
	      , failMsg
	      , failNegateMsg
	      , subset
	      , obj
	      , true
	    );
	  });

	  /**
	   * ### .oneOf(list[, msg])
	   *
	   * Asserts that the target is a member of the given array `list`. However,
	   * it's often best to assert that the target is equal to its expected value.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
	   *
	   * Comparisons are performed using strict (`===`) equality.
	   *
	   * Add `.not` earlier in the chain to negate `.oneOf`.
	   *
	   *     expect(1).to.equal(1); // Recommended
	   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
	   *
	   * It can also be chained with `.contain` or `.include`, which will work with
	   * both arrays and strings:
	   *
	   *     expect('Today is sunny').to.contain.oneOf(['sunny', 'cloudy'])
	   *     expect('Today is rainy').to.not.contain.oneOf(['sunny', 'cloudy'])
	   *     expect([1,2,3]).to.contain.oneOf([3,4,5])
	   *     expect([1,2,3]).to.not.contain.oneOf([4,5,6])
	   *
	   * `.oneOf` accepts an optional `msg` argument which is a custom error message
	   * to show when the assertion fails. The message can also be given as the
	   * second argument to `expect`.
	   *
	   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
	   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
	   *
	   * @name oneOf
	   * @param {Array<*>} list
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function oneOf (list, msg) {
	    if (msg) flag(this, 'message', msg);
	    var expected = flag(this, 'object')
	      , flagMsg = flag(this, 'message')
	      , ssfi = flag(this, 'ssfi')
	      , contains = flag(this, 'contains')
	      , isDeep = flag(this, 'deep');
	    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');

	    if (contains) {
	      this.assert(
	        list.some(function(possibility) { return expected.indexOf(possibility) > -1 })
	        , 'expected #{this} to contain one of #{exp}'
	        , 'expected #{this} to not contain one of #{exp}'
	        , list
	        , expected
	      );
	    } else {
	      if (isDeep) {
	        this.assert(
	          list.some(function(possibility) { return _.eql(expected, possibility) })
	          , 'expected #{this} to deeply equal one of #{exp}'
	          , 'expected #{this} to deeply equal one of #{exp}'
	          , list
	          , expected
	        );
	      } else {
	        this.assert(
	          list.indexOf(expected) > -1
	          , 'expected #{this} to be one of #{exp}'
	          , 'expected #{this} to not be one of #{exp}'
	          , list
	          , expected
	        );
	      }
	    }
	  }

	  Assertion.addMethod('oneOf', oneOf);

	  /**
	   * ### .change(subject[, prop[, msg]])
	   *
	   * When one argument is provided, `.change` asserts that the given function
	   * `subject` returns a different value when it's invoked before the target
	   * function compared to when it's invoked afterward. However, it's often best
	   * to assert that `subject` is equal to its expected value.
	   *
	   *     var dots = ''
	   *       , addDot = function () { dots += '.'; }
	   *       , getDots = function () { return dots; };
	   *
	   *     // Recommended
	   *     expect(getDots()).to.equal('');
	   *     addDot();
	   *     expect(getDots()).to.equal('.');
	   *
	   *     // Not recommended
	   *     expect(addDot).to.change(getDots);
	   *
	   * When two arguments are provided, `.change` asserts that the value of the
	   * given object `subject`'s `prop` property is different before invoking the
	   * target function compared to afterward.
	   *
	   *     var myObj = {dots: ''}
	   *       , addDot = function () { myObj.dots += '.'; };
	   *
	   *     // Recommended
	   *     expect(myObj).to.have.property('dots', '');
	   *     addDot();
	   *     expect(myObj).to.have.property('dots', '.');
	   *
	   *     // Not recommended
	   *     expect(addDot).to.change(myObj, 'dots');
	   *
	   * Strict (`===`) equality is used to compare before and after values.
	   *
	   * Add `.not` earlier in the chain to negate `.change`.
	   *
	   *     var dots = ''
	   *       , noop = function () {}
	   *       , getDots = function () { return dots; };
	   *
	   *     expect(noop).to.not.change(getDots);
	   *
	   *     var myObj = {dots: ''}
	   *       , noop = function () {};
	   *
	   *     expect(noop).to.not.change(myObj, 'dots');
	   *
	   * `.change` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`. When not providing two arguments, always
	   * use the second form.
	   *
	   *     var myObj = {dots: ''}
	   *       , addDot = function () { myObj.dots += '.'; };
	   *
	   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
	   *
	   *     var dots = ''
	   *       , addDot = function () { dots += '.'; }
	   *       , getDots = function () { return dots; };
	   *
	   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
	   *
	   * `.change` also causes all `.by` assertions that follow in the chain to
	   * assert how much a numeric subject was increased or decreased by. However,
	   * it's dangerous to use `.change.by`. The problem is that it creates
	   * uncertain expectations by asserting that the subject either increases by
	   * the given delta, or that it decreases by the given delta. It's often best
	   * to identify the exact output that's expected, and then write an assertion
	   * that only accepts that exact output.
	   *
	   *     var myObj = {val: 1}
	   *       , addTwo = function () { myObj.val += 2; }
	   *       , subtractTwo = function () { myObj.val -= 2; };
	   *
	   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
	   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
	   *
	   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
	   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
	   *
	   * The alias `.changes` can be used interchangeably with `.change`.
	   *
	   * @name change
	   * @alias changes
	   * @param {String} subject
	   * @param {String} prop name _optional_
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertChanges (subject, prop, msg) {
	    if (msg) flag(this, 'message', msg);
	    var fn = flag(this, 'object')
	      , flagMsg = flag(this, 'message')
	      , ssfi = flag(this, 'ssfi');
	    new Assertion(fn, flagMsg, ssfi, true).is.a('function');

	    var initial;
	    if (!prop) {
	      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
	      initial = subject();
	    } else {
	      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
	      initial = subject[prop];
	    }

	    fn();

	    var final = prop === undefined || prop === null ? subject() : subject[prop];
	    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

	    // This gets flagged because of the .by(delta) assertion
	    flag(this, 'deltaMsgObj', msgObj);
	    flag(this, 'initialDeltaValue', initial);
	    flag(this, 'finalDeltaValue', final);
	    flag(this, 'deltaBehavior', 'change');
	    flag(this, 'realDelta', final !== initial);

	    this.assert(
	      initial !== final
	      , 'expected ' + msgObj + ' to change'
	      , 'expected ' + msgObj + ' to not change'
	    );
	  }

	  Assertion.addMethod('change', assertChanges);
	  Assertion.addMethod('changes', assertChanges);

	  /**
	   * ### .increase(subject[, prop[, msg]])
	   *
	   * When one argument is provided, `.increase` asserts that the given function
	   * `subject` returns a greater number when it's invoked after invoking the
	   * target function compared to when it's invoked beforehand. `.increase` also
	   * causes all `.by` assertions that follow in the chain to assert how much
	   * greater of a number is returned. It's often best to assert that the return
	   * value increased by the expected amount, rather than asserting it increased
	   * by any amount.
	   *
	   *     var val = 1
	   *       , addTwo = function () { val += 2; }
	   *       , getVal = function () { return val; };
	   *
	   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
	   *     expect(addTwo).to.increase(getVal); // Not recommended
	   *
	   * When two arguments are provided, `.increase` asserts that the value of the
	   * given object `subject`'s `prop` property is greater after invoking the
	   * target function compared to beforehand.
	   *
	   *     var myObj = {val: 1}
	   *       , addTwo = function () { myObj.val += 2; };
	   *
	   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
	   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.increase`. However, it's
	   * dangerous to do so. The problem is that it creates uncertain expectations
	   * by asserting that the subject either decreases, or that it stays the same.
	   * It's often best to identify the exact output that's expected, and then
	   * write an assertion that only accepts that exact output.
	   *
	   * When the subject is expected to decrease, it's often best to assert that it
	   * decreased by the expected amount.
	   *
	   *     var myObj = {val: 1}
	   *       , subtractTwo = function () { myObj.val -= 2; };
	   *
	   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
	   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
	   *
	   * When the subject is expected to stay the same, it's often best to assert
	   * exactly that.
	   *
	   *     var myObj = {val: 1}
	   *       , noop = function () {};
	   *
	   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
	   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
	   *
	   * `.increase` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`. When not providing two arguments, always
	   * use the second form.
	   *
	   *     var myObj = {val: 1}
	   *       , noop = function () {};
	   *
	   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
	   *
	   *     var val = 1
	   *       , noop = function () {}
	   *       , getVal = function () { return val; };
	   *
	   *     expect(noop, 'nooo why fail??').to.increase(getVal);
	   *
	   * The alias `.increases` can be used interchangeably with `.increase`.
	   *
	   * @name increase
	   * @alias increases
	   * @param {String|Function} subject
	   * @param {String} prop name _optional_
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertIncreases (subject, prop, msg) {
	    if (msg) flag(this, 'message', msg);
	    var fn = flag(this, 'object')
	      , flagMsg = flag(this, 'message')
	      , ssfi = flag(this, 'ssfi');
	    new Assertion(fn, flagMsg, ssfi, true).is.a('function');

	    var initial;
	    if (!prop) {
	      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
	      initial = subject();
	    } else {
	      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
	      initial = subject[prop];
	    }

	    // Make sure that the target is a number
	    new Assertion(initial, flagMsg, ssfi, true).is.a('number');

	    fn();

	    var final = prop === undefined || prop === null ? subject() : subject[prop];
	    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

	    flag(this, 'deltaMsgObj', msgObj);
	    flag(this, 'initialDeltaValue', initial);
	    flag(this, 'finalDeltaValue', final);
	    flag(this, 'deltaBehavior', 'increase');
	    flag(this, 'realDelta', final - initial);

	    this.assert(
	      final - initial > 0
	      , 'expected ' + msgObj + ' to increase'
	      , 'expected ' + msgObj + ' to not increase'
	    );
	  }

	  Assertion.addMethod('increase', assertIncreases);
	  Assertion.addMethod('increases', assertIncreases);

	  /**
	   * ### .decrease(subject[, prop[, msg]])
	   *
	   * When one argument is provided, `.decrease` asserts that the given function
	   * `subject` returns a lesser number when it's invoked after invoking the
	   * target function compared to when it's invoked beforehand. `.decrease` also
	   * causes all `.by` assertions that follow in the chain to assert how much
	   * lesser of a number is returned. It's often best to assert that the return
	   * value decreased by the expected amount, rather than asserting it decreased
	   * by any amount.
	   *
	   *     var val = 1
	   *       , subtractTwo = function () { val -= 2; }
	   *       , getVal = function () { return val; };
	   *
	   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
	   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
	   *
	   * When two arguments are provided, `.decrease` asserts that the value of the
	   * given object `subject`'s `prop` property is lesser after invoking the
	   * target function compared to beforehand.
	   *
	   *     var myObj = {val: 1}
	   *       , subtractTwo = function () { myObj.val -= 2; };
	   *
	   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
	   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.decrease`. However, it's
	   * dangerous to do so. The problem is that it creates uncertain expectations
	   * by asserting that the subject either increases, or that it stays the same.
	   * It's often best to identify the exact output that's expected, and then
	   * write an assertion that only accepts that exact output.
	   *
	   * When the subject is expected to increase, it's often best to assert that it
	   * increased by the expected amount.
	   *
	   *     var myObj = {val: 1}
	   *       , addTwo = function () { myObj.val += 2; };
	   *
	   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
	   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
	   *
	   * When the subject is expected to stay the same, it's often best to assert
	   * exactly that.
	   *
	   *     var myObj = {val: 1}
	   *       , noop = function () {};
	   *
	   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
	   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
	   *
	   * `.decrease` accepts an optional `msg` argument which is a custom error
	   * message to show when the assertion fails. The message can also be given as
	   * the second argument to `expect`. When not providing two arguments, always
	   * use the second form.
	   *
	   *     var myObj = {val: 1}
	   *       , noop = function () {};
	   *
	   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
	   *
	   *     var val = 1
	   *       , noop = function () {}
	   *       , getVal = function () { return val; };
	   *
	   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
	   *
	   * The alias `.decreases` can be used interchangeably with `.decrease`.
	   *
	   * @name decrease
	   * @alias decreases
	   * @param {String|Function} subject
	   * @param {String} prop name _optional_
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertDecreases (subject, prop, msg) {
	    if (msg) flag(this, 'message', msg);
	    var fn = flag(this, 'object')
	      , flagMsg = flag(this, 'message')
	      , ssfi = flag(this, 'ssfi');
	    new Assertion(fn, flagMsg, ssfi, true).is.a('function');

	    var initial;
	    if (!prop) {
	      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
	      initial = subject();
	    } else {
	      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
	      initial = subject[prop];
	    }

	    // Make sure that the target is a number
	    new Assertion(initial, flagMsg, ssfi, true).is.a('number');

	    fn();

	    var final = prop === undefined || prop === null ? subject() : subject[prop];
	    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

	    flag(this, 'deltaMsgObj', msgObj);
	    flag(this, 'initialDeltaValue', initial);
	    flag(this, 'finalDeltaValue', final);
	    flag(this, 'deltaBehavior', 'decrease');
	    flag(this, 'realDelta', initial - final);

	    this.assert(
	      final - initial < 0
	      , 'expected ' + msgObj + ' to decrease'
	      , 'expected ' + msgObj + ' to not decrease'
	    );
	  }

	  Assertion.addMethod('decrease', assertDecreases);
	  Assertion.addMethod('decreases', assertDecreases);

	  /**
	   * ### .by(delta[, msg])
	   *
	   * When following an `.increase` assertion in the chain, `.by` asserts that
	   * the subject of the `.increase` assertion increased by the given `delta`.
	   *
	   *     var myObj = {val: 1}
	   *       , addTwo = function () { myObj.val += 2; };
	   *
	   *     expect(addTwo).to.increase(myObj, 'val').by(2);
	   *
	   * When following a `.decrease` assertion in the chain, `.by` asserts that the
	   * subject of the `.decrease` assertion decreased by the given `delta`.
	   *
	   *     var myObj = {val: 1}
	   *       , subtractTwo = function () { myObj.val -= 2; };
	   *
	   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
	   *
	   * When following a `.change` assertion in the chain, `.by` asserts that the
	   * subject of the `.change` assertion either increased or decreased by the
	   * given `delta`. However, it's dangerous to use `.change.by`. The problem is
	   * that it creates uncertain expectations. It's often best to identify the
	   * exact output that's expected, and then write an assertion that only accepts
	   * that exact output.
	   *
	   *     var myObj = {val: 1}
	   *       , addTwo = function () { myObj.val += 2; }
	   *       , subtractTwo = function () { myObj.val -= 2; };
	   *
	   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
	   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
	   *
	   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
	   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
	   *
	   * Add `.not` earlier in the chain to negate `.by`. However, it's often best
	   * to assert that the subject changed by its expected delta, rather than
	   * asserting that it didn't change by one of countless unexpected deltas.
	   *
	   *     var myObj = {val: 1}
	   *       , addTwo = function () { myObj.val += 2; };
	   *
	   *     // Recommended
	   *     expect(addTwo).to.increase(myObj, 'val').by(2);
	   *
	   *     // Not recommended
	   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
	   *
	   * `.by` accepts an optional `msg` argument which is a custom error message to
	   * show when the assertion fails. The message can also be given as the second
	   * argument to `expect`.
	   *
	   *     var myObj = {val: 1}
	   *       , addTwo = function () { myObj.val += 2; };
	   *
	   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
	   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
	   *
	   * @name by
	   * @param {Number} delta
	   * @param {String} msg _optional_
	   * @namespace BDD
	   * @api public
	   */

	  function assertDelta(delta, msg) {
	    if (msg) flag(this, 'message', msg);

	    var msgObj = flag(this, 'deltaMsgObj');
	    var initial = flag(this, 'initialDeltaValue');
	    var final = flag(this, 'finalDeltaValue');
	    var behavior = flag(this, 'deltaBehavior');
	    var realDelta = flag(this, 'realDelta');

	    var expression;
	    if (behavior === 'change') {
	      expression = Math.abs(final - initial) === Math.abs(delta);
	    } else {
	      expression = realDelta === Math.abs(delta);
	    }

	    this.assert(
	      expression
	      , 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta
	      , 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta
	    );
	  }

	  Assertion.addMethod('by', assertDelta);

	  /**
	   * ### .extensible
	   *
	   * Asserts that the target is extensible, which means that new properties can
	   * be added to it. Primitives are never extensible.
	   *
	   *     expect({a: 1}).to.be.extensible;
	   *
	   * Add `.not` earlier in the chain to negate `.extensible`.
	   *
	   *     var nonExtensibleObject = Object.preventExtensions({})
	   *       , sealedObject = Object.seal({})
	   *       , frozenObject = Object.freeze({});
	   *
	   *     expect(nonExtensibleObject).to.not.be.extensible;
	   *     expect(sealedObject).to.not.be.extensible;
	   *     expect(frozenObject).to.not.be.extensible;
	   *     expect(1).to.not.be.extensible;
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect(1, 'nooo why fail??').to.be.extensible;
	   *
	   * @name extensible
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('extensible', function() {
	    var obj = flag(this, 'object');

	    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
	    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
	    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
	    // The following provides ES6 behavior for ES5 environments.

	    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);

	    this.assert(
	      isExtensible
	      , 'expected #{this} to be extensible'
	      , 'expected #{this} to not be extensible'
	    );
	  });

	  /**
	   * ### .sealed
	   *
	   * Asserts that the target is sealed, which means that new properties can't be
	   * added to it, and its existing properties can't be reconfigured or deleted.
	   * However, it's possible that its existing properties can still be reassigned
	   * to different values. Primitives are always sealed.
	   *
	   *     var sealedObject = Object.seal({});
	   *     var frozenObject = Object.freeze({});
	   *
	   *     expect(sealedObject).to.be.sealed;
	   *     expect(frozenObject).to.be.sealed;
	   *     expect(1).to.be.sealed;
	   *
	   * Add `.not` earlier in the chain to negate `.sealed`.
	   *
	   *     expect({a: 1}).to.not.be.sealed;
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
	   *
	   * @name sealed
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('sealed', function() {
	    var obj = flag(this, 'object');

	    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
	    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
	    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
	    // The following provides ES6 behavior for ES5 environments.

	    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;

	    this.assert(
	      isSealed
	      , 'expected #{this} to be sealed'
	      , 'expected #{this} to not be sealed'
	    );
	  });

	  /**
	   * ### .frozen
	   *
	   * Asserts that the target is frozen, which means that new properties can't be
	   * added to it, and its existing properties can't be reassigned to different
	   * values, reconfigured, or deleted. Primitives are always frozen.
	   *
	   *     var frozenObject = Object.freeze({});
	   *
	   *     expect(frozenObject).to.be.frozen;
	   *     expect(1).to.be.frozen;
	   *
	   * Add `.not` earlier in the chain to negate `.frozen`.
	   *
	   *     expect({a: 1}).to.not.be.frozen;
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
	   *
	   * @name frozen
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('frozen', function() {
	    var obj = flag(this, 'object');

	    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
	    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
	    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
	    // The following provides ES6 behavior for ES5 environments.

	    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;

	    this.assert(
	      isFrozen
	      , 'expected #{this} to be frozen'
	      , 'expected #{this} to not be frozen'
	    );
	  });

	  /**
	   * ### .finite
	   *
	   * Asserts that the target is a number, and isn't `NaN` or positive/negative
	   * `Infinity`.
	   *
	   *     expect(1).to.be.finite;
	   *
	   * Add `.not` earlier in the chain to negate `.finite`. However, it's
	   * dangerous to do so. The problem is that it creates uncertain expectations
	   * by asserting that the subject either isn't a number, or that it's `NaN`, or
	   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
	   * best to identify the exact output that's expected, and then write an
	   * assertion that only accepts that exact output.
	   *
	   * When the target isn't expected to be a number, it's often best to assert
	   * that it's the expected type, rather than asserting that it isn't one of
	   * many unexpected types.
	   *
	   *     expect('foo').to.be.a('string'); // Recommended
	   *     expect('foo').to.not.be.finite; // Not recommended
	   *
	   * When the target is expected to be `NaN`, it's often best to assert exactly
	   * that.
	   *
	   *     expect(NaN).to.be.NaN; // Recommended
	   *     expect(NaN).to.not.be.finite; // Not recommended
	   *
	   * When the target is expected to be positive infinity, it's often best to
	   * assert exactly that.
	   *
	   *     expect(Infinity).to.equal(Infinity); // Recommended
	   *     expect(Infinity).to.not.be.finite; // Not recommended
	   *
	   * When the target is expected to be negative infinity, it's often best to
	   * assert exactly that.
	   *
	   *     expect(-Infinity).to.equal(-Infinity); // Recommended
	   *     expect(-Infinity).to.not.be.finite; // Not recommended
	   *
	   * A custom error message can be given as the second argument to `expect`.
	   *
	   *     expect('foo', 'nooo why fail??').to.be.finite;
	   *
	   * @name finite
	   * @namespace BDD
	   * @api public
	   */

	  Assertion.addProperty('finite', function(msg) {
	    var obj = flag(this, 'object');

	    this.assert(
	        typeof obj === 'number' && isFinite(obj)
	      , 'expected #{this} to be a finite number'
	      , 'expected #{this} to not be a finite number'
	    );
	  });
	};

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var expect$1 = function (chai, util) {
	  chai.expect = function (val, message) {
	    return new chai.Assertion(val, message);
	  };

	  /**
	   * ### .fail([message])
	   * ### .fail(actual, expected, [message], [operator])
	   *
	   * Throw a failure.
	   *
	   *     expect.fail();
	   *     expect.fail("custom error message");
	   *     expect.fail(1, 2);
	   *     expect.fail(1, 2, "custom error message");
	   *     expect.fail(1, 2, "custom error message", ">");
	   *     expect.fail(1, 2, undefined, ">");
	   *
	   * @name fail
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @param {String} operator
	   * @namespace BDD
	   * @api public
	   */

	  chai.expect.fail = function (actual, expected, message, operator) {
	    if (arguments.length < 2) {
	        message = actual;
	        actual = undefined;
	    }

	    message = message || 'expect.fail()';
	    throw new chai.AssertionError(message, {
	        actual: actual
	      , expected: expected
	      , operator: operator
	    }, chai.expect.fail);
	  };
	};

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var should = function (chai, util) {
	  var Assertion = chai.Assertion;

	  function loadShould () {
	    // explicitly define this method as function as to have it's name to include as `ssfi`
	    function shouldGetter() {
	      if (this instanceof String
	          || this instanceof Number
	          || this instanceof Boolean
	          || typeof Symbol === 'function' && this instanceof Symbol
	          || typeof BigInt === 'function' && this instanceof BigInt) {
	        return new Assertion(this.valueOf(), null, shouldGetter);
	      }
	      return new Assertion(this, null, shouldGetter);
	    }
	    function shouldSetter(value) {
	      // See https://github.com/chaijs/chai/issues/86: this makes
	      // `whatever.should = someValue` actually set `someValue`, which is
	      // especially useful for `global.should = require('chai').should()`.
	      //
	      // Note that we have to use [[DefineProperty]] instead of [[Put]]
	      // since otherwise we would trigger this very setter!
	      Object.defineProperty(this, 'should', {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    }
	    // modify Object.prototype to have `should`
	    Object.defineProperty(Object.prototype, 'should', {
	      set: shouldSetter
	      , get: shouldGetter
	      , configurable: true
	    });

	    var should = {};

	    /**
	     * ### .fail([message])
	     * ### .fail(actual, expected, [message], [operator])
	     *
	     * Throw a failure.
	     *
	     *     should.fail();
	     *     should.fail("custom error message");
	     *     should.fail(1, 2);
	     *     should.fail(1, 2, "custom error message");
	     *     should.fail(1, 2, "custom error message", ">");
	     *     should.fail(1, 2, undefined, ">");
	     *
	     *
	     * @name fail
	     * @param {Mixed} actual
	     * @param {Mixed} expected
	     * @param {String} message
	     * @param {String} operator
	     * @namespace BDD
	     * @api public
	     */

	    should.fail = function (actual, expected, message, operator) {
	      if (arguments.length < 2) {
	          message = actual;
	          actual = undefined;
	      }

	      message = message || 'should.fail()';
	      throw new chai.AssertionError(message, {
	          actual: actual
	        , expected: expected
	        , operator: operator
	      }, should.fail);
	    };

	    /**
	     * ### .equal(actual, expected, [message])
	     *
	     * Asserts non-strict equality (`==`) of `actual` and `expected`.
	     *
	     *     should.equal(3, '3', '== coerces values to strings');
	     *
	     * @name equal
	     * @param {Mixed} actual
	     * @param {Mixed} expected
	     * @param {String} message
	     * @namespace Should
	     * @api public
	     */

	    should.equal = function (val1, val2, msg) {
	      new Assertion(val1, msg).to.equal(val2);
	    };

	    /**
	     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
	     *
	     * Asserts that `function` will throw an error that is an instance of
	     * `constructor`, or alternately that it will throw an error with message
	     * matching `regexp`.
	     *
	     *     should.throw(fn, 'function throws a reference error');
	     *     should.throw(fn, /function throws a reference error/);
	     *     should.throw(fn, ReferenceError);
	     *     should.throw(fn, ReferenceError, 'function throws a reference error');
	     *     should.throw(fn, ReferenceError, /function throws a reference error/);
	     *
	     * @name throw
	     * @alias Throw
	     * @param {Function} function
	     * @param {ErrorConstructor} constructor
	     * @param {RegExp} regexp
	     * @param {String} message
	     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	     * @namespace Should
	     * @api public
	     */

	    should.Throw = function (fn, errt, errs, msg) {
	      new Assertion(fn, msg).to.Throw(errt, errs);
	    };

	    /**
	     * ### .exist
	     *
	     * Asserts that the target is neither `null` nor `undefined`.
	     *
	     *     var foo = 'hi';
	     *
	     *     should.exist(foo, 'foo exists');
	     *
	     * @name exist
	     * @namespace Should
	     * @api public
	     */

	    should.exist = function (val, msg) {
	      new Assertion(val, msg).to.exist;
	    };

	    // negation
	    should.not = {};

	    /**
	     * ### .not.equal(actual, expected, [message])
	     *
	     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
	     *
	     *     should.not.equal(3, 4, 'these numbers are not equal');
	     *
	     * @name not.equal
	     * @param {Mixed} actual
	     * @param {Mixed} expected
	     * @param {String} message
	     * @namespace Should
	     * @api public
	     */

	    should.not.equal = function (val1, val2, msg) {
	      new Assertion(val1, msg).to.not.equal(val2);
	    };

	    /**
	     * ### .throw(function, [constructor/regexp], [message])
	     *
	     * Asserts that `function` will _not_ throw an error that is an instance of
	     * `constructor`, or alternately that it will not throw an error with message
	     * matching `regexp`.
	     *
	     *     should.not.throw(fn, Error, 'function does not throw');
	     *
	     * @name not.throw
	     * @alias not.Throw
	     * @param {Function} function
	     * @param {ErrorConstructor} constructor
	     * @param {RegExp} regexp
	     * @param {String} message
	     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	     * @namespace Should
	     * @api public
	     */

	    should.not.Throw = function (fn, errt, errs, msg) {
	      new Assertion(fn, msg).to.not.Throw(errt, errs);
	    };

	    /**
	     * ### .not.exist
	     *
	     * Asserts that the target is neither `null` nor `undefined`.
	     *
	     *     var bar = null;
	     *
	     *     should.not.exist(bar, 'bar does not exist');
	     *
	     * @name not.exist
	     * @namespace Should
	     * @api public
	     */

	    should.not.exist = function (val, msg) {
	      new Assertion(val, msg).to.not.exist;
	    };

	    should['throw'] = should['Throw'];
	    should.not['throw'] = should.not['Throw'];

	    return should;
	  }
	  chai.should = loadShould;
	  chai.Should = loadShould;
	};

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var assert = function (chai, util) {
	  /*!
	   * Chai dependencies.
	   */

	  var Assertion = chai.Assertion
	    , flag = util.flag;

	  /*!
	   * Module export.
	   */

	  /**
	   * ### assert(expression, message)
	   *
	   * Write your own test expressions.
	   *
	   *     assert('foo' !== 'bar', 'foo is not bar');
	   *     assert(Array.isArray([]), 'empty arrays are arrays');
	   *
	   * @param {Mixed} expression to test for truthiness
	   * @param {String} message to display on error
	   * @name assert
	   * @namespace Assert
	   * @api public
	   */

	  var assert = chai.assert = function (express, errmsg) {
	    var test = new Assertion(null, null, chai.assert, true);
	    test.assert(
	        express
	      , errmsg
	      , '[ negation message unavailable ]'
	    );
	  };

	  /**
	   * ### .fail([message])
	   * ### .fail(actual, expected, [message], [operator])
	   *
	   * Throw a failure. Node.js `assert` module-compatible.
	   *
	   *     assert.fail();
	   *     assert.fail("custom error message");
	   *     assert.fail(1, 2);
	   *     assert.fail(1, 2, "custom error message");
	   *     assert.fail(1, 2, "custom error message", ">");
	   *     assert.fail(1, 2, undefined, ">");
	   *
	   * @name fail
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @param {String} operator
	   * @namespace Assert
	   * @api public
	   */

	  assert.fail = function (actual, expected, message, operator) {
	    if (arguments.length < 2) {
	        // Comply with Node's fail([message]) interface

	        message = actual;
	        actual = undefined;
	    }

	    message = message || 'assert.fail()';
	    throw new chai.AssertionError(message, {
	        actual: actual
	      , expected: expected
	      , operator: operator
	    }, assert.fail);
	  };

	  /**
	   * ### .isOk(object, [message])
	   *
	   * Asserts that `object` is truthy.
	   *
	   *     assert.isOk('everything', 'everything is ok');
	   *     assert.isOk(false, 'this will fail');
	   *
	   * @name isOk
	   * @alias ok
	   * @param {Mixed} object to test
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isOk = function (val, msg) {
	    new Assertion(val, msg, assert.isOk, true).is.ok;
	  };

	  /**
	   * ### .isNotOk(object, [message])
	   *
	   * Asserts that `object` is falsy.
	   *
	   *     assert.isNotOk('everything', 'this will fail');
	   *     assert.isNotOk(false, 'this will pass');
	   *
	   * @name isNotOk
	   * @alias notOk
	   * @param {Mixed} object to test
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotOk = function (val, msg) {
	    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
	  };

	  /**
	   * ### .equal(actual, expected, [message])
	   *
	   * Asserts non-strict equality (`==`) of `actual` and `expected`.
	   *
	   *     assert.equal(3, '3', '== coerces values to strings');
	   *
	   * @name equal
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.equal = function (act, exp, msg) {
	    var test = new Assertion(act, msg, assert.equal, true);

	    test.assert(
	        exp == flag(test, 'object')
	      , 'expected #{this} to equal #{exp}'
	      , 'expected #{this} to not equal #{act}'
	      , exp
	      , act
	      , true
	    );
	  };

	  /**
	   * ### .notEqual(actual, expected, [message])
	   *
	   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
	   *
	   *     assert.notEqual(3, 4, 'these numbers are not equal');
	   *
	   * @name notEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notEqual = function (act, exp, msg) {
	    var test = new Assertion(act, msg, assert.notEqual, true);

	    test.assert(
	        exp != flag(test, 'object')
	      , 'expected #{this} to not equal #{exp}'
	      , 'expected #{this} to equal #{act}'
	      , exp
	      , act
	      , true
	    );
	  };

	  /**
	   * ### .strictEqual(actual, expected, [message])
	   *
	   * Asserts strict equality (`===`) of `actual` and `expected`.
	   *
	   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
	   *
	   * @name strictEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.strictEqual = function (act, exp, msg) {
	    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
	  };

	  /**
	   * ### .notStrictEqual(actual, expected, [message])
	   *
	   * Asserts strict inequality (`!==`) of `actual` and `expected`.
	   *
	   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
	   *
	   * @name notStrictEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notStrictEqual = function (act, exp, msg) {
	    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
	  };

	  /**
	   * ### .deepEqual(actual, expected, [message])
	   *
	   * Asserts that `actual` is deeply equal to `expected`.
	   *
	   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
	   *
	   * @name deepEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @alias deepStrictEqual
	   * @namespace Assert
	   * @api public
	   */

	  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
	    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
	  };

	  /**
	   * ### .notDeepEqual(actual, expected, [message])
	   *
	   * Assert that `actual` is not deeply equal to `expected`.
	   *
	   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
	   *
	   * @name notDeepEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notDeepEqual = function (act, exp, msg) {
	    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
	  };

	   /**
	   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
	   *
	   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
	   *
	   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
	   *
	   * @name isAbove
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeAbove
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isAbove = function (val, abv, msg) {
	    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
	  };

	   /**
	   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
	   *
	   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
	   *
	   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
	   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
	   *
	   * @name isAtLeast
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeAtLeast
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isAtLeast = function (val, atlst, msg) {
	    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
	  };

	   /**
	   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
	   *
	   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
	   *
	   *     assert.isBelow(3, 6, '3 is strictly less than 6');
	   *
	   * @name isBelow
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeBelow
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isBelow = function (val, blw, msg) {
	    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
	  };

	   /**
	   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
	   *
	   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
	   *
	   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
	   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
	   *
	   * @name isAtMost
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeAtMost
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isAtMost = function (val, atmst, msg) {
	    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
	  };

	  /**
	   * ### .isTrue(value, [message])
	   *
	   * Asserts that `value` is true.
	   *
	   *     var teaServed = true;
	   *     assert.isTrue(teaServed, 'the tea has been served');
	   *
	   * @name isTrue
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isTrue = function (val, msg) {
	    new Assertion(val, msg, assert.isTrue, true).is['true'];
	  };

	  /**
	   * ### .isNotTrue(value, [message])
	   *
	   * Asserts that `value` is not true.
	   *
	   *     var tea = 'tasty chai';
	   *     assert.isNotTrue(tea, 'great, time for tea!');
	   *
	   * @name isNotTrue
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotTrue = function (val, msg) {
	    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
	  };

	  /**
	   * ### .isFalse(value, [message])
	   *
	   * Asserts that `value` is false.
	   *
	   *     var teaServed = false;
	   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
	   *
	   * @name isFalse
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isFalse = function (val, msg) {
	    new Assertion(val, msg, assert.isFalse, true).is['false'];
	  };

	  /**
	   * ### .isNotFalse(value, [message])
	   *
	   * Asserts that `value` is not false.
	   *
	   *     var tea = 'tasty chai';
	   *     assert.isNotFalse(tea, 'great, time for tea!');
	   *
	   * @name isNotFalse
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotFalse = function (val, msg) {
	    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
	  };

	  /**
	   * ### .isNull(value, [message])
	   *
	   * Asserts that `value` is null.
	   *
	   *     assert.isNull(err, 'there was no error');
	   *
	   * @name isNull
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNull = function (val, msg) {
	    new Assertion(val, msg, assert.isNull, true).to.equal(null);
	  };

	  /**
	   * ### .isNotNull(value, [message])
	   *
	   * Asserts that `value` is not null.
	   *
	   *     var tea = 'tasty chai';
	   *     assert.isNotNull(tea, 'great, time for tea!');
	   *
	   * @name isNotNull
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotNull = function (val, msg) {
	    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
	  };

	  /**
	   * ### .isNaN
	   *
	   * Asserts that value is NaN.
	   *
	   *     assert.isNaN(NaN, 'NaN is NaN');
	   *
	   * @name isNaN
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNaN = function (val, msg) {
	    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
	  };

	  /**
	   * ### .isNotNaN
	   *
	   * Asserts that value is not NaN.
	   *
	   *     assert.isNotNaN(4, '4 is not NaN');
	   *
	   * @name isNotNaN
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	  assert.isNotNaN = function (val, msg) {
	    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
	  };

	  /**
	   * ### .exists
	   *
	   * Asserts that the target is neither `null` nor `undefined`.
	   *
	   *     var foo = 'hi';
	   *
	   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
	   *
	   * @name exists
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.exists = function (val, msg) {
	    new Assertion(val, msg, assert.exists, true).to.exist;
	  };

	  /**
	   * ### .notExists
	   *
	   * Asserts that the target is either `null` or `undefined`.
	   *
	   *     var bar = null
	   *       , baz;
	   *
	   *     assert.notExists(bar);
	   *     assert.notExists(baz, 'baz is either null or undefined');
	   *
	   * @name notExists
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notExists = function (val, msg) {
	    new Assertion(val, msg, assert.notExists, true).to.not.exist;
	  };

	  /**
	   * ### .isUndefined(value, [message])
	   *
	   * Asserts that `value` is `undefined`.
	   *
	   *     var tea;
	   *     assert.isUndefined(tea, 'no tea defined');
	   *
	   * @name isUndefined
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isUndefined = function (val, msg) {
	    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);
	  };

	  /**
	   * ### .isDefined(value, [message])
	   *
	   * Asserts that `value` is not `undefined`.
	   *
	   *     var tea = 'cup of chai';
	   *     assert.isDefined(tea, 'tea has been defined');
	   *
	   * @name isDefined
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isDefined = function (val, msg) {
	    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);
	  };

	  /**
	   * ### .isFunction(value, [message])
	   *
	   * Asserts that `value` is a function.
	   *
	   *     function serveTea() { return 'cup of tea'; };
	   *     assert.isFunction(serveTea, 'great, we can have tea now');
	   *
	   * @name isFunction
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isFunction = function (val, msg) {
	    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');
	  };

	  /**
	   * ### .isNotFunction(value, [message])
	   *
	   * Asserts that `value` is _not_ a function.
	   *
	   *     var serveTea = [ 'heat', 'pour', 'sip' ];
	   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
	   *
	   * @name isNotFunction
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotFunction = function (val, msg) {
	    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');
	  };

	  /**
	   * ### .isObject(value, [message])
	   *
	   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
	   * _The assertion does not match subclassed objects._
	   *
	   *     var selection = { name: 'Chai', serve: 'with spices' };
	   *     assert.isObject(selection, 'tea selection is an object');
	   *
	   * @name isObject
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isObject = function (val, msg) {
	    new Assertion(val, msg, assert.isObject, true).to.be.a('object');
	  };

	  /**
	   * ### .isNotObject(value, [message])
	   *
	   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
	   *
	   *     var selection = 'chai'
	   *     assert.isNotObject(selection, 'tea selection is not an object');
	   *     assert.isNotObject(null, 'null is not an object');
	   *
	   * @name isNotObject
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotObject = function (val, msg) {
	    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');
	  };

	  /**
	   * ### .isArray(value, [message])
	   *
	   * Asserts that `value` is an array.
	   *
	   *     var menu = [ 'green', 'chai', 'oolong' ];
	   *     assert.isArray(menu, 'what kind of tea do we want?');
	   *
	   * @name isArray
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isArray = function (val, msg) {
	    new Assertion(val, msg, assert.isArray, true).to.be.an('array');
	  };

	  /**
	   * ### .isNotArray(value, [message])
	   *
	   * Asserts that `value` is _not_ an array.
	   *
	   *     var menu = 'green|chai|oolong';
	   *     assert.isNotArray(menu, 'what kind of tea do we want?');
	   *
	   * @name isNotArray
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotArray = function (val, msg) {
	    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');
	  };

	  /**
	   * ### .isString(value, [message])
	   *
	   * Asserts that `value` is a string.
	   *
	   *     var teaOrder = 'chai';
	   *     assert.isString(teaOrder, 'order placed');
	   *
	   * @name isString
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isString = function (val, msg) {
	    new Assertion(val, msg, assert.isString, true).to.be.a('string');
	  };

	  /**
	   * ### .isNotString(value, [message])
	   *
	   * Asserts that `value` is _not_ a string.
	   *
	   *     var teaOrder = 4;
	   *     assert.isNotString(teaOrder, 'order placed');
	   *
	   * @name isNotString
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotString = function (val, msg) {
	    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');
	  };

	  /**
	   * ### .isNumber(value, [message])
	   *
	   * Asserts that `value` is a number.
	   *
	   *     var cups = 2;
	   *     assert.isNumber(cups, 'how many cups');
	   *
	   * @name isNumber
	   * @param {Number} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNumber = function (val, msg) {
	    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');
	  };

	  /**
	   * ### .isNotNumber(value, [message])
	   *
	   * Asserts that `value` is _not_ a number.
	   *
	   *     var cups = '2 cups please';
	   *     assert.isNotNumber(cups, 'how many cups');
	   *
	   * @name isNotNumber
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotNumber = function (val, msg) {
	    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');
	  };

	   /**
	   * ### .isFinite(value, [message])
	   *
	   * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
	   *
	   *     var cups = 2;
	   *     assert.isFinite(cups, 'how many cups');
	   *
	   *     assert.isFinite(NaN); // throws
	   *
	   * @name isFinite
	   * @param {Number} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isFinite = function (val, msg) {
	    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
	  };

	  /**
	   * ### .isBoolean(value, [message])
	   *
	   * Asserts that `value` is a boolean.
	   *
	   *     var teaReady = true
	   *       , teaServed = false;
	   *
	   *     assert.isBoolean(teaReady, 'is the tea ready');
	   *     assert.isBoolean(teaServed, 'has tea been served');
	   *
	   * @name isBoolean
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isBoolean = function (val, msg) {
	    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');
	  };

	  /**
	   * ### .isNotBoolean(value, [message])
	   *
	   * Asserts that `value` is _not_ a boolean.
	   *
	   *     var teaReady = 'yep'
	   *       , teaServed = 'nope';
	   *
	   *     assert.isNotBoolean(teaReady, 'is the tea ready');
	   *     assert.isNotBoolean(teaServed, 'has tea been served');
	   *
	   * @name isNotBoolean
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotBoolean = function (val, msg) {
	    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');
	  };

	  /**
	   * ### .typeOf(value, name, [message])
	   *
	   * Asserts that `value`'s type is `name`, as determined by
	   * `Object.prototype.toString`.
	   *
	   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
	   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
	   *     assert.typeOf('tea', 'string', 'we have a string');
	   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
	   *     assert.typeOf(null, 'null', 'we have a null');
	   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
	   *
	   * @name typeOf
	   * @param {Mixed} value
	   * @param {String} name
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.typeOf = function (val, type, msg) {
	    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
	  };

	  /**
	   * ### .notTypeOf(value, name, [message])
	   *
	   * Asserts that `value`'s type is _not_ `name`, as determined by
	   * `Object.prototype.toString`.
	   *
	   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
	   *
	   * @name notTypeOf
	   * @param {Mixed} value
	   * @param {String} typeof name
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notTypeOf = function (val, type, msg) {
	    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
	  };

	  /**
	   * ### .instanceOf(object, constructor, [message])
	   *
	   * Asserts that `value` is an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , chai = new Tea('chai');
	   *
	   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
	   *
	   * @name instanceOf
	   * @param {Object} object
	   * @param {Constructor} constructor
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.instanceOf = function (val, type, msg) {
	    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
	  };

	  /**
	   * ### .notInstanceOf(object, constructor, [message])
	   *
	   * Asserts `value` is not an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , chai = new String('chai');
	   *
	   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
	   *
	   * @name notInstanceOf
	   * @param {Object} object
	   * @param {Constructor} constructor
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notInstanceOf = function (val, type, msg) {
	    new Assertion(val, msg, assert.notInstanceOf, true)
	      .to.not.be.instanceOf(type);
	  };

	  /**
	   * ### .include(haystack, needle, [message])
	   *
	   * Asserts that `haystack` includes `needle`. Can be used to assert the
	   * inclusion of a value in an array, a substring in a string, or a subset of
	   * properties in an object.
	   *
	   *     assert.include([1,2,3], 2, 'array contains value');
	   *     assert.include('foobar', 'foo', 'string contains substring');
	   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
	   *
	   * Strict equality (===) is used. When asserting the inclusion of a value in
	   * an array, the array is searched for an element that's strictly equal to the
	   * given value. When asserting a subset of properties in an object, the object
	   * is searched for the given property keys, checking that each one is present
	   * and strictly equal to the given property value. For instance:
	   *
	   *     var obj1 = {a: 1}
	   *       , obj2 = {b: 2};
	   *     assert.include([obj1, obj2], obj1);
	   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
	   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
	   *
	   * @name include
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.include = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.include, true).include(inc);
	  };

	  /**
	   * ### .notInclude(haystack, needle, [message])
	   *
	   * Asserts that `haystack` does not include `needle`. Can be used to assert
	   * the absence of a value in an array, a substring in a string, or a subset of
	   * properties in an object.
	   *
	   *     assert.notInclude([1,2,3], 4, "array doesn't contain value");
	   *     assert.notInclude('foobar', 'baz', "string doesn't contain substring");
	   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
	   *
	   * Strict equality (===) is used. When asserting the absence of a value in an
	   * array, the array is searched to confirm the absence of an element that's
	   * strictly equal to the given value. When asserting a subset of properties in
	   * an object, the object is searched to confirm that at least one of the given
	   * property keys is either not present or not strictly equal to the given
	   * property value. For instance:
	   *
	   *     var obj1 = {a: 1}
	   *       , obj2 = {b: 2};
	   *     assert.notInclude([obj1, obj2], {a: 1});
	   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
	   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
	   *
	   * @name notInclude
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notInclude = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
	  };

	  /**
	   * ### .deepInclude(haystack, needle, [message])
	   *
	   * Asserts that `haystack` includes `needle`. Can be used to assert the
	   * inclusion of a value in an array or a subset of properties in an object.
	   * Deep equality is used.
	   *
	   *     var obj1 = {a: 1}
	   *       , obj2 = {b: 2};
	   *     assert.deepInclude([obj1, obj2], {a: 1});
	   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
	   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
	   *
	   * @name deepInclude
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.deepInclude = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
	  };

	  /**
	   * ### .notDeepInclude(haystack, needle, [message])
	   *
	   * Asserts that `haystack` does not include `needle`. Can be used to assert
	   * the absence of a value in an array or a subset of properties in an object.
	   * Deep equality is used.
	   *
	   *     var obj1 = {a: 1}
	   *       , obj2 = {b: 2};
	   *     assert.notDeepInclude([obj1, obj2], {a: 9});
	   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
	   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
	   *
	   * @name notDeepInclude
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notDeepInclude = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
	  };

	  /**
	   * ### .nestedInclude(haystack, needle, [message])
	   *
	   * Asserts that 'haystack' includes 'needle'.
	   * Can be used to assert the inclusion of a subset of properties in an
	   * object.
	   * Enables the use of dot- and bracket-notation for referencing nested
	   * properties.
	   * '[]' and '.' in property names can be escaped using double backslashes.
	   *
	   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
	   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
	   *
	   * @name nestedInclude
	   * @param {Object} haystack
	   * @param {Object} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.nestedInclude = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
	  };

	  /**
	   * ### .notNestedInclude(haystack, needle, [message])
	   *
	   * Asserts that 'haystack' does not include 'needle'.
	   * Can be used to assert the absence of a subset of properties in an
	   * object.
	   * Enables the use of dot- and bracket-notation for referencing nested
	   * properties.
	   * '[]' and '.' in property names can be escaped using double backslashes.
	   *
	   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
	   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
	   *
	   * @name notNestedInclude
	   * @param {Object} haystack
	   * @param {Object} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notNestedInclude = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.notNestedInclude, true)
	      .not.nested.include(inc);
	  };

	  /**
	   * ### .deepNestedInclude(haystack, needle, [message])
	   *
	   * Asserts that 'haystack' includes 'needle'.
	   * Can be used to assert the inclusion of a subset of properties in an
	   * object while checking for deep equality.
	   * Enables the use of dot- and bracket-notation for referencing nested
	   * properties.
	   * '[]' and '.' in property names can be escaped using double backslashes.
	   *
	   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
	   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
	   *
	   * @name deepNestedInclude
	   * @param {Object} haystack
	   * @param {Object} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.deepNestedInclude = function(exp, inc, msg) {
	    new Assertion(exp, msg, assert.deepNestedInclude, true)
	      .deep.nested.include(inc);
	  };

	  /**
	   * ### .notDeepNestedInclude(haystack, needle, [message])
	   *
	   * Asserts that 'haystack' does not include 'needle'.
	   * Can be used to assert the absence of a subset of properties in an
	   * object while checking for deep equality.
	   * Enables the use of dot- and bracket-notation for referencing nested
	   * properties.
	   * '[]' and '.' in property names can be escaped using double backslashes.
	   *
	   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
	   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
	   *
	   * @name notDeepNestedInclude
	   * @param {Object} haystack
	   * @param {Object} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notDeepNestedInclude = function(exp, inc, msg) {
	    new Assertion(exp, msg, assert.notDeepNestedInclude, true)
	      .not.deep.nested.include(inc);
	  };

	  /**
	   * ### .ownInclude(haystack, needle, [message])
	   *
	   * Asserts that 'haystack' includes 'needle'.
	   * Can be used to assert the inclusion of a subset of properties in an
	   * object while ignoring inherited properties.
	   *
	   *     assert.ownInclude({ a: 1 }, { a: 1 });
	   *
	   * @name ownInclude
	   * @param {Object} haystack
	   * @param {Object} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.ownInclude = function(exp, inc, msg) {
	    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
	  };

	  /**
	   * ### .notOwnInclude(haystack, needle, [message])
	   *
	   * Asserts that 'haystack' includes 'needle'.
	   * Can be used to assert the absence of a subset of properties in an
	   * object while ignoring inherited properties.
	   *
	   *     Object.prototype.b = 2;
	   *
	   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
	   *
	   * @name notOwnInclude
	   * @param {Object} haystack
	   * @param {Object} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notOwnInclude = function(exp, inc, msg) {
	    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
	  };

	  /**
	   * ### .deepOwnInclude(haystack, needle, [message])
	   *
	   * Asserts that 'haystack' includes 'needle'.
	   * Can be used to assert the inclusion of a subset of properties in an
	   * object while ignoring inherited properties and checking for deep equality.
	   *
	   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
	   *
	   * @name deepOwnInclude
	   * @param {Object} haystack
	   * @param {Object} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.deepOwnInclude = function(exp, inc, msg) {
	    new Assertion(exp, msg, assert.deepOwnInclude, true)
	      .deep.own.include(inc);
	  };

	   /**
	   * ### .notDeepOwnInclude(haystack, needle, [message])
	   *
	   * Asserts that 'haystack' includes 'needle'.
	   * Can be used to assert the absence of a subset of properties in an
	   * object while ignoring inherited properties and checking for deep equality.
	   *
	   *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
	   *
	   * @name notDeepOwnInclude
	   * @param {Object} haystack
	   * @param {Object} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notDeepOwnInclude = function(exp, inc, msg) {
	    new Assertion(exp, msg, assert.notDeepOwnInclude, true)
	      .not.deep.own.include(inc);
	  };

	  /**
	   * ### .match(value, regexp, [message])
	   *
	   * Asserts that `value` matches the regular expression `regexp`.
	   *
	   *     assert.match('foobar', /^foo/, 'regexp matches');
	   *
	   * @name match
	   * @param {Mixed} value
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.match = function (exp, re, msg) {
	    new Assertion(exp, msg, assert.match, true).to.match(re);
	  };

	  /**
	   * ### .notMatch(value, regexp, [message])
	   *
	   * Asserts that `value` does not match the regular expression `regexp`.
	   *
	   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
	   *
	   * @name notMatch
	   * @param {Mixed} value
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notMatch = function (exp, re, msg) {
	    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
	  };

	  /**
	   * ### .property(object, property, [message])
	   *
	   * Asserts that `object` has a direct or inherited property named by
	   * `property`.
	   *
	   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
	   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
	   *
	   * @name property
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.property = function (obj, prop, msg) {
	    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
	  };

	  /**
	   * ### .notProperty(object, property, [message])
	   *
	   * Asserts that `object` does _not_ have a direct or inherited property named
	   * by `property`.
	   *
	   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
	   *
	   * @name notProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg, assert.notProperty, true)
	      .to.not.have.property(prop);
	  };

	  /**
	   * ### .propertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a direct or inherited property named by
	   * `property` with a value given by `value`. Uses a strict equality check
	   * (===).
	   *
	   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
	   *
	   * @name propertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.propertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg, assert.propertyVal, true)
	      .to.have.property(prop, val);
	  };

	  /**
	   * ### .notPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` does _not_ have a direct or inherited property named
	   * by `property` with value given by `value`. Uses a strict equality check
	   * (===).
	   *
	   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
	   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
	   *
	   * @name notPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg, assert.notPropertyVal, true)
	      .to.not.have.property(prop, val);
	  };

	  /**
	   * ### .deepPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a direct or inherited property named by
	   * `property` with a value given by `value`. Uses a deep equality check.
	   *
	   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
	   *
	   * @name deepPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.deepPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg, assert.deepPropertyVal, true)
	      .to.have.deep.property(prop, val);
	  };

	  /**
	   * ### .notDeepPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` does _not_ have a direct or inherited property named
	   * by `property` with value given by `value`. Uses a deep equality check.
	   *
	   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
	   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
	   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
	   *
	   * @name notDeepPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notDeepPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg, assert.notDeepPropertyVal, true)
	      .to.not.have.deep.property(prop, val);
	  };

	  /**
	   * ### .ownProperty(object, property, [message])
	   *
	   * Asserts that `object` has a direct property named by `property`. Inherited
	   * properties aren't checked.
	   *
	   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
	   *
	   * @name ownProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.ownProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg, assert.ownProperty, true)
	      .to.have.own.property(prop);
	  };

	  /**
	   * ### .notOwnProperty(object, property, [message])
	   *
	   * Asserts that `object` does _not_ have a direct property named by
	   * `property`. Inherited properties aren't checked.
	   *
	   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
	   *     assert.notOwnProperty({}, 'toString');
	   *
	   * @name notOwnProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.notOwnProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg, assert.notOwnProperty, true)
	      .to.not.have.own.property(prop);
	  };

	  /**
	   * ### .ownPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a direct property named by `property` and a value
	   * equal to the provided `value`. Uses a strict equality check (===).
	   * Inherited properties aren't checked.
	   *
	   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
	   *
	   * @name ownPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.ownPropertyVal = function (obj, prop, value, msg) {
	    new Assertion(obj, msg, assert.ownPropertyVal, true)
	      .to.have.own.property(prop, value);
	  };

	  /**
	   * ### .notOwnPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` does _not_ have a direct property named by `property`
	   * with a value equal to the provided `value`. Uses a strict equality check
	   * (===). Inherited properties aren't checked.
	   *
	   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
	   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
	   *
	   * @name notOwnPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.notOwnPropertyVal = function (obj, prop, value, msg) {
	    new Assertion(obj, msg, assert.notOwnPropertyVal, true)
	      .to.not.have.own.property(prop, value);
	  };

	  /**
	   * ### .deepOwnPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a direct property named by `property` and a value
	   * equal to the provided `value`. Uses a deep equality check. Inherited
	   * properties aren't checked.
	   *
	   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
	   *
	   * @name deepOwnPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
	    new Assertion(obj, msg, assert.deepOwnPropertyVal, true)
	      .to.have.deep.own.property(prop, value);
	  };

	  /**
	   * ### .notDeepOwnPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` does _not_ have a direct property named by `property`
	   * with a value equal to the provided `value`. Uses a deep equality check.
	   * Inherited properties aren't checked.
	   *
	   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
	   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
	   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
	   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
	   *
	   * @name notDeepOwnPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
	    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true)
	      .to.not.have.deep.own.property(prop, value);
	  };

	  /**
	   * ### .nestedProperty(object, property, [message])
	   *
	   * Asserts that `object` has a direct or inherited property named by
	   * `property`, which can be a string using dot- and bracket-notation for
	   * nested reference.
	   *
	   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
	   *
	   * @name nestedProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.nestedProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg, assert.nestedProperty, true)
	      .to.have.nested.property(prop);
	  };

	  /**
	   * ### .notNestedProperty(object, property, [message])
	   *
	   * Asserts that `object` does _not_ have a property named by `property`, which
	   * can be a string using dot- and bracket-notation for nested reference. The
	   * property cannot exist on the object nor anywhere in its prototype chain.
	   *
	   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
	   *
	   * @name notNestedProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notNestedProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg, assert.notNestedProperty, true)
	      .to.not.have.nested.property(prop);
	  };

	  /**
	   * ### .nestedPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property` with value given
	   * by `value`. `property` can use dot- and bracket-notation for nested
	   * reference. Uses a strict equality check (===).
	   *
	   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
	   *
	   * @name nestedPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.nestedPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg, assert.nestedPropertyVal, true)
	      .to.have.nested.property(prop, val);
	  };

	  /**
	   * ### .notNestedPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` does _not_ have a property named by `property` with
	   * value given by `value`. `property` can use dot- and bracket-notation for
	   * nested reference. Uses a strict equality check (===).
	   *
	   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
	   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
	   *
	   * @name notNestedPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notNestedPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg, assert.notNestedPropertyVal, true)
	      .to.not.have.nested.property(prop, val);
	  };

	  /**
	   * ### .deepNestedPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property` with a value given
	   * by `value`. `property` can use dot- and bracket-notation for nested
	   * reference. Uses a deep equality check.
	   *
	   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
	   *
	   * @name deepNestedPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg, assert.deepNestedPropertyVal, true)
	      .to.have.deep.nested.property(prop, val);
	  };

	  /**
	   * ### .notDeepNestedPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` does _not_ have a property named by `property` with
	   * value given by `value`. `property` can use dot- and bracket-notation for
	   * nested reference. Uses a deep equality check.
	   *
	   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
	   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
	   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
	   *
	   * @name notDeepNestedPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true)
	      .to.not.have.deep.nested.property(prop, val);
	  };

	  /**
	   * ### .lengthOf(object, length, [message])
	   *
	   * Asserts that `object` has a `length` or `size` with the expected value.
	   *
	   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
	   *     assert.lengthOf('foobar', 6, 'string has length of 6');
	   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
	   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
	   *
	   * @name lengthOf
	   * @param {Mixed} object
	   * @param {Number} length
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.lengthOf = function (exp, len, msg) {
	    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
	  };

	  /**
	   * ### .hasAnyKeys(object, [keys], [message])
	   *
	   * Asserts that `object` has at least one of the `keys` provided.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
	   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
	   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
	   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
	   *
	   * @name hasAnyKeys
	   * @param {Mixed} object
	   * @param {Array|Object} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.hasAnyKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
	  };

	  /**
	   * ### .hasAllKeys(object, [keys], [message])
	   *
	   * Asserts that `object` has all and only all of the `keys` provided.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
	   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
	   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
	   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
	   *
	   * @name hasAllKeys
	   * @param {Mixed} object
	   * @param {String[]} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.hasAllKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
	  };

	  /**
	   * ### .containsAllKeys(object, [keys], [message])
	   *
	   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
	   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
	   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
	   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
	   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
	   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
	   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
	   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
	   *
	   * @name containsAllKeys
	   * @param {Mixed} object
	   * @param {String[]} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.containsAllKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.containsAllKeys, true)
	      .to.contain.all.keys(keys);
	  };

	  /**
	   * ### .doesNotHaveAnyKeys(object, [keys], [message])
	   *
	   * Asserts that `object` has none of the `keys` provided.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
	   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
	   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
	   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
	   *
	   * @name doesNotHaveAnyKeys
	   * @param {Mixed} object
	   * @param {String[]} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true)
	      .to.not.have.any.keys(keys);
	  };

	  /**
	   * ### .doesNotHaveAllKeys(object, [keys], [message])
	   *
	   * Asserts that `object` does not have at least one of the `keys` provided.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
	   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
	   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
	   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
	   *
	   * @name doesNotHaveAllKeys
	   * @param {Mixed} object
	   * @param {String[]} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.doesNotHaveAllKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true)
	      .to.not.have.all.keys(keys);
	  };

	  /**
	   * ### .hasAnyDeepKeys(object, [keys], [message])
	   *
	   * Asserts that `object` has at least one of the `keys` provided.
	   * Since Sets and Maps can have objects as keys you can use this assertion to perform
	   * a deep comparison.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
	   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
	   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
	   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
	   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
	   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
	   *
	   * @name hasAnyDeepKeys
	   * @param {Mixed} object
	   * @param {Array|Object} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.hasAnyDeepKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.hasAnyDeepKeys, true)
	      .to.have.any.deep.keys(keys);
	  };

	 /**
	   * ### .hasAllDeepKeys(object, [keys], [message])
	   *
	   * Asserts that `object` has all and only all of the `keys` provided.
	   * Since Sets and Maps can have objects as keys you can use this assertion to perform
	   * a deep comparison.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
	   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
	   *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
	   *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
	   *
	   * @name hasAllDeepKeys
	   * @param {Mixed} object
	   * @param {Array|Object} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.hasAllDeepKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.hasAllDeepKeys, true)
	      .to.have.all.deep.keys(keys);
	  };

	 /**
	   * ### .containsAllDeepKeys(object, [keys], [message])
	   *
	   * Asserts that `object` contains all of the `keys` provided.
	   * Since Sets and Maps can have objects as keys you can use this assertion to perform
	   * a deep comparison.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
	   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
	   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
	   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
	   *
	   * @name containsAllDeepKeys
	   * @param {Mixed} object
	   * @param {Array|Object} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.containsAllDeepKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.containsAllDeepKeys, true)
	      .to.contain.all.deep.keys(keys);
	  };

	 /**
	   * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
	   *
	   * Asserts that `object` has none of the `keys` provided.
	   * Since Sets and Maps can have objects as keys you can use this assertion to perform
	   * a deep comparison.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
	   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
	   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
	   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
	   *
	   * @name doesNotHaveAnyDeepKeys
	   * @param {Mixed} object
	   * @param {Array|Object} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true)
	      .to.not.have.any.deep.keys(keys);
	  };

	 /**
	   * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
	   *
	   * Asserts that `object` does not have at least one of the `keys` provided.
	   * Since Sets and Maps can have objects as keys you can use this assertion to perform
	   * a deep comparison.
	   * You can also provide a single object instead of a `keys` array and its keys
	   * will be used as the expected set of keys.
	   *
	   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
	   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
	   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
	   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
	   *
	   * @name doesNotHaveAllDeepKeys
	   * @param {Mixed} object
	   * @param {Array|Object} keys
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
	    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true)
	      .to.not.have.all.deep.keys(keys);
	  };

	 /**
	   * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
	   *
	   * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
	   * instance of `errorLike`.
	   * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
	   * instance as `errorLike`.
	   * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
	   * message matching `errMsgMatcher`.
	   *
	   *     assert.throws(fn, 'Error thrown must have this msg');
	   *     assert.throws(fn, /Error thrown must have a msg that matches this/);
	   *     assert.throws(fn, ReferenceError);
	   *     assert.throws(fn, errorInstance);
	   *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
	   *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
	   *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
	   *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
	   *
	   * @name throws
	   * @alias throw
	   * @alias Throw
	   * @param {Function} fn
	   * @param {ErrorConstructor|Error} errorLike
	   * @param {RegExp|String} errMsgMatcher
	   * @param {String} message
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @namespace Assert
	   * @api public
	   */

	  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
	    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
	      errMsgMatcher = errorLike;
	      errorLike = null;
	    }

	    var assertErr = new Assertion(fn, msg, assert.throws, true)
	      .to.throw(errorLike, errMsgMatcher);
	    return flag(assertErr, 'object');
	  };

	  /**
	   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
	   *
	   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
	   * instance of `errorLike`.
	   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
	   * instance as `errorLike`.
	   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
	   * message matching `errMsgMatcher`.
	   *
	   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
	   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
	   *     assert.doesNotThrow(fn, Error);
	   *     assert.doesNotThrow(fn, errorInstance);
	   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
	   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
	   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
	   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
	   *
	   * @name doesNotThrow
	   * @param {Function} fn
	   * @param {ErrorConstructor} errorLike
	   * @param {RegExp|String} errMsgMatcher
	   * @param {String} message
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @namespace Assert
	   * @api public
	   */

	  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
	    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
	      errMsgMatcher = errorLike;
	      errorLike = null;
	    }

	    new Assertion(fn, msg, assert.doesNotThrow, true)
	      .to.not.throw(errorLike, errMsgMatcher);
	  };

	  /**
	   * ### .operator(val1, operator, val2, [message])
	   *
	   * Compares two values using `operator`.
	   *
	   *     assert.operator(1, '<', 2, 'everything is ok');
	   *     assert.operator(1, '>', 2, 'this will fail');
	   *
	   * @name operator
	   * @param {Mixed} val1
	   * @param {String} operator
	   * @param {Mixed} val2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.operator = function (val, operator, val2, msg) {
	    var ok;
	    switch(operator) {
	      case '==':
	        ok = val == val2;
	        break;
	      case '===':
	        ok = val === val2;
	        break;
	      case '>':
	        ok = val > val2;
	        break;
	      case '>=':
	        ok = val >= val2;
	        break;
	      case '<':
	        ok = val < val2;
	        break;
	      case '<=':
	        ok = val <= val2;
	        break;
	      case '!=':
	        ok = val != val2;
	        break;
	      case '!==':
	        ok = val !== val2;
	        break;
	      default:
	        msg = msg ? msg + ': ' : msg;
	        throw new chai.AssertionError(
	          msg + 'Invalid operator "' + operator + '"',
	          undefined,
	          assert.operator
	        );
	    }
	    var test = new Assertion(ok, msg, assert.operator, true);
	    test.assert(
	        true === flag(test, 'object')
	      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
	      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
	  };

	  /**
	   * ### .closeTo(actual, expected, delta, [message])
	   *
	   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
	   *
	   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
	   *
	   * @name closeTo
	   * @param {Number} actual
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.closeTo = function (act, exp, delta, msg) {
	    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
	  };

	  /**
	   * ### .approximately(actual, expected, delta, [message])
	   *
	   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
	   *
	   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
	   *
	   * @name approximately
	   * @param {Number} actual
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.approximately = function (act, exp, delta, msg) {
	    new Assertion(act, msg, assert.approximately, true)
	      .to.be.approximately(exp, delta);
	  };

	  /**
	   * ### .sameMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` have the same members in any order. Uses a
	   * strict equality check (===).
	   *
	   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
	   *
	   * @name sameMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.sameMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg, assert.sameMembers, true)
	      .to.have.same.members(set2);
	  };

	  /**
	   * ### .notSameMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` don't have the same members in any order.
	   * Uses a strict equality check (===).
	   *
	   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
	   *
	   * @name notSameMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notSameMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg, assert.notSameMembers, true)
	      .to.not.have.same.members(set2);
	  };

	  /**
	   * ### .sameDeepMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` have the same members in any order. Uses a
	   * deep equality check.
	   *
	   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
	   *
	   * @name sameDeepMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.sameDeepMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg, assert.sameDeepMembers, true)
	      .to.have.same.deep.members(set2);
	  };

	  /**
	   * ### .notSameDeepMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` don't have the same members in any order.
	   * Uses a deep equality check.
	   *
	   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
	   *
	   * @name notSameDeepMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notSameDeepMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg, assert.notSameDeepMembers, true)
	      .to.not.have.same.deep.members(set2);
	  };

	  /**
	   * ### .sameOrderedMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` have the same members in the same order.
	   * Uses a strict equality check (===).
	   *
	   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
	   *
	   * @name sameOrderedMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.sameOrderedMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg, assert.sameOrderedMembers, true)
	      .to.have.same.ordered.members(set2);
	  };

	  /**
	   * ### .notSameOrderedMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` don't have the same members in the same
	   * order. Uses a strict equality check (===).
	   *
	   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
	   *
	   * @name notSameOrderedMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notSameOrderedMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg, assert.notSameOrderedMembers, true)
	      .to.not.have.same.ordered.members(set2);
	  };

	  /**
	   * ### .sameDeepOrderedMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` have the same members in the same order.
	   * Uses a deep equality check.
	   *
	   *     assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
	   *
	   * @name sameDeepOrderedMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.sameDeepOrderedMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true)
	      .to.have.same.deep.ordered.members(set2);
	  };

	  /**
	   * ### .notSameDeepOrderedMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` don't have the same members in the same
	   * order. Uses a deep equality check.
	   *
	   *     assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
	   *     assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
	   *
	   * @name notSameDeepOrderedMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true)
	      .to.not.have.same.deep.ordered.members(set2);
	  };

	  /**
	   * ### .includeMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` is included in `superset` in any order. Uses a
	   * strict equality check (===). Duplicates are ignored.
	   *
	   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
	   *
	   * @name includeMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.includeMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg, assert.includeMembers, true)
	      .to.include.members(subset);
	  };

	  /**
	   * ### .notIncludeMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` isn't included in `superset` in any order. Uses a
	   * strict equality check (===). Duplicates are ignored.
	   *
	   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
	   *
	   * @name notIncludeMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notIncludeMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg, assert.notIncludeMembers, true)
	      .to.not.include.members(subset);
	  };

	  /**
	   * ### .includeDeepMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` is included in `superset` in any order. Uses a deep
	   * equality check. Duplicates are ignored.
	   *
	   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
	   *
	   * @name includeDeepMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.includeDeepMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg, assert.includeDeepMembers, true)
	      .to.include.deep.members(subset);
	  };

	  /**
	   * ### .notIncludeDeepMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` isn't included in `superset` in any order. Uses a
	   * deep equality check. Duplicates are ignored.
	   *
	   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
	   *
	   * @name notIncludeDeepMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notIncludeDeepMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg, assert.notIncludeDeepMembers, true)
	      .to.not.include.deep.members(subset);
	  };

	  /**
	   * ### .includeOrderedMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` is included in `superset` in the same order
	   * beginning with the first element in `superset`. Uses a strict equality
	   * check (===).
	   *
	   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
	   *
	   * @name includeOrderedMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.includeOrderedMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg, assert.includeOrderedMembers, true)
	      .to.include.ordered.members(subset);
	  };

	  /**
	   * ### .notIncludeOrderedMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` isn't included in `superset` in the same order
	   * beginning with the first element in `superset`. Uses a strict equality
	   * check (===).
	   *
	   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
	   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
	   *
	   * @name notIncludeOrderedMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notIncludeOrderedMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true)
	      .to.not.include.ordered.members(subset);
	  };

	  /**
	   * ### .includeDeepOrderedMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` is included in `superset` in the same order
	   * beginning with the first element in `superset`. Uses a deep equality
	   * check.
	   *
	   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
	   *
	   * @name includeDeepOrderedMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.includeDeepOrderedMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true)
	      .to.include.deep.ordered.members(subset);
	  };

	  /**
	   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` isn't included in `superset` in the same order
	   * beginning with the first element in `superset`. Uses a deep equality
	   * check.
	   *
	   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
	   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
	   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
	   *
	   * @name notIncludeDeepOrderedMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true)
	      .to.not.include.deep.ordered.members(subset);
	  };

	  /**
	   * ### .oneOf(inList, list, [message])
	   *
	   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
	   *
	   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
	   *
	   * @name oneOf
	   * @param {*} inList
	   * @param {Array<*>} list
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */

	  assert.oneOf = function (inList, list, msg) {
	    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
	  };

	  /**
	   * ### .changes(function, object, property, [message])
	   *
	   * Asserts that a function changes the value of a property.
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 22 };
	   *     assert.changes(fn, obj, 'val');
	   *
	   * @name changes
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.changes = function (fn, obj, prop, msg) {
	    if (arguments.length === 3 && typeof obj === 'function') {
	      msg = prop;
	      prop = null;
	    }

	    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
	  };

	   /**
	   * ### .changesBy(function, object, property, delta, [message])
	   *
	   * Asserts that a function changes the value of a property by an amount (delta).
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val += 2 };
	   *     assert.changesBy(fn, obj, 'val', 2);
	   *
	   * @name changesBy
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {Number} change amount (delta)
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.changesBy = function (fn, obj, prop, delta, msg) {
	    if (arguments.length === 4 && typeof obj === 'function') {
	      var tmpMsg = delta;
	      delta = prop;
	      msg = tmpMsg;
	    } else if (arguments.length === 3) {
	      delta = prop;
	      prop = null;
	    }

	    new Assertion(fn, msg, assert.changesBy, true)
	      .to.change(obj, prop).by(delta);
	  };

	   /**
	   * ### .doesNotChange(function, object, property, [message])
	   *
	   * Asserts that a function does not change the value of a property.
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { console.log('foo'); };
	   *     assert.doesNotChange(fn, obj, 'val');
	   *
	   * @name doesNotChange
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.doesNotChange = function (fn, obj, prop, msg) {
	    if (arguments.length === 3 && typeof obj === 'function') {
	      msg = prop;
	      prop = null;
	    }

	    return new Assertion(fn, msg, assert.doesNotChange, true)
	      .to.not.change(obj, prop);
	  };

	  /**
	   * ### .changesButNotBy(function, object, property, delta, [message])
	   *
	   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val += 10 };
	   *     assert.changesButNotBy(fn, obj, 'val', 5);
	   *
	   * @name changesButNotBy
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {Number} change amount (delta)
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
	    if (arguments.length === 4 && typeof obj === 'function') {
	      var tmpMsg = delta;
	      delta = prop;
	      msg = tmpMsg;
	    } else if (arguments.length === 3) {
	      delta = prop;
	      prop = null;
	    }

	    new Assertion(fn, msg, assert.changesButNotBy, true)
	      .to.change(obj, prop).but.not.by(delta);
	  };

	  /**
	   * ### .increases(function, object, property, [message])
	   *
	   * Asserts that a function increases a numeric object property.
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 13 };
	   *     assert.increases(fn, obj, 'val');
	   *
	   * @name increases
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.increases = function (fn, obj, prop, msg) {
	    if (arguments.length === 3 && typeof obj === 'function') {
	      msg = prop;
	      prop = null;
	    }

	    return new Assertion(fn, msg, assert.increases, true)
	      .to.increase(obj, prop);
	  };

	  /**
	   * ### .increasesBy(function, object, property, delta, [message])
	   *
	   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val += 10 };
	   *     assert.increasesBy(fn, obj, 'val', 10);
	   *
	   * @name increasesBy
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {Number} change amount (delta)
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.increasesBy = function (fn, obj, prop, delta, msg) {
	    if (arguments.length === 4 && typeof obj === 'function') {
	      var tmpMsg = delta;
	      delta = prop;
	      msg = tmpMsg;
	    } else if (arguments.length === 3) {
	      delta = prop;
	      prop = null;
	    }

	    new Assertion(fn, msg, assert.increasesBy, true)
	      .to.increase(obj, prop).by(delta);
	  };

	  /**
	   * ### .doesNotIncrease(function, object, property, [message])
	   *
	   * Asserts that a function does not increase a numeric object property.
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 8 };
	   *     assert.doesNotIncrease(fn, obj, 'val');
	   *
	   * @name doesNotIncrease
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.doesNotIncrease = function (fn, obj, prop, msg) {
	    if (arguments.length === 3 && typeof obj === 'function') {
	      msg = prop;
	      prop = null;
	    }

	    return new Assertion(fn, msg, assert.doesNotIncrease, true)
	      .to.not.increase(obj, prop);
	  };

	  /**
	   * ### .increasesButNotBy(function, object, property, delta, [message])
	   *
	   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 15 };
	   *     assert.increasesButNotBy(fn, obj, 'val', 10);
	   *
	   * @name increasesButNotBy
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {Number} change amount (delta)
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
	    if (arguments.length === 4 && typeof obj === 'function') {
	      var tmpMsg = delta;
	      delta = prop;
	      msg = tmpMsg;
	    } else if (arguments.length === 3) {
	      delta = prop;
	      prop = null;
	    }

	    new Assertion(fn, msg, assert.increasesButNotBy, true)
	      .to.increase(obj, prop).but.not.by(delta);
	  };

	  /**
	   * ### .decreases(function, object, property, [message])
	   *
	   * Asserts that a function decreases a numeric object property.
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 5 };
	   *     assert.decreases(fn, obj, 'val');
	   *
	   * @name decreases
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.decreases = function (fn, obj, prop, msg) {
	    if (arguments.length === 3 && typeof obj === 'function') {
	      msg = prop;
	      prop = null;
	    }

	    return new Assertion(fn, msg, assert.decreases, true)
	      .to.decrease(obj, prop);
	  };

	  /**
	   * ### .decreasesBy(function, object, property, delta, [message])
	   *
	   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val -= 5 };
	   *     assert.decreasesBy(fn, obj, 'val', 5);
	   *
	   * @name decreasesBy
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {Number} change amount (delta)
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.decreasesBy = function (fn, obj, prop, delta, msg) {
	    if (arguments.length === 4 && typeof obj === 'function') {
	      var tmpMsg = delta;
	      delta = prop;
	      msg = tmpMsg;
	    } else if (arguments.length === 3) {
	      delta = prop;
	      prop = null;
	    }

	    new Assertion(fn, msg, assert.decreasesBy, true)
	      .to.decrease(obj, prop).by(delta);
	  };

	  /**
	   * ### .doesNotDecrease(function, object, property, [message])
	   *
	   * Asserts that a function does not decreases a numeric object property.
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 15 };
	   *     assert.doesNotDecrease(fn, obj, 'val');
	   *
	   * @name doesNotDecrease
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.doesNotDecrease = function (fn, obj, prop, msg) {
	    if (arguments.length === 3 && typeof obj === 'function') {
	      msg = prop;
	      prop = null;
	    }

	    return new Assertion(fn, msg, assert.doesNotDecrease, true)
	      .to.not.decrease(obj, prop);
	  };

	  /**
	   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
	   *
	   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 5 };
	   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
	   *
	   * @name doesNotDecreaseBy
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {Number} change amount (delta)
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
	    if (arguments.length === 4 && typeof obj === 'function') {
	      var tmpMsg = delta;
	      delta = prop;
	      msg = tmpMsg;
	    } else if (arguments.length === 3) {
	      delta = prop;
	      prop = null;
	    }

	    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true)
	      .to.not.decrease(obj, prop).by(delta);
	  };

	  /**
	   * ### .decreasesButNotBy(function, object, property, delta, [message])
	   *
	   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 5 };
	   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
	   *
	   * @name decreasesButNotBy
	   * @param {Function} modifier function
	   * @param {Object} object or getter function
	   * @param {String} property name _optional_
	   * @param {Number} change amount (delta)
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
	    if (arguments.length === 4 && typeof obj === 'function') {
	      var tmpMsg = delta;
	      delta = prop;
	      msg = tmpMsg;
	    } else if (arguments.length === 3) {
	      delta = prop;
	      prop = null;
	    }

	    new Assertion(fn, msg, assert.decreasesButNotBy, true)
	      .to.decrease(obj, prop).but.not.by(delta);
	  };

	  /*!
	   * ### .ifError(object)
	   *
	   * Asserts if value is not a false value, and throws if it is a true value.
	   * This is added to allow for chai to be a drop-in replacement for Node's
	   * assert class.
	   *
	   *     var err = new Error('I am a custom error');
	   *     assert.ifError(err); // Rethrows err!
	   *
	   * @name ifError
	   * @param {Object} object
	   * @namespace Assert
	   * @api public
	   */

	  assert.ifError = function (val) {
	    if (val) {
	      throw(val);
	    }
	  };

	  /**
	   * ### .isExtensible(object)
	   *
	   * Asserts that `object` is extensible (can have new properties added to it).
	   *
	   *     assert.isExtensible({});
	   *
	   * @name isExtensible
	   * @alias extensible
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.isExtensible = function (obj, msg) {
	    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
	  };

	  /**
	   * ### .isNotExtensible(object)
	   *
	   * Asserts that `object` is _not_ extensible.
	   *
	   *     var nonExtensibleObject = Object.preventExtensions({});
	   *     var sealedObject = Object.seal({});
	   *     var frozenObject = Object.freeze({});
	   *
	   *     assert.isNotExtensible(nonExtensibleObject);
	   *     assert.isNotExtensible(sealedObject);
	   *     assert.isNotExtensible(frozenObject);
	   *
	   * @name isNotExtensible
	   * @alias notExtensible
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotExtensible = function (obj, msg) {
	    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
	  };

	  /**
	   * ### .isSealed(object)
	   *
	   * Asserts that `object` is sealed (cannot have new properties added to it
	   * and its existing properties cannot be removed).
	   *
	   *     var sealedObject = Object.seal({});
	   *     var frozenObject = Object.seal({});
	   *
	   *     assert.isSealed(sealedObject);
	   *     assert.isSealed(frozenObject);
	   *
	   * @name isSealed
	   * @alias sealed
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.isSealed = function (obj, msg) {
	    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
	  };

	  /**
	   * ### .isNotSealed(object)
	   *
	   * Asserts that `object` is _not_ sealed.
	   *
	   *     assert.isNotSealed({});
	   *
	   * @name isNotSealed
	   * @alias notSealed
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotSealed = function (obj, msg) {
	    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
	  };

	  /**
	   * ### .isFrozen(object)
	   *
	   * Asserts that `object` is frozen (cannot have new properties added to it
	   * and its existing properties cannot be modified).
	   *
	   *     var frozenObject = Object.freeze({});
	   *     assert.frozen(frozenObject);
	   *
	   * @name isFrozen
	   * @alias frozen
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.isFrozen = function (obj, msg) {
	    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
	  };

	  /**
	   * ### .isNotFrozen(object)
	   *
	   * Asserts that `object` is _not_ frozen.
	   *
	   *     assert.isNotFrozen({});
	   *
	   * @name isNotFrozen
	   * @alias notFrozen
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotFrozen = function (obj, msg) {
	    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
	  };

	  /**
	   * ### .isEmpty(target)
	   *
	   * Asserts that the target does not contain any values.
	   * For arrays and strings, it checks the `length` property.
	   * For `Map` and `Set` instances, it checks the `size` property.
	   * For non-function objects, it gets the count of own
	   * enumerable string keys.
	   *
	   *     assert.isEmpty([]);
	   *     assert.isEmpty('');
	   *     assert.isEmpty(new Map);
	   *     assert.isEmpty({});
	   *
	   * @name isEmpty
	   * @alias empty
	   * @param {Object|Array|String|Map|Set} target
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.isEmpty = function(val, msg) {
	    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
	  };

	  /**
	   * ### .isNotEmpty(target)
	   *
	   * Asserts that the target contains values.
	   * For arrays and strings, it checks the `length` property.
	   * For `Map` and `Set` instances, it checks the `size` property.
	   * For non-function objects, it gets the count of own
	   * enumerable string keys.
	   *
	   *     assert.isNotEmpty([1, 2]);
	   *     assert.isNotEmpty('34');
	   *     assert.isNotEmpty(new Set([5, 6]));
	   *     assert.isNotEmpty({ key: 7 });
	   *
	   * @name isNotEmpty
	   * @alias notEmpty
	   * @param {Object|Array|String|Map|Set} target
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */

	  assert.isNotEmpty = function(val, msg) {
	    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
	  };

	  /*!
	   * Aliases.
	   */

	  (function alias(name, as){
	    assert[as] = assert[name];
	    return alias;
	  })
	  ('isOk', 'ok')
	  ('isNotOk', 'notOk')
	  ('throws', 'throw')
	  ('throws', 'Throw')
	  ('isExtensible', 'extensible')
	  ('isNotExtensible', 'notExtensible')
	  ('isSealed', 'sealed')
	  ('isNotSealed', 'notSealed')
	  ('isFrozen', 'frozen')
	  ('isNotFrozen', 'notFrozen')
	  ('isEmpty', 'empty')
	  ('isNotEmpty', 'notEmpty');
	};

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var hasRequiredChai;

	function requireChai () {
		if (hasRequiredChai) return chai$2;
		hasRequiredChai = 1;
		(function (exports) {
			var used = [];

			/*!
			 * Chai version
			 */

			exports.version = '4.3.3';

			/*!
			 * Assertion Error
			 */

			exports.AssertionError = assertionError;

			/*!
			 * Utils for plugins (not exported)
			 */

			var util = requireUtils();

			/**
			 * # .use(function)
			 *
			 * Provides a way to extend the internals of Chai.
			 *
			 * @param {Function}
			 * @returns {this} for chaining
			 * @api public
			 */

			exports.use = function (fn) {
			  if (!~used.indexOf(fn)) {
			    fn(exports, util);
			    used.push(fn);
			  }

			  return exports;
			};

			/*!
			 * Utility Functions
			 */

			exports.util = util;

			/*!
			 * Configuration
			 */

			var config = config$5;
			exports.config = config;

			/*!
			 * Primary `Assertion` prototype
			 */

			var assertion$1 = assertion;
			exports.use(assertion$1);

			/*!
			 * Core Assertions
			 */

			var core = assertions;
			exports.use(core);

			/*!
			 * Expect interface
			 */

			var expect = expect$1;
			exports.use(expect);

			/*!
			 * Should interface
			 */

			var should$1 = should;
			exports.use(should$1);

			/*!
			 * Assert interface
			 */

			var assert$1 = assert;
			exports.use(assert$1); 
		} (chai$2));
		return chai$2;
	}

	var chai = requireChai();

	var chai$1 = /*@__PURE__*/getDefaultExportFromCjs(chai);

	chai$1.expect;
	chai$1.version;
	chai$1.Assertion;
	chai$1.AssertionError;
	chai$1.util;
	chai$1.config;
	chai$1.use;
	chai$1.should;
	chai$1.assert;
	chai$1.core;

	/*

	LCS implementation that supports arrays or strings

	reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem

	*/

	const defaultMatch = function (array1, array2, index1, index2) {
	  return array1[index1] === array2[index2];
	};
	const lengthMatrix = function (array1, array2, match, context) {
	  const len1 = array1.length;
	  const len2 = array2.length;
	  let x, y;

	  // initialize empty matrix of len1+1 x len2+1
	  const matrix = [len1 + 1];
	  for (x = 0; x < len1 + 1; x++) {
	    matrix[x] = [len2 + 1];
	    for (y = 0; y < len2 + 1; y++) {
	      matrix[x][y] = 0;
	    }
	  }
	  matrix.match = match;
	  // save sequence lengths for each coordinate
	  for (x = 1; x < len1 + 1; x++) {
	    for (y = 1; y < len2 + 1; y++) {
	      if (match(array1, array2, x - 1, y - 1, context)) {
	        matrix[x][y] = matrix[x - 1][y - 1] + 1;
	      } else {
	        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
	      }
	    }
	  }
	  return matrix;
	};
	const backtrack = function (matrix, array1, array2, context) {
	  let index1 = array1.length;
	  let index2 = array2.length;
	  const subsequence = {
	    sequence: [],
	    indices1: [],
	    indices2: []
	  };
	  while (index1 !== 0 && index2 !== 0) {
	    const sameLetter = matrix.match(array1, array2, index1 - 1, index2 - 1, context);
	    if (sameLetter) {
	      subsequence.sequence.unshift(array1[index1 - 1]);
	      subsequence.indices1.unshift(index1 - 1);
	      subsequence.indices2.unshift(index2 - 1);
	      --index1;
	      --index2;
	    } else {
	      const valueAtMatrixAbove = matrix[index1][index2 - 1];
	      const valueAtMatrixLeft = matrix[index1 - 1][index2];
	      if (valueAtMatrixAbove > valueAtMatrixLeft) {
	        --index2;
	      } else {
	        --index1;
	      }
	    }
	  }
	  return subsequence;
	};
	const get = function (array1, array2, match, context) {
	  const innerContext = context || {};
	  const matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);
	  const result = backtrack(matrix, array1, array2, innerContext);
	  if (typeof array1 === 'string' && typeof array2 === 'string') {
	    result.sequence = result.sequence.join('');
	  }
	  return result;
	};
	var lcs = {
	  get
	};

	/*
	 * mocha's bdd syntax is inspired in RSpec
	 *   please read: http://betterspecs.org/
	 */
	const expect = chai$1.expect;
	describe('jsondiffpatch', () => {
	  before(() => {});
	  it('has a diff method', () => {
	    expect(diff).to.be.a('function');
	  });
	});
	const DiffPatcher = DiffPatcher$1;
	const isArray = typeof Array.isArray === 'function' ? Array.isArray : a => typeof a === 'object' && a instanceof Array;
	const valueDescription = value => {
	  if (value === null) {
	    return 'null';
	  }
	  if (typeof value === 'boolean') {
	    return value.toString();
	  }
	  if (value instanceof Date) {
	    return 'Date';
	  }
	  if (value instanceof RegExp) {
	    return 'RegExp';
	  }
	  if (isArray(value)) {
	    return 'array';
	  }
	  if (typeof value === 'string') {
	    if (value.length >= 60) {
	      return 'large text';
	    }
	  }
	  return typeof value;
	};

	// Object.keys polyfill
	const objectKeys = typeof Object.keys === 'function' ? obj => Object.keys(obj) : obj => {
	  const keys = [];
	  for (const key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) {
	      keys.push(key);
	    }
	  }
	  return keys;
	};

	// Array.prototype.forEach polyfill
	const arrayForEach = typeof Array.prototype.forEach === 'function' ? (array, fn) => array.forEach(fn) : (array, fn) => {
	  for (let index = 0, length = array.length; index < length; index++) {
	    fn(array[index], index, array);
	  }
	};
	describe('DiffPatcher', () => {
	  arrayForEach(objectKeys(examples), groupName => {
	    const group = examples[groupName];
	    describe(groupName, () => {
	      arrayForEach(group, example => {
	        if (!example) {
	          return;
	        }
	        const name = example.name || `${valueDescription(example.left)} -> ${valueDescription(example.right)}`;
	        describe(name, () => {
	          before(function () {
	            this.instance = new DiffPatcher(example.options);
	          });
	          if (example.error) {
	            it(`diff should fail with: ${example.error}`, function () {
	              const instance = this.instance;
	              expect(() => {
	                instance.diff(example.left, example.right);
	              }).to.throw(example.error);
	            });
	            return;
	          }
	          it('can diff', function () {
	            const delta = this.instance.diff(example.left, example.right);
	            expect(delta).to.deep.equal(example.delta);
	          });
	          it('can diff backwards', function () {
	            const reverse = this.instance.diff(example.right, example.left);
	            expect(reverse).to.deep.equal(example.reverse);
	          });
	          if (!example.noPatch) {
	            it('can patch', function () {
	              const right = this.instance.patch(clone(example.left), example.delta);
	              expect(right).to.deep.equal(example.right);
	            });
	            it('can reverse delta', function () {
	              let reverse = this.instance.reverse(example.delta);
	              if (example.exactReverse !== false) {
	                expect(reverse).to.deep.equal(example.reverse);
	              } else {
	                // reversed delta and the swapped-diff delta are
	                // not always equal, to verify they're equivalent,
	                // patch and compare the results
	                expect(this.instance.patch(clone(example.right), reverse)).to.deep.equal(example.left);
	                reverse = this.instance.diff(example.right, example.left);
	                expect(this.instance.patch(clone(example.right), reverse)).to.deep.equal(example.left);
	              }
	            });
	            it('can unpatch', function () {
	              const left = this.instance.unpatch(clone(example.right), example.delta);
	              expect(left).to.deep.equal(example.left);
	            });
	          }
	        });
	      });
	    });
	  });
	  describe('.clone', () => {
	    it('clones complex objects', () => {
	      const obj = {
	        name: 'a string',
	        nested: {
	          attributes: [{
	            name: 'one',
	            value: 345,
	            since: new Date(1934, 1, 1)
	          }],
	          another: 'property',
	          enabled: true,
	          nested2: {
	            name: 'another string'
	          }
	        }
	      };
	      const cloned = clone(obj);
	      expect(cloned).to.deep.equal(obj);
	    });
	    it('clones RegExp', () => {
	      const obj = {
	        pattern: /expr/gim
	      };
	      const cloned = clone(obj);
	      expect(cloned).to.deep.equal({
	        pattern: /expr/gim
	      });
	    });
	  });
	  describe('using cloneDiffValues', () => {
	    before(function () {
	      this.instance = new DiffPatcher({
	        cloneDiffValues: true
	      });
	    });
	    it("ensures deltas don't reference original objects", function () {
	      const left = {
	        oldProp: {
	          value: 3
	        }
	      };
	      const right = {
	        newProp: {
	          value: 5
	        }
	      };
	      const delta = this.instance.diff(left, right);
	      left.oldProp.value = 1;
	      right.newProp.value = 8;
	      expect(delta).to.deep.equal({
	        oldProp: [{
	          value: 3
	        }, 0, 0],
	        newProp: [{
	          value: 5
	        }]
	      });
	    });
	  });
	  describe('static shortcuts', () => {
	    it('diff', () => {
	      const delta = diff(4, 5);
	      expect(delta).to.deep.equal([4, 5]);
	    });
	    it('patch', () => {
	      const right = patch(4, [4, 5]);
	      expect(right).to.eql(5);
	    });
	    it('unpatch', () => {
	      const left = unpatch(5, [4, 5]);
	      expect(left).to.eql(4);
	    });
	    it('reverse', () => {
	      const reverseDelta = reverse([4, 5]);
	      expect(reverseDelta).to.deep.equal([5, 4]);
	    });
	  });
	  describe('plugins', () => {
	    before(function () {
	      this.instance = new DiffPatcher();
	    });
	    describe('getting pipe filter list', () => {
	      it('returns builtin filters', function () {
	        expect(this.instance.processor.pipes.diff.list()).to.deep.equal(['collectChildren', 'trivial', 'dates', 'texts', 'objects', 'arrays']);
	      });
	    });
	    describe('supporting numeric deltas', () => {
	      const NUMERIC_DIFFERENCE = -8;
	      it('diff', function () {
	        // a constant to identify the custom delta type
	        function numericDiffFilter(context) {
	          if (typeof context.left === 'number' && typeof context.right === 'number') {
	            // store number delta, eg. useful for distributed counters
	            context.setResult([0, context.right - context.left, NUMERIC_DIFFERENCE]).exit();
	          }
	        }
	        // a filterName is useful if I want to allow other filters to
	        // be inserted before/after this one
	        numericDiffFilter.filterName = 'numeric';

	        // insert new filter, right before trivial one
	        this.instance.processor.pipes.diff.before('trivial', numericDiffFilter);
	        const delta = this.instance.diff({
	          population: 400
	        }, {
	          population: 403
	        });
	        expect(delta).to.deep.equal({
	          population: [0, 3, NUMERIC_DIFFERENCE]
	        });
	      });
	      it('patch', function () {
	        function numericPatchFilter(context) {
	          if (context.delta && Array.isArray(context.delta) && context.delta[2] === NUMERIC_DIFFERENCE) {
	            context.setResult(context.left + context.delta[1]).exit();
	          }
	        }
	        numericPatchFilter.filterName = 'numeric';
	        this.instance.processor.pipes.patch.before('trivial', numericPatchFilter);
	        const delta = {
	          population: [0, 3, NUMERIC_DIFFERENCE]
	        };
	        const right = this.instance.patch({
	          population: 600
	        }, delta);
	        expect(right).to.deep.equal({
	          population: 603
	        });
	      });
	      it('unpatch', function () {
	        function numericReverseFilter(context) {
	          if (context.nested) {
	            return;
	          }
	          if (context.delta && Array.isArray(context.delta) && context.delta[2] === NUMERIC_DIFFERENCE) {
	            context.setResult([0, -context.delta[1], NUMERIC_DIFFERENCE]).exit();
	          }
	        }
	        numericReverseFilter.filterName = 'numeric';
	        this.instance.processor.pipes.reverse.after('trivial', numericReverseFilter);
	        const delta = {
	          population: [0, 3, NUMERIC_DIFFERENCE]
	        };
	        const reverseDelta = this.instance.reverse(delta);
	        expect(reverseDelta).to.deep.equal({
	          population: [0, -3, NUMERIC_DIFFERENCE]
	        });
	        const right = {
	          population: 703
	        };
	        this.instance.unpatch(right, delta);
	        expect(right).to.deep.equal({
	          population: 700
	        });
	      });
	    });
	    describe('removing and replacing pipe filters', () => {
	      it('removes specified filter', function () {
	        expect(this.instance.processor.pipes.diff.list()).to.deep.equal(['collectChildren', 'numeric', 'trivial', 'dates', 'texts', 'objects', 'arrays']);
	        this.instance.processor.pipes.diff.remove('dates');
	        expect(this.instance.processor.pipes.diff.list()).to.deep.equal(['collectChildren', 'numeric', 'trivial', 'texts', 'objects', 'arrays']);
	      });
	      it('replaces specified filter', function () {
	        function fooFilter(context) {
	          context.setResult(['foo']).exit();
	        }
	        fooFilter.filterName = 'foo';
	        expect(this.instance.processor.pipes.diff.list()).to.deep.equal(['collectChildren', 'numeric', 'trivial', 'texts', 'objects', 'arrays']);
	        this.instance.processor.pipes.diff.replace('trivial', fooFilter);
	        expect(this.instance.processor.pipes.diff.list()).to.deep.equal(['collectChildren', 'numeric', 'foo', 'texts', 'objects', 'arrays']);
	      });
	    });
	  });
	  describe('formatters', () => {
	    describe('jsonpatch', () => {
	      let instance;
	      let formatter;
	      before(() => {
	        instance = new DiffPatcher();
	        formatter = index.jsonpatch;
	      });
	      const expectFormat = (before, after, expected) => {
	        const diff = instance.diff(before, after);
	        const format = formatter.format(diff);
	        expect(format).to.be.eql(expected);
	      };
	      const removeOp = path => ({
	        op: 'remove',
	        path
	      });
	      const moveOp = (from, path) => ({
	        op: 'move',
	        from,
	        path
	      });
	      const addOp = (path, value) => ({
	        op: 'add',
	        path,
	        value
	      });
	      const replaceOp = (path, value) => ({
	        op: 'replace',
	        path,
	        value
	      });
	      it('should return empty format for empty diff', () => {
	        expectFormat([], [], []);
	      });
	      it('should format an add operation for array insertion', () => {
	        expectFormat([1, 2, 3], [1, 2, 3, 4], [addOp('/3', 4)]);
	      });
	      it('should format an add operation for object insertion', () => {
	        expectFormat({
	          a: 'a',
	          b: 'b'
	        }, {
	          a: 'a',
	          b: 'b',
	          c: 'c'
	        }, [addOp('/c', 'c')]);
	      });
	      it('should format for deletion of array', () => {
	        expectFormat([1, 2, 3, 4], [1, 2, 3], [removeOp('/3')]);
	      });
	      it('should format for deletion of object', () => {
	        expectFormat({
	          a: 'a',
	          b: 'b',
	          c: 'c'
	        }, {
	          a: 'a',
	          b: 'b'
	        }, [removeOp('/c')]);
	      });
	      it('should format for replace of object', () => {
	        expectFormat({
	          a: 'a',
	          b: 'b'
	        }, {
	          a: 'a',
	          b: 'c'
	        }, [replaceOp('/b', 'c')]);
	      });
	      it('should put add/remove for array with primitive items', () => {
	        expectFormat([1, 2, 3], [1, 2, 4], [removeOp('/2'), addOp('/2', 4)]);
	      });
	      it('should sort remove by desc order', () => {
	        expectFormat([1, 2, 3], [1], [removeOp('/2'), removeOp('/1')]);
	      });
	      describe('patcher with comparator', () => {
	        before(() => {
	          instance = new DiffPatcher({
	            objectHash(obj) {
	              if (obj && obj.id) {
	                return obj.id;
	              }
	            }
	          });
	        });
	        const anObjectWithId = id => ({
	          id
	        });
	        it('should remove higher level first', () => {
	          const before = [anObjectWithId('removed'), {
	            id: 'remaining_outer',
	            items: [anObjectWithId('removed_inner'), anObjectWithId('remaining_inner')]
	          }];
	          const after = [{
	            id: 'remaining_outer',
	            items: [anObjectWithId('remaining_inner')]
	          }];
	          const expectedDiff = [removeOp('/0'), removeOp('/0/items/0')];
	          expectFormat(before, after, expectedDiff);
	        });
	        it('should annotate move', () => {
	          const before = [anObjectWithId('first'), anObjectWithId('second')];
	          const after = [anObjectWithId('second'), anObjectWithId('first')];
	          const expectedDiff = [moveOp('/1', '/0')];
	          expectFormat(before, after, expectedDiff);
	        });
	        it('should sort the ops', () => {
	          expectFormat({
	            hl: [{
	              id: 1,
	              bla: 'bla'
	            }, {
	              id: 2,
	              bla: 'ga'
	            }]
	          }, {
	            hl: [{
	              id: 2,
	              bla: 'bla'
	            }, {
	              id: 1,
	              bla: 'ga'
	            }]
	          }, [moveOp('/hl/1', '/hl/0'), replaceOp('/hl/0/bla', 'bla'), replaceOp('/hl/1/bla', 'ga')]);
	        });
	      });
	      it('should annotate as moved op', () => {
	        expectFormat([1, 2], [2, 1], [moveOp('/1', '/0')]);
	      });
	      it('should add full path for moved op', () => {
	        expectFormat({
	          hl: [1, 2]
	        }, {
	          hl: [2, 1]
	        }, [moveOp('/hl/1', '/hl/0')]);
	      });
	      it('should put the full path in move op and sort by HL - #230', () => {
	        const before = {
	          middleName: 'z',
	          referenceNumbers: [{
	            id: 'id-3',
	            referenceNumber: '123',
	            index: 'index-0'
	          }, {
	            id: 'id-1',
	            referenceNumber: '456',
	            index: 'index-1'
	          }, {
	            id: 'id-2',
	            referenceNumber: '789',
	            index: 'index-2'
	          }]
	        };
	        const after = {
	          middleName: 'x',
	          referenceNumbers: [{
	            id: 'id-1',
	            referenceNumber: '456',
	            index: 'index-0'
	          }, {
	            id: 'id-3',
	            referenceNumber: '123',
	            index: 'index-1'
	          }, {
	            id: 'id-2',
	            referenceNumber: '789',
	            index: 'index-2'
	          }]
	        };
	        const diff = [{
	          op: 'move',
	          from: '/referenceNumbers/1',
	          path: '/referenceNumbers/0'
	        }, {
	          op: 'replace',
	          path: '/middleName',
	          value: 'x'
	        }, {
	          op: 'replace',
	          path: '/referenceNumbers/0/index',
	          value: 'index-0'
	        }, {
	          op: 'replace',
	          path: '/referenceNumbers/1/index',
	          value: 'index-1'
	        }];
	        instance = new DiffPatcher({
	          objectHash(obj) {
	            return obj.id;
	          }
	        });
	        expectFormat(before, after, diff);
	      });
	    });
	    describe('html', () => {
	      let instance;
	      let formatter;
	      before(() => {
	        instance = new DiffPatcher({
	          textDiff: {
	            minLength: 10
	          }
	        });
	        formatter = index.html;
	      });
	      const expectFormat = (before, after, expected) => {
	        const diff = instance.diff(before, after);
	        const format = formatter.format(diff);
	        expect(format).to.be.eql(expected);
	      };
	      const expectedHtml = expectedDiff => {
	        const html = [];
	        arrayForEach(expectedDiff, function (diff) {
	          html.push('<li>');
	          html.push('<div class="jsondiffpatch-textdiff-location">');
	          html.push(`<span class="jsondiffpatch-textdiff-line-number">${diff.start}</span>`);
	          html.push(`<span class="jsondiffpatch-textdiff-char">${diff.length}</span>`);
	          html.push('</div>');
	          html.push('<div class="jsondiffpatch-textdiff-line">');
	          arrayForEach(diff.data, function (data) {
	            html.push(`<span class="jsondiffpatch-textdiff-${data.type}">${data.text}</span>`);
	          });
	          html.push('</div>');
	          html.push('</li>');
	        });
	        return '<div class="jsondiffpatch-delta jsondiffpatch-textdiff">' + '<div class="jsondiffpatch-value">' + '<ul class="jsondiffpatch-textdiff">' + `${html.join('')}</ul></div></div>`;
	      };
	      it('should format Chinese', () => {
	        const before = '';
	        const after = 'meow';
	        const expectedDiff = [{
	          start: 1,
	          length: 17,
	          data: [{
	            type: 'deleted',
	            text: ''
	          }, {
	            type: 'added',
	            text: ''
	          }, {
	            type: 'context',
	            text: ''
	          }]
	        }, {
	          start: 8,
	          length: 16,
	          data: [{
	            type: 'context',
	            text: ''
	          }, {
	            type: 'added',
	            text: 'meow'
	          }, {
	            type: 'context',
	            text: ''
	          }]
	        }];
	        expectFormat(before, after, expectedHtml(expectedDiff));
	      });
	      it('should format Japanese', () => {
	        const before = '';
	        const after = 'meow';
	        const expectedDiff = [{
	          start: 1,
	          length: 13,
	          data: [{
	            type: 'context',
	            text: ''
	          }, {
	            type: 'added',
	            text: 'meow'
	          }, {
	            type: 'context',
	            text: ''
	          }, {
	            type: 'deleted',
	            text: ''
	          }, {
	            type: 'added',
	            text: ''
	          }, {
	            type: 'context',
	            text: ''
	          }]
	        }];
	        expectFormat(before, after, expectedHtml(expectedDiff));
	      });
	    });
	  });
	});
	describe('lcs', () => {
	  it('should lcs arrays ', () => {
	    expect(lcs.get([], [])).to.deep.equal({
	      sequence: [],
	      indices1: [],
	      indices2: []
	    });
	    expect(lcs.get([1], [2])).to.deep.equal({
	      sequence: [],
	      indices1: [],
	      indices2: []
	    });

	    // indices1 and indices2 show where the sequence
	    // elements are located in the original arrays
	    expect(lcs.get([1], [-9, 1])).to.deep.equal({
	      sequence: [1],
	      indices1: [0],
	      indices2: [1]
	    });

	    // indices1 and indices2 show where the sequence
	    // elements are located in the original arrays
	    expect(lcs.get([1, 9, 3, 4, 5], [-9, 1, 34, 3, 2, 1, 5, 93])).to.deep.equal({
	      sequence: [1, 3, 5],
	      indices1: [0, 2, 4],
	      indices2: [1, 3, 6]
	    });
	  });
	  it('should compute diff for large array', () => {
	    const ARRAY_LENGTH = 5000; // js stack is about 50k
	    function randomArray() {
	      const result = [];
	      for (let i = 0; i < ARRAY_LENGTH; i++) {
	        if (Math.random() > 0.5) {
	          result.push('A');
	        } else {
	          result.push('B');
	        }
	      }
	      return result;
	    }
	    lcs.get(randomArray(), randomArray());
	  });
	});

}));
//# sourceMappingURL=jsondiffpatch.umd.test.js.map
