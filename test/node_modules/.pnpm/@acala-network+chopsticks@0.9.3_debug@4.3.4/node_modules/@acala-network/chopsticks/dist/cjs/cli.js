"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _dotenv = require("dotenv");
const _helpers = require("yargs/helpers");
const _lodash = /*#__PURE__*/ _interop_require_default(require("lodash"));
const _yargs = /*#__PURE__*/ _interop_require_default(require("yargs"));
const _chopstickscore = require("@acala-network/chopsticks-core");
const _index = require("./schema/index.js");
const _clioptions = require("./cli-options.js");
const _index1 = require("./plugins/index.js");
const _index2 = require("./index.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
(0, _dotenv.config)();
const processArgv = async (argv)=>{
    if (argv.config) {
        Object.assign(argv, _lodash.default.defaults(argv, await (0, _index.fetchConfig)(argv.config)));
    }
    argv.port = argv.port ?? (process.env.PORT ? Number(process.env.PORT) : 8000);
};
const commands = (0, _yargs.default)((0, _helpers.hideBin)(process.argv)).scriptName('chopsticks').middleware(processArgv, false).command('*', 'Dev mode, fork off a chain', (yargs)=>yargs.options({
        ..._clioptions.defaultOptions,
        ..._clioptions.mockOptions,
        port: {
            desc: 'Port to listen on',
            number: true
        },
        'build-block-mode': {
            desc: 'Build block mode. Default to Batch',
            enum: [
                _chopstickscore.BuildBlockMode.Batch,
                _chopstickscore.BuildBlockMode.Manual,
                _chopstickscore.BuildBlockMode.Instant
            ]
        },
        'allow-unresolved-imports': {
            desc: 'Allow wasm unresolved imports',
            boolean: true
        },
        'max-memory-block-count': {
            desc: 'Max memory block count',
            number: true
        },
        resume: {
            desc: `Resume from the specified block hash or block number in db.
                 If true, it will resume from the latest block in db.
                 Note this will override the block option`,
            string: true
        }
    }), async (argv)=>{
    await (0, _index2.setupWithServer)(argv);
}).command('xcm', 'XCM setup with relaychain and parachains', (yargs)=>yargs.options({
        relaychain: {
            desc: 'Relaychain config file path',
            string: true
        },
        parachain: {
            desc: 'Parachain config file path',
            type: 'array',
            string: true,
            required: true
        }
    }).alias('relaychain', 'r').alias('parachain', 'p'), async (argv)=>{
    const parachains = [];
    for (const config of argv.parachain){
        const { chain } = await (0, _index2.setupWithServer)(await (0, _index.fetchConfig)(config));
        parachains.push(chain);
    }
    if (parachains.length > 1) {
        await (0, _chopstickscore.connectParachains)(parachains);
    }
    if (argv.relaychain) {
        const { chain: relaychain } = await (0, _index2.setupWithServer)(await (0, _index.fetchConfig)(argv.relaychain));
        for (const parachain of parachains){
            await (0, _chopstickscore.connectVertical)(relaychain, parachain);
        }
    }
}).strict().help().alias('help', 'h').alias('version', 'v').alias('config', 'c').alias('endpoint', 'e').alias('port', 'p').alias('block', 'b').alias('import-storage', 's').alias('wasm-override', 'w').usage('Usage: $0 <command> [options]').example('$0', '-c acala');
if (!process.env.DISABLE_PLUGINS) {
    (0, _index1.pluginExtendCli)(commands).then(()=>commands.parse());
} else {
    commands.parse();
}
