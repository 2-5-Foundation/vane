"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "rpc", {
    enumerable: true,
    get: function() {
        return rpc;
    }
});
const _zod = require("zod");
const _chopstickscore = require("@acala-network/chopsticks-core");
const _decoder = require("../../utils/decoder.js");
const _generatehtmldiff = require("../../utils/generate-html-diff.js");
const _index = require("../../schema/index.js");
const zParaId = _zod.z.string().regex(/^\d+$/).transform(Number);
const schema = _zod.z.object({
    raw: _zod.z.boolean().optional(),
    html: _zod.z.boolean().optional(),
    extrinsic: _index.zHex.or(_zod.z.object({
        call: _index.zHex,
        address: _index.zHex
    })).optional(),
    hrmp: _zod.z.record(zParaId, _zod.z.array(_zod.z.object({
        sentAt: _zod.z.number(),
        data: _index.zHex
    })).min(1)).optional(),
    dmp: _zod.z.array(_zod.z.object({
        sentAt: _zod.z.number(),
        msg: _index.zHex
    })).min(1).optional(),
    ump: _zod.z.record(zParaId, _zod.z.array(_index.zHex).min(1)).optional(),
    at: _index.zHash.optional()
});
const rpc = async (context, [params])=>{
    const { html, extrinsic, hrmp, dmp, ump, raw, at } = schema.parse(params);
    const dryRun = async ()=>{
        if (extrinsic) {
            const { outcome, storageDiff } = await context.chain.dryRunExtrinsic(extrinsic, at);
            if (outcome.isErr) {
                throw new _chopstickscore.ResponseError(1, outcome.asErr.toString());
            }
            return storageDiff;
        }
        if (hrmp) {
            return context.chain.dryRunHrmp(hrmp, at);
        }
        if (dmp) {
            return context.chain.dryRunDmp(dmp, at);
        }
        if (ump) {
            return context.chain.dryRunUmp(ump, at);
        }
        throw new _chopstickscore.ResponseError(1, 'No extrinsic to run');
    };
    const storageDiff = await dryRun();
    if (html) {
        return (0, _generatehtmldiff.generateHtmlDiff)(context.chain.head, storageDiff);
    }
    if (raw) {
        return storageDiff;
    }
    const { oldState, newState, delta } = await (0, _decoder.decodeStorageDiff)(context.chain.head, storageDiff);
    return {
        old: oldState,
        new: newState,
        delta
    };
};
