"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "cli", {
    enumerable: true,
    get: function() {
        return cli;
    }
});
const _chopstickscore = require("@acala-network/chopsticks-core");
const _lodash = /*#__PURE__*/ _interop_require_default(require("lodash"));
const _server = require("../../server.js");
const _clioptions = require("../../cli-options.js");
const _index = require("../../rpc/index.js");
const _context = require("../../context.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const logger = _chopstickscore.defaultLogger.child({
    name: 'follow-chain'
});
const options = _lodash.default.pick(_clioptions.defaultOptions, [
    'endpoint',
    'wasm-override',
    'runtime-log-level',
    'offchain-worker'
]);
const cli = (y)=>{
    y.command('follow-chain', 'Always follow the latest block on upstream', (yargs)=>yargs.options({
            ...options,
            port: {
                desc: 'Port to listen on',
                number: true
            },
            'head-mode': {
                desc: 'Head mode',
                choices: [
                    'latest',
                    'finalized'
                ],
                default: 'finalized'
            }
        }), async (argv)=>{
        const port = argv.port ?? 8000;
        const endpoint = argv.endpoint;
        if (/^(https|http):\/\//.test(endpoint || '')) {
            throw Error('http provider is not supported');
        }
        const context = await (0, _context.setupContext)(argv, true);
        const { close, port: listenPort } = await (0, _server.createServer)((0, _index.handler)(context), port);
        logger.info(`${await context.chain.api.getSystemChain()} RPC listening on port ${listenPort}`);
        const chain = context.chain;
        chain.api[argv.headMode === 'latest' ? 'subscribeRemoteNewHeads' : 'subscribeRemoteFinalizedHeads'](async (error, data)=>{
            try {
                if (error) throw error;
                logger.info({
                    header: data
                }, `Follow ${argv.headMode} head from upstream`);
                const parent = await chain.getBlock(data.parentHash);
                if (!parent) throw Error(`Cannot find parent', ${data.parentHash}`);
                const registry = await parent.registry;
                const header = registry.createType('Header', data);
                const wasm = await parent.wasm;
                const block = new _chopstickscore.Block(chain, header.number.toNumber(), header.hash.toHex(), parent);
                await chain.setHead(block);
                const calls = [
                    [
                        'Core_initialize_block',
                        [
                            header.toHex()
                        ]
                    ]
                ];
                for (const extrinsic of (await block.extrinsics)){
                    calls.push([
                        'BlockBuilder_apply_extrinsic',
                        [
                            extrinsic
                        ]
                    ]);
                }
                calls.push([
                    'BlockBuilder_finalize_block',
                    []
                ]);
                const result = await (0, _chopstickscore.runTask)({
                    wasm,
                    calls,
                    mockSignatureHost: false,
                    allowUnresolvedImports: false,
                    runtimeLogLevel: argv.runtimeLogLevel || 0
                }, (0, _chopstickscore.taskHandler)(parent));
                if ('Error' in result) {
                    throw new Error(result.Error);
                }
            } catch (e) {
                logger.error(e, 'Error when processing new head');
                await close();
                process.exit(1);
            }
        });
    });
};
