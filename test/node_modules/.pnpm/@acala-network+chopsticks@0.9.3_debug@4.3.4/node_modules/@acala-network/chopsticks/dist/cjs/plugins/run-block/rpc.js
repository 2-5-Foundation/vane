"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    name: function() {
        return name;
    },
    rpc: function() {
        return rpc;
    }
});
const _util = require("@polkadot/util");
const _zod = require("zod");
const _chopstickscore = require("@acala-network/chopsticks-core");
const _index = require("../../schema/index.js");
const schema = _zod.z.object({
    includeRaw: _zod.z.boolean().optional(),
    includeParsed: _zod.z.boolean().optional(),
    includeBlockDetails: _zod.z.boolean().optional(),
    parent: _index.zHash.optional(),
    block: _zod.z.object({
        header: _zod.z.any(),
        extrinsics: _zod.z.array(_index.zHex)
    })
});
const name = 'runBlock';
const rpc = async ({ chain }, [params])=>{
    const { includeRaw, includeParsed, includeBlockDetails, parent, block } = schema.parse(params);
    const includeRawStorage = includeRaw ?? true;
    const parentBlock = await chain.getBlock(parent);
    if (!parentBlock) {
        throw Error(`Invalid block hash ${parent}`);
    }
    const registry = await parentBlock.registry;
    const header = registry.createType('Header', block.header);
    const wasm = await parentBlock.wasm;
    const meta = await parentBlock.meta;
    const blockNumber = parentBlock.number + 1;
    const hash = `0x${Math.round(Math.random() * 100000000).toString(16).padEnd(64, '0')}`;
    const newBlock = new _chopstickscore.Block(chain, blockNumber, hash, parentBlock, {
        header,
        extrinsics: [],
        storage: parentBlock.storage
    });
    const resp = {
        phases: []
    };
    // exclude system events because it can be stupidly large and redudant
    const systemEventsKey = (0, _chopstickscore.compactHex)(meta.query.system.events());
    // large and not really useful
    const systemExtrinsicDataKey = (0, _util.u8aToHex)(meta.query.system.extrinsicData.keyPrefix());
    const run = async (fn, args)=>{
        const result = await (0, _chopstickscore.runTask)({
            wasm,
            calls: [
                [
                    fn,
                    args
                ]
            ],
            mockSignatureHost: false,
            allowUnresolvedImports: false,
            runtimeLogLevel: 5
        }, (0, _chopstickscore.taskHandler)(newBlock));
        if ('Error' in result) {
            throw new Error(result.Error);
        }
        const resp = {
            storageDiff: []
        };
        const raw = result.Call.storageDiff;
        newBlock.pushStorageLayer().setAll(raw);
        for (const [key, value] of raw){
            if (key === systemEventsKey) {
                continue;
            }
            if (key.startsWith(systemExtrinsicDataKey)) {
                continue;
            }
            const obj = {};
            if (includeRawStorage) {
                obj.raw = {
                    key,
                    value
                };
            }
            if (includeParsed) {
                const decoded = (0, _chopstickscore.decodeKeyValue)(await newBlock.meta, newBlock, key, value, false);
                if (decoded) {
                    obj.parsed = {
                        section: decoded.section,
                        method: decoded.method,
                        key: decoded.key,
                        value: decoded.value
                    };
                }
            }
            resp.storageDiff.push(obj);
        }
        resp.logs = result.Call.runtimeLogs;
        return resp;
    };
    const resInit = await run('Core_initialize_block', [
        header.toHex()
    ]);
    resp.phases.push({
        phase: 'Initialization',
        ...resInit
    });
    for (const extrinsic of block.extrinsics){
        const res = await run('BlockBuilder_apply_extrinsic', [
            extrinsic
        ]);
        resp.phases.push({
            phase: resp.phases.length - 1,
            ...res
        });
    }
    const resFinalize = await run('BlockBuilder_finalize_block', []);
    resp.phases.push({
        phase: 'Finalization',
        ...resFinalize
    });
    if (includeBlockDetails) {
        const meta = await newBlock.meta;
        const registry = await newBlock.registry;
        const timestamp = await newBlock.read('u64', meta.query.timestamp.now);
        const events = await newBlock.read('Vec<EventRecord>', meta.query.system.events);
        const parsedEvents = events?.map((event)=>({
                phase: event.phase.isApplyExtrinsic ? event.phase.asApplyExtrinsic.toNumber() : event.phase.toString(),
                section: event.event.section,
                method: event.event.method,
                args: event.event.data.map((arg)=>arg.toJSON())
            }));
        const extrinsics = block.extrinsics.map((extrinsic, idx)=>{
            const parsed = registry.createType('GenericExtrinsic', extrinsic);
            const resultEvent = events?.find(({ event, phase })=>event.section === 'system' && (event.method === 'ExtrinsicSuccess' || event.method === 'ExtrinsicFailed') && phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(idx));
            return {
                section: parsed.method.section,
                method: parsed.method.method,
                args: parsed.method.args.map((arg)=>arg.toJSON()),
                success: resultEvent?.event.method === 'ExtrinsicSuccess'
            };
        });
        resp.blockDetails = {
            timestamp: timestamp?.toString(),
            events: parsedEvents,
            extrinsics
        };
    }
    return resp;
};
