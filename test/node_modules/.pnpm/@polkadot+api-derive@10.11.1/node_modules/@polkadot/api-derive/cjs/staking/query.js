"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryMulti = exports.query = void 0;
const rxjs_1 = require("rxjs");
const index_js_1 = require("../util/index.js");
function parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, stakingLedgerOpt) {
    return {
        accountId: stashId,
        controllerId: controllerIdOpt?.unwrapOr(null) || null,
        exposure,
        nominators: nominatorsOpt.isSome
            ? nominatorsOpt.unwrap().targets
            : [],
        rewardDestination,
        stakingLedger: stakingLedgerOpt.unwrapOrDefault(),
        stashId,
        validatorPrefs
    };
}
function getLedgers(api, optIds, { withLedger = false }) {
    const ids = optIds
        .filter((o) => withLedger && !!o && o.isSome)
        .map((o) => o.unwrap());
    const emptyLed = api.registry.createType('Option<StakingLedger>');
    return (ids.length
        ? (0, rxjs_1.combineLatest)(ids.map((s) => api.query.staking.ledger(s)))
        : (0, rxjs_1.of)([])).pipe((0, rxjs_1.map)((optLedgers) => {
        let offset = -1;
        return optIds.map((o) => o && o.isSome
            ? optLedgers[++offset] || emptyLed
            : emptyLed);
    }));
}
function getStashInfo(api, stashIds, activeEra, { withController, withDestination, withExposure, withLedger, withNominations, withPrefs }) {
    const emptyNoms = api.registry.createType('Option<Nominations>');
    const emptyRewa = api.registry.createType('RewardDestination');
    const emptyExpo = api.registry.createType('Exposure');
    const emptyPrefs = api.registry.createType('ValidatorPrefs');
    return (0, rxjs_1.combineLatest)([
        withController || withLedger
            ? (0, rxjs_1.combineLatest)(stashIds.map((s) => api.query.staking.bonded(s)))
            : (0, rxjs_1.of)(stashIds.map(() => null)),
        withNominations
            ? (0, rxjs_1.combineLatest)(stashIds.map((s) => api.query.staking.nominators(s)))
            : (0, rxjs_1.of)(stashIds.map(() => emptyNoms)),
        withDestination
            ? (0, rxjs_1.combineLatest)(stashIds.map((s) => api.query.staking.payee(s)))
            : (0, rxjs_1.of)(stashIds.map(() => emptyRewa)),
        withPrefs
            ? (0, rxjs_1.combineLatest)(stashIds.map((s) => api.query.staking.validators(s)))
            : (0, rxjs_1.of)(stashIds.map(() => emptyPrefs)),
        withExposure
            ? (0, rxjs_1.combineLatest)(stashIds.map((s) => api.query.staking.erasStakers(activeEra, s)))
            : (0, rxjs_1.of)(stashIds.map(() => emptyExpo))
    ]);
}
function getBatch(api, activeEra, stashIds, flags) {
    return getStashInfo(api, stashIds, activeEra, flags).pipe((0, rxjs_1.switchMap)(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure]) => getLedgers(api, controllerIdOpt, flags).pipe((0, rxjs_1.map)((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]))))));
}
/**
 * @description From a stash, retrieve the controllerId and all relevant details
 */
exports.query = (0, index_js_1.firstMemo)((api, accountId, flags) => api.derive.staking.queryMulti([accountId], flags));
function queryMulti(instanceId, api) {
    return (0, index_js_1.memo)(instanceId, (accountIds, flags) => api.derive.session.indexes().pipe((0, rxjs_1.switchMap)(({ activeEra }) => {
        const stashIds = accountIds.map((a) => api.registry.createType('AccountId', a));
        return stashIds.length
            ? getBatch(api, activeEra, stashIds, flags)
            : (0, rxjs_1.of)([]);
    })));
}
exports.queryMulti = queryMulti;
