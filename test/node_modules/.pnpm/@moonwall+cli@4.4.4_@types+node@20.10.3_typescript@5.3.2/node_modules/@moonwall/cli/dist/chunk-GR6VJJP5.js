import {
  zombieHandler
} from "./chunk-SNZ35SNI.js";
import {
  chopsticksHandler
} from "./chunk-I4LGJH3H.js";
import {
  devHandler
} from "./chunk-UKKPX4WO.js";
import {
  readOnlyHandler
} from "./chunk-XPQOGVEO.js";
import {
  MoonwallContext,
  contextCreator
} from "./chunk-RDW3KT5X.js";
import {
  importAsyncConfig
} from "./chunk-3IRCD3RX.js";

// src/lib/runnerContext.ts
import "@moonbeam-network/api-augment";
import Bottleneck from "bottleneck";
import Debug from "debug";
import { afterAll, beforeAll, describe, it } from "vitest";
var RT_VERSION = Number(process.env.MOON_RTVERSION);
var RT_NAME = process.env.MOON_RTNAME;
var limiter = void 0;
function describeSuite({
  id: suiteId,
  title,
  testCases,
  foundationMethods,
  minRtVersion,
  chainType,
  notChainType
}) {
  if (minRtVersion && minRtVersion > RT_VERSION || chainType && chainType !== RT_NAME || notChainType && notChainType === RT_NAME) {
    describe.skip(`\u{1F5C3}\uFE0F  #${suiteId} ${title}`);
    return;
  }
  let ctx = null;
  beforeAll(async function() {
    const globalConfig = await importAsyncConfig();
    if (!process.env.MOON_TEST_ENV) {
      throw new Error("MOON_TEST_ENV not set");
    }
    ctx = await contextCreator();
    const env = globalConfig.environments.find(({ name }) => name === process.env.MOON_TEST_ENV);
    if (env.foundation.type === "read_only") {
      const settings = loadParams(env.foundation.launchSpec);
      limiter = new Bottleneck(settings);
    }
  });
  afterAll(async function() {
    await MoonwallContext.destroy();
    ctx = null;
  });
  const testCase = (params) => {
    if (params.modifier) {
      it[params.modifier](
        `\u{1F4C1}  #${suiteId.concat(params.id)} ${params.title}`,
        params.test,
        params.timeout
      );
      return;
    }
    if (params.minRtVersion && params.minRtVersion > RT_VERSION || params.chainType && params.chainType !== RT_NAME || params.notChainType && params.notChainType === RT_NAME) {
      it.skip(`\u{1F4C1}  #${suiteId.concat(params.id)} ${params.title}`, params.test, params.timeout);
      return;
    }
    it(`\u{1F4C1}  #${suiteId.concat(params.id)} ${params.title}`, params.test, params.timeout);
  };
  describe(`\u{1F5C3}\uFE0F  #${suiteId} ${title}`, function() {
    const getApi = (apiType, apiName) => {
      const provider = ctx.providers.find((prov) => {
        if (apiType && apiName) {
          return prov.type == apiType && prov.name === apiName;
        } else if (apiType && !apiName) {
          return prov.type == apiType;
        } else if (!apiType && apiName) {
          return prov.name === apiName;
        } else {
          return false;
        }
      });
      if (!provider) {
        throw new Error(
          `API of type ${apiType} ${apiName ? "and name " + apiName : ""} could not be found`
        );
      }
      return !limiter ? provider.api : scheduleWithBottleneck(provider.api);
    };
    const context = {
      api: (type, name) => getApi(type, name),
      viem: (apiName) => getApi("viem", apiName),
      polkadotJs: (apiName) => getApi("polkadotJs", apiName),
      ethers: (apiName) => getApi("ethers", apiName),
      web3: (apiName) => getApi("web3", apiName)
    };
    const foundationHandlers = {
      dev: devHandler,
      chopsticks: chopsticksHandler,
      zombie: zombieHandler,
      read_only: readOnlyHandler,
      fork: readOnlyHandler
    };
    const handler = foundationHandlers[foundationMethods];
    if (!handler) {
      throw new Error(`Unsupported foundation methods: ${foundationMethods}`);
    }
    handler({
      testCases,
      context,
      testCase,
      logger,
      ctx
    });
  });
}
var logger = () => {
  process.env.DEBUG_COLORS = "1";
  const debug = Debug(`test:${process.env.MOON_TEST_ENV}`);
  debug.log = console.log.bind(process.stdout);
  Debug.enable("test:*");
  return debug;
};
var loadParams = (config) => {
  const defaultParams = { maxConcurrent: 5, minTime: 100 };
  if (!config || config.rateLimiter === void 0 || config.rateLimiter === true) {
    return defaultParams;
  }
  if (config.rateLimiter === false) {
    return {};
  }
  if (typeof config.rateLimiter === "object") {
    return config.rateLimiter;
  }
};
var scheduleWithBottleneck = (api) => {
  return new Proxy(api, {
    get(target, propKey) {
      const origMethod = target[propKey];
      if (typeof origMethod === "function" && propKey !== "rpc" && propKey !== "tx") {
        return (...args) => {
          return limiter.schedule(() => origMethod.apply(target, args));
        };
      }
      return origMethod;
    }
  });
};

export {
  describeSuite
};
