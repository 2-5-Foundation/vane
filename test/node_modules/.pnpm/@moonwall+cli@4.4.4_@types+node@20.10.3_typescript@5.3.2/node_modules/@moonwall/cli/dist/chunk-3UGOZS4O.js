import {
  extractError
} from "./chunk-J2C3XM4W.js";
import {
  MoonwallContext
} from "./chunk-RDW3KT5X.js";
import {
  importAsyncConfig,
  isEthereumDevConfig
} from "./chunk-3IRCD3RX.js";

// src/internal/foundations/devModeHelpers.ts
import "@moonbeam-network/api-augment";
import {
  alith,
  createAndFinalizeBlock,
  customWeb3Request,
  generateKeyringPair
} from "@moonwall/util";
import { Keyring } from "@polkadot/api";
import chalk from "chalk";
import Debug from "debug";
import { setTimeout } from "timers/promises";
import { assert } from "vitest";
var debug = Debug("DevTest");
async function getDevProviderPath() {
  const globalConfig = await importAsyncConfig();
  const env = globalConfig.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
  return env.connections ? env.connections[0].endpoints[0].replace("ws://", "http://") : `http://127.0.0.1:${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`;
}
function returnSigner(options) {
  return "privateKey" in options.signer && "type" in options.signer ? generateKeyringPair(options.signer.type, options.signer.privateKey) : options.signer;
}
function returnDefaultSigner() {
  return isEthereumDevConfig() ? alith : new Keyring({ type: "sr25519" }).addFromUri("//Alice", { name: "Alice default" });
}
async function createDevBlock(context, options, transactions) {
  const containsViem = context.isEthereumChain && context.viem() && MoonwallContext.getContext().providers.find((prov) => prov.type == "viem") ? true : false;
  const api = context.polkadotJs();
  const originalBlockNumber = (await api.rpc.chain.getHeader()).number.toBigInt();
  const signer = options.signer !== void 0 ? returnSigner(options) : returnDefaultSigner();
  const results = [];
  const txs = transactions == void 0 ? [] : Array.isArray(transactions) ? transactions : [transactions];
  for await (const call of txs) {
    if (typeof call == "string") {
      results.push({
        type: "eth",
        hash: containsViem ? (await context.viem().request({
          method: "eth_sendRawTransaction",
          params: [call]
        })).result : (await customWeb3Request(context.web3(), "eth_sendRawTransaction", [call])).result
      });
    } else if (call.isSigned) {
      const tx = api.tx(call);
      debug(
        `- Signed: ${tx.method.section}.${tx.method.method}(${tx.args.map((d) => d.toHuman()).join("; ")}) [ nonce: ${tx.nonce}]`
      );
      results.push({
        type: "sub",
        hash: (await call.send()).toString()
      });
    } else {
      const tx = api.tx(call);
      debug(
        `- Unsigned: ${tx.method.section}.${tx.method.method}(${tx.args.map((d) => d.toHuman()).join("; ")}) [ nonce: ${tx.nonce}]`
      );
      results.push({
        type: "sub",
        hash: (await call.signAndSend(signer)).toString()
      });
    }
  }
  const { parentHash, finalize } = options;
  const blockResult = await createAndFinalizeBlock(api, parentHash, finalize);
  if (results.length == 0) {
    return {
      block: blockResult
    };
  }
  const allRecords = await (await api.at(blockResult.hash)).query.system.events();
  const blockData = await api.rpc.chain.getBlock(blockResult.hash);
  const result = results.map((result2) => {
    const extrinsicIndex = result2.type == "eth" ? allRecords.find(
      ({ phase, event: { section, method, data } }) => phase.isApplyExtrinsic && section == "ethereum" && method == "Executed" && data[2].toString() == result2.hash
    )?.phase?.asApplyExtrinsic?.toNumber() : blockData.block.extrinsics.findIndex((ext) => ext.hash.toHex() == result2.hash);
    const events = allRecords.filter(
      ({ phase }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.toNumber() === extrinsicIndex
    );
    const failure = extractError(events);
    return {
      extrinsic: extrinsicIndex >= 0 ? blockData.block.extrinsics[extrinsicIndex] : null,
      events,
      error: failure && (failure.isModule && api.registry.findMetaError(failure.asModule) || { name: failure.toString() }),
      successful: extrinsicIndex !== void 0 && !failure,
      hash: result2.hash
    };
  });
  if (results.find((res) => res.type == "eth")) {
    for (let i = 0; i < 1e3; i++) {
      const currentBlock = (await api.rpc.chain.getHeader()).number.toBigInt();
      await setTimeout(30);
      if (currentBlock > originalBlockNumber) {
        break;
      }
    }
  }
  const actualEvents = result.flatMap((resp) => resp.events);
  if (options.expectEvents && options.expectEvents.length > 0) {
    const match = options.expectEvents.every((eEvt) => {
      const found = actualEvents.map((aEvt) => eEvt.is(aEvt.event)).reduce((acc, curr) => acc || curr, false);
      if (!found) {
        options.logger ? options.logger(
          `Event ${chalk.bgWhiteBright.blackBright(eEvt.meta.name)} not present in block`
        ) : console.error(
          `Event ${chalk.bgWhiteBright.blackBright(eEvt.meta.name)} not present in block`
        );
      }
      return found;
    });
    assert(match, "Expected events not present in block");
  }
  if (!options.allowFailures) {
    actualEvents.forEach((event) => {
      assert(
        !api.events.system.ExtrinsicFailed.is(event.event),
        "ExtrinsicFailed event detected, enable 'allowFailures' if this is expected."
      );
    });
  }
  return {
    block: blockResult,
    result: Array.isArray(transactions) ? result : result[0]
  };
}

export {
  getDevProviderPath,
  createDevBlock
};
