var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/governanceProcedures.ts
var governanceProcedures_exports = {};
__export(governanceProcedures_exports, {
  COUNCIL_MEMBERS: () => COUNCIL_MEMBERS,
  COUNCIL_THRESHOLD: () => COUNCIL_THRESHOLD,
  TECHNICAL_COMMITTEE_MEMBERS: () => TECHNICAL_COMMITTEE_MEMBERS,
  TECHNICAL_COMMITTEE_THRESHOLD: () => TECHNICAL_COMMITTEE_THRESHOLD,
  cancelReferendaWithCouncil: () => cancelReferendaWithCouncil,
  dispatchAsGeneralAdmin: () => dispatchAsGeneralAdmin,
  execCouncilProposal: () => execCouncilProposal,
  execTechnicalCommitteeProposal: () => execTechnicalCommitteeProposal,
  executeProposalWithCouncil: () => executeProposalWithCouncil,
  instantFastTrack: () => instantFastTrack,
  maximizeConvictionVotingOf: () => maximizeConvictionVotingOf,
  notePreimage: () => notePreimage,
  proposeReferendaAndDeposit: () => proposeReferendaAndDeposit
});
module.exports = __toCommonJS(governanceProcedures_exports);
var import_api_augment = require("@moonbeam-network/api-augment");
var import_vitest = require("vitest");
var import_util_crypto = require("@polkadot/util-crypto");
var import_util = require("@moonwall/util");
var COUNCIL_MEMBERS = [import_util.baltathar, import_util.charleth, import_util.dorothy];
var COUNCIL_THRESHOLD = Math.ceil(COUNCIL_MEMBERS.length * 2 / 3);
var TECHNICAL_COMMITTEE_MEMBERS = [import_util.alith, import_util.baltathar];
var TECHNICAL_COMMITTEE_THRESHOLD = Math.ceil(
  TECHNICAL_COMMITTEE_MEMBERS.length * 2 / 3
);
var notePreimage = async (context, proposal, account = import_util.alith) => {
  const encodedProposal = proposal.method.toHex() || "";
  await context.createBlock(
    context.polkadotJs().tx.preimage.notePreimage(encodedProposal).signAsync(account)
  );
  return (0, import_util_crypto.blake2AsHex)(encodedProposal);
};
var instantFastTrack = async (context, proposal, { votingPeriod, delayPeriod } = { votingPeriod: 2, delayPeriod: 0 }) => {
  const proposalHash = typeof proposal == "string" ? proposal : await notePreimage(context, proposal);
  await execCouncilProposal(
    context,
    context.polkadotJs().tx.democracy.externalProposeMajority({
      Lookup: {
        hash: proposalHash,
        len: typeof proposal == "string" ? proposal : proposal.method.encodedLength
      }
    })
  );
  await execTechnicalCommitteeProposal(
    context,
    context.polkadotJs().tx.democracy.fastTrack(proposalHash, votingPeriod, delayPeriod)
  );
  return proposalHash;
};
var execCouncilProposal = async (context, polkadotCall, index = -1, voters = COUNCIL_MEMBERS, threshold = COUNCIL_THRESHOLD) => {
  const lengthBound = polkadotCall.method.encodedLength;
  const { result: proposalResult } = await context.createBlock(
    context.polkadotJs().tx.councilCollective.propose(threshold, polkadotCall, lengthBound).signAsync(import_util.charleth)
  );
  if (threshold <= 1) {
    return proposalResult;
  }
  (0, import_vitest.expect)(proposalResult.successful, `Council proposal refused: ${proposalResult?.error?.name}`).to.be.true;
  const proposalHash = proposalResult.events.find(({ event: { method } }) => method.toString() == "Proposed").event.data[2].toHex();
  const proposalIndex = index >= 0 ? index : (await context.polkadotJs().query.councilCollective.proposalCount()).toNumber() - 1;
  await Promise.all(
    voters.map(
      (voter) => context.polkadotJs().tx.councilCollective.vote(proposalHash, proposalIndex, true).signAndSend(voter)
    )
  );
  await context.createBlock();
  return await context.createBlock(
    context.polkadotJs().tx.councilCollective.close(
      proposalHash,
      proposalIndex,
      {
        refTime: 2e9,
        proofSize: 1e5
      },
      lengthBound
    ).signAsync(import_util.dorothy)
  );
};
var proposeReferendaAndDeposit = async (context, decisionDepositer, proposal, origin) => {
  const proposalHash = typeof proposal == "string" ? proposal : await notePreimage(context, proposal);
  const { result: proposalResult } = await context.createBlock(
    context.polkadotJs().tx.referenda.submit(
      origin,
      {
        Lookup: {
          hash: proposalHash,
          len: typeof proposal == "string" ? proposal : proposal.method.encodedLength
        }
      },
      { At: 0 }
    ).signAsync(import_util.alith)
  );
  (0, import_vitest.expect)(proposalResult.successful, `Unable to post referenda: ${proposalResult?.error?.name}`).to.be.true;
  const refIndex = proposalResult.events.find(({ event: { method } }) => method.toString() == "Submitted").event.data[0].toString();
  await context.createBlock(
    context.polkadotJs().tx.referenda.placeDecisionDeposit(refIndex).signAsync(decisionDepositer)
  );
  return [+refIndex, proposalHash];
};
var dispatchAsGeneralAdmin = async (context, call) => {
  await context.createBlock(
    context.polkadotJs().tx.sudo.sudo(
      context.polkadotJs().tx.utility.dispatchAs(
        {
          Origins: "GeneralAdmin"
        },
        call
      )
    )
  );
};
var maximizeConvictionVotingOf = async (context, voters, refIndex) => {
  const fee = (await context.polkadotJs().tx.convictionVoting.vote(refIndex, {
    Standard: {
      vote: { aye: true, conviction: "Locked6x" },
      balance: (await context.polkadotJs().query.system.account(import_util.alith.address)).data.free
    }
  }).paymentInfo(import_util.alith)).partialFee;
  await context.createBlock(
    voters.map(
      async (voter) => context.polkadotJs().tx.convictionVoting.vote(refIndex, {
        Standard: {
          vote: { aye: true, conviction: "Locked6x" },
          balance: await (await context.polkadotJs().query.system.account(voter.address)).data.free.sub(fee)
        }
      }).signAsync(voter)
    )
  );
};
var execTechnicalCommitteeProposal = async (context, polkadotCall, voters = TECHNICAL_COMMITTEE_MEMBERS, threshold = TECHNICAL_COMMITTEE_THRESHOLD) => {
  const lengthBound = polkadotCall.encodedLength;
  const { result: proposalResult } = await context.createBlock(
    context.polkadotJs().tx.techCommitteeCollective.propose(threshold, polkadotCall, lengthBound)
  );
  if (threshold <= 1) {
    return proposalResult;
  }
  (0, import_vitest.expect)(proposalResult.successful, `Council proposal refused: ${proposalResult?.error?.name}`).to.be.true;
  const proposalHash = proposalResult.events.find(({ event: { method } }) => method.toString() == "Proposed").event.data[2].toHex();
  const proposalCount = await context.polkadotJs().query.techCommitteeCollective.proposalCount();
  await context.createBlock(
    voters.map(
      (voter) => context.polkadotJs().tx.techCommitteeCollective.vote(proposalHash, Number(proposalCount) - 1, true).signAsync(voter)
    )
  );
  const { result: closeResult } = await context.createBlock(
    context.polkadotJs().tx.techCommitteeCollective.close(
      proposalHash,
      Number(proposalCount) - 1,
      {
        refTime: 2e9,
        proofSize: 1e5
      },
      lengthBound
    ).signAsync(import_util.baltathar)
  );
  return closeResult;
};
var executeProposalWithCouncil = async (api, encodedHash) => {
  let nonce = (await api.rpc.system.accountNextIndex(import_util.alith.address)).toNumber();
  const referendumNextIndex = (await api.query.democracy.referendumCount()).toNumber();
  const callData = api.consts.system.version.specVersion.toNumber() >= 2e3 ? { Legacy: encodedHash } : encodedHash;
  const external = api.tx.democracy.externalProposeMajority(callData);
  const fastTrack = api.tx.democracy.fastTrack(encodedHash, 1, 0);
  const voteAmount = 1n * 10n ** BigInt(api.registry.chainDecimals[0]);
  process.stdout.write(`Sending motion + fast-track + vote for ${encodedHash}...`);
  await Promise.all([
    api.tx.councilCollective.propose(1, external, external.length).signAndSend(import_util.alith, { nonce: nonce++ }),
    api.tx.techCommitteeCollective.propose(1, fastTrack, fastTrack.length).signAndSend(import_util.alith, { nonce: nonce++ }),
    api.tx.democracy.vote(referendumNextIndex, {
      Standard: {
        balance: voteAmount,
        vote: { aye: true, conviction: 1 }
      }
    }).signAndSend(import_util.alith, { nonce: nonce++ })
  ]);
  process.stdout.write(`\u2705
`);
  process.stdout.write(`Waiting for referendum [${referendumNextIndex}] to be executed...`);
  let referenda;
  while (!referenda) {
    referenda = (await api.query.democracy.referendumInfoOf.entries()).find(
      (ref) => ref[1].unwrap().isFinished && api.registry.createType("u32", ref[0].toU8a().slice(-4)).toNumber() == referendumNextIndex
    )?.[1].unwrap();
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
  process.stdout.write(`${referenda.asFinished.approved ? `\u2705` : `\u274C`} 
`);
  if (!referenda.asFinished.approved) {
    throw new Error("Finished Referendum was not approved");
  }
};
var cancelReferendaWithCouncil = async (api, refIndex) => {
  const proposal = api.tx.democracy.cancelReferendum(refIndex);
  const encodedProposal = proposal.method.toHex();
  const encodedHash = (0, import_util_crypto.blake2AsHex)(encodedProposal);
  let nonce = (await api.rpc.system.accountNextIndex(import_util.alith.address)).toNumber();
  await api.tx.democracy.notePreimage(encodedProposal).signAndSend(import_util.alith, { nonce: nonce++ });
  await executeProposalWithCouncil(api, encodedHash);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  COUNCIL_MEMBERS,
  COUNCIL_THRESHOLD,
  TECHNICAL_COMMITTEE_MEMBERS,
  TECHNICAL_COMMITTEE_THRESHOLD,
  cancelReferendaWithCouncil,
  dispatchAsGeneralAdmin,
  execCouncilProposal,
  execTechnicalCommitteeProposal,
  executeProposalWithCouncil,
  instantFastTrack,
  maximizeConvictionVotingOf,
  notePreimage,
  proposeReferendaAndDeposit
});
