var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/runnerContext.ts
var runnerContext_exports = {};
__export(runnerContext_exports, {
  describeSuite: () => describeSuite
});
module.exports = __toCommonJS(runnerContext_exports);
var import_api_augment9 = require("@moonbeam-network/api-augment");
var import_bottleneck = __toESM(require("bottleneck"), 1);
var import_debug5 = __toESM(require("debug"), 1);
var import_vitest4 = require("vitest");

// src/lib/configReader.ts
var import_api_augment = require("@moonbeam-network/api-augment");
var import_promises = require("fs/promises");
var import_fs = require("fs");
var import_jsonc_parser = __toESM(require("jsonc-parser"), 1);
var import_path = __toESM(require("path"), 1);
var cachedConfig;
async function parseConfig(filePath) {
  let result;
  const file = await (0, import_promises.readFile)(filePath, "utf8");
  switch ((0, import_path.extname)(filePath)) {
    case ".json":
      result = JSON.parse(file);
      break;
    case ".config":
      result = import_jsonc_parser.default.parse(file);
      break;
    default:
      result = void 0;
      break;
  }
  return result;
}
function parseConfigSync(filePath) {
  let result;
  const file = (0, import_fs.readFileSync)(filePath, "utf8");
  switch ((0, import_path.extname)(filePath)) {
    case ".json":
      result = JSON.parse(file);
      break;
    case ".config":
      result = import_jsonc_parser.default.parse(file);
      break;
    default:
      result = void 0;
      break;
  }
  return result;
}
function isOptionSet(option) {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  const optionValue = traverseConfig(env, option);
  return optionValue !== void 0;
}
function isEthereumZombieConfig() {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  return env.foundation.type == "zombie" && !env.foundation.zombieSpec.disableDefaultEthProviders;
}
function isEthereumDevConfig() {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  return env.foundation.type == "dev" && !env.foundation.launchSpec[0].disableDefaultEthProviders;
}
function importJsonConfig() {
  if (cachedConfig) {
    return cachedConfig;
  }
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path.default.isAbsolute(configPath) ? configPath : import_path.default.join(process.cwd(), configPath);
  try {
    const config = parseConfigSync(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
    return cachedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
async function importAsyncConfig() {
  if (cachedConfig) {
    return cachedConfig;
  }
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path.default.isAbsolute(configPath) ? configPath : import_path.default.join(process.cwd(), configPath);
  try {
    const config = await parseConfig(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
    return cachedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
function replaceEnvVars(value) {
  if (typeof value === "string") {
    return value.replace(/\$\{([^}]+)\}/g, (match, group) => {
      const envVarValue = process.env[group];
      return envVarValue || match;
    });
  } else if (Array.isArray(value)) {
    return value.map(replaceEnvVars);
  } else if (typeof value === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, replaceEnvVars(v)]));
  } else {
    return value;
  }
}
function traverseConfig(configObj, option) {
  if (typeof configObj !== "object" || configObj === null)
    return void 0;
  if (Object.prototype.hasOwnProperty.call(configObj, option)) {
    return configObj[option];
  }
  for (const key in configObj) {
    const result = traverseConfig(configObj[key], option);
    if (result !== void 0) {
      return result;
    }
  }
  return void 0;
}

// src/lib/globalContext.ts
var import_api_augment3 = require("@moonbeam-network/api-augment");
var import_orchestrator = __toESM(require("@zombienet/orchestrator"), 1);
var import_debug3 = __toESM(require("debug"), 1);
var import_fs3 = __toESM(require("fs"), 1);
var import_net2 = __toESM(require("net"), 1);
var import_readline = __toESM(require("readline"), 1);
var import_promises3 = require("timers/promises");

// src/internal/commandParsers.ts
var import_chalk = __toESM(require("chalk"), 1);
var import_path2 = __toESM(require("path"), 1);

// src/lib/repoDefinitions/moonbeam.ts
var repo = {
  name: "moonbeam",
  binaries: [
    {
      name: "moonbeam",
      defaultArgs: [
        "--no-hardware-benchmarks",
        "--no-telemetry",
        "--reserved-only",
        "--rpc-cors=all",
        "--no-grandpa",
        "--sealing=manual",
        "--force-authoring",
        "--no-prometheus",
        "--alice",
        "--chain=moonbase-dev",
        "--tmp"
      ]
    },
    { name: "moonbase-runtime" },
    { name: "moonbeam-runtime" },
    { name: "moonriver-runtime" }
  ],
  ghAuthor: "moonbeam-foundation",
  ghRepo: "moonbeam"
};
var moonbeam_default = repo;

// src/lib/repoDefinitions/polkadot.ts
var repo2 = {
  name: "polkadot",
  binaries: [
    { name: "polkadot" },
    { name: "polkadot-prepare-worker" },
    { name: "polkadot-execute-worker" }
  ],
  ghAuthor: "paritytech",
  ghRepo: "polkadot-sdk"
};
var polkadot_default = repo2;

// src/lib/repoDefinitions/tanssi.ts
var repo3 = {
  name: "tanssi",
  binaries: [
    { name: "tanssi-node", defaultArgs: ["--dev", "--sealing=manual", "--no-hardware-benchmarks"] },
    { name: "container-chain-template-simple-node" },
    { name: "container-chain-template-frontier-node" }
  ],
  ghAuthor: "moondance-labs",
  ghRepo: "tanssi"
};
var tanssi_default = repo3;

// src/lib/repoDefinitions/index.ts
function standardRepos() {
  const defaultRepos = [moonbeam_default, polkadot_default, tanssi_default];
  return [...defaultRepos];
}

// src/internal/commandParsers.ts
function parseZombieCmd(launchSpec) {
  if (launchSpec) {
    return { cmd: launchSpec.configPath };
  } else {
    throw new Error(
      `No ZombieSpec found in config. 
 Are you sure your ${import_chalk.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "configPath" in zombieSpec?`
    );
  }
}
function fetchDefaultArgs(binName, additionalRepos = []) {
  let defaultArgs;
  const repos = [...standardRepos(), ...additionalRepos];
  for (const repo4 of repos) {
    const foundBin = repo4.binaries.find((bin) => bin.name === binName);
    if (foundBin) {
      defaultArgs = foundBin.defaultArgs;
      break;
    }
  }
  if (!defaultArgs) {
    defaultArgs = ["--dev"];
  }
  return defaultArgs;
}
function parseRunCmd(launchSpec, additionalRepos) {
  const launch = !launchSpec.running ? true : launchSpec.running;
  const cmd = launchSpec.binPath;
  const args = launchSpec.options ? [...launchSpec.options] : fetchDefaultArgs(import_path2.default.basename(launchSpec.binPath), additionalRepos);
  if (launchSpec.ports) {
    const ports = launchSpec.ports;
    if (ports.p2pPort) {
      args.push(`--port=${ports.p2pPort}`);
    }
    if (ports.wsPort) {
      args.push(`--ws-port=${ports.wsPort}`);
    }
    if (ports.rpcPort) {
      args.push(`--rpc-port=${ports.rpcPort}`);
    }
  } else {
    if (launchSpec.newRpcBehaviour) {
      args.push(`--rpc-port=${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`);
    } else {
      args.push(`--ws-port=${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`);
    }
  }
  return { cmd, args, launch };
}
function parseChopsticksRunCmd(launchSpecs) {
  const launch = !launchSpecs[0].running ? true : launchSpecs[0].running;
  if (launchSpecs.length === 1) {
    const chopsticksCmd2 = "node";
    const chopsticksArgs2 = [
      "node_modules/@acala-network/chopsticks/chopsticks.cjs",
      `--config=${launchSpecs[0].configPath}`
    ];
    const mode = launchSpecs[0].buildBlockMode ? launchSpecs[0].buildBlockMode : "manual";
    const num = mode == "batch" ? 0 : mode == "instant" ? 1 : 2;
    chopsticksArgs2.push(`--build-block-mode=${num}`);
    if (launchSpecs[0].wsPort) {
      chopsticksArgs2.push(`--port=${launchSpecs[0].wsPort}`);
    }
    if (launchSpecs[0].wasmOverride) {
      chopsticksArgs2.push(`--wasm-override=${launchSpecs[0].wasmOverride}`);
    }
    if (launchSpecs[0].allowUnresolvedImports) {
      chopsticksArgs2.push("--allow-unresolved-imports");
    }
    return {
      cmd: chopsticksCmd2,
      args: chopsticksArgs2,
      launch
    };
  }
  const chopsticksCmd = "node";
  const chopsticksArgs = ["node_modules/@acala-network/chopsticks/chopsticks.cjs", "xcm"];
  launchSpecs.forEach((spec) => {
    const type = spec.type ? spec.type : "parachain";
    switch (type) {
      case "parachain":
        chopsticksArgs.push(`--parachain=${spec.configPath}`);
        break;
      case "relaychain":
        chopsticksArgs.push(`--relaychain=${spec.configPath}`);
    }
  });
  return {
    cmd: chopsticksCmd,
    args: chopsticksArgs,
    launch
  };
}

// src/internal/foundations/zombieHelpers.ts
var import_chalk3 = __toESM(require("chalk"), 1);
var import_node_fs2 = __toESM(require("fs"), 1);

// src/internal/fileCheckers.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_chalk2 = __toESM(require("chalk"), 1);
var import_node_os = __toESM(require("os"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_node_path = __toESM(require("path"), 1);
async function checkExists(path7) {
  const binPath = path7.split(" ")[0];
  const fsResult = import_node_fs.default.existsSync(binPath);
  if (!fsResult) {
    throw new Error(
      `No binary file found at location: ${binPath} 
 Are you sure your ${import_chalk2.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "binPath" in launchSpec?`
    );
  }
  const binArch = await getBinaryArchitecture(binPath);
  const currentArch = import_node_os.default.arch();
  if (binArch !== currentArch && binArch !== "unknown") {
    throw new Error(
      `The binary architecture ${import_chalk2.default.bgWhiteBright.blackBright(
        binArch
      )} does not match this system's architecture ${import_chalk2.default.bgWhiteBright.blackBright(
        currentArch
      )}
Download or compile a new binary executable for ${import_chalk2.default.bgWhiteBright.blackBright(
        currentArch
      )} `
    );
  }
  return true;
}
function checkAccess(path7) {
  const binPath = path7.split(" ")[0];
  try {
    import_node_fs.default.accessSync(binPath, import_node_fs.default.constants.X_OK);
  } catch (err) {
    console.error(`The file ${binPath} is not executable`);
    throw new Error(`The file at ${binPath} , lacks execute permissions.`);
  }
}
async function getBinaryArchitecture(filePath) {
  return new Promise((resolve, reject) => {
    const architectureMap = {
      0: "unknown",
      3: "x86",
      62: "x64",
      183: "arm64"
    };
    import_node_fs.default.open(filePath, "r", (err, fd) => {
      if (err) {
        reject(err);
        return;
      }
      const buffer = Buffer.alloc(20);
      import_node_fs.default.read(fd, buffer, 0, 20, 0, (err2, bytesRead, buffer2) => {
        if (err2) {
          reject(err2);
          return;
        }
        const e_machine = buffer2.readUInt16LE(18);
        const architecture = architectureMap[e_machine] || "unknown";
        resolve(architecture);
      });
    });
  });
}

// src/internal/foundations/zombieHelpers.ts
var import_promises2 = require("timers/promises");
var import_net = __toESM(require("net"), 1);
async function checkZombieBins(config) {
  const relayBinPath = config.relaychain.default_command;
  await checkExists(relayBinPath);
  checkAccess(relayBinPath);
  const promises = config.parachains.map((para) => {
    if (para.collator) {
      if (!para.collator.command) {
        throw new Error(
          "No command found for collator, please check your zombienet config file for collator command"
        );
      }
      checkExists(para.collator.command);
      checkAccess(para.collator.command);
    }
    if (para.collators) {
      para.collators.forEach((coll) => {
        if (!coll.command) {
          throw new Error(
            "No command found for collators, please check your zombienet config file for para collators command"
          );
        }
        checkExists(coll.command);
        checkAccess(coll.command);
      });
    }
  });
  await Promise.all(promises);
}
function getZombieConfig(path7) {
  const fsResult = import_node_fs2.default.existsSync(path7);
  if (!fsResult) {
    throw new Error(
      `No ZombieConfig file found at location: ${path7} 
 Are you sure your ${import_chalk3.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "configPath" in zombieSpec?`
    );
  }
  const buffer = import_node_fs2.default.readFileSync(path7, "utf-8");
  return JSON.parse(buffer);
}
async function sendIpcMessage(message) {
  return new Promise(async (resolve, reject) => {
    let response;
    const ipcPath = process.env.MOON_IPC_SOCKET;
    const client = import_net.default.createConnection({ path: ipcPath });
    client.on("data", async (data) => {
      response = JSON.parse(data.toString());
      if (response.status === "success") {
        client.end();
        for (let i = 0; ; i++) {
          if (client.closed) {
            break;
          }
          if (i > 100) {
            reject(new Error(`Closing IPC connection failed`));
          }
          await (0, import_promises2.setTimeout)(200);
        }
        resolve(response);
      }
      if (response.status === "failure") {
        reject(new Error(JSON.stringify(response)));
      }
    });
    for (let i = 0; ; i++) {
      if (!client.connecting) {
        break;
      }
      if (i > 100) {
        reject(new Error(`Connection to ${ipcPath} failed`));
      }
      await (0, import_promises2.setTimeout)(200);
    }
    await new Promise((resolve2) => {
      client.write(JSON.stringify(message), () => resolve2("Sent!"));
    });
  });
}

// src/internal/localNode.ts
var import_child_process = require("child_process");
var import_debug = __toESM(require("debug"), 1);
var import_fs2 = __toESM(require("fs"), 1);
var import_path3 = __toESM(require("path"), 1);
var import_ws = __toESM(require("ws"), 1);
var debugNode = (0, import_debug.default)("global:node");
async function launchNode(cmd, args, name) {
  if (cmd.includes("moonbeam")) {
    await checkExists(cmd);
    checkAccess(cmd);
  }
  const dirPath = import_path3.default.join(process.cwd(), "tmp", "node_logs");
  const onProcessExit = () => {
    runningNode && runningNode.kill();
  };
  const onProcessInterrupt = () => {
    runningNode && runningNode.kill();
  };
  process.once("exit", onProcessExit);
  process.once("SIGINT", onProcessInterrupt);
  const runningNode = (0, import_child_process.spawn)(cmd, args);
  const logLocation = import_path3.default.join(
    dirPath,
    `${import_path3.default.basename(cmd)}_node_${args.find((a) => a.includes("port"))?.split("=")[1]}_${runningNode.pid}.log`
  ).replaceAll("node_node_undefined", "chopsticks");
  process.env.MOON_LOG_LOCATION = logLocation;
  const fsStream = import_fs2.default.createWriteStream(logLocation);
  runningNode.once("exit", () => {
    process.removeListener("exit", onProcessExit);
    process.removeListener("SIGINT", onProcessInterrupt);
    runningNode.stderr?.off("data", writeLogToFile);
    runningNode.stdout?.off("data", writeLogToFile);
    fsStream.end();
    debugNode(`Exiting dev node: ${name}`);
  });
  runningNode.on("error", (err) => {
    if (err.errno == "ENOENT") {
      console.error(
        `\x1B[31mMissing Local binary at(${cmd}).
Please compile the project\x1B[0m`
      );
    } else {
      console.error(err);
    }
    process.exit(1);
  });
  const writeLogToFile = (chunk) => {
    if (fsStream.writable) {
      fsStream.write(chunk, (err) => {
        if (err)
          console.error(err);
        else
          fsStream.emit("drain");
      });
    }
  };
  runningNode.stderr?.on("data", writeLogToFile);
  runningNode.stdout?.on("data", writeLogToFile);
  probe:
    for (; ; ) {
      try {
        const ports = await findPortsByPid(runningNode.pid);
        if (ports) {
          for (const port of ports) {
            try {
              await checkWebSocketJSONRPC(port);
              break probe;
            } catch {
              continue;
            }
          }
        }
      } catch {
        continue;
      }
    }
  return runningNode;
}
async function checkWebSocketJSONRPC(port) {
  return new Promise((resolve, reject) => {
    const ws = new import_ws.default(`ws://localhost:${port}`);
    ws.on("open", () => {
      ws.send(
        JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "system_chain",
          params: []
        })
      );
    });
    ws.on("message", (data) => {
      try {
        const response = JSON.parse(data.toString());
        if (response.jsonrpc === "2.0" && response.id === 1) {
          resolve(true);
        } else {
          reject(false);
        }
      } catch (e) {
        reject(false);
      }
      ws.close();
    });
    ws.on("error", () => {
      reject(false);
    });
  });
}
async function findPortsByPid(pid, retryCount = 600, retryDelay = 100) {
  for (let i = 0; i < retryCount; i++) {
    try {
      const stdout = (0, import_child_process.execSync)(`lsof -i -n -P | grep LISTEN | grep ${pid}`).toString();
      const ports = [];
      const lines = stdout.split("\n");
      for (const line of lines) {
        const regex = /(?:\*|127\.0\.0\.1):(\d+)/;
        const match = line.match(regex);
        if (match) {
          ports.push(Number(match[1]));
        }
      }
      if (ports.length) {
        return ports;
      }
    } catch (error) {
      if (i === retryCount - 1) {
        throw error;
      }
    }
    await new Promise((resolve) => setTimeout(resolve, retryDelay));
  }
  return [];
}

// src/internal/providerFactories.ts
var import_api_augment2 = require("@moonbeam-network/api-augment");
var import_util = require("@moonwall/util");
var import_api = require("@polkadot/api");
var import_debug2 = __toESM(require("debug"), 1);
var import_ethers = require("ethers");
var import_viem = require("viem");
var import_accounts = require("viem/accounts");
var import_web3 = require("web3");
var import_web3_providers_ws = require("web3-providers-ws");
var debug = (0, import_debug2.default)("global:providers");
var ProviderFactory = class _ProviderFactory {
  constructor(providerConfig) {
    this.providerConfig = providerConfig;
    this.url = providerConfig.endpoints.includes("ENV_VAR") ? process.env.WSS_URL : providerConfig.endpoints[0];
    this.privateKey = process.env.MOON_PRIV_KEY || import_util.ALITH_PRIVATE_KEY;
  }
  url;
  privateKey;
  create() {
    switch (this.providerConfig.type) {
      case "polkadotJs":
        return this.createPolkadotJs();
      case "web3":
        return this.createWeb3();
      case "ethers":
        return this.createEthers();
      case "viem":
        return this.createViem();
      default:
        return this.createDefault();
    }
  }
  createPolkadotJs() {
    debug(`\u{1F7E2}  PolkadotJs provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: async () => {
        const options = {
          provider: new import_api.WsProvider(this.url),
          initWasm: false,
          noInitWarn: true,
          isPedantic: false,
          rpc: this.providerConfig.rpc ? this.providerConfig.rpc : void 0,
          typesBundle: this.providerConfig.additionalTypes ? this.providerConfig.additionalTypes : void 0
        };
        const api = await import_api.ApiPromise.create(options);
        await api.isReady;
        return api;
      },
      ws: () => new import_api.WsProvider(this.url)
    };
  }
  createWeb3() {
    debug(`\u{1F7E2}  Web3 provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: () => {
        const provider = new import_web3_providers_ws.WebSocketProvider(
          this.url,
          {},
          { delay: 50, autoReconnect: false, maxAttempts: 10 }
        );
        return new import_web3.Web3(provider);
      }
    };
  }
  createEthers() {
    debug(`\u{1F7E2}  Ethers provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: () => {
        const provider = new import_ethers.ethers.WebSocketProvider(this.url);
        return new import_ethers.Wallet(this.privateKey, provider);
      }
    };
  }
  createViem() {
    debug(`\u{1F7E2}  Viem omni provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: async () => (0, import_viem.createWalletClient)({
        chain: await (0, import_util.deriveViemChain)(this.url),
        account: (0, import_accounts.privateKeyToAccount)(this.privateKey),
        transport: (0, import_viem.http)(this.url.replace("ws", "http"))
      }).extend(import_viem.publicActions)
    };
  }
  createDefault() {
    debug(`\u{1F7E2}  Default provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: () => console.log(`\u{1F6A7}  provider ${this.providerConfig.name} not yet implemented`)
    };
  }
  static prepare(providerConfigs) {
    return providerConfigs.map((providerConfig) => new _ProviderFactory(providerConfig).create());
  }
  static prepareDefaultDev() {
    return this.prepare([
      {
        name: "dev",
        type: "polkadotJs",
        endpoints: [vitestAutoUrl]
      },
      {
        name: "w3",
        type: "web3",
        endpoints: [vitestAutoUrl]
      },
      {
        name: "eth",
        type: "ethers",
        endpoints: [vitestAutoUrl]
      },
      {
        name: "public",
        type: "viem",
        endpoints: [vitestAutoUrl]
      }
    ]);
  }
  static prepareDefaultZombie() {
    const MOON_PARA_WSS = process.env.MOON_PARA_WSS || "error";
    const MOON_RELAY_WSS = process.env.MOON_RELAY_WSS || "error";
    return this.prepare([
      {
        name: "w3",
        type: "web3",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "eth",
        type: "ethers",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "viem",
        type: "viem",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "parachain",
        type: "polkadotJs",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "relaychain",
        type: "polkadotJs",
        endpoints: [MOON_RELAY_WSS]
      }
    ]);
  }
  static prepareNoEthDefaultZombie() {
    const MOON_PARA_WSS = process.env.MOON_PARA_WSS || "error";
    const MOON_RELAY_WSS = process.env.MOON_RELAY_WSS || "error";
    return this.prepare([
      {
        name: "parachain",
        type: "polkadotJs",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "relaychain",
        type: "polkadotJs",
        endpoints: [MOON_RELAY_WSS]
      }
    ]);
  }
};
var ProviderInterfaceFactory = class _ProviderInterfaceFactory {
  constructor(name, type, connect) {
    this.name = name;
    this.type = type;
    this.connect = connect;
  }
  async create() {
    switch (this.type) {
      case "polkadotJs":
        return this.createPolkadotJs();
      case "web3":
        return this.createWeb3();
      case "ethers":
        return this.createEthers();
      case "viem":
        return this.createViem();
      default:
        throw new Error("UNKNOWN TYPE");
    }
  }
  async createPolkadotJs() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: () => {
        debug(
          `\u{1F44B}  Provider ${this.name} is connected to chain ${api.consts.system.version.specName.toString()} RT${api.consts.system.version.specVersion.toNumber()}`
        );
        return {
          rtVersion: api.consts.system.version.specVersion.toNumber(),
          rtName: api.consts.system.version.specName.toString()
        };
      },
      disconnect: async () => api.disconnect()
    };
  }
  async createWeb3() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: async () => console.log(
        `\u{1F44B} Provider ${this.name} is connected to chain ` + await api.eth.getChainId()
      ),
      disconnect: async () => {
        api.currentProvider.disconnect();
      }
    };
  }
  async createEthers() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: async () => debug(
        `\u{1F44B}  Provider ${this.name} is connected to chain ` + (await api.provider.getNetwork()).chainId
      ),
      disconnect: () => api.provider.destroy()
    };
  }
  async createViem() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: async () => console.log(`\u{1F44B} Provider ${this.name} is connected to chain ` + await api.getChainId()),
      disconnect: async () => {
      }
    };
  }
  static async populate(name, type, connect) {
    return await new _ProviderInterfaceFactory(name, type, connect).create();
  }
};
var vitestAutoUrl = `ws://127.0.0.1:${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`;

// src/lib/globalContext.ts
var import_node_child_process = require("child_process");
var import_child_process2 = require("child_process");
var debugSetup = (0, import_debug3.default)("global:context");
var MoonwallContext = class _MoonwallContext {
  static instance;
  environment;
  providers;
  nodes;
  foundation;
  zombieNetwork;
  rtUpgradePath;
  ipcServer;
  constructor(config) {
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    this.providers = [];
    this.nodes = [];
    this.foundation = env.foundation.type;
    const foundationHandlers = {
      read_only: this.handleReadOnly,
      chopsticks: this.handleChopsticks,
      dev: this.handleDev,
      zombie: this.handleZombie,
      fork: this.handleReadOnly
      // TODO: Implement fork
    };
    const foundationHandler = foundationHandlers[env.foundation.type];
    this.environment = { providers: [], nodes: [], ...foundationHandler.call(this, env, config) };
  }
  handleZombie(env) {
    if (env.foundation.type !== "zombie") {
      throw new Error(`Foundation type must be 'zombie'`);
    }
    const { cmd: zombieConfig } = parseZombieCmd(env.foundation.zombieSpec);
    this.rtUpgradePath = env.foundation.rtUpgradePath;
    return {
      name: env.name,
      foundationType: "zombie",
      nodes: [
        {
          name: env.foundation.zombieSpec.name,
          cmd: zombieConfig,
          args: [],
          launch: true
        }
      ]
    };
  }
  handleDev(env, config) {
    if (env.foundation.type !== "dev") {
      throw new Error(`Foundation type must be 'dev'`);
    }
    const { cmd, args, launch } = parseRunCmd(
      env.foundation.launchSpec[0],
      config.additionalRepos
    );
    return {
      name: env.name,
      foundationType: "dev",
      nodes: [
        {
          name: env.foundation.launchSpec[0].name,
          cmd,
          args,
          launch
        }
      ],
      providers: env.connections ? ProviderFactory.prepare(env.connections) : isEthereumDevConfig() ? ProviderFactory.prepareDefaultDev() : ProviderFactory.prepare([
        {
          name: "node",
          type: "polkadotJs",
          endpoints: [vitestAutoUrl]
        }
      ])
    };
  }
  handleReadOnly(env) {
    if (env.foundation.type !== "read_only") {
      throw new Error(`Foundation type must be 'read_only'`);
    }
    if (!env.connections) {
      throw new Error(
        `${env.name} env config is missing connections specification, required by foundation READ_ONLY`
      );
    }
    return {
      name: env.name,
      foundationType: "read_only",
      providers: ProviderFactory.prepare(env.connections)
    };
  }
  handleChopsticks(env) {
    if (env.foundation.type !== "chopsticks") {
      throw new Error(`Foundation type must be 'chopsticks'`);
    }
    this.rtUpgradePath = env.foundation.rtUpgradePath;
    return {
      name: env.name,
      foundationType: "chopsticks",
      nodes: [parseChopsticksRunCmd(env.foundation.launchSpec)],
      providers: [...ProviderFactory.prepare(env.connections)]
    };
  }
  async startZombieNetwork() {
    const config = await importAsyncConfig();
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    if (env.foundation.type !== "zombie") {
      throw new Error(`Foundation type must be 'zombie', something has gone very wrong.`);
    }
    console.log("\u{1F9DF} Spawning zombie nodes ...");
    const nodes = this.environment.nodes;
    const zombieConfig = getZombieConfig(nodes[0].cmd);
    await checkZombieBins(zombieConfig);
    const network = await import_orchestrator.default.start("", zombieConfig, { logType: "silent" });
    process.env.MOON_RELAY_WSS = network.relay[0].wsUri;
    process.env.MOON_PARA_WSS = Object.values(network.paras)[0].nodes[0].wsUri;
    const nodeNames = Object.keys(network.nodesByName);
    process.env.MOON_ZOMBIE_DIR = `${network.tmpDir}`;
    process.env.MOON_ZOMBIE_NODES = nodeNames.join("|");
    const onProcessExit = () => {
      try {
        const processIds = Object.values(this.zombieNetwork.client.processMap).filter((item) => item["pid"]).map((process2) => process2["pid"]);
        (0, import_node_child_process.exec)(`kill ${processIds.join(" ")}`, (error) => {
          if (error) {
            console.error(`Error killing process: ${error.message}`);
          }
        });
      } catch (err) {
      }
    };
    const socketPath = `${network.tmpDir}/node-ipc.sock`;
    const server = import_net2.default.createServer((client) => {
      client.on("data", async (data) => {
        const writeToClient = (message) => {
          if (client.writable) {
            client.write(JSON.stringify(message));
          } else {
            console.log("Client disconnected, cannot send response.");
          }
        };
        try {
          const message = JSON.parse(data.toString());
          const zombieClient = network.client;
          switch (message.cmd) {
            case "networkmap": {
              const result = Object.keys(network.nodesByName);
              writeToClient({
                status: "success",
                result: network.nodesByName,
                message: result.join("|")
              });
              break;
            }
            case "restart": {
              await this.disconnect();
              await zombieClient.restartNode(message.nodeName, null);
              await (0, import_promises3.setTimeout)(1e3);
              await this.connectEnvironment(true);
              writeToClient({
                status: "success",
                result: true,
                message: `${message.nodeName} restarted`
              });
              break;
            }
            case "resume": {
              const node = network.getNodeByName(message.nodeName);
              await this.disconnect();
              const result = await node.resume();
              await zombieClient.wait_node_ready(message.nodeName);
              await this.connectEnvironment(true);
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} resumed with result ${result}`
              });
              break;
            }
            case "pause": {
              const node = network.getNodeByName(message.nodeName);
              await this.disconnect();
              const result = await node.pause();
              await (0, import_promises3.setTimeout)(1e3);
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} paused with result ${result}`
              });
              break;
            }
            case "kill": {
              const pid = network.client.processMap[message.nodeName].pid;
              delete network.client.processMap[message.nodeName];
              const result = (0, import_node_child_process.exec)(`kill ${pid}`, { timeout: 1e3 });
              writeToClient({
                status: "success",
                result: result.exitCode === 0,
                message: `${message.nodeName}, pid ${pid} killed with exitCode ${result.exitCode}`
              });
              break;
            }
            case "isup": {
              const node = network.getNodeByName(message.nodeName);
              const result = await node.isUp();
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} isUp result is ${result}`
              });
              break;
            }
            default:
              throw new Error(`Invalid command received: ${message.cmd}`);
          }
        } catch (e) {
          console.log("\u{1F4E8} Error processing message from client:", data.toString());
          console.error(e.message);
          writeToClient({ status: "failure", result: false, message: e.message });
        }
      });
    });
    server.listen(socketPath, () => {
      console.log("\u{1F4E8} IPC Server listening on", socketPath);
    });
    this.ipcServer = server;
    process.env.MOON_IPC_SOCKET = socketPath;
    process.once("exit", onProcessExit);
    process.once("SIGINT", onProcessExit);
    this.zombieNetwork = network;
    return;
  }
  async startNetwork() {
    if (process.env.MOON_RECYCLE == "true") {
      return _MoonwallContext.getContext();
    }
    if (this.nodes.length > 0) {
      return _MoonwallContext.getContext();
    }
    const nodes = _MoonwallContext.getContext().environment.nodes;
    if (this.environment.foundationType === "zombie") {
      return await this.startZombieNetwork();
    }
    const promises = nodes.map(async ({ cmd, args, name, launch }) => {
      if (launch) {
        const result = await launchNode(cmd, args, name);
        this.nodes.push(result);
      } else {
        return Promise.resolve();
      }
    });
    await Promise.allSettled(promises);
    return _MoonwallContext.getContext();
  }
  async connectEnvironment(silent = false) {
    const config = await importAsyncConfig();
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    if (this.environment.foundationType == "zombie") {
      this.environment.providers = env.connections ? ProviderFactory.prepare(env.connections) : isEthereumZombieConfig() ? ProviderFactory.prepareDefaultZombie() : ProviderFactory.prepareNoEthDefaultZombie();
    }
    if (this.providers.length > 0) {
      return _MoonwallContext.getContext();
    }
    const promises = this.environment.providers.map(
      async ({ name, type, connect }) => new Promise(async (resolve) => {
        this.providers.push(await ProviderInterfaceFactory.populate(name, type, connect));
        resolve("");
      })
    );
    await Promise.all(promises);
    if (this.foundation == "zombie") {
      let readStreams;
      if (!isOptionSet("disableLogEavesdropping")) {
        !silent && console.log(`\u{1F9BB} Eavesdropping on node logs at ${process.env.MOON_ZOMBIE_DIR}`);
        const zombieNodeLogs = process.env.MOON_ZOMBIE_NODES.split("|").map((nodeName) => `${process.env.MOON_ZOMBIE_DIR}/${nodeName}.log`);
        readStreams = zombieNodeLogs.map((logPath) => {
          const readStream = import_fs3.default.createReadStream(logPath, { encoding: "utf8" });
          const lineReader = import_readline.default.createInterface({
            input: readStream
          });
          lineReader.on("line", (line) => {
            if (line.includes("WARN") || line.includes("ERROR")) {
              console.log(line);
            }
          });
          return readStream;
        });
      }
      const promises2 = this.providers.filter(({ type }) => type == "polkadotJs").filter(
        ({ name }) => env.foundation.type == "zombie" && (!env.foundation.zombieSpec.skipBlockCheck || !env.foundation.zombieSpec.skipBlockCheck.includes(name))
      ).map(async (provider) => {
        return await new Promise(async (resolve) => {
          !silent && console.log(`\u23F2\uFE0F  Waiting for chain ${provider.name} to produce blocks...`);
          while ((await provider.api.rpc.chain.getBlock()).block.header.number.toNumber() == 0) {
            await (0, import_promises3.setTimeout)(500);
          }
          !silent && console.log(`\u2705 Chain ${provider.name} producing blocks, continuing`);
          resolve("");
        });
      });
      await Promise.all(promises2);
      if (!isOptionSet("disableLogEavesdropping")) {
        readStreams.forEach((readStream) => readStream.close());
      }
    }
    return _MoonwallContext.getContext();
  }
  async disconnect(providerName) {
    if (providerName) {
      this.providers.find(({ name }) => name === providerName).disconnect();
      this.providers.filter(({ name }) => name !== providerName);
    } else {
      await Promise.all(this.providers.map((prov) => prov.disconnect()));
      this.providers = [];
    }
  }
  static printStats() {
    if (_MoonwallContext) {
      console.dir(_MoonwallContext.getContext(), { depth: 1 });
    } else {
      console.log("Global context not created!");
    }
  }
  static getContext(config, force = false) {
    if (!_MoonwallContext.instance || force) {
      if (!config) {
        throw new Error("\u274C Config must be provided on Global Context instantiation");
      }
      _MoonwallContext.instance = new _MoonwallContext(config);
      debugSetup(`\u{1F7E2}  Moonwall context "${config.label}" created`);
    }
    return _MoonwallContext.instance;
  }
  static async destroy() {
    const ctx = this.instance;
    try {
      await ctx.disconnect();
    } catch {
      console.log("\u{1F6D1}  All connections disconnected");
    }
    while (ctx.nodes.length > 0) {
      const node = ctx.nodes.pop();
      const pid = node.pid;
      node.kill();
      for (; ; ) {
        const isRunning = await isPidRunning(pid);
        if (isRunning) {
          await (0, import_promises3.setTimeout)(10);
        } else {
          break;
        }
      }
    }
    if (ctx.zombieNetwork) {
      console.log("\u{1FA93}  Killing zombie nodes");
      await ctx.zombieNetwork.stop();
      const processIds = Object.values(ctx.zombieNetwork.client.processMap).filter((item) => item["pid"]).map((process2) => process2["pid"]);
      try {
        (0, import_child_process2.execSync)(`kill ${processIds.join(" ")}`, {});
      } catch (e) {
        console.log(e.message);
        console.log("continuing...");
      }
      await waitForPidsToDie(processIds);
      ctx.ipcServer?.close();
      ctx.ipcServer?.removeAllListeners();
    }
  }
};
var contextCreator = async () => {
  const config = await importAsyncConfig();
  const ctx = MoonwallContext.getContext(config);
  await runNetworkOnly();
  await ctx.connectEnvironment();
  return ctx;
};
var runNetworkOnly = async () => {
  const config = await importAsyncConfig();
  const ctx = MoonwallContext.getContext(config);
  await ctx.startNetwork();
};
async function isPidRunning(pid) {
  const output = (0, import_node_child_process.exec)(`ps -p ${pid} -o pid=`);
  return output.exitCode === 0;
}
async function waitForPidsToDie(pids) {
  const checkPids = async () => {
    const checks = pids.map(async (pid) => await isPidRunning(pid));
    const results = await Promise.all(checks);
    return results.every((running) => !running);
  };
  while (!await checkPids()) {
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
}

// src/lib/handlers/chopsticksHandler.ts
var import_util4 = require("@moonwall/util");
var import_api2 = require("@polkadot/api");

// src/internal/foundations/chopsticksHelpers.ts
var import_chalk4 = __toESM(require("chalk"), 1);
var import_promises4 = require("timers/promises");
var import_vitest = require("vitest");
async function getWsFromConfig(providerName) {
  if (providerName) {
    const provider = MoonwallContext.getContext().environment.providers.find(
      ({ name }) => name == providerName
    );
    if (typeof provider == "undefined") {
      throw new Error(`Cannot find provider ${import_chalk4.default.bgWhiteBright.blackBright(providerName)}`);
    }
    if (!provider.ws) {
      throw new Error("Provider does not have an attached ws() property ");
    }
    return provider.ws();
  } else {
    const provider = MoonwallContext.getContext().environment.providers.find(
      ({ type }) => type == "polkadotJs"
    );
    if (typeof provider == "undefined") {
      throw new Error(
        `Cannot find providers of type ${import_chalk4.default.bgWhiteBright.blackBright("polkadotJs")}`
      );
    }
    if (!provider.ws) {
      throw new Error("Provider does not have an attached ws() property ");
    }
    return provider.ws();
  }
}
async function createChopsticksBlock(context, options = { allowFailures: false }) {
  const result = await sendNewBlockRequest(options);
  const apiAt = await context.polkadotJs().at(result);
  const actualEvents = await apiAt.query.system.events();
  if (options && options.expectEvents) {
    const match = options.expectEvents.every((eEvt) => {
      const found = actualEvents.map((aEvt) => eEvt.is(aEvt.event)).reduce((acc, curr) => acc || curr, false);
      if (!found) {
        options.logger ? options.logger(
          `Event ${import_chalk4.default.bgWhiteBright.blackBright(eEvt.meta.name)} not present in block`
        ) : console.error(
          `Event ${import_chalk4.default.bgWhiteBright.blackBright(eEvt.meta.name)} not present in block`
        );
      }
      return found;
    });
    (0, import_vitest.assert)(match, "Expected events not present in block");
  }
  if (options && options.allowFailures === true) {
  } else {
    actualEvents.forEach((event) => {
      (0, import_vitest.assert)(
        !context.polkadotJs().events.system.ExtrinsicFailed.is(event.event),
        "ExtrinsicFailed event detected, enable 'allowFailures' if this is expected."
      );
    });
  }
  return { result };
}
async function sendNewBlockRequest(params) {
  const ws = params ? await getWsFromConfig(params.providerName) : await getWsFromConfig();
  let result = "";
  while (!ws.isConnected) {
    await (0, import_promises4.setTimeout)(100);
  }
  if (params && params.count || params && params.to) {
    result = await ws.send("dev_newBlock", [{ count: params.count, to: params.to }]);
  } else {
    result = await ws.send("dev_newBlock", [{ count: 1 }]);
  }
  await ws.disconnect();
  return result;
}
async function sendSetStorageRequest(params) {
  const ws = params ? await getWsFromConfig(params.providerName) : await getWsFromConfig();
  while (!ws.isConnected) {
    await (0, import_promises4.setTimeout)(100);
  }
  await ws.send("dev_setStorage", [
    { [params.module]: { [params.method]: params.methodParams } }
  ]);
  await ws.disconnect();
}

// src/lib/upgradeProcedures.ts
var import_api_augment6 = require("@moonbeam-network/api-augment");
var import_util_crypto2 = require("@polkadot/util-crypto");
var import_chalk5 = __toESM(require("chalk"), 1);
var import_ethers2 = require("ethers");
var import_fs5 = __toESM(require("fs"), 1);

// src/lib/binariesHelpers.ts
var import_api_augment4 = require("@moonbeam-network/api-augment");
var import_path4 = __toESM(require("path"), 1);
var import_fs4 = __toESM(require("fs"), 1);
var import_child_process3 = __toESM(require("child_process"), 1);
var import_util2 = require("@moonwall/util");
var BINARY_DIRECTORY = process.env.BINARY_DIRECTORY || "binaries";
var RUNTIME_DIRECTORY = process.env.RUNTIME_DIRECTORY || "runtimes";
var SPECS_DIRECTORY = process.env.SPECS_DIRECTORY || "specs";
async function getRuntimeWasm(runtimeName, runtimeTag, localPath) {
  const runtimePath = import_path4.default.join(RUNTIME_DIRECTORY, `${runtimeName}-${runtimeTag}.wasm`);
  if (!import_fs4.default.existsSync(RUNTIME_DIRECTORY)) {
    import_fs4.default.mkdirSync(RUNTIME_DIRECTORY, { recursive: true });
  }
  if (runtimeTag == "local") {
    const builtRuntimePath = localPath ? localPath : import_path4.default.join(
      import_util2.OVERRIDE_RUNTIME_PATH || `../target/release/wbuild/${runtimeName}-runtime/`,
      `${runtimeName}_runtime.compact.compressed.wasm`
    );
    const code = import_fs4.default.readFileSync(builtRuntimePath);
    import_fs4.default.writeFileSync(runtimePath, `0x${code.toString("hex")}`);
  } else if (!import_fs4.default.existsSync(runtimePath)) {
    console.log(`     Missing ${runtimePath} locally, downloading it...`);
    import_child_process3.default.execSync(
      `mkdir -p ${import_path4.default.dirname(runtimePath)} && wget -q https://github.com/PureStake/moonbeam/releases/download/${runtimeTag}/${runtimeName}-${runtimeTag}.wasm -O ${runtimePath}.bin`
    );
    const code = import_fs4.default.readFileSync(`${runtimePath}.bin`);
    import_fs4.default.writeFileSync(runtimePath, `0x${code.toString("hex")}`);
    console.log(`${runtimePath} downloaded !`);
  }
  return runtimePath;
}

// src/lib/governanceProcedures.ts
var import_api_augment5 = require("@moonbeam-network/api-augment");
var import_vitest2 = require("vitest");
var import_util_crypto = require("@polkadot/util-crypto");
var import_util3 = require("@moonwall/util");
var COUNCIL_MEMBERS = [import_util3.baltathar, import_util3.charleth, import_util3.dorothy];
var COUNCIL_THRESHOLD = Math.ceil(COUNCIL_MEMBERS.length * 2 / 3);
var TECHNICAL_COMMITTEE_MEMBERS = [import_util3.alith, import_util3.baltathar];
var TECHNICAL_COMMITTEE_THRESHOLD = Math.ceil(
  TECHNICAL_COMMITTEE_MEMBERS.length * 2 / 3
);
var executeProposalWithCouncil = async (api, encodedHash) => {
  let nonce = (await api.rpc.system.accountNextIndex(import_util3.alith.address)).toNumber();
  const referendumNextIndex = (await api.query.democracy.referendumCount()).toNumber();
  const callData = api.consts.system.version.specVersion.toNumber() >= 2e3 ? { Legacy: encodedHash } : encodedHash;
  const external = api.tx.democracy.externalProposeMajority(callData);
  const fastTrack = api.tx.democracy.fastTrack(encodedHash, 1, 0);
  const voteAmount = 1n * 10n ** BigInt(api.registry.chainDecimals[0]);
  process.stdout.write(`Sending motion + fast-track + vote for ${encodedHash}...`);
  await Promise.all([
    api.tx.councilCollective.propose(1, external, external.length).signAndSend(import_util3.alith, { nonce: nonce++ }),
    api.tx.techCommitteeCollective.propose(1, fastTrack, fastTrack.length).signAndSend(import_util3.alith, { nonce: nonce++ }),
    api.tx.democracy.vote(referendumNextIndex, {
      Standard: {
        balance: voteAmount,
        vote: { aye: true, conviction: 1 }
      }
    }).signAndSend(import_util3.alith, { nonce: nonce++ })
  ]);
  process.stdout.write(`\u2705
`);
  process.stdout.write(`Waiting for referendum [${referendumNextIndex}] to be executed...`);
  let referenda;
  while (!referenda) {
    referenda = (await api.query.democracy.referendumInfoOf.entries()).find(
      (ref) => ref[1].unwrap().isFinished && api.registry.createType("u32", ref[0].toU8a().slice(-4)).toNumber() == referendumNextIndex
    )?.[1].unwrap();
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
  process.stdout.write(`${referenda.asFinished.approved ? `\u2705` : `\u274C`} 
`);
  if (!referenda.asFinished.approved) {
    throw new Error("Finished Referendum was not approved");
  }
};
var cancelReferendaWithCouncil = async (api, refIndex) => {
  const proposal = api.tx.democracy.cancelReferendum(refIndex);
  const encodedProposal = proposal.method.toHex();
  const encodedHash = (0, import_util_crypto.blake2AsHex)(encodedProposal);
  let nonce = (await api.rpc.system.accountNextIndex(import_util3.alith.address)).toNumber();
  await api.tx.democracy.notePreimage(encodedProposal).signAndSend(import_util3.alith, { nonce: nonce++ });
  await executeProposalWithCouncil(api, encodedHash);
};

// src/lib/upgradeProcedures.ts
async function upgradeRuntimeChopsticks(context, path7) {
  if (!(0, import_fs5.existsSync)(path7)) {
    throw new Error("Runtime wasm not found at path: " + path7);
  }
  const rtWasm = (0, import_fs5.readFileSync)(path7);
  const rtHex = `0x${rtWasm.toString("hex")}`;
  const rtHash = (0, import_util_crypto2.blake2AsHex)(rtHex);
  await context.setStorage({
    module: "parachainSystem",
    method: "authorizedUpgrade",
    methodParams: rtHash
  });
  await context.createBlock();
  const api = context.polkadotJs();
  const signer = context.keyring.alice;
  await api.tx.parachainSystem.enactAuthorizedUpgrade(rtHex).signAndSend(signer);
  await context.createBlock({ count: 3 });
}
async function upgradeRuntime(api, preferences) {
  const options = {
    waitMigration: true,
    useGovernance: false,
    ...preferences
  };
  return new Promise(async (resolve, reject) => {
    const log = (text) => {
      if (options.logger) {
        return options.logger(text);
      } else {
        return;
      }
    };
    try {
      const code = import_fs5.default.readFileSync(
        await getRuntimeWasm(options.runtimeName, options.runtimeTag, options.localPath)
      ).toString();
      log("Checking if upgrade is needed...");
      const existingCode = await api.rpc.state.getStorage(":code");
      if (existingCode.toString() == code) {
        reject(
          `Runtime upgrade with same code: ${existingCode.toString().slice(0, 20)} vs ${code.toString().slice(0, 20)}`
        );
      }
      let nonce = (await api.rpc.system.accountNextIndex(options.from.address)).toNumber();
      if (options.useGovernance) {
        log("Using governance...");
        const proposal = api.consts.system.version.specVersion.toNumber() >= 2400 ? api.tx.parachainSystem.authorizeUpgrade((0, import_util_crypto2.blake2AsHex)(code), false) : api.tx.parachainSystem.authorizeUpgrade((0, import_util_crypto2.blake2AsHex)(code));
        const encodedProposal = proposal.method.toHex();
        const encodedHash = (0, import_util_crypto2.blake2AsHex)(encodedProposal);
        log("Checking if preimage already exists...");
        const preImageExists = api.query.preimage && await api.query.preimage.statusFor(encodedHash);
        const democracyPreImageExists = !api.query.preimage && await api.query.democracy.preimages(encodedHash);
        if (api.query.preimage && preImageExists.isSome && preImageExists.unwrap().isRequested) {
          log(`Preimage ${encodedHash} already exists !
`);
        } else if (!api.query.preimage && democracyPreImageExists) {
          log(`Preimage ${encodedHash} already exists !
`);
        } else {
          log(
            `Registering preimage (${(0, import_ethers2.sha256)(Buffer.from(code))} [~${Math.floor(
              code.length / 1024
            )} kb])...`
          );
          if (api.query.preimage) {
            await api.tx.preimage.notePreimage(encodedProposal).signAndSend(options.from, { nonce: nonce++ });
          } else {
            await api.tx.democracy.notePreimage(encodedProposal).signAndSend(options.from, { nonce: nonce++ });
          }
          log(`Complete \u2705`);
        }
        const referendum = await api.query.democracy.referendumInfoOf.entries();
        const referendaIndex = api.query.preimage ? referendum.filter(
          (ref) => ref[1].unwrap().isOngoing && ref[1].unwrap().asOngoing.proposal.isLookup && ref[1].unwrap().asOngoing.proposal.asLookup.hash.toHex() == encodedHash
        ).map(
          (ref) => api.registry.createType("u32", ref[0].toU8a().slice(-4)).toNumber()
        )?.[0] : referendum.filter(
          (ref) => ref[1].unwrap().isOngoing && ref[1].unwrap().asOngoing.proposalHash.toHex() == encodedHash
        ).map(
          (ref) => api.registry.createType("u32", ref[0].toU8a().slice(-4)).toNumber()
        )?.[0];
        if (referendaIndex !== null && referendaIndex !== void 0) {
          log(`Vote for upgrade already in referendum, cancelling it.`);
          await cancelReferendaWithCouncil(api, referendaIndex);
        }
        await executeProposalWithCouncil(api, encodedHash);
        nonce = (await api.rpc.system.accountNextIndex(options.from.address)).toNumber();
        log(`Enacting authorized upgrade...`);
        await api.tx.parachainSystem.enactAuthorizedUpgrade(code).signAndSend(options.from, { nonce: nonce++ });
        log(`Complete \u2705`);
      } else {
        log(
          `Sending sudo.setCode (${(0, import_ethers2.sha256)(Buffer.from(code))} [~${Math.floor(
            code.length / 1024
          )} kb])...`
        );
        const isWeightV1 = !api.registry.createType("Weight").proofSize;
        await api.tx.sudo.sudoUncheckedWeight(
          await api.tx.system.setCodeWithoutChecks(code),
          isWeightV1 ? "1" : {
            proofSize: 1,
            refTime: 1
          }
        ).signAndSend(options.from, { nonce: nonce++ });
        log(`\u2705`);
      }
      log(`Waiting to apply new runtime (${import_chalk5.default.red(`~4min`)})...`);
      let isInitialVersion = true;
      const unsub = await api.rpc.state.subscribeStorage([":code"], async (newCode) => {
        if (!isInitialVersion) {
          const blockNumber = (await api.rpc.chain.getHeader()).number.toNumber();
          log(
            `Complete \u2705 [New Code: ${newCode.toString().slice(0, 5)}...${newCode.toString().slice(-4)} , Old Code:${existingCode.toString().slice(0, 5)}...${existingCode.toString().slice(-4)}] [#${blockNumber}]`
          );
          unsub();
          if (newCode.toString() != code) {
            reject(
              `Unexpected new code: ${newCode.toString().slice(0, 20)} vs ${code.toString().slice(0, 20)}`
            );
          }
          if (options.waitMigration) {
            const blockToWait = (await api.rpc.chain.getHeader()).number.toNumber() + 1;
            await new Promise(async (resolve2) => {
              const subBlocks = await api.rpc.chain.subscribeNewHeads(async (header) => {
                if (header.number.toNumber() == blockToWait) {
                  subBlocks();
                  resolve2(blockToWait);
                }
              });
            });
          }
          resolve(blockNumber);
        }
        isInitialVersion = false;
      });
    } catch (e) {
      console.error(`Failed to setCode`);
      reject(e);
    }
  });
}

// src/lib/handlers/chopsticksHandler.ts
var chopsticksHandler = ({
  testCases,
  context,
  testCase,
  logger: logger2
}) => {
  const accountTypeLookup = () => {
    const metadata = ctx.polkadotJs().runtimeMetadata.asLatest;
    const systemPalletIndex = metadata.pallets.findIndex(
      (pallet) => pallet.name.toString() === "System"
    );
    const systemAccountStorageType = metadata.pallets[systemPalletIndex].storage.unwrap().items.find((storage) => storage.name.toString() === "Account").type;
    return metadata.lookup.getTypeDef(systemAccountStorageType.asMap.key).type;
  };
  const newKeyring = () => {
    const isEth = accountTypeLookup() == "AccountId20";
    const keyring = new import_api2.Keyring({
      type: isEth ? "ethereum" : "sr25519"
    });
    return {
      alice: keyring.addFromUri(isEth ? import_util4.ALITH_PRIVATE_KEY : "//Alice", { name: "Alice default" }),
      bob: keyring.addFromUri(isEth ? import_util4.BALTATHAR_PRIVATE_KEY : "//Bob", { name: "Bob default" }),
      charlie: keyring.addFromUri(isEth ? import_util4.CHARLETH_PRIVATE_KEY : "//Charlie", {
        name: "Charlie default"
      }),
      dave: keyring.addFromUri(isEth ? import_util4.DOROTHY_PRIVATE_KEY : "//Dave", { name: "Dave default" })
    };
  };
  const ctx = {
    ...context,
    get isEthereumChain() {
      return accountTypeLookup() === "AccountId20";
    },
    get isSubstrateChain() {
      return accountTypeLookup() === "AccountId32";
    },
    get pjsApi() {
      return context.polkadotJs();
    },
    get keyring() {
      return newKeyring();
    },
    createBlock: async (options = {}) => await createChopsticksBlock(context, options),
    setStorage: async (params) => await sendSetStorageRequest(params),
    upgradeRuntime: async () => {
      await upgradeRuntimeChopsticks(ctx, (() => MoonwallContext.getContext().rtUpgradePath)());
    }
  };
  testCases({
    context: ctx,
    it: testCase,
    log: logger2()
  });
};

// src/lib/handlers/devHandler.ts
var import_util7 = require("@moonwall/util");

// src/internal/foundations/devModeHelpers.ts
var import_api_augment8 = require("@moonbeam-network/api-augment");
var import_util5 = require("@moonwall/util");
var import_api3 = require("@polkadot/api");
var import_chalk6 = __toESM(require("chalk"), 1);
var import_debug4 = __toESM(require("debug"), 1);
var import_promises5 = require("timers/promises");
var import_vitest3 = require("vitest");

// src/lib/contextHelpers.ts
var import_api_augment7 = require("@moonbeam-network/api-augment");
function filterAndApply(events, section, methods, onFound) {
  return events.filter(({ event }) => section === event.section && methods.includes(event.method)).map((record) => onFound(record));
}
function getDispatchError({
  event: {
    data: [dispatchError]
  }
}) {
  return dispatchError;
}
function extractError(events = []) {
  return filterAndApply(events, "system", ["ExtrinsicFailed"], getDispatchError)[0];
}

// src/internal/foundations/devModeHelpers.ts
var debug2 = (0, import_debug4.default)("DevTest");
function returnSigner(options) {
  return "privateKey" in options.signer && "type" in options.signer ? (0, import_util5.generateKeyringPair)(options.signer.type, options.signer.privateKey) : options.signer;
}
function returnDefaultSigner() {
  return isEthereumDevConfig() ? import_util5.alith : new import_api3.Keyring({ type: "sr25519" }).addFromUri("//Alice", { name: "Alice default" });
}
async function createDevBlock(context, options, transactions) {
  const containsViem = context.isEthereumChain && context.viem() && MoonwallContext.getContext().providers.find((prov) => prov.type == "viem") ? true : false;
  const api = context.polkadotJs();
  const originalBlockNumber = (await api.rpc.chain.getHeader()).number.toBigInt();
  const signer = options.signer !== void 0 ? returnSigner(options) : returnDefaultSigner();
  const results = [];
  const txs = transactions == void 0 ? [] : Array.isArray(transactions) ? transactions : [transactions];
  for await (const call of txs) {
    if (typeof call == "string") {
      results.push({
        type: "eth",
        hash: containsViem ? (await context.viem().request({
          method: "eth_sendRawTransaction",
          params: [call]
        })).result : (await (0, import_util5.customWeb3Request)(context.web3(), "eth_sendRawTransaction", [call])).result
      });
    } else if (call.isSigned) {
      const tx = api.tx(call);
      debug2(
        `- Signed: ${tx.method.section}.${tx.method.method}(${tx.args.map((d) => d.toHuman()).join("; ")}) [ nonce: ${tx.nonce}]`
      );
      results.push({
        type: "sub",
        hash: (await call.send()).toString()
      });
    } else {
      const tx = api.tx(call);
      debug2(
        `- Unsigned: ${tx.method.section}.${tx.method.method}(${tx.args.map((d) => d.toHuman()).join("; ")}) [ nonce: ${tx.nonce}]`
      );
      results.push({
        type: "sub",
        hash: (await call.signAndSend(signer)).toString()
      });
    }
  }
  const { parentHash, finalize } = options;
  const blockResult = await (0, import_util5.createAndFinalizeBlock)(api, parentHash, finalize);
  if (results.length == 0) {
    return {
      block: blockResult
    };
  }
  const allRecords = await (await api.at(blockResult.hash)).query.system.events();
  const blockData = await api.rpc.chain.getBlock(blockResult.hash);
  const result = results.map((result2) => {
    const extrinsicIndex = result2.type == "eth" ? allRecords.find(
      ({ phase, event: { section, method, data } }) => phase.isApplyExtrinsic && section == "ethereum" && method == "Executed" && data[2].toString() == result2.hash
    )?.phase?.asApplyExtrinsic?.toNumber() : blockData.block.extrinsics.findIndex((ext) => ext.hash.toHex() == result2.hash);
    const events = allRecords.filter(
      ({ phase }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.toNumber() === extrinsicIndex
    );
    const failure = extractError(events);
    return {
      extrinsic: extrinsicIndex >= 0 ? blockData.block.extrinsics[extrinsicIndex] : null,
      events,
      error: failure && (failure.isModule && api.registry.findMetaError(failure.asModule) || { name: failure.toString() }),
      successful: extrinsicIndex !== void 0 && !failure,
      hash: result2.hash
    };
  });
  if (results.find((res) => res.type == "eth")) {
    for (let i = 0; i < 1e3; i++) {
      const currentBlock = (await api.rpc.chain.getHeader()).number.toBigInt();
      await (0, import_promises5.setTimeout)(30);
      if (currentBlock > originalBlockNumber) {
        break;
      }
    }
  }
  const actualEvents = result.flatMap((resp) => resp.events);
  if (options.expectEvents && options.expectEvents.length > 0) {
    const match = options.expectEvents.every((eEvt) => {
      const found = actualEvents.map((aEvt) => eEvt.is(aEvt.event)).reduce((acc, curr) => acc || curr, false);
      if (!found) {
        options.logger ? options.logger(
          `Event ${import_chalk6.default.bgWhiteBright.blackBright(eEvt.meta.name)} not present in block`
        ) : console.error(
          `Event ${import_chalk6.default.bgWhiteBright.blackBright(eEvt.meta.name)} not present in block`
        );
      }
      return found;
    });
    (0, import_vitest3.assert)(match, "Expected events not present in block");
  }
  if (!options.allowFailures) {
    actualEvents.forEach((event) => {
      (0, import_vitest3.assert)(
        !api.events.system.ExtrinsicFailed.is(event.event),
        "ExtrinsicFailed event detected, enable 'allowFailures' if this is expected."
      );
    });
  }
  return {
    block: blockResult,
    result: Array.isArray(transactions) ? result : result[0]
  };
}

// src/lib/contractFunctions.ts
var import_util6 = require("@moonwall/util");
var import_chalk7 = __toESM(require("chalk"), 1);
var import_ethers3 = require("ethers");
var import_fs6 = __toESM(require("fs"), 1);
var import_path5 = __toESM(require("path"), 1);
var import_viem2 = require("viem");
var import_accounts2 = require("viem/accounts");
function getCompiledPath(contractName) {
  const config = importJsonConfig();
  const contractsDir = config.environments.find(
    (env) => env.name === process.env.MOON_TEST_ENV
  )?.contracts;
  if (!contractsDir) {
    throw new Error(
      `Contracts directory not found for environment config ${process.env.MOON_TEST_ENV}
Please specify path to Foundry directory at:  ${import_chalk7.default.bgWhiteBright.blackBright(
        "moonwall.config.json > environments > contracts"
      )}`
    );
  }
  const compiledJsonPath = recursiveSearch(contractsDir, `${contractName}.json`);
  const solidityFilePath = recursiveSearch(contractsDir, `${contractName}.sol`);
  if (!compiledJsonPath && !solidityFilePath) {
    throw new Error(
      `Neither solidity contract ${contractName}.sol nor its compiled json exists in ${contractsDir}`
    );
  } else if (!compiledJsonPath) {
    throw new Error(
      `Compiled contract ${contractName}.json doesn't exist
Please ${import_chalk7.default.bgWhiteBright.blackBright("recompile contract")} ${contractName}.sol`
    );
  }
  return compiledJsonPath;
}
function fetchCompiledContract(contractName) {
  const compiledPath = getCompiledPath(contractName);
  const json = (0, import_fs6.readFileSync)(compiledPath, "utf8");
  const parsed = JSON.parse(json);
  return {
    abi: parsed.contract.abi,
    bytecode: parsed.byteCode,
    methods: parsed.contract.evm.methodIdentifiers,
    deployedBytecode: "0x" + parsed.contract.evm.deployedBytecode.object
  };
}
function recursiveSearch(dir, filename) {
  const files = import_fs6.default.readdirSync(dir);
  for (const file of files) {
    const filepath = import_path5.default.join(dir, file);
    const stats = import_fs6.default.statSync(filepath);
    if (stats.isDirectory()) {
      const searchResult = recursiveSearch(filepath, filename);
      if (searchResult) {
        return searchResult;
      }
    } else if (stats.isFile() && file === filename) {
      return filepath;
    }
  }
  return null;
}
async function interactWithPrecompileContract(context, callOptions) {
  const { precompileName, ...rest } = callOptions;
  const precompileInfo = import_util6.PRECOMPILES[precompileName];
  if (!precompileInfo) {
    throw new Error(`No precompile found with the name: ${precompileName}`);
  }
  const [contractAddress, contractName] = Array.isArray(precompileInfo) ? precompileInfo : [precompileInfo, precompileName];
  return await interactWithContract(context, {
    ...rest,
    contractName,
    contractAddress
  });
}
async function interactWithContract(context, callOptions) {
  const {
    contractName,
    contractAddress,
    functionName,
    args = [],
    web3Library = "viem",
    gas = "estimate",
    value = 0n,
    privateKey = import_util6.ALITH_PRIVATE_KEY,
    rawTxOnly = false,
    call = false
  } = callOptions;
  const { abi } = fetchCompiledContract(contractName);
  const data = (0, import_viem2.encodeFunctionData)({
    abi,
    functionName,
    args
  });
  const account = (0, import_accounts2.privateKeyToAccount)(privateKey);
  const gasParam = gas === "estimate" ? await context.viem().estimateGas({ account: account.address, to: contractAddress, value: 0n, data }) : gas > 0n ? gas : 200000n;
  if (!call && rawTxOnly) {
    return web3Library === "viem" ? (0, import_util6.createViemTransaction)(context, {
      to: contractAddress,
      data,
      gas: gasParam,
      privateKey,
      value
    }) : (0, import_util6.createEthersTransaction)(context, {
      to: contractAddress,
      data,
      gas: gasParam,
      value: (0, import_viem2.toHex)(value),
      privateKey
    });
  }
  if (call) {
    if (web3Library === "viem") {
      const result = await context.viem().call({ account: account.address, to: contractAddress, value: 0n, data, gas: gasParam });
      return (0, import_viem2.decodeFunctionResult)({ abi, functionName, data: result.data });
    } else {
      const result = await context.ethers().call({
        from: account.address,
        to: contractAddress,
        value: (0, import_viem2.toHex)(value),
        data,
        gasLimit: (0, import_viem2.toHex)(gasParam)
      });
      return new import_ethers3.Interface(abi).decodeFunctionResult(functionName, result);
    }
  } else if (!rawTxOnly) {
    if (web3Library === "viem") {
      const hash = await context.viem().sendTransaction({
        account,
        to: contractAddress,
        value,
        data,
        gas: gasParam
      });
      return hash;
    } else {
      const signer = new import_ethers3.Wallet(privateKey, context.ethers().provider);
      const { hash } = await signer.sendTransaction({
        from: account.address,
        to: contractAddress,
        value: (0, import_viem2.toHex)(value),
        data,
        gasLimit: (0, import_viem2.toHex)(gasParam)
      });
      return hash;
    }
  } else {
    throw new Error("This should never happen, if it does there's a logic error in the code");
  }
}
async function deployCreateCompiledContract(context, contractName, options) {
  const { abi, bytecode, methods } = fetchCompiledContract(contractName);
  const { privateKey = import_util6.ALITH_PRIVATE_KEY, args = [], ...rest } = options || {};
  const blob = {
    ...rest,
    privateKey,
    args
  };
  const { contractAddress, logs, status, hash } = await (0, import_util6.deployViemContract)(
    context,
    abi,
    bytecode,
    blob
  );
  return {
    contractAddress,
    logs,
    hash,
    status,
    abi,
    bytecode,
    methods
  };
}

// src/lib/handlers/devHandler.ts
var import_api4 = require("@polkadot/api");
var devHandler = ({ testCases, context, testCase, logger: logger2 }) => {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  const ethCompatible = isEthereumDevConfig();
  const accountTypeLookup = () => {
    const metadata = ctx.polkadotJs().runtimeMetadata.asLatest;
    const systemPalletIndex = metadata.pallets.findIndex(
      (pallet) => pallet.name.toString() === "System"
    );
    const systemAccountStorageType = metadata.pallets[systemPalletIndex].storage.unwrap().items.find((storage) => storage.name.toString() === "Account").type;
    return metadata.lookup.getTypeDef(systemAccountStorageType.asMap.key).type;
  };
  const newKeyring = () => {
    const isEth = accountTypeLookup() == "AccountId20";
    const keyring = new import_api4.Keyring({
      type: isEth ? "ethereum" : "sr25519"
    });
    return {
      alice: keyring.addFromUri(isEth ? import_util7.ALITH_PRIVATE_KEY : "//Alice", { name: "Alice default" }),
      bob: keyring.addFromUri(isEth ? import_util7.BALTATHAR_PRIVATE_KEY : "//Bob", { name: "Bob default" }),
      charlie: keyring.addFromUri(isEth ? import_util7.CHARLETH_PRIVATE_KEY : "//Charlie", {
        name: "Charlie default"
      }),
      dave: keyring.addFromUri(isEth ? import_util7.DOROTHY_PRIVATE_KEY : "//Dave", { name: "Dave default" })
    };
  };
  const ctx = {
    ...context,
    get isEthereumChain() {
      return accountTypeLookup() === "AccountId20";
    },
    get isSubstrateChain() {
      return accountTypeLookup() === "AccountId32";
    },
    get pjsApi() {
      return context.polkadotJs();
    },
    get keyring() {
      return newKeyring();
    },
    createBlock: async (transactions, options) => {
      const defaults = {
        signer: env.defaultSigner || import_util7.alith,
        allowFailures: env.defaultAllowFailures === void 0 ? true : env.defaultAllowFailures,
        finalize: env.defaultFinalization === void 0 ? true : env.defaultFinalization
      };
      return await createDevBlock(context, { ...defaults, ...options }, transactions);
    },
    createTxn: !ethCompatible ? void 0 : (options) => {
      const { libraryType = "viem", ...txnOptions } = options;
      return libraryType === "viem" ? (0, import_util7.createViemTransaction)(ctx, txnOptions) : (0, import_util7.createEthersTransaction)(ctx, txnOptions);
    },
    readPrecompile: !ethCompatible ? void 0 : async (options) => {
      const response = await interactWithPrecompileContract(ctx, {
        call: true,
        ...options
      });
      return response;
    },
    writePrecompile: !ethCompatible ? void 0 : async (options) => {
      const response = await interactWithPrecompileContract(ctx, { call: false, ...options });
      return response;
    },
    readContract: !ethCompatible ? void 0 : async (options) => {
      const response = await interactWithContract(ctx, {
        call: true,
        ...options
      });
      return response;
    },
    writeContract: !ethCompatible ? void 0 : async (options) => {
      const response = await interactWithContract(ctx, { call: false, ...options });
      return response;
    },
    deployContract: !ethCompatible ? void 0 : async (contractName, options) => {
      return await deployCreateCompiledContract(ctx, contractName, options);
    }
  };
  testCases({
    context: ctx,
    it: testCase,
    log: logger2()
  });
};

// src/lib/handlers/readOnlyHandler.ts
var readOnlyHandler = ({
  testCases,
  context,
  testCase,
  logger: logger2
}) => {
  testCases({
    context: {
      ...context,
      waitBlock: async (blocksToWaitFor = 1, chainName, mode = "quantity") => {
        const ctx = MoonwallContext.getContext();
        const provider = chainName ? ctx.providers.find((prov) => prov.name === chainName && prov.type === "polkadotJs") : ctx.providers.find((prov) => prov.type === "polkadotJs");
        if (!provider) {
          throw new Error("No PolkadotJs api found in provider config");
        }
        const api = provider.api;
        const currentBlockNumber = (await api.rpc.chain.getBlock()).block.header.number.toNumber();
        for (; ; ) {
          await new Promise((resolve) => setTimeout(resolve, 100));
          const newBlockNumber = (await api.rpc.chain.getBlock()).block.header.number.toNumber();
          if (mode === "quantity" && newBlockNumber >= currentBlockNumber + blocksToWaitFor) {
            break;
          } else if (mode === "height" && newBlockNumber >= blocksToWaitFor) {
            break;
          }
        }
      }
    },
    it: testCase,
    log: logger2()
  });
};

// src/lib/handlers/zombieHandler.ts
var import_util8 = require("@moonwall/util");
var zombieHandler = ({
  testCases,
  context,
  testCase,
  logger: logger2
}) => {
  testCases({
    context: {
      ...context,
      waitBlock: async (blocksToWaitFor = 1, chain = "parachain", mode = "quantity") => {
        const ctx = MoonwallContext.getContext();
        const provider = ctx.providers.find((prov) => prov.name === chain);
        if (!provider) {
          throw new Error(`Provider '${chain}' not found`);
        }
        const api = provider.api;
        const currentBlockNumber = (await api.rpc.chain.getBlock()).block.header.number.toNumber();
        for (; ; ) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          const newBlockNumber = (await api.rpc.chain.getBlock()).block.header.number.toNumber();
          if (mode === "quantity" && newBlockNumber >= currentBlockNumber + blocksToWaitFor) {
            break;
          } else if (mode === "height" && newBlockNumber >= blocksToWaitFor) {
            break;
          }
        }
      },
      upgradeRuntime: async (options = {}) => {
        const ctx = MoonwallContext.getContext();
        const provider = ctx.providers.find((prov) => prov.name === "parachain");
        if (!provider) {
          throw new Error(`Provider 'parachain' not found`);
        }
        const api = provider.api;
        const params = {
          runtimeName: options.runtimeName || "moonbase",
          runtimeTag: options.runtimeTag || "local",
          localPath: options.localPath || ctx.rtUpgradePath,
          useGovernance: options.useGovernance || false,
          waitMigration: options.waitMigration || true,
          from: options.from || import_util8.alith
        };
        if (options.logger) {
          params.logger = options.logger;
        }
        await upgradeRuntime(api, params);
      },
      restartNode: async (nodeName) => {
        await sendIpcMessage({
          text: `Restarting node ${nodeName}`,
          cmd: "restart",
          nodeName
        });
      },
      pauseNode: async (nodeName) => {
        await sendIpcMessage({
          text: `Pausing node ${nodeName}`,
          cmd: "pause",
          nodeName
        });
      },
      resumeNode: async (nodeName) => {
        await sendIpcMessage({
          text: `Resuming node ${nodeName}`,
          cmd: "resume",
          nodeName
        });
      },
      killNode: async (nodeName) => {
        await sendIpcMessage({
          text: `Killing node ${nodeName}`,
          cmd: "kill",
          nodeName
        });
      },
      isUp: async (nodeName) => {
        const response = await sendIpcMessage({
          text: `Checking if node ${nodeName} is up`,
          cmd: "isup",
          nodeName
        });
        return response.status === "success";
      }
    },
    it: testCase,
    log: logger2()
  });
};

// src/lib/runnerContext.ts
var RT_VERSION = Number(process.env.MOON_RTVERSION);
var RT_NAME = process.env.MOON_RTNAME;
var limiter = void 0;
function describeSuite({
  id: suiteId,
  title,
  testCases,
  foundationMethods,
  minRtVersion,
  chainType,
  notChainType
}) {
  if (minRtVersion && minRtVersion > RT_VERSION || chainType && chainType !== RT_NAME || notChainType && notChainType === RT_NAME) {
    import_vitest4.describe.skip(`\u{1F5C3}\uFE0F  #${suiteId} ${title}`);
    return;
  }
  let ctx = null;
  (0, import_vitest4.beforeAll)(async function() {
    const globalConfig = await importAsyncConfig();
    if (!process.env.MOON_TEST_ENV) {
      throw new Error("MOON_TEST_ENV not set");
    }
    ctx = await contextCreator();
    const env = globalConfig.environments.find(({ name }) => name === process.env.MOON_TEST_ENV);
    if (env.foundation.type === "read_only") {
      const settings = loadParams(env.foundation.launchSpec);
      limiter = new import_bottleneck.default(settings);
    }
  });
  (0, import_vitest4.afterAll)(async function() {
    await MoonwallContext.destroy();
    ctx = null;
  });
  const testCase = (params) => {
    if (params.modifier) {
      import_vitest4.it[params.modifier](
        `\u{1F4C1}  #${suiteId.concat(params.id)} ${params.title}`,
        params.test,
        params.timeout
      );
      return;
    }
    if (params.minRtVersion && params.minRtVersion > RT_VERSION || params.chainType && params.chainType !== RT_NAME || params.notChainType && params.notChainType === RT_NAME) {
      import_vitest4.it.skip(`\u{1F4C1}  #${suiteId.concat(params.id)} ${params.title}`, params.test, params.timeout);
      return;
    }
    (0, import_vitest4.it)(`\u{1F4C1}  #${suiteId.concat(params.id)} ${params.title}`, params.test, params.timeout);
  };
  (0, import_vitest4.describe)(`\u{1F5C3}\uFE0F  #${suiteId} ${title}`, function() {
    const getApi = (apiType, apiName) => {
      const provider = ctx.providers.find((prov) => {
        if (apiType && apiName) {
          return prov.type == apiType && prov.name === apiName;
        } else if (apiType && !apiName) {
          return prov.type == apiType;
        } else if (!apiType && apiName) {
          return prov.name === apiName;
        } else {
          return false;
        }
      });
      if (!provider) {
        throw new Error(
          `API of type ${apiType} ${apiName ? "and name " + apiName : ""} could not be found`
        );
      }
      return !limiter ? provider.api : scheduleWithBottleneck(provider.api);
    };
    const context = {
      api: (type, name) => getApi(type, name),
      viem: (apiName) => getApi("viem", apiName),
      polkadotJs: (apiName) => getApi("polkadotJs", apiName),
      ethers: (apiName) => getApi("ethers", apiName),
      web3: (apiName) => getApi("web3", apiName)
    };
    const foundationHandlers = {
      dev: devHandler,
      chopsticks: chopsticksHandler,
      zombie: zombieHandler,
      read_only: readOnlyHandler,
      fork: readOnlyHandler
    };
    const handler = foundationHandlers[foundationMethods];
    if (!handler) {
      throw new Error(`Unsupported foundation methods: ${foundationMethods}`);
    }
    handler({
      testCases,
      context,
      testCase,
      logger,
      ctx
    });
  });
}
var logger = () => {
  process.env.DEBUG_COLORS = "1";
  const debug3 = (0, import_debug5.default)(`test:${process.env.MOON_TEST_ENV}`);
  debug3.log = console.log.bind(process.stdout);
  import_debug5.default.enable("test:*");
  return debug3;
};
var loadParams = (config) => {
  const defaultParams = { maxConcurrent: 5, minTime: 100 };
  if (!config || config.rateLimiter === void 0 || config.rateLimiter === true) {
    return defaultParams;
  }
  if (config.rateLimiter === false) {
    return {};
  }
  if (typeof config.rateLimiter === "object") {
    return config.rateLimiter;
  }
};
var scheduleWithBottleneck = (api) => {
  return new Proxy(api, {
    get(target, propKey) {
      const origMethod = target[propKey];
      if (typeof origMethod === "function" && propKey !== "rpc" && propKey !== "tx") {
        return (...args) => {
          return limiter.schedule(() => origMethod.apply(target, args));
        };
      }
      return origMethod;
    }
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  describeSuite
});
