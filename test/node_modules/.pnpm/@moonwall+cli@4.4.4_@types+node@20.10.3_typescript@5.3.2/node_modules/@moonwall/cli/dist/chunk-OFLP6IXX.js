import {
  downloader
} from "./chunk-X7BPU2SI.js";
import {
  runTask
} from "./chunk-V365EHXB.js";
import {
  allReposAsync
} from "./chunk-3ZFRI75O.js";

// src/internal/cmdFunctions/fetchArtifact.ts
import fs from "node:fs/promises";
import path from "path";
import fetch from "node-fetch";
import semver from "semver";
import chalk from "chalk";
import { minimatch } from "minimatch";
import { execSync } from "node:child_process";
async function fetchArtifact(args) {
  if (await fs.access(args.path).catch(() => true)) {
    console.log("Folder not exists, creating");
    fs.mkdir(args.path);
  }
  const binary = args.bin;
  const repo = (await allReposAsync()).find(
    (network) => network.binaries.find((bin) => bin.name === binary)
  );
  if (!repo) {
    throw new Error(`Downloading ${binary} unsupported`);
  }
  const url = `https://api.github.com/repos/${repo.ghAuthor}/${repo.ghRepo}/releases`;
  const enteredPath = args.path ? args.path : "tmp/";
  const releases = await (await fetch(url)).json();
  const release = binary.includes("-runtime") ? releases.find((release2) => {
    if (args.ver === "latest") {
      return release2.assets.find((asset2) => asset2.name.includes(binary));
    } else {
      return release2.assets.find((asset2) => asset2.name === `${binary}-${args.ver}.wasm`);
    }
  }) : args.ver === "latest" ? releases.find((release2) => release2.assets.find((asset2) => asset2.name === binary)) : releases.filter((release2) => release2.tag_name.includes(args.ver)).find((release2) => release2.assets.find((asset2) => minimatch(asset2.name, binary)));
  if (release == null) {
    throw new Error(`Release not found for ${args.ver}`);
  }
  const asset = binary.includes("-runtime") ? release.assets.find((asset2) => asset2.name.includes(binary) && asset2.name.includes("wasm")) : release.assets.find((asset2) => minimatch(asset2.name, binary));
  if (!binary.includes("-runtime")) {
    const url2 = asset.browser_download_url;
    const filename = path.basename(url2);
    const binPath = path.join("./", enteredPath, filename);
    await downloader(url2, binPath);
    await fs.chmod(binPath, "755");
    if (filename.endsWith(".tar.gz")) {
      const outputBuffer = execSync(`tar -xzvf ${binPath}`);
      const cleaned = outputBuffer.toString().split("\n")[0].split("/")[0];
      const version = (await runTask(`./${cleaned} --version`)).trim();
      process.stdout.write(` ${chalk.green(version.trim())} \u2713
`);
      return;
    } else {
      const version = (await runTask(`./${binPath} --version`)).trim();
      process.stdout.write(` ${chalk.green(version.trim())} \u2713
`);
      return;
    }
  } else {
    const binaryPath = path.join("./", args.path, `${args.bin}-${args.ver}.wasm`);
    await downloader(asset.browser_download_url, binaryPath);
    await fs.chmod(binaryPath, "755");
    process.stdout.write(` ${chalk.green("done")} \u2713
`);
    return;
  }
}
async function getVersions(name, runtime = false) {
  const repo = (await allReposAsync()).find(
    (network) => network.binaries.find((bin) => bin.name === name)
  );
  if (!repo) {
    throw new Error(`Network not found for ${name}`);
  }
  const url = `https://api.github.com/repos/${repo.ghAuthor}/${repo.ghRepo}/releases`;
  const releases = await (await fetch(url)).json();
  const versions = releases.map((release) => {
    let tag = release.tag_name;
    if (release.tag_name.includes("v")) {
      tag = tag.split("v")[1];
    }
    if (tag.includes("-rc")) {
      tag = tag.split("-rc")[0];
    }
    return tag;
  }).filter(
    (version) => runtime && version.includes("runtime") || !runtime && !version.includes("runtime")
  ).map((version) => version.replace("runtime-", ""));
  const set = new Set(versions);
  return runtime ? [...set] : [...set].sort(
    (a, b) => semver.valid(a) && semver.valid(b) ? semver.rcompare(a, b) : a
  );
}

export {
  fetchArtifact,
  getVersions
};
