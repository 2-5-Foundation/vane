var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/upgradeProcedures.ts
var upgradeProcedures_exports = {};
__export(upgradeProcedures_exports, {
  upgradeRuntime: () => upgradeRuntime,
  upgradeRuntimeChopsticks: () => upgradeRuntimeChopsticks
});
module.exports = __toCommonJS(upgradeProcedures_exports);
var import_api_augment3 = require("@moonbeam-network/api-augment");
var import_util_crypto2 = require("@polkadot/util-crypto");
var import_chalk = __toESM(require("chalk"), 1);
var import_ethers = require("ethers");
var import_fs2 = __toESM(require("fs"), 1);

// src/lib/binariesHelpers.ts
var import_api_augment = require("@moonbeam-network/api-augment");
var import_path = __toESM(require("path"), 1);
var import_fs = __toESM(require("fs"), 1);
var import_child_process = __toESM(require("child_process"), 1);
var import_util = require("@moonwall/util");
var BINARY_DIRECTORY = process.env.BINARY_DIRECTORY || "binaries";
var RUNTIME_DIRECTORY = process.env.RUNTIME_DIRECTORY || "runtimes";
var SPECS_DIRECTORY = process.env.SPECS_DIRECTORY || "specs";
async function getRuntimeWasm(runtimeName, runtimeTag, localPath) {
  const runtimePath = import_path.default.join(RUNTIME_DIRECTORY, `${runtimeName}-${runtimeTag}.wasm`);
  if (!import_fs.default.existsSync(RUNTIME_DIRECTORY)) {
    import_fs.default.mkdirSync(RUNTIME_DIRECTORY, { recursive: true });
  }
  if (runtimeTag == "local") {
    const builtRuntimePath = localPath ? localPath : import_path.default.join(
      import_util.OVERRIDE_RUNTIME_PATH || `../target/release/wbuild/${runtimeName}-runtime/`,
      `${runtimeName}_runtime.compact.compressed.wasm`
    );
    const code = import_fs.default.readFileSync(builtRuntimePath);
    import_fs.default.writeFileSync(runtimePath, `0x${code.toString("hex")}`);
  } else if (!import_fs.default.existsSync(runtimePath)) {
    console.log(`     Missing ${runtimePath} locally, downloading it...`);
    import_child_process.default.execSync(
      `mkdir -p ${import_path.default.dirname(runtimePath)} && wget -q https://github.com/PureStake/moonbeam/releases/download/${runtimeTag}/${runtimeName}-${runtimeTag}.wasm -O ${runtimePath}.bin`
    );
    const code = import_fs.default.readFileSync(`${runtimePath}.bin`);
    import_fs.default.writeFileSync(runtimePath, `0x${code.toString("hex")}`);
    console.log(`${runtimePath} downloaded !`);
  }
  return runtimePath;
}

// src/lib/governanceProcedures.ts
var import_api_augment2 = require("@moonbeam-network/api-augment");
var import_vitest = require("vitest");
var import_util_crypto = require("@polkadot/util-crypto");
var import_util2 = require("@moonwall/util");
var COUNCIL_MEMBERS = [import_util2.baltathar, import_util2.charleth, import_util2.dorothy];
var COUNCIL_THRESHOLD = Math.ceil(COUNCIL_MEMBERS.length * 2 / 3);
var TECHNICAL_COMMITTEE_MEMBERS = [import_util2.alith, import_util2.baltathar];
var TECHNICAL_COMMITTEE_THRESHOLD = Math.ceil(
  TECHNICAL_COMMITTEE_MEMBERS.length * 2 / 3
);
var executeProposalWithCouncil = async (api, encodedHash) => {
  let nonce = (await api.rpc.system.accountNextIndex(import_util2.alith.address)).toNumber();
  const referendumNextIndex = (await api.query.democracy.referendumCount()).toNumber();
  const callData = api.consts.system.version.specVersion.toNumber() >= 2e3 ? { Legacy: encodedHash } : encodedHash;
  const external = api.tx.democracy.externalProposeMajority(callData);
  const fastTrack = api.tx.democracy.fastTrack(encodedHash, 1, 0);
  const voteAmount = 1n * 10n ** BigInt(api.registry.chainDecimals[0]);
  process.stdout.write(`Sending motion + fast-track + vote for ${encodedHash}...`);
  await Promise.all([
    api.tx.councilCollective.propose(1, external, external.length).signAndSend(import_util2.alith, { nonce: nonce++ }),
    api.tx.techCommitteeCollective.propose(1, fastTrack, fastTrack.length).signAndSend(import_util2.alith, { nonce: nonce++ }),
    api.tx.democracy.vote(referendumNextIndex, {
      Standard: {
        balance: voteAmount,
        vote: { aye: true, conviction: 1 }
      }
    }).signAndSend(import_util2.alith, { nonce: nonce++ })
  ]);
  process.stdout.write(`\u2705
`);
  process.stdout.write(`Waiting for referendum [${referendumNextIndex}] to be executed...`);
  let referenda;
  while (!referenda) {
    referenda = (await api.query.democracy.referendumInfoOf.entries()).find(
      (ref) => ref[1].unwrap().isFinished && api.registry.createType("u32", ref[0].toU8a().slice(-4)).toNumber() == referendumNextIndex
    )?.[1].unwrap();
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
  process.stdout.write(`${referenda.asFinished.approved ? `\u2705` : `\u274C`} 
`);
  if (!referenda.asFinished.approved) {
    throw new Error("Finished Referendum was not approved");
  }
};
var cancelReferendaWithCouncil = async (api, refIndex) => {
  const proposal = api.tx.democracy.cancelReferendum(refIndex);
  const encodedProposal = proposal.method.toHex();
  const encodedHash = (0, import_util_crypto.blake2AsHex)(encodedProposal);
  let nonce = (await api.rpc.system.accountNextIndex(import_util2.alith.address)).toNumber();
  await api.tx.democracy.notePreimage(encodedProposal).signAndSend(import_util2.alith, { nonce: nonce++ });
  await executeProposalWithCouncil(api, encodedHash);
};

// src/lib/upgradeProcedures.ts
async function upgradeRuntimeChopsticks(context, path2) {
  if (!(0, import_fs2.existsSync)(path2)) {
    throw new Error("Runtime wasm not found at path: " + path2);
  }
  const rtWasm = (0, import_fs2.readFileSync)(path2);
  const rtHex = `0x${rtWasm.toString("hex")}`;
  const rtHash = (0, import_util_crypto2.blake2AsHex)(rtHex);
  await context.setStorage({
    module: "parachainSystem",
    method: "authorizedUpgrade",
    methodParams: rtHash
  });
  await context.createBlock();
  const api = context.polkadotJs();
  const signer = context.keyring.alice;
  await api.tx.parachainSystem.enactAuthorizedUpgrade(rtHex).signAndSend(signer);
  await context.createBlock({ count: 3 });
}
async function upgradeRuntime(api, preferences) {
  const options = {
    waitMigration: true,
    useGovernance: false,
    ...preferences
  };
  return new Promise(async (resolve, reject) => {
    const log = (text) => {
      if (options.logger) {
        return options.logger(text);
      } else {
        return;
      }
    };
    try {
      const code = import_fs2.default.readFileSync(
        await getRuntimeWasm(options.runtimeName, options.runtimeTag, options.localPath)
      ).toString();
      log("Checking if upgrade is needed...");
      const existingCode = await api.rpc.state.getStorage(":code");
      if (existingCode.toString() == code) {
        reject(
          `Runtime upgrade with same code: ${existingCode.toString().slice(0, 20)} vs ${code.toString().slice(0, 20)}`
        );
      }
      let nonce = (await api.rpc.system.accountNextIndex(options.from.address)).toNumber();
      if (options.useGovernance) {
        log("Using governance...");
        const proposal = api.consts.system.version.specVersion.toNumber() >= 2400 ? api.tx.parachainSystem.authorizeUpgrade((0, import_util_crypto2.blake2AsHex)(code), false) : api.tx.parachainSystem.authorizeUpgrade((0, import_util_crypto2.blake2AsHex)(code));
        const encodedProposal = proposal.method.toHex();
        const encodedHash = (0, import_util_crypto2.blake2AsHex)(encodedProposal);
        log("Checking if preimage already exists...");
        const preImageExists = api.query.preimage && await api.query.preimage.statusFor(encodedHash);
        const democracyPreImageExists = !api.query.preimage && await api.query.democracy.preimages(encodedHash);
        if (api.query.preimage && preImageExists.isSome && preImageExists.unwrap().isRequested) {
          log(`Preimage ${encodedHash} already exists !
`);
        } else if (!api.query.preimage && democracyPreImageExists) {
          log(`Preimage ${encodedHash} already exists !
`);
        } else {
          log(
            `Registering preimage (${(0, import_ethers.sha256)(Buffer.from(code))} [~${Math.floor(
              code.length / 1024
            )} kb])...`
          );
          if (api.query.preimage) {
            await api.tx.preimage.notePreimage(encodedProposal).signAndSend(options.from, { nonce: nonce++ });
          } else {
            await api.tx.democracy.notePreimage(encodedProposal).signAndSend(options.from, { nonce: nonce++ });
          }
          log(`Complete \u2705`);
        }
        const referendum = await api.query.democracy.referendumInfoOf.entries();
        const referendaIndex = api.query.preimage ? referendum.filter(
          (ref) => ref[1].unwrap().isOngoing && ref[1].unwrap().asOngoing.proposal.isLookup && ref[1].unwrap().asOngoing.proposal.asLookup.hash.toHex() == encodedHash
        ).map(
          (ref) => api.registry.createType("u32", ref[0].toU8a().slice(-4)).toNumber()
        )?.[0] : referendum.filter(
          (ref) => ref[1].unwrap().isOngoing && ref[1].unwrap().asOngoing.proposalHash.toHex() == encodedHash
        ).map(
          (ref) => api.registry.createType("u32", ref[0].toU8a().slice(-4)).toNumber()
        )?.[0];
        if (referendaIndex !== null && referendaIndex !== void 0) {
          log(`Vote for upgrade already in referendum, cancelling it.`);
          await cancelReferendaWithCouncil(api, referendaIndex);
        }
        await executeProposalWithCouncil(api, encodedHash);
        nonce = (await api.rpc.system.accountNextIndex(options.from.address)).toNumber();
        log(`Enacting authorized upgrade...`);
        await api.tx.parachainSystem.enactAuthorizedUpgrade(code).signAndSend(options.from, { nonce: nonce++ });
        log(`Complete \u2705`);
      } else {
        log(
          `Sending sudo.setCode (${(0, import_ethers.sha256)(Buffer.from(code))} [~${Math.floor(
            code.length / 1024
          )} kb])...`
        );
        const isWeightV1 = !api.registry.createType("Weight").proofSize;
        await api.tx.sudo.sudoUncheckedWeight(
          await api.tx.system.setCodeWithoutChecks(code),
          isWeightV1 ? "1" : {
            proofSize: 1,
            refTime: 1
          }
        ).signAndSend(options.from, { nonce: nonce++ });
        log(`\u2705`);
      }
      log(`Waiting to apply new runtime (${import_chalk.default.red(`~4min`)})...`);
      let isInitialVersion = true;
      const unsub = await api.rpc.state.subscribeStorage([":code"], async (newCode) => {
        if (!isInitialVersion) {
          const blockNumber = (await api.rpc.chain.getHeader()).number.toNumber();
          log(
            `Complete \u2705 [New Code: ${newCode.toString().slice(0, 5)}...${newCode.toString().slice(-4)} , Old Code:${existingCode.toString().slice(0, 5)}...${existingCode.toString().slice(-4)}] [#${blockNumber}]`
          );
          unsub();
          if (newCode.toString() != code) {
            reject(
              `Unexpected new code: ${newCode.toString().slice(0, 20)} vs ${code.toString().slice(0, 20)}`
            );
          }
          if (options.waitMigration) {
            const blockToWait = (await api.rpc.chain.getHeader()).number.toNumber() + 1;
            await new Promise(async (resolve2) => {
              const subBlocks = await api.rpc.chain.subscribeNewHeads(async (header) => {
                if (header.number.toNumber() == blockToWait) {
                  subBlocks();
                  resolve2(blockToWait);
                }
              });
            });
          }
          resolve(blockNumber);
        }
        isInitialVersion = false;
      });
    } catch (e) {
      console.error(`Failed to setCode`);
      reject(e);
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  upgradeRuntime,
  upgradeRuntimeChopsticks
});
