var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/internal/fileCheckers.ts
var fileCheckers_exports = {};
__export(fileCheckers_exports, {
  checkAccess: () => checkAccess,
  checkAlreadyRunning: () => checkAlreadyRunning,
  checkExists: () => checkExists,
  checkListeningPorts: () => checkListeningPorts,
  downloadBinsIfMissing: () => downloadBinsIfMissing,
  promptAlreadyRunning: () => promptAlreadyRunning
});
module.exports = __toCommonJS(fileCheckers_exports);
var import_node_fs = __toESM(require("fs"), 1);
var import_child_process = require("child_process");
var import_chalk = __toESM(require("chalk"), 1);
var import_node_os = __toESM(require("os"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_node_path = __toESM(require("path"), 1);
async function checkExists(path2) {
  const binPath = path2.split(" ")[0];
  const fsResult = import_node_fs.default.existsSync(binPath);
  if (!fsResult) {
    throw new Error(
      `No binary file found at location: ${binPath} 
 Are you sure your ${import_chalk.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "binPath" in launchSpec?`
    );
  }
  const binArch = await getBinaryArchitecture(binPath);
  const currentArch = import_node_os.default.arch();
  if (binArch !== currentArch && binArch !== "unknown") {
    throw new Error(
      `The binary architecture ${import_chalk.default.bgWhiteBright.blackBright(
        binArch
      )} does not match this system's architecture ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )}
Download or compile a new binary executable for ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )} `
    );
  }
  return true;
}
async function downloadBinsIfMissing(binPath) {
  const binName = import_node_path.default.basename(binPath);
  const binDir = import_node_path.default.dirname(binPath);
  const binPathExists = import_node_fs.default.existsSync(binPath);
  if (!binPathExists && process.arch === "x64") {
    const choices = await import_inquirer.default.prompt({
      name: "download",
      type: "list",
      message: `The binary ${import_chalk.default.bgBlack.greenBright(
        binName
      )} is missing from ${import_chalk.default.bgBlack.greenBright(
        import_node_path.default.join(process.cwd(), binDir)
      )}.
Would you like to download it now?`,
      default: 0,
      choices: [
        { name: `Yes, download ${binName}`, value: true },
        { name: "No, quit program", value: false }
      ]
    });
    if (!choices.download) {
      process.exit(0);
    } else {
      (0, import_child_process.execSync)(`mkdir -p ${binDir}`);
      (0, import_child_process.execSync)(`pnpm moonwall download ${binName} latest ${binDir}`, {
        stdio: "inherit"
      });
    }
  } else if (!binPathExists) {
    console.log(
      `The binary: ${import_chalk.default.bgBlack.greenBright(
        binName
      )} is missing from: ${import_chalk.default.bgBlack.greenBright(import_node_path.default.join(process.cwd(), binDir))}`
    );
    console.log(
      `Given you are running ${import_chalk.default.bgBlack.yellowBright(
        process.arch
      )} architecture, you will need to build it manually from source \u{1F6E0}\uFE0F`
    );
    throw new Error("Executable binary not available");
  }
}
function checkListeningPorts(processId) {
  try {
    const stdOut = (0, import_child_process.execSync)(`lsof -p  ${processId} | grep LISTEN`, { encoding: "utf-8" });
    const binName = stdOut.split("\n")[0].split(" ")[0];
    const ports = stdOut.split("\n").filter(Boolean).map((line) => {
      const port = line.split(":")[1];
      return port.split(" ")[0];
    });
    const filtered = new Set(ports);
    return { binName, processId, ports: [...filtered].sort() };
  } catch (e) {
    console.log(e);
    const binName = (0, import_child_process.execSync)(`ps -p ${processId} -o comm=`).toString().trim();
    console.log(
      `Process ${processId} is running which for binary ${binName}, however it is unresponsive.`
    );
    console.log(
      "Running Moonwall with this in the background may cause unexpected behaviour. Please manually kill the process and try running Moonwall again."
    );
    console.log(`N.B. You can kill it with: sudo kill -9 ${processId}`);
    throw new Error(e);
  }
}
function checkAlreadyRunning(binaryName) {
  try {
    console.log(`Checking if ${import_chalk.default.bgWhiteBright.blackBright(binaryName)} is already running...`);
    const stdout = (0, import_child_process.execSync)(`pgrep ${[binaryName.slice(0, 14)]}`, {
      encoding: "utf8",
      timeout: 2e3
    });
    const pIdStrings = stdout.split("\n").filter(Boolean);
    return pIdStrings.map((pId) => parseInt(pId, 10));
  } catch (error) {
    if (error.status === 1) {
      return [];
    }
    throw error;
  }
}
async function promptAlreadyRunning(pids) {
  const choice = await import_inquirer.default.prompt({
    name: "AlreadyRunning",
    type: "list",
    message: `The following processes are already running: 
${pids.map((pid) => {
      const { binName, ports } = checkListeningPorts(pid);
      return `${binName} - pid: ${pid}, listenPorts: [${ports.join(", ")}]`;
    }).join("\n")}`,
    default: 1,
    choices: [
      { name: "\u{1FA93}  Kill processes and continue", value: "kill" },
      { name: "\u27A1\uFE0F   Continue (and let processes live)", value: "continue" },
      { name: "\u{1F6D1}  Abort (and let processes live)", value: "abort" }
    ]
  });
  switch (choice.AlreadyRunning) {
    case "kill":
      pids.forEach((pid) => {
        (0, import_child_process.execSync)(`kill ${pid}`);
      });
      break;
    case "continue":
      break;
    case "abort":
      throw new Error("Abort Signal Picked");
  }
}
function checkAccess(path2) {
  const binPath = path2.split(" ")[0];
  try {
    import_node_fs.default.accessSync(binPath, import_node_fs.default.constants.X_OK);
  } catch (err) {
    console.error(`The file ${binPath} is not executable`);
    throw new Error(`The file at ${binPath} , lacks execute permissions.`);
  }
}
async function getBinaryArchitecture(filePath) {
  return new Promise((resolve, reject) => {
    const architectureMap = {
      0: "unknown",
      3: "x86",
      62: "x64",
      183: "arm64"
    };
    import_node_fs.default.open(filePath, "r", (err, fd) => {
      if (err) {
        reject(err);
        return;
      }
      const buffer = Buffer.alloc(20);
      import_node_fs.default.read(fd, buffer, 0, 20, 0, (err2, bytesRead, buffer2) => {
        if (err2) {
          reject(err2);
          return;
        }
        const e_machine = buffer2.readUInt16LE(18);
        const architecture = architectureMap[e_machine] || "unknown";
        resolve(architecture);
      });
    });
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  checkAccess,
  checkAlreadyRunning,
  checkExists,
  checkListeningPorts,
  downloadBinsIfMissing,
  promptAlreadyRunning
});
