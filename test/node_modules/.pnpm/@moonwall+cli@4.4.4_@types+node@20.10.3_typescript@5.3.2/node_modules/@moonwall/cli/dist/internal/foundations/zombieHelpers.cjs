var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/internal/foundations/zombieHelpers.ts
var zombieHelpers_exports = {};
__export(zombieHelpers_exports, {
  checkZombieBins: () => checkZombieBins,
  getZombieConfig: () => getZombieConfig,
  sendIpcMessage: () => sendIpcMessage
});
module.exports = __toCommonJS(zombieHelpers_exports);
var import_chalk2 = __toESM(require("chalk"), 1);
var import_node_fs2 = __toESM(require("fs"), 1);

// src/internal/fileCheckers.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_chalk = __toESM(require("chalk"), 1);
var import_node_os = __toESM(require("os"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_node_path = __toESM(require("path"), 1);
async function checkExists(path2) {
  const binPath = path2.split(" ")[0];
  const fsResult = import_node_fs.default.existsSync(binPath);
  if (!fsResult) {
    throw new Error(
      `No binary file found at location: ${binPath} 
 Are you sure your ${import_chalk.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "binPath" in launchSpec?`
    );
  }
  const binArch = await getBinaryArchitecture(binPath);
  const currentArch = import_node_os.default.arch();
  if (binArch !== currentArch && binArch !== "unknown") {
    throw new Error(
      `The binary architecture ${import_chalk.default.bgWhiteBright.blackBright(
        binArch
      )} does not match this system's architecture ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )}
Download or compile a new binary executable for ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )} `
    );
  }
  return true;
}
function checkAccess(path2) {
  const binPath = path2.split(" ")[0];
  try {
    import_node_fs.default.accessSync(binPath, import_node_fs.default.constants.X_OK);
  } catch (err) {
    console.error(`The file ${binPath} is not executable`);
    throw new Error(`The file at ${binPath} , lacks execute permissions.`);
  }
}
async function getBinaryArchitecture(filePath) {
  return new Promise((resolve, reject) => {
    const architectureMap = {
      0: "unknown",
      3: "x86",
      62: "x64",
      183: "arm64"
    };
    import_node_fs.default.open(filePath, "r", (err, fd) => {
      if (err) {
        reject(err);
        return;
      }
      const buffer = Buffer.alloc(20);
      import_node_fs.default.read(fd, buffer, 0, 20, 0, (err2, bytesRead, buffer2) => {
        if (err2) {
          reject(err2);
          return;
        }
        const e_machine = buffer2.readUInt16LE(18);
        const architecture = architectureMap[e_machine] || "unknown";
        resolve(architecture);
      });
    });
  });
}

// src/internal/foundations/zombieHelpers.ts
var import_promises = require("timers/promises");
var import_net = __toESM(require("net"), 1);
async function checkZombieBins(config) {
  const relayBinPath = config.relaychain.default_command;
  await checkExists(relayBinPath);
  checkAccess(relayBinPath);
  const promises = config.parachains.map((para) => {
    if (para.collator) {
      if (!para.collator.command) {
        throw new Error(
          "No command found for collator, please check your zombienet config file for collator command"
        );
      }
      checkExists(para.collator.command);
      checkAccess(para.collator.command);
    }
    if (para.collators) {
      para.collators.forEach((coll) => {
        if (!coll.command) {
          throw new Error(
            "No command found for collators, please check your zombienet config file for para collators command"
          );
        }
        checkExists(coll.command);
        checkAccess(coll.command);
      });
    }
  });
  await Promise.all(promises);
}
function getZombieConfig(path2) {
  const fsResult = import_node_fs2.default.existsSync(path2);
  if (!fsResult) {
    throw new Error(
      `No ZombieConfig file found at location: ${path2} 
 Are you sure your ${import_chalk2.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "configPath" in zombieSpec?`
    );
  }
  const buffer = import_node_fs2.default.readFileSync(path2, "utf-8");
  return JSON.parse(buffer);
}
async function sendIpcMessage(message) {
  return new Promise(async (resolve, reject) => {
    let response;
    const ipcPath = process.env.MOON_IPC_SOCKET;
    const client = import_net.default.createConnection({ path: ipcPath });
    client.on("data", async (data) => {
      response = JSON.parse(data.toString());
      if (response.status === "success") {
        client.end();
        for (let i = 0; ; i++) {
          if (client.closed) {
            break;
          }
          if (i > 100) {
            reject(new Error(`Closing IPC connection failed`));
          }
          await (0, import_promises.setTimeout)(200);
        }
        resolve(response);
      }
      if (response.status === "failure") {
        reject(new Error(JSON.stringify(response)));
      }
    });
    for (let i = 0; ; i++) {
      if (!client.connecting) {
        break;
      }
      if (i > 100) {
        reject(new Error(`Connection to ${ipcPath} failed`));
      }
      await (0, import_promises.setTimeout)(200);
    }
    await new Promise((resolve2) => {
      client.write(JSON.stringify(message), () => resolve2("Sent!"));
    });
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  checkZombieBins,
  getZombieConfig,
  sendIpcMessage
});
