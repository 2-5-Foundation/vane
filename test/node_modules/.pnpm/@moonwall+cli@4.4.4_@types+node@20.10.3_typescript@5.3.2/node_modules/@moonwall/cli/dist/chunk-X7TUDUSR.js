import {
  cancelReferendaWithCouncil,
  executeProposalWithCouncil
} from "./chunk-ELWCOTTZ.js";
import {
  getRuntimeWasm
} from "./chunk-TOMAY27Z.js";

// src/lib/upgradeProcedures.ts
import "@moonbeam-network/api-augment";
import { blake2AsHex } from "@polkadot/util-crypto";
import chalk from "chalk";
import { sha256 } from "ethers";
import fs, { existsSync, readFileSync } from "fs";
async function upgradeRuntimeChopsticks(context, path) {
  if (!existsSync(path)) {
    throw new Error("Runtime wasm not found at path: " + path);
  }
  const rtWasm = readFileSync(path);
  const rtHex = `0x${rtWasm.toString("hex")}`;
  const rtHash = blake2AsHex(rtHex);
  await context.setStorage({
    module: "parachainSystem",
    method: "authorizedUpgrade",
    methodParams: rtHash
  });
  await context.createBlock();
  const api = context.polkadotJs();
  const signer = context.keyring.alice;
  await api.tx.parachainSystem.enactAuthorizedUpgrade(rtHex).signAndSend(signer);
  await context.createBlock({ count: 3 });
}
async function upgradeRuntime(api, preferences) {
  const options = {
    waitMigration: true,
    useGovernance: false,
    ...preferences
  };
  return new Promise(async (resolve, reject) => {
    const log = (text) => {
      if (options.logger) {
        return options.logger(text);
      } else {
        return;
      }
    };
    try {
      const code = fs.readFileSync(
        await getRuntimeWasm(options.runtimeName, options.runtimeTag, options.localPath)
      ).toString();
      log("Checking if upgrade is needed...");
      const existingCode = await api.rpc.state.getStorage(":code");
      if (existingCode.toString() == code) {
        reject(
          `Runtime upgrade with same code: ${existingCode.toString().slice(0, 20)} vs ${code.toString().slice(0, 20)}`
        );
      }
      let nonce = (await api.rpc.system.accountNextIndex(options.from.address)).toNumber();
      if (options.useGovernance) {
        log("Using governance...");
        const proposal = api.consts.system.version.specVersion.toNumber() >= 2400 ? api.tx.parachainSystem.authorizeUpgrade(blake2AsHex(code), false) : api.tx.parachainSystem.authorizeUpgrade(blake2AsHex(code));
        const encodedProposal = proposal.method.toHex();
        const encodedHash = blake2AsHex(encodedProposal);
        log("Checking if preimage already exists...");
        const preImageExists = api.query.preimage && await api.query.preimage.statusFor(encodedHash);
        const democracyPreImageExists = !api.query.preimage && await api.query.democracy.preimages(encodedHash);
        if (api.query.preimage && preImageExists.isSome && preImageExists.unwrap().isRequested) {
          log(`Preimage ${encodedHash} already exists !
`);
        } else if (!api.query.preimage && democracyPreImageExists) {
          log(`Preimage ${encodedHash} already exists !
`);
        } else {
          log(
            `Registering preimage (${sha256(Buffer.from(code))} [~${Math.floor(
              code.length / 1024
            )} kb])...`
          );
          if (api.query.preimage) {
            await api.tx.preimage.notePreimage(encodedProposal).signAndSend(options.from, { nonce: nonce++ });
          } else {
            await api.tx.democracy.notePreimage(encodedProposal).signAndSend(options.from, { nonce: nonce++ });
          }
          log(`Complete \u2705`);
        }
        const referendum = await api.query.democracy.referendumInfoOf.entries();
        const referendaIndex = api.query.preimage ? referendum.filter(
          (ref) => ref[1].unwrap().isOngoing && ref[1].unwrap().asOngoing.proposal.isLookup && ref[1].unwrap().asOngoing.proposal.asLookup.hash.toHex() == encodedHash
        ).map(
          (ref) => api.registry.createType("u32", ref[0].toU8a().slice(-4)).toNumber()
        )?.[0] : referendum.filter(
          (ref) => ref[1].unwrap().isOngoing && ref[1].unwrap().asOngoing.proposalHash.toHex() == encodedHash
        ).map(
          (ref) => api.registry.createType("u32", ref[0].toU8a().slice(-4)).toNumber()
        )?.[0];
        if (referendaIndex !== null && referendaIndex !== void 0) {
          log(`Vote for upgrade already in referendum, cancelling it.`);
          await cancelReferendaWithCouncil(api, referendaIndex);
        }
        await executeProposalWithCouncil(api, encodedHash);
        nonce = (await api.rpc.system.accountNextIndex(options.from.address)).toNumber();
        log(`Enacting authorized upgrade...`);
        await api.tx.parachainSystem.enactAuthorizedUpgrade(code).signAndSend(options.from, { nonce: nonce++ });
        log(`Complete \u2705`);
      } else {
        log(
          `Sending sudo.setCode (${sha256(Buffer.from(code))} [~${Math.floor(
            code.length / 1024
          )} kb])...`
        );
        const isWeightV1 = !api.registry.createType("Weight").proofSize;
        await api.tx.sudo.sudoUncheckedWeight(
          await api.tx.system.setCodeWithoutChecks(code),
          isWeightV1 ? "1" : {
            proofSize: 1,
            refTime: 1
          }
        ).signAndSend(options.from, { nonce: nonce++ });
        log(`\u2705`);
      }
      log(`Waiting to apply new runtime (${chalk.red(`~4min`)})...`);
      let isInitialVersion = true;
      const unsub = await api.rpc.state.subscribeStorage([":code"], async (newCode) => {
        if (!isInitialVersion) {
          const blockNumber = (await api.rpc.chain.getHeader()).number.toNumber();
          log(
            `Complete \u2705 [New Code: ${newCode.toString().slice(0, 5)}...${newCode.toString().slice(-4)} , Old Code:${existingCode.toString().slice(0, 5)}...${existingCode.toString().slice(-4)}] [#${blockNumber}]`
          );
          unsub();
          if (newCode.toString() != code) {
            reject(
              `Unexpected new code: ${newCode.toString().slice(0, 20)} vs ${code.toString().slice(0, 20)}`
            );
          }
          if (options.waitMigration) {
            const blockToWait = (await api.rpc.chain.getHeader()).number.toNumber() + 1;
            await new Promise(async (resolve2) => {
              const subBlocks = await api.rpc.chain.subscribeNewHeads(async (header) => {
                if (header.number.toNumber() == blockToWait) {
                  subBlocks();
                  resolve2(blockToWait);
                }
              });
            });
          }
          resolve(blockNumber);
        }
        isInitialVersion = false;
      });
    } catch (e) {
      console.error(`Failed to setCode`);
      reject(e);
    }
  });
}

export {
  upgradeRuntimeChopsticks,
  upgradeRuntime
};
