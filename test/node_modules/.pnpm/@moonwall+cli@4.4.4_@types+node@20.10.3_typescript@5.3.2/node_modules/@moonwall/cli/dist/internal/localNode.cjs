var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/internal/localNode.ts
var localNode_exports = {};
__export(localNode_exports, {
  launchNode: () => launchNode
});
module.exports = __toCommonJS(localNode_exports);
var import_child_process = require("child_process");
var import_debug = __toESM(require("debug"), 1);
var import_fs = __toESM(require("fs"), 1);
var import_path = __toESM(require("path"), 1);
var import_ws = __toESM(require("ws"), 1);

// src/internal/fileCheckers.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_chalk = __toESM(require("chalk"), 1);
var import_node_os = __toESM(require("os"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_node_path = __toESM(require("path"), 1);
async function checkExists(path3) {
  const binPath = path3.split(" ")[0];
  const fsResult = import_node_fs.default.existsSync(binPath);
  if (!fsResult) {
    throw new Error(
      `No binary file found at location: ${binPath} 
 Are you sure your ${import_chalk.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "binPath" in launchSpec?`
    );
  }
  const binArch = await getBinaryArchitecture(binPath);
  const currentArch = import_node_os.default.arch();
  if (binArch !== currentArch && binArch !== "unknown") {
    throw new Error(
      `The binary architecture ${import_chalk.default.bgWhiteBright.blackBright(
        binArch
      )} does not match this system's architecture ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )}
Download or compile a new binary executable for ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )} `
    );
  }
  return true;
}
function checkAccess(path3) {
  const binPath = path3.split(" ")[0];
  try {
    import_node_fs.default.accessSync(binPath, import_node_fs.default.constants.X_OK);
  } catch (err) {
    console.error(`The file ${binPath} is not executable`);
    throw new Error(`The file at ${binPath} , lacks execute permissions.`);
  }
}
async function getBinaryArchitecture(filePath) {
  return new Promise((resolve, reject) => {
    const architectureMap = {
      0: "unknown",
      3: "x86",
      62: "x64",
      183: "arm64"
    };
    import_node_fs.default.open(filePath, "r", (err, fd) => {
      if (err) {
        reject(err);
        return;
      }
      const buffer = Buffer.alloc(20);
      import_node_fs.default.read(fd, buffer, 0, 20, 0, (err2, bytesRead, buffer2) => {
        if (err2) {
          reject(err2);
          return;
        }
        const e_machine = buffer2.readUInt16LE(18);
        const architecture = architectureMap[e_machine] || "unknown";
        resolve(architecture);
      });
    });
  });
}

// src/internal/localNode.ts
var debugNode = (0, import_debug.default)("global:node");
async function launchNode(cmd, args, name) {
  if (cmd.includes("moonbeam")) {
    await checkExists(cmd);
    checkAccess(cmd);
  }
  const dirPath = import_path.default.join(process.cwd(), "tmp", "node_logs");
  const onProcessExit = () => {
    runningNode && runningNode.kill();
  };
  const onProcessInterrupt = () => {
    runningNode && runningNode.kill();
  };
  process.once("exit", onProcessExit);
  process.once("SIGINT", onProcessInterrupt);
  const runningNode = (0, import_child_process.spawn)(cmd, args);
  const logLocation = import_path.default.join(
    dirPath,
    `${import_path.default.basename(cmd)}_node_${args.find((a) => a.includes("port"))?.split("=")[1]}_${runningNode.pid}.log`
  ).replaceAll("node_node_undefined", "chopsticks");
  process.env.MOON_LOG_LOCATION = logLocation;
  const fsStream = import_fs.default.createWriteStream(logLocation);
  runningNode.once("exit", () => {
    process.removeListener("exit", onProcessExit);
    process.removeListener("SIGINT", onProcessInterrupt);
    runningNode.stderr?.off("data", writeLogToFile);
    runningNode.stdout?.off("data", writeLogToFile);
    fsStream.end();
    debugNode(`Exiting dev node: ${name}`);
  });
  runningNode.on("error", (err) => {
    if (err.errno == "ENOENT") {
      console.error(
        `\x1B[31mMissing Local binary at(${cmd}).
Please compile the project\x1B[0m`
      );
    } else {
      console.error(err);
    }
    process.exit(1);
  });
  const writeLogToFile = (chunk) => {
    if (fsStream.writable) {
      fsStream.write(chunk, (err) => {
        if (err)
          console.error(err);
        else
          fsStream.emit("drain");
      });
    }
  };
  runningNode.stderr?.on("data", writeLogToFile);
  runningNode.stdout?.on("data", writeLogToFile);
  probe:
    for (; ; ) {
      try {
        const ports = await findPortsByPid(runningNode.pid);
        if (ports) {
          for (const port of ports) {
            try {
              await checkWebSocketJSONRPC(port);
              break probe;
            } catch {
              continue;
            }
          }
        }
      } catch {
        continue;
      }
    }
  return runningNode;
}
async function checkWebSocketJSONRPC(port) {
  return new Promise((resolve, reject) => {
    const ws = new import_ws.default(`ws://localhost:${port}`);
    ws.on("open", () => {
      ws.send(
        JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "system_chain",
          params: []
        })
      );
    });
    ws.on("message", (data) => {
      try {
        const response = JSON.parse(data.toString());
        if (response.jsonrpc === "2.0" && response.id === 1) {
          resolve(true);
        } else {
          reject(false);
        }
      } catch (e) {
        reject(false);
      }
      ws.close();
    });
    ws.on("error", () => {
      reject(false);
    });
  });
}
async function findPortsByPid(pid, retryCount = 600, retryDelay = 100) {
  for (let i = 0; i < retryCount; i++) {
    try {
      const stdout = (0, import_child_process.execSync)(`lsof -i -n -P | grep LISTEN | grep ${pid}`).toString();
      const ports = [];
      const lines = stdout.split("\n");
      for (const line of lines) {
        const regex = /(?:\*|127\.0\.0\.1):(\d+)/;
        const match = line.match(regex);
        if (match) {
          ports.push(Number(match[1]));
        }
      }
      if (ports.length) {
        return ports;
      }
    } catch (error) {
      if (i === retryCount - 1) {
        throw error;
      }
    }
    await new Promise((resolve) => setTimeout(resolve, retryDelay));
  }
  return [];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  launchNode
});
