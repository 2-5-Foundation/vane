import {
  clearNodeLogs
} from "./chunk-N6GJ5CGR.js";
import {
  MoonwallContext,
  contextCreator,
  runNetworkOnly
} from "./chunk-RDW3KT5X.js";
import {
  commonChecks
} from "./chunk-WRSD6W42.js";
import {
  cacheConfig,
  importAsyncConfig,
  loadEnvVars
} from "./chunk-3IRCD3RX.js";

// src/cmds/runTests.ts
import chalk from "chalk";
import path from "path";
import { startVitest } from "vitest/node";
async function testCmd(envName, additionalArgs) {
  await cacheConfig();
  const globalConfig = await importAsyncConfig();
  const env = globalConfig.environments.find(({ name }) => name === envName);
  process.env.MOON_TEST_ENV = envName;
  if (!env) {
    const envList = globalConfig.environments.map((env2) => env2.name);
    new Error(
      `No environment found in config for: ${chalk.bgWhiteBright.blackBright(
        envName
      )}
 Environments defined in config are: ${envList}
`
    );
  }
  loadEnvVars();
  await commonChecks(env);
  if (env.foundation.type == "dev" && !env.foundation.launchSpec[0].retainAllLogs || env.foundation.type == "chopsticks" && !env.foundation.launchSpec[0].retainAllLogs) {
    clearNodeLogs();
  }
  const vitest = await executeTests(env, additionalArgs);
  const failed = vitest.state.getFiles().filter((file) => file.result.state === "fail");
  if (failed.length === 0) {
    console.log("\u2705 All tests passed");
    return true;
  } else {
    console.log("\u274C Some tests failed");
    return false;
  }
}
async function executeTests(env, additionalArgs) {
  return new Promise(async (resolve, reject) => {
    const globalConfig = await importAsyncConfig();
    if (env.foundation.type === "read_only") {
      try {
        if (!process.env.MOON_TEST_ENV) {
          throw new Error("MOON_TEST_ENV not set");
        }
        const ctx = await contextCreator();
        const chainData = ctx.providers.filter((provider) => provider.type == "polkadotJs" && provider.name.includes("para")).map((provider) => {
          return {
            [provider.name]: {
              rtName: provider.greet().rtName,
              rtVersion: provider.greet().rtVersion
            }
          };
        });
        const { rtVersion, rtName } = Object.values(chainData[0])[0];
        process.env.MOON_RTVERSION = rtVersion;
        process.env.MOON_RTNAME = rtName;
        await MoonwallContext.destroy();
      } catch {
      }
    }
    const baseOptions = {
      watch: false,
      globals: true,
      reporters: env.reporters ? env.reporters : ["default"],
      outputFile: env.reportFile,
      testTimeout: env.timeout || globalConfig.defaultTestTimeout,
      hookTimeout: env.timeout || globalConfig.defaultTestTimeout,
      passWithNoTests: false,
      deps: {
        optimizer: { ssr: { enabled: false }, web: { enabled: false } }
      },
      include: env.include ? env.include : ["**/*{test,spec,test_,test-}*{ts,mts,cts}"],
      onConsoleLog(log) {
        if (filterList.includes(log.trim()))
          return false;
        if (log.includes("has multiple versions, ensure that there is only one installed.")) {
          return false;
        }
      }
    };
    const options = addThreadConfig(baseOptions, env.multiThreads);
    if (globalConfig.environments.find((env2) => env2.name === process.env.MOON_TEST_ENV)?.foundation.type == "zombie") {
      await runNetworkOnly();
      process.env.MOON_RECYCLE = "true";
    }
    try {
      const folders = env.testFileDir.map((folder) => path.join(".", folder, "/"));
      resolve(await startVitest("test", folders, { ...options, ...additionalArgs }));
    } catch (e) {
      console.error(e);
      reject(e);
    }
  });
}
var filterList = ["<empty line>", "", "stdout | unknown test"];
function addThreadConfig(config, threads = false) {
  const configWithThreads = {
    ...config,
    pool: "threads",
    poolOptions: {
      threads: {
        isolate: true,
        minThreads: 1,
        maxThreads: 1,
        singleThread: false,
        useAtomics: false
      }
    }
  };
  if (threads == true && process.env.MOON_RECYCLE !== "true") {
    configWithThreads.poolOptions.threads = {
      isolate: true,
      minThreads: 1,
      maxThreads: 3,
      singleThread: false,
      useAtomics: false
    };
  }
  if (typeof threads === "number") {
    configWithThreads.poolOptions.threads.maxThreads = threads;
    configWithThreads.poolOptions.threads.singleThread = false;
  }
  if (typeof threads === "object") {
    const key = Object.keys(threads)[0];
    if (["threads", "forks", "vmThreads", "typescript"].includes(key)) {
      configWithThreads.pool = key;
      configWithThreads.poolOptions = Object.values(threads)[0];
    } else {
      throw new Error(`Invalid pool type: ${key}`);
    }
  }
  return configWithThreads;
}

export {
  testCmd,
  executeTests
};
