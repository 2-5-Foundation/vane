var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/internal/launcherCommon.ts
var launcherCommon_exports = {};
__export(launcherCommon_exports, {
  commonChecks: () => commonChecks,
  executeScript: () => executeScript
});
module.exports = __toCommonJS(launcherCommon_exports);
var import_chalk2 = __toESM(require("chalk"), 1);
var import_child_process2 = require("child_process");
var import_fs2 = __toESM(require("fs"), 1);
var import_path2 = __toESM(require("path"), 1);

// src/lib/configReader.ts
var import_api_augment = require("@moonbeam-network/api-augment");
var import_promises = require("fs/promises");
var import_fs = require("fs");
var import_jsonc_parser = __toESM(require("jsonc-parser"), 1);
var import_path = __toESM(require("path"), 1);
var cachedConfig;
async function parseConfig(filePath) {
  let result;
  const file = await (0, import_promises.readFile)(filePath, "utf8");
  switch ((0, import_path.extname)(filePath)) {
    case ".json":
      result = JSON.parse(file);
      break;
    case ".config":
      result = import_jsonc_parser.default.parse(file);
      break;
    default:
      result = void 0;
      break;
  }
  return result;
}
async function importAsyncConfig() {
  if (cachedConfig) {
    return cachedConfig;
  }
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path.default.isAbsolute(configPath) ? configPath : import_path.default.join(process.cwd(), configPath);
  try {
    const config = await parseConfig(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
    return cachedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
function replaceEnvVars(value) {
  if (typeof value === "string") {
    return value.replace(/\$\{([^}]+)\}/g, (match, group) => {
      const envVarValue = process.env[group];
      return envVarValue || match;
    });
  } else if (Array.isArray(value)) {
    return value.map(replaceEnvVars);
  } else if (typeof value === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, replaceEnvVars(v)]));
  } else {
    return value;
  }
}
function parseZombieConfigForBins(zombieConfigPath) {
  const config = JSON.parse((0, import_fs.readFileSync)(zombieConfigPath, "utf8"));
  const commands = [];
  if (config.relaychain && config.relaychain.default_command) {
    commands.push(import_path.default.basename(config.relaychain.default_command));
  }
  if (config.parachains) {
    for (const parachain of config.parachains) {
      if (parachain.collator && parachain.collator.command) {
        commands.push(import_path.default.basename(parachain.collator.command));
      }
    }
  }
  return [...new Set(commands)].sort();
}

// src/internal/fileCheckers.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_child_process = require("child_process");
var import_chalk = __toESM(require("chalk"), 1);
var import_node_os = __toESM(require("os"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_node_path = __toESM(require("path"), 1);
async function downloadBinsIfMissing(binPath) {
  const binName = import_node_path.default.basename(binPath);
  const binDir = import_node_path.default.dirname(binPath);
  const binPathExists = import_node_fs.default.existsSync(binPath);
  if (!binPathExists && process.arch === "x64") {
    const choices = await import_inquirer.default.prompt({
      name: "download",
      type: "list",
      message: `The binary ${import_chalk.default.bgBlack.greenBright(
        binName
      )} is missing from ${import_chalk.default.bgBlack.greenBright(
        import_node_path.default.join(process.cwd(), binDir)
      )}.
Would you like to download it now?`,
      default: 0,
      choices: [
        { name: `Yes, download ${binName}`, value: true },
        { name: "No, quit program", value: false }
      ]
    });
    if (!choices.download) {
      process.exit(0);
    } else {
      (0, import_child_process.execSync)(`mkdir -p ${binDir}`);
      (0, import_child_process.execSync)(`pnpm moonwall download ${binName} latest ${binDir}`, {
        stdio: "inherit"
      });
    }
  } else if (!binPathExists) {
    console.log(
      `The binary: ${import_chalk.default.bgBlack.greenBright(
        binName
      )} is missing from: ${import_chalk.default.bgBlack.greenBright(import_node_path.default.join(process.cwd(), binDir))}`
    );
    console.log(
      `Given you are running ${import_chalk.default.bgBlack.yellowBright(
        process.arch
      )} architecture, you will need to build it manually from source \u{1F6E0}\uFE0F`
    );
    throw new Error("Executable binary not available");
  }
}
function checkListeningPorts(processId) {
  try {
    const stdOut = (0, import_child_process.execSync)(`lsof -p  ${processId} | grep LISTEN`, { encoding: "utf-8" });
    const binName = stdOut.split("\n")[0].split(" ")[0];
    const ports = stdOut.split("\n").filter(Boolean).map((line) => {
      const port = line.split(":")[1];
      return port.split(" ")[0];
    });
    const filtered = new Set(ports);
    return { binName, processId, ports: [...filtered].sort() };
  } catch (e) {
    console.log(e);
    const binName = (0, import_child_process.execSync)(`ps -p ${processId} -o comm=`).toString().trim();
    console.log(
      `Process ${processId} is running which for binary ${binName}, however it is unresponsive.`
    );
    console.log(
      "Running Moonwall with this in the background may cause unexpected behaviour. Please manually kill the process and try running Moonwall again."
    );
    console.log(`N.B. You can kill it with: sudo kill -9 ${processId}`);
    throw new Error(e);
  }
}
function checkAlreadyRunning(binaryName) {
  try {
    console.log(`Checking if ${import_chalk.default.bgWhiteBright.blackBright(binaryName)} is already running...`);
    const stdout = (0, import_child_process.execSync)(`pgrep ${[binaryName.slice(0, 14)]}`, {
      encoding: "utf8",
      timeout: 2e3
    });
    const pIdStrings = stdout.split("\n").filter(Boolean);
    return pIdStrings.map((pId) => parseInt(pId, 10));
  } catch (error) {
    if (error.status === 1) {
      return [];
    }
    throw error;
  }
}
async function promptAlreadyRunning(pids) {
  const choice = await import_inquirer.default.prompt({
    name: "AlreadyRunning",
    type: "list",
    message: `The following processes are already running: 
${pids.map((pid) => {
      const { binName, ports } = checkListeningPorts(pid);
      return `${binName} - pid: ${pid}, listenPorts: [${ports.join(", ")}]`;
    }).join("\n")}`,
    default: 1,
    choices: [
      { name: "\u{1FA93}  Kill processes and continue", value: "kill" },
      { name: "\u27A1\uFE0F   Continue (and let processes live)", value: "continue" },
      { name: "\u{1F6D1}  Abort (and let processes live)", value: "abort" }
    ]
  });
  switch (choice.AlreadyRunning) {
    case "kill":
      pids.forEach((pid) => {
        (0, import_child_process.execSync)(`kill ${pid}`);
      });
      break;
    case "continue":
      break;
    case "abort":
      throw new Error("Abort Signal Picked");
  }
}

// src/internal/launcherCommon.ts
async function commonChecks(env) {
  const globalConfig = await importAsyncConfig();
  if (env.foundation.type == "dev") {
    await devBinCheck(env);
  }
  if (env.foundation.type == "zombie") {
    await zombieBinCheck(env);
  }
  if (process.env.MOON_RUN_SCRIPTS == "true" && globalConfig.scriptsDir && env.runScripts && env.runScripts.length > 0) {
    for (const scriptCommand of env.runScripts) {
      await executeScript(scriptCommand);
    }
  }
}
async function zombieBinCheck(env) {
  if (env.foundation.type !== "zombie") {
    throw new Error("This function is only for zombie environments");
  }
  const bins = parseZombieConfigForBins(env.foundation.zombieSpec.configPath);
  const pids = bins.flatMap((bin) => checkAlreadyRunning(bin));
  pids.length == 0 || process.env.CI || await promptAlreadyRunning(pids);
}
async function devBinCheck(env) {
  if (env.foundation.type !== "dev") {
    throw new Error("This function is only for dev environments");
  }
  const binName = import_path2.default.basename(env.foundation.launchSpec[0].binPath);
  const pids = checkAlreadyRunning(binName);
  pids.length == 0 || process.env.CI || await promptAlreadyRunning(pids);
  await downloadBinsIfMissing(env.foundation.launchSpec[0].binPath);
}
async function executeScript(scriptCommand, args) {
  const scriptsDir = (await importAsyncConfig()).scriptsDir;
  const files = await import_fs2.default.promises.readdir(scriptsDir);
  try {
    const script = scriptCommand.split(" ")[0];
    const ext = import_path2.default.extname(script);
    const scriptPath = import_path2.default.join(process.cwd(), scriptsDir, scriptCommand);
    if (!files.includes(script)) {
      throw new Error(`Script ${script} not found in ${scriptsDir}`);
    }
    console.log(`========== Executing script: ${import_chalk2.default.bgGrey.greenBright(script)} ==========`);
    switch (ext) {
      case ".js":
        (0, import_child_process2.execSync)("node " + scriptPath + ` ${args}`, { stdio: "inherit" });
        break;
      case ".ts":
        (0, import_child_process2.execSync)("pnpm tsx " + scriptPath + ` ${args}`, { stdio: "inherit" });
        break;
      case ".sh":
        (0, import_child_process2.execSync)(scriptPath + ` ${args}`, { stdio: "inherit" });
        break;
      default:
        console.log(`${ext} not supported, skipping ${script}`);
    }
  } catch (err) {
    console.error(`Error executing script: ${import_chalk2.default.bgGrey.redBright(err)}`);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  commonChecks,
  executeScript
});
