var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/contractFunctions.ts
var contractFunctions_exports = {};
__export(contractFunctions_exports, {
  deployCreateCompiledContract: () => deployCreateCompiledContract,
  fetchCompiledContract: () => fetchCompiledContract,
  interactWithContract: () => interactWithContract,
  interactWithPrecompileContract: () => interactWithPrecompileContract,
  recursiveSearch: () => recursiveSearch
});
module.exports = __toCommonJS(contractFunctions_exports);
var import_util = require("@moonwall/util");
var import_chalk = __toESM(require("chalk"), 1);
var import_ethers = require("ethers");
var import_fs2 = __toESM(require("fs"), 1);
var import_path2 = __toESM(require("path"), 1);
var import_viem = require("viem");
var import_accounts = require("viem/accounts");

// src/lib/configReader.ts
var import_api_augment = require("@moonbeam-network/api-augment");
var import_fs = require("fs");
var import_jsonc_parser = __toESM(require("jsonc-parser"), 1);
var import_path = __toESM(require("path"), 1);
var cachedConfig;
function parseConfigSync(filePath) {
  let result;
  const file = (0, import_fs.readFileSync)(filePath, "utf8");
  switch ((0, import_path.extname)(filePath)) {
    case ".json":
      result = JSON.parse(file);
      break;
    case ".config":
      result = import_jsonc_parser.default.parse(file);
      break;
    default:
      result = void 0;
      break;
  }
  return result;
}
function importJsonConfig() {
  if (cachedConfig) {
    return cachedConfig;
  }
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path.default.isAbsolute(configPath) ? configPath : import_path.default.join(process.cwd(), configPath);
  try {
    const config = parseConfigSync(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
    return cachedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
function replaceEnvVars(value) {
  if (typeof value === "string") {
    return value.replace(/\$\{([^}]+)\}/g, (match, group) => {
      const envVarValue = process.env[group];
      return envVarValue || match;
    });
  } else if (Array.isArray(value)) {
    return value.map(replaceEnvVars);
  } else if (typeof value === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, replaceEnvVars(v)]));
  } else {
    return value;
  }
}

// src/lib/contractFunctions.ts
function getCompiledPath(contractName) {
  const config = importJsonConfig();
  const contractsDir = config.environments.find(
    (env) => env.name === process.env.MOON_TEST_ENV
  )?.contracts;
  if (!contractsDir) {
    throw new Error(
      `Contracts directory not found for environment config ${process.env.MOON_TEST_ENV}
Please specify path to Foundry directory at:  ${import_chalk.default.bgWhiteBright.blackBright(
        "moonwall.config.json > environments > contracts"
      )}`
    );
  }
  const compiledJsonPath = recursiveSearch(contractsDir, `${contractName}.json`);
  const solidityFilePath = recursiveSearch(contractsDir, `${contractName}.sol`);
  if (!compiledJsonPath && !solidityFilePath) {
    throw new Error(
      `Neither solidity contract ${contractName}.sol nor its compiled json exists in ${contractsDir}`
    );
  } else if (!compiledJsonPath) {
    throw new Error(
      `Compiled contract ${contractName}.json doesn't exist
Please ${import_chalk.default.bgWhiteBright.blackBright("recompile contract")} ${contractName}.sol`
    );
  }
  return compiledJsonPath;
}
function fetchCompiledContract(contractName) {
  const compiledPath = getCompiledPath(contractName);
  const json = (0, import_fs2.readFileSync)(compiledPath, "utf8");
  const parsed = JSON.parse(json);
  return {
    abi: parsed.contract.abi,
    bytecode: parsed.byteCode,
    methods: parsed.contract.evm.methodIdentifiers,
    deployedBytecode: "0x" + parsed.contract.evm.deployedBytecode.object
  };
}
function recursiveSearch(dir, filename) {
  const files = import_fs2.default.readdirSync(dir);
  for (const file of files) {
    const filepath = import_path2.default.join(dir, file);
    const stats = import_fs2.default.statSync(filepath);
    if (stats.isDirectory()) {
      const searchResult = recursiveSearch(filepath, filename);
      if (searchResult) {
        return searchResult;
      }
    } else if (stats.isFile() && file === filename) {
      return filepath;
    }
  }
  return null;
}
async function interactWithPrecompileContract(context, callOptions) {
  const { precompileName, ...rest } = callOptions;
  const precompileInfo = import_util.PRECOMPILES[precompileName];
  if (!precompileInfo) {
    throw new Error(`No precompile found with the name: ${precompileName}`);
  }
  const [contractAddress, contractName] = Array.isArray(precompileInfo) ? precompileInfo : [precompileInfo, precompileName];
  return await interactWithContract(context, {
    ...rest,
    contractName,
    contractAddress
  });
}
async function interactWithContract(context, callOptions) {
  const {
    contractName,
    contractAddress,
    functionName,
    args = [],
    web3Library = "viem",
    gas = "estimate",
    value = 0n,
    privateKey = import_util.ALITH_PRIVATE_KEY,
    rawTxOnly = false,
    call = false
  } = callOptions;
  const { abi } = fetchCompiledContract(contractName);
  const data = (0, import_viem.encodeFunctionData)({
    abi,
    functionName,
    args
  });
  const account = (0, import_accounts.privateKeyToAccount)(privateKey);
  const gasParam = gas === "estimate" ? await context.viem().estimateGas({ account: account.address, to: contractAddress, value: 0n, data }) : gas > 0n ? gas : 200000n;
  if (!call && rawTxOnly) {
    return web3Library === "viem" ? (0, import_util.createViemTransaction)(context, {
      to: contractAddress,
      data,
      gas: gasParam,
      privateKey,
      value
    }) : (0, import_util.createEthersTransaction)(context, {
      to: contractAddress,
      data,
      gas: gasParam,
      value: (0, import_viem.toHex)(value),
      privateKey
    });
  }
  if (call) {
    if (web3Library === "viem") {
      const result = await context.viem().call({ account: account.address, to: contractAddress, value: 0n, data, gas: gasParam });
      return (0, import_viem.decodeFunctionResult)({ abi, functionName, data: result.data });
    } else {
      const result = await context.ethers().call({
        from: account.address,
        to: contractAddress,
        value: (0, import_viem.toHex)(value),
        data,
        gasLimit: (0, import_viem.toHex)(gasParam)
      });
      return new import_ethers.Interface(abi).decodeFunctionResult(functionName, result);
    }
  } else if (!rawTxOnly) {
    if (web3Library === "viem") {
      const hash = await context.viem().sendTransaction({
        account,
        to: contractAddress,
        value,
        data,
        gas: gasParam
      });
      return hash;
    } else {
      const signer = new import_ethers.Wallet(privateKey, context.ethers().provider);
      const { hash } = await signer.sendTransaction({
        from: account.address,
        to: contractAddress,
        value: (0, import_viem.toHex)(value),
        data,
        gasLimit: (0, import_viem.toHex)(gasParam)
      });
      return hash;
    }
  } else {
    throw new Error("This should never happen, if it does there's a logic error in the code");
  }
}
async function deployCreateCompiledContract(context, contractName, options) {
  const { abi, bytecode, methods } = fetchCompiledContract(contractName);
  const { privateKey = import_util.ALITH_PRIVATE_KEY, args = [], ...rest } = options || {};
  const blob = {
    ...rest,
    privateKey,
    args
  };
  const { contractAddress, logs, status, hash } = await (0, import_util.deployViemContract)(
    context,
    abi,
    bytecode,
    blob
  );
  return {
    contractAddress,
    logs,
    hash,
    status,
    abi,
    bytecode,
    methods
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  deployCreateCompiledContract,
  fetchCompiledContract,
  interactWithContract,
  interactWithPrecompileContract,
  recursiveSearch
});
