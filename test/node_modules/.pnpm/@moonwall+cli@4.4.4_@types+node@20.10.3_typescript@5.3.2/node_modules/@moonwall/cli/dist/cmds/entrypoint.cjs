var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/internal/logging.ts
var originalWrite = process.stderr.write.bind(process.stderr);
var blockList = [
  "has multiple versions, ensure that there is only one installed",
  "Unable to map [u8; 32] to a lookup index"
];
process.stderr.write = (chunk, encodingOrCallback, callback) => {
  let shouldWrite = true;
  if (typeof chunk === "string") {
    shouldWrite = !blockList.some((phrase) => chunk.includes(phrase));
  }
  if (shouldWrite) {
    if (typeof encodingOrCallback === "function") {
      return originalWrite(chunk, encodingOrCallback);
    } else {
      return originalWrite(chunk, encodingOrCallback, callback);
    }
  }
  if (callback) {
    callback();
  } else if (typeof encodingOrCallback === "function") {
    encodingOrCallback();
  }
  return true;
};

// src/cmds/entrypoint.ts
var import_api_augment4 = require("@moonbeam-network/api-augment");
var import_yargs = __toESM(require("yargs"), 1);
var import_helpers = require("yargs/helpers");

// src/cmds/runTests.ts
var import_chalk5 = __toESM(require("chalk"), 1);
var import_path6 = __toESM(require("path"), 1);
var import_node = require("vitest/node");

// src/internal/cmdFunctions/tempLogs.ts
var import_path = __toESM(require("path"), 1);
var import_fs = __toESM(require("fs"), 1);
function clearNodeLogs(silent = true) {
  const dirPath = import_path.default.join(process.cwd(), "tmp", "node_logs");
  if (!import_fs.default.existsSync(dirPath)) {
    import_fs.default.mkdirSync(dirPath, { recursive: true });
  }
  const files = import_fs.default.readdirSync(dirPath);
  for (const file of files) {
    !silent && console.log(`Deleting log: ${file}`);
    if (file.endsWith(".log")) {
      import_fs.default.unlinkSync(import_path.default.join(dirPath, file));
    }
  }
}
function reportLogLocation(silent = false) {
  const dirPath = import_path.default.join(process.cwd(), "tmp", "node_logs");
  const result = import_fs.default.readdirSync(dirPath);
  let consoleMessage = "";
  let filePath = "";
  try {
    filePath = process.env.MOON_ZOMBIE_DIR ? process.env.MOON_ZOMBIE_DIR : process.env.MOON_LOG_LOCATION ? process.env.MOON_LOG_LOCATION : import_path.default.join(dirPath, result.find((file) => import_path.default.extname(file) == ".log"));
    consoleMessage = `  \u{1FAB5}   Log location: ${filePath}`;
  } catch (e) {
    console.error(e);
  }
  !silent && console.log(consoleMessage);
  return filePath.trim();
}

// src/internal/launcherCommon.ts
var import_chalk2 = __toESM(require("chalk"), 1);
var import_child_process2 = require("child_process");
var import_fs3 = __toESM(require("fs"), 1);
var import_path3 = __toESM(require("path"), 1);

// src/lib/configReader.ts
var import_api_augment = require("@moonbeam-network/api-augment");
var import_promises = require("fs/promises");
var import_fs2 = require("fs");
var import_jsonc_parser = __toESM(require("jsonc-parser"), 1);
var import_path2 = __toESM(require("path"), 1);
var cachedConfig;
async function parseConfig(filePath) {
  let result;
  const file = await (0, import_promises.readFile)(filePath, "utf8");
  switch ((0, import_path2.extname)(filePath)) {
    case ".json":
      result = JSON.parse(file);
      break;
    case ".config":
      result = import_jsonc_parser.default.parse(file);
      break;
    default:
      result = void 0;
      break;
  }
  return result;
}
function parseConfigSync(filePath) {
  let result;
  const file = (0, import_fs2.readFileSync)(filePath, "utf8");
  switch ((0, import_path2.extname)(filePath)) {
    case ".json":
      result = JSON.parse(file);
      break;
    case ".config":
      result = import_jsonc_parser.default.parse(file);
      break;
    default:
      result = void 0;
      break;
  }
  return result;
}
function isOptionSet(option) {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  const optionValue = traverseConfig(env, option);
  return optionValue !== void 0;
}
function isEthereumZombieConfig() {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  return env.foundation.type == "zombie" && !env.foundation.zombieSpec.disableDefaultEthProviders;
}
function isEthereumDevConfig() {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  return env.foundation.type == "dev" && !env.foundation.launchSpec[0].disableDefaultEthProviders;
}
async function cacheConfig() {
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path2.default.isAbsolute(configPath) ? configPath : import_path2.default.join(process.cwd(), configPath);
  try {
    const config = parseConfigSync(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
function importJsonConfig() {
  if (cachedConfig) {
    return cachedConfig;
  }
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path2.default.isAbsolute(configPath) ? configPath : import_path2.default.join(process.cwd(), configPath);
  try {
    const config = parseConfigSync(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
    return cachedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
async function importAsyncConfig() {
  if (cachedConfig) {
    return cachedConfig;
  }
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path2.default.isAbsolute(configPath) ? configPath : import_path2.default.join(process.cwd(), configPath);
  try {
    const config = await parseConfig(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
    return cachedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
function loadEnvVars() {
  const globalConfig = importJsonConfig();
  const env = globalConfig.environments.find(({ name }) => name === process.env.MOON_TEST_ENV);
  env.envVars && env.envVars.forEach((envVar) => {
    const [key, value] = envVar.split("=");
    process.env[key] = value;
  });
}
function replaceEnvVars(value) {
  if (typeof value === "string") {
    return value.replace(/\$\{([^}]+)\}/g, (match, group) => {
      const envVarValue = process.env[group];
      return envVarValue || match;
    });
  } else if (Array.isArray(value)) {
    return value.map(replaceEnvVars);
  } else if (typeof value === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, replaceEnvVars(v)]));
  } else {
    return value;
  }
}
function traverseConfig(configObj, option) {
  if (typeof configObj !== "object" || configObj === null)
    return void 0;
  if (Object.prototype.hasOwnProperty.call(configObj, option)) {
    return configObj[option];
  }
  for (const key in configObj) {
    const result = traverseConfig(configObj[key], option);
    if (result !== void 0) {
      return result;
    }
  }
  return void 0;
}
function parseZombieConfigForBins(zombieConfigPath) {
  const config = JSON.parse((0, import_fs2.readFileSync)(zombieConfigPath, "utf8"));
  const commands = [];
  if (config.relaychain && config.relaychain.default_command) {
    commands.push(import_path2.default.basename(config.relaychain.default_command));
  }
  if (config.parachains) {
    for (const parachain of config.parachains) {
      if (parachain.collator && parachain.collator.command) {
        commands.push(import_path2.default.basename(parachain.collator.command));
      }
    }
  }
  return [...new Set(commands)].sort();
}

// src/internal/fileCheckers.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_child_process = require("child_process");
var import_chalk = __toESM(require("chalk"), 1);
var import_node_os = __toESM(require("os"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_node_path = __toESM(require("path"), 1);
async function checkExists(path10) {
  const binPath = path10.split(" ")[0];
  const fsResult = import_node_fs.default.existsSync(binPath);
  if (!fsResult) {
    throw new Error(
      `No binary file found at location: ${binPath} 
 Are you sure your ${import_chalk.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "binPath" in launchSpec?`
    );
  }
  const binArch = await getBinaryArchitecture(binPath);
  const currentArch = import_node_os.default.arch();
  if (binArch !== currentArch && binArch !== "unknown") {
    throw new Error(
      `The binary architecture ${import_chalk.default.bgWhiteBright.blackBright(
        binArch
      )} does not match this system's architecture ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )}
Download or compile a new binary executable for ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )} `
    );
  }
  return true;
}
async function downloadBinsIfMissing(binPath) {
  const binName = import_node_path.default.basename(binPath);
  const binDir = import_node_path.default.dirname(binPath);
  const binPathExists = import_node_fs.default.existsSync(binPath);
  if (!binPathExists && process.arch === "x64") {
    const choices = await import_inquirer.default.prompt({
      name: "download",
      type: "list",
      message: `The binary ${import_chalk.default.bgBlack.greenBright(
        binName
      )} is missing from ${import_chalk.default.bgBlack.greenBright(
        import_node_path.default.join(process.cwd(), binDir)
      )}.
Would you like to download it now?`,
      default: 0,
      choices: [
        { name: `Yes, download ${binName}`, value: true },
        { name: "No, quit program", value: false }
      ]
    });
    if (!choices.download) {
      process.exit(0);
    } else {
      (0, import_child_process.execSync)(`mkdir -p ${binDir}`);
      (0, import_child_process.execSync)(`pnpm moonwall download ${binName} latest ${binDir}`, {
        stdio: "inherit"
      });
    }
  } else if (!binPathExists) {
    console.log(
      `The binary: ${import_chalk.default.bgBlack.greenBright(
        binName
      )} is missing from: ${import_chalk.default.bgBlack.greenBright(import_node_path.default.join(process.cwd(), binDir))}`
    );
    console.log(
      `Given you are running ${import_chalk.default.bgBlack.yellowBright(
        process.arch
      )} architecture, you will need to build it manually from source \u{1F6E0}\uFE0F`
    );
    throw new Error("Executable binary not available");
  }
}
function checkListeningPorts(processId) {
  try {
    const stdOut = (0, import_child_process.execSync)(`lsof -p  ${processId} | grep LISTEN`, { encoding: "utf-8" });
    const binName = stdOut.split("\n")[0].split(" ")[0];
    const ports = stdOut.split("\n").filter(Boolean).map((line) => {
      const port = line.split(":")[1];
      return port.split(" ")[0];
    });
    const filtered = new Set(ports);
    return { binName, processId, ports: [...filtered].sort() };
  } catch (e) {
    console.log(e);
    const binName = (0, import_child_process.execSync)(`ps -p ${processId} -o comm=`).toString().trim();
    console.log(
      `Process ${processId} is running which for binary ${binName}, however it is unresponsive.`
    );
    console.log(
      "Running Moonwall with this in the background may cause unexpected behaviour. Please manually kill the process and try running Moonwall again."
    );
    console.log(`N.B. You can kill it with: sudo kill -9 ${processId}`);
    throw new Error(e);
  }
}
function checkAlreadyRunning(binaryName) {
  try {
    console.log(`Checking if ${import_chalk.default.bgWhiteBright.blackBright(binaryName)} is already running...`);
    const stdout = (0, import_child_process.execSync)(`pgrep ${[binaryName.slice(0, 14)]}`, {
      encoding: "utf8",
      timeout: 2e3
    });
    const pIdStrings = stdout.split("\n").filter(Boolean);
    return pIdStrings.map((pId) => parseInt(pId, 10));
  } catch (error) {
    if (error.status === 1) {
      return [];
    }
    throw error;
  }
}
async function promptAlreadyRunning(pids) {
  const choice = await import_inquirer.default.prompt({
    name: "AlreadyRunning",
    type: "list",
    message: `The following processes are already running: 
${pids.map((pid) => {
      const { binName, ports } = checkListeningPorts(pid);
      return `${binName} - pid: ${pid}, listenPorts: [${ports.join(", ")}]`;
    }).join("\n")}`,
    default: 1,
    choices: [
      { name: "\u{1FA93}  Kill processes and continue", value: "kill" },
      { name: "\u27A1\uFE0F   Continue (and let processes live)", value: "continue" },
      { name: "\u{1F6D1}  Abort (and let processes live)", value: "abort" }
    ]
  });
  switch (choice.AlreadyRunning) {
    case "kill":
      pids.forEach((pid) => {
        (0, import_child_process.execSync)(`kill ${pid}`);
      });
      break;
    case "continue":
      break;
    case "abort":
      throw new Error("Abort Signal Picked");
  }
}
function checkAccess(path10) {
  const binPath = path10.split(" ")[0];
  try {
    import_node_fs.default.accessSync(binPath, import_node_fs.default.constants.X_OK);
  } catch (err) {
    console.error(`The file ${binPath} is not executable`);
    throw new Error(`The file at ${binPath} , lacks execute permissions.`);
  }
}
async function getBinaryArchitecture(filePath) {
  return new Promise((resolve, reject) => {
    const architectureMap = {
      0: "unknown",
      3: "x86",
      62: "x64",
      183: "arm64"
    };
    import_node_fs.default.open(filePath, "r", (err, fd) => {
      if (err) {
        reject(err);
        return;
      }
      const buffer = Buffer.alloc(20);
      import_node_fs.default.read(fd, buffer, 0, 20, 0, (err2, bytesRead, buffer2) => {
        if (err2) {
          reject(err2);
          return;
        }
        const e_machine = buffer2.readUInt16LE(18);
        const architecture = architectureMap[e_machine] || "unknown";
        resolve(architecture);
      });
    });
  });
}

// src/internal/launcherCommon.ts
async function commonChecks(env) {
  const globalConfig = await importAsyncConfig();
  if (env.foundation.type == "dev") {
    await devBinCheck(env);
  }
  if (env.foundation.type == "zombie") {
    await zombieBinCheck(env);
  }
  if (process.env.MOON_RUN_SCRIPTS == "true" && globalConfig.scriptsDir && env.runScripts && env.runScripts.length > 0) {
    for (const scriptCommand of env.runScripts) {
      await executeScript(scriptCommand);
    }
  }
}
async function zombieBinCheck(env) {
  if (env.foundation.type !== "zombie") {
    throw new Error("This function is only for zombie environments");
  }
  const bins = parseZombieConfigForBins(env.foundation.zombieSpec.configPath);
  const pids = bins.flatMap((bin) => checkAlreadyRunning(bin));
  pids.length == 0 || process.env.CI || await promptAlreadyRunning(pids);
}
async function devBinCheck(env) {
  if (env.foundation.type !== "dev") {
    throw new Error("This function is only for dev environments");
  }
  const binName = import_path3.default.basename(env.foundation.launchSpec[0].binPath);
  const pids = checkAlreadyRunning(binName);
  pids.length == 0 || process.env.CI || await promptAlreadyRunning(pids);
  await downloadBinsIfMissing(env.foundation.launchSpec[0].binPath);
}
async function executeScript(scriptCommand, args) {
  const scriptsDir = (await importAsyncConfig()).scriptsDir;
  const files = await import_fs3.default.promises.readdir(scriptsDir);
  try {
    const script = scriptCommand.split(" ")[0];
    const ext = import_path3.default.extname(script);
    const scriptPath = import_path3.default.join(process.cwd(), scriptsDir, scriptCommand);
    if (!files.includes(script)) {
      throw new Error(`Script ${script} not found in ${scriptsDir}`);
    }
    console.log(`========== Executing script: ${import_chalk2.default.bgGrey.greenBright(script)} ==========`);
    switch (ext) {
      case ".js":
        (0, import_child_process2.execSync)("node " + scriptPath + ` ${args}`, { stdio: "inherit" });
        break;
      case ".ts":
        (0, import_child_process2.execSync)("pnpm tsx " + scriptPath + ` ${args}`, { stdio: "inherit" });
        break;
      case ".sh":
        (0, import_child_process2.execSync)(scriptPath + ` ${args}`, { stdio: "inherit" });
        break;
      default:
        console.log(`${ext} not supported, skipping ${script}`);
    }
  } catch (err) {
    console.error(`Error executing script: ${import_chalk2.default.bgGrey.redBright(err)}`);
  }
}

// src/lib/globalContext.ts
var import_api_augment3 = require("@moonbeam-network/api-augment");
var import_orchestrator = __toESM(require("@zombienet/orchestrator"), 1);
var import_debug3 = __toESM(require("debug"), 1);
var import_fs5 = __toESM(require("fs"), 1);
var import_net2 = __toESM(require("net"), 1);
var import_readline = __toESM(require("readline"), 1);
var import_promises3 = require("timers/promises");

// src/internal/commandParsers.ts
var import_chalk3 = __toESM(require("chalk"), 1);
var import_path4 = __toESM(require("path"), 1);

// src/lib/repoDefinitions/moonbeam.ts
var repo = {
  name: "moonbeam",
  binaries: [
    {
      name: "moonbeam",
      defaultArgs: [
        "--no-hardware-benchmarks",
        "--no-telemetry",
        "--reserved-only",
        "--rpc-cors=all",
        "--no-grandpa",
        "--sealing=manual",
        "--force-authoring",
        "--no-prometheus",
        "--alice",
        "--chain=moonbase-dev",
        "--tmp"
      ]
    },
    { name: "moonbase-runtime" },
    { name: "moonbeam-runtime" },
    { name: "moonriver-runtime" }
  ],
  ghAuthor: "moonbeam-foundation",
  ghRepo: "moonbeam"
};
var moonbeam_default = repo;

// src/lib/repoDefinitions/polkadot.ts
var repo2 = {
  name: "polkadot",
  binaries: [
    { name: "polkadot" },
    { name: "polkadot-prepare-worker" },
    { name: "polkadot-execute-worker" }
  ],
  ghAuthor: "paritytech",
  ghRepo: "polkadot-sdk"
};
var polkadot_default = repo2;

// src/lib/repoDefinitions/tanssi.ts
var repo3 = {
  name: "tanssi",
  binaries: [
    { name: "tanssi-node", defaultArgs: ["--dev", "--sealing=manual", "--no-hardware-benchmarks"] },
    { name: "container-chain-template-simple-node" },
    { name: "container-chain-template-frontier-node" }
  ],
  ghAuthor: "moondance-labs",
  ghRepo: "tanssi"
};
var tanssi_default = repo3;

// src/lib/repoDefinitions/index.ts
async function allReposAsync() {
  const defaultRepos = [moonbeam_default, polkadot_default, tanssi_default];
  const globalConfig = await importAsyncConfig();
  const importedRepos = globalConfig.additionalRepos ? globalConfig.additionalRepos : [];
  return [...defaultRepos, ...importedRepos];
}
function standardRepos() {
  const defaultRepos = [moonbeam_default, polkadot_default, tanssi_default];
  return [...defaultRepos];
}

// src/internal/commandParsers.ts
function parseZombieCmd(launchSpec) {
  if (launchSpec) {
    return { cmd: launchSpec.configPath };
  } else {
    throw new Error(
      `No ZombieSpec found in config. 
 Are you sure your ${import_chalk3.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "configPath" in zombieSpec?`
    );
  }
}
function fetchDefaultArgs(binName, additionalRepos = []) {
  let defaultArgs;
  const repos = [...standardRepos(), ...additionalRepos];
  for (const repo4 of repos) {
    const foundBin = repo4.binaries.find((bin) => bin.name === binName);
    if (foundBin) {
      defaultArgs = foundBin.defaultArgs;
      break;
    }
  }
  if (!defaultArgs) {
    defaultArgs = ["--dev"];
  }
  return defaultArgs;
}
function parseRunCmd(launchSpec, additionalRepos) {
  const launch = !launchSpec.running ? true : launchSpec.running;
  const cmd = launchSpec.binPath;
  const args = launchSpec.options ? [...launchSpec.options] : fetchDefaultArgs(import_path4.default.basename(launchSpec.binPath), additionalRepos);
  if (launchSpec.ports) {
    const ports = launchSpec.ports;
    if (ports.p2pPort) {
      args.push(`--port=${ports.p2pPort}`);
    }
    if (ports.wsPort) {
      args.push(`--ws-port=${ports.wsPort}`);
    }
    if (ports.rpcPort) {
      args.push(`--rpc-port=${ports.rpcPort}`);
    }
  } else {
    if (launchSpec.newRpcBehaviour) {
      args.push(`--rpc-port=${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`);
    } else {
      args.push(`--ws-port=${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`);
    }
  }
  return { cmd, args, launch };
}
function parseChopsticksRunCmd(launchSpecs) {
  const launch = !launchSpecs[0].running ? true : launchSpecs[0].running;
  if (launchSpecs.length === 1) {
    const chopsticksCmd2 = "node";
    const chopsticksArgs2 = [
      "node_modules/@acala-network/chopsticks/chopsticks.cjs",
      `--config=${launchSpecs[0].configPath}`
    ];
    const mode = launchSpecs[0].buildBlockMode ? launchSpecs[0].buildBlockMode : "manual";
    const num = mode == "batch" ? 0 : mode == "instant" ? 1 : 2;
    chopsticksArgs2.push(`--build-block-mode=${num}`);
    if (launchSpecs[0].wsPort) {
      chopsticksArgs2.push(`--port=${launchSpecs[0].wsPort}`);
    }
    if (launchSpecs[0].wasmOverride) {
      chopsticksArgs2.push(`--wasm-override=${launchSpecs[0].wasmOverride}`);
    }
    if (launchSpecs[0].allowUnresolvedImports) {
      chopsticksArgs2.push("--allow-unresolved-imports");
    }
    return {
      cmd: chopsticksCmd2,
      args: chopsticksArgs2,
      launch
    };
  }
  const chopsticksCmd = "node";
  const chopsticksArgs = ["node_modules/@acala-network/chopsticks/chopsticks.cjs", "xcm"];
  launchSpecs.forEach((spec) => {
    const type = spec.type ? spec.type : "parachain";
    switch (type) {
      case "parachain":
        chopsticksArgs.push(`--parachain=${spec.configPath}`);
        break;
      case "relaychain":
        chopsticksArgs.push(`--relaychain=${spec.configPath}`);
    }
  });
  return {
    cmd: chopsticksCmd,
    args: chopsticksArgs,
    launch
  };
}

// src/internal/foundations/zombieHelpers.ts
var import_chalk4 = __toESM(require("chalk"), 1);
var import_node_fs2 = __toESM(require("fs"), 1);
var import_promises2 = require("timers/promises");
var import_net = __toESM(require("net"), 1);
async function checkZombieBins(config) {
  const relayBinPath = config.relaychain.default_command;
  await checkExists(relayBinPath);
  checkAccess(relayBinPath);
  const promises = config.parachains.map((para) => {
    if (para.collator) {
      if (!para.collator.command) {
        throw new Error(
          "No command found for collator, please check your zombienet config file for collator command"
        );
      }
      checkExists(para.collator.command);
      checkAccess(para.collator.command);
    }
    if (para.collators) {
      para.collators.forEach((coll) => {
        if (!coll.command) {
          throw new Error(
            "No command found for collators, please check your zombienet config file for para collators command"
          );
        }
        checkExists(coll.command);
        checkAccess(coll.command);
      });
    }
  });
  await Promise.all(promises);
}
function getZombieConfig(path10) {
  const fsResult = import_node_fs2.default.existsSync(path10);
  if (!fsResult) {
    throw new Error(
      `No ZombieConfig file found at location: ${path10} 
 Are you sure your ${import_chalk4.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "configPath" in zombieSpec?`
    );
  }
  const buffer = import_node_fs2.default.readFileSync(path10, "utf-8");
  return JSON.parse(buffer);
}
async function sendIpcMessage(message) {
  return new Promise(async (resolve, reject) => {
    let response;
    const ipcPath = process.env.MOON_IPC_SOCKET;
    const client = import_net.default.createConnection({ path: ipcPath });
    client.on("data", async (data) => {
      response = JSON.parse(data.toString());
      if (response.status === "success") {
        client.end();
        for (let i = 0; ; i++) {
          if (client.closed) {
            break;
          }
          if (i > 100) {
            reject(new Error(`Closing IPC connection failed`));
          }
          await (0, import_promises2.setTimeout)(200);
        }
        resolve(response);
      }
      if (response.status === "failure") {
        reject(new Error(JSON.stringify(response)));
      }
    });
    for (let i = 0; ; i++) {
      if (!client.connecting) {
        break;
      }
      if (i > 100) {
        reject(new Error(`Connection to ${ipcPath} failed`));
      }
      await (0, import_promises2.setTimeout)(200);
    }
    await new Promise((resolve2) => {
      client.write(JSON.stringify(message), () => resolve2("Sent!"));
    });
  });
}

// src/internal/localNode.ts
var import_child_process3 = require("child_process");
var import_debug = __toESM(require("debug"), 1);
var import_fs4 = __toESM(require("fs"), 1);
var import_path5 = __toESM(require("path"), 1);
var import_ws = __toESM(require("ws"), 1);
var debugNode = (0, import_debug.default)("global:node");
async function launchNode(cmd, args, name) {
  if (cmd.includes("moonbeam")) {
    await checkExists(cmd);
    checkAccess(cmd);
  }
  const dirPath = import_path5.default.join(process.cwd(), "tmp", "node_logs");
  const onProcessExit = () => {
    runningNode && runningNode.kill();
  };
  const onProcessInterrupt = () => {
    runningNode && runningNode.kill();
  };
  process.once("exit", onProcessExit);
  process.once("SIGINT", onProcessInterrupt);
  const runningNode = (0, import_child_process3.spawn)(cmd, args);
  const logLocation = import_path5.default.join(
    dirPath,
    `${import_path5.default.basename(cmd)}_node_${args.find((a) => a.includes("port"))?.split("=")[1]}_${runningNode.pid}.log`
  ).replaceAll("node_node_undefined", "chopsticks");
  process.env.MOON_LOG_LOCATION = logLocation;
  const fsStream = import_fs4.default.createWriteStream(logLocation);
  runningNode.once("exit", () => {
    process.removeListener("exit", onProcessExit);
    process.removeListener("SIGINT", onProcessInterrupt);
    runningNode.stderr?.off("data", writeLogToFile);
    runningNode.stdout?.off("data", writeLogToFile);
    fsStream.end();
    debugNode(`Exiting dev node: ${name}`);
  });
  runningNode.on("error", (err) => {
    if (err.errno == "ENOENT") {
      console.error(
        `\x1B[31mMissing Local binary at(${cmd}).
Please compile the project\x1B[0m`
      );
    } else {
      console.error(err);
    }
    process.exit(1);
  });
  const writeLogToFile = (chunk) => {
    if (fsStream.writable) {
      fsStream.write(chunk, (err) => {
        if (err)
          console.error(err);
        else
          fsStream.emit("drain");
      });
    }
  };
  runningNode.stderr?.on("data", writeLogToFile);
  runningNode.stdout?.on("data", writeLogToFile);
  probe:
    for (; ; ) {
      try {
        const ports = await findPortsByPid(runningNode.pid);
        if (ports) {
          for (const port of ports) {
            try {
              await checkWebSocketJSONRPC(port);
              break probe;
            } catch {
              continue;
            }
          }
        }
      } catch {
        continue;
      }
    }
  return runningNode;
}
async function checkWebSocketJSONRPC(port) {
  return new Promise((resolve, reject) => {
    const ws = new import_ws.default(`ws://localhost:${port}`);
    ws.on("open", () => {
      ws.send(
        JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "system_chain",
          params: []
        })
      );
    });
    ws.on("message", (data) => {
      try {
        const response = JSON.parse(data.toString());
        if (response.jsonrpc === "2.0" && response.id === 1) {
          resolve(true);
        } else {
          reject(false);
        }
      } catch (e) {
        reject(false);
      }
      ws.close();
    });
    ws.on("error", () => {
      reject(false);
    });
  });
}
async function findPortsByPid(pid, retryCount = 600, retryDelay = 100) {
  for (let i = 0; i < retryCount; i++) {
    try {
      const stdout = (0, import_child_process3.execSync)(`lsof -i -n -P | grep LISTEN | grep ${pid}`).toString();
      const ports = [];
      const lines = stdout.split("\n");
      for (const line of lines) {
        const regex = /(?:\*|127\.0\.0\.1):(\d+)/;
        const match = line.match(regex);
        if (match) {
          ports.push(Number(match[1]));
        }
      }
      if (ports.length) {
        return ports;
      }
    } catch (error) {
      if (i === retryCount - 1) {
        throw error;
      }
    }
    await new Promise((resolve) => setTimeout(resolve, retryDelay));
  }
  return [];
}

// src/internal/providerFactories.ts
var import_api_augment2 = require("@moonbeam-network/api-augment");
var import_util = require("@moonwall/util");
var import_api = require("@polkadot/api");
var import_debug2 = __toESM(require("debug"), 1);
var import_ethers = require("ethers");
var import_viem = require("viem");
var import_accounts = require("viem/accounts");
var import_web3 = require("web3");
var import_web3_providers_ws = require("web3-providers-ws");
var debug = (0, import_debug2.default)("global:providers");
var ProviderFactory = class _ProviderFactory {
  constructor(providerConfig) {
    this.providerConfig = providerConfig;
    this.url = providerConfig.endpoints.includes("ENV_VAR") ? process.env.WSS_URL : providerConfig.endpoints[0];
    this.privateKey = process.env.MOON_PRIV_KEY || import_util.ALITH_PRIVATE_KEY;
  }
  url;
  privateKey;
  create() {
    switch (this.providerConfig.type) {
      case "polkadotJs":
        return this.createPolkadotJs();
      case "web3":
        return this.createWeb3();
      case "ethers":
        return this.createEthers();
      case "viem":
        return this.createViem();
      default:
        return this.createDefault();
    }
  }
  createPolkadotJs() {
    debug(`\u{1F7E2}  PolkadotJs provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: async () => {
        const options = {
          provider: new import_api.WsProvider(this.url),
          initWasm: false,
          noInitWarn: true,
          isPedantic: false,
          rpc: this.providerConfig.rpc ? this.providerConfig.rpc : void 0,
          typesBundle: this.providerConfig.additionalTypes ? this.providerConfig.additionalTypes : void 0
        };
        const api = await import_api.ApiPromise.create(options);
        await api.isReady;
        return api;
      },
      ws: () => new import_api.WsProvider(this.url)
    };
  }
  createWeb3() {
    debug(`\u{1F7E2}  Web3 provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: () => {
        const provider = new import_web3_providers_ws.WebSocketProvider(
          this.url,
          {},
          { delay: 50, autoReconnect: false, maxAttempts: 10 }
        );
        return new import_web3.Web3(provider);
      }
    };
  }
  createEthers() {
    debug(`\u{1F7E2}  Ethers provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: () => {
        const provider = new import_ethers.ethers.WebSocketProvider(this.url);
        return new import_ethers.Wallet(this.privateKey, provider);
      }
    };
  }
  createViem() {
    debug(`\u{1F7E2}  Viem omni provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: async () => (0, import_viem.createWalletClient)({
        chain: await (0, import_util.deriveViemChain)(this.url),
        account: (0, import_accounts.privateKeyToAccount)(this.privateKey),
        transport: (0, import_viem.http)(this.url.replace("ws", "http"))
      }).extend(import_viem.publicActions)
    };
  }
  createDefault() {
    debug(`\u{1F7E2}  Default provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: () => console.log(`\u{1F6A7}  provider ${this.providerConfig.name} not yet implemented`)
    };
  }
  static prepare(providerConfigs) {
    return providerConfigs.map((providerConfig) => new _ProviderFactory(providerConfig).create());
  }
  static prepareDefaultDev() {
    return this.prepare([
      {
        name: "dev",
        type: "polkadotJs",
        endpoints: [vitestAutoUrl]
      },
      {
        name: "w3",
        type: "web3",
        endpoints: [vitestAutoUrl]
      },
      {
        name: "eth",
        type: "ethers",
        endpoints: [vitestAutoUrl]
      },
      {
        name: "public",
        type: "viem",
        endpoints: [vitestAutoUrl]
      }
    ]);
  }
  static prepareDefaultZombie() {
    const MOON_PARA_WSS = process.env.MOON_PARA_WSS || "error";
    const MOON_RELAY_WSS = process.env.MOON_RELAY_WSS || "error";
    return this.prepare([
      {
        name: "w3",
        type: "web3",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "eth",
        type: "ethers",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "viem",
        type: "viem",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "parachain",
        type: "polkadotJs",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "relaychain",
        type: "polkadotJs",
        endpoints: [MOON_RELAY_WSS]
      }
    ]);
  }
  static prepareNoEthDefaultZombie() {
    const MOON_PARA_WSS = process.env.MOON_PARA_WSS || "error";
    const MOON_RELAY_WSS = process.env.MOON_RELAY_WSS || "error";
    return this.prepare([
      {
        name: "parachain",
        type: "polkadotJs",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "relaychain",
        type: "polkadotJs",
        endpoints: [MOON_RELAY_WSS]
      }
    ]);
  }
};
var ProviderInterfaceFactory = class _ProviderInterfaceFactory {
  constructor(name, type, connect) {
    this.name = name;
    this.type = type;
    this.connect = connect;
  }
  async create() {
    switch (this.type) {
      case "polkadotJs":
        return this.createPolkadotJs();
      case "web3":
        return this.createWeb3();
      case "ethers":
        return this.createEthers();
      case "viem":
        return this.createViem();
      default:
        throw new Error("UNKNOWN TYPE");
    }
  }
  async createPolkadotJs() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: () => {
        debug(
          `\u{1F44B}  Provider ${this.name} is connected to chain ${api.consts.system.version.specName.toString()} RT${api.consts.system.version.specVersion.toNumber()}`
        );
        return {
          rtVersion: api.consts.system.version.specVersion.toNumber(),
          rtName: api.consts.system.version.specName.toString()
        };
      },
      disconnect: async () => api.disconnect()
    };
  }
  async createWeb3() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: async () => console.log(
        `\u{1F44B} Provider ${this.name} is connected to chain ` + await api.eth.getChainId()
      ),
      disconnect: async () => {
        api.currentProvider.disconnect();
      }
    };
  }
  async createEthers() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: async () => debug(
        `\u{1F44B}  Provider ${this.name} is connected to chain ` + (await api.provider.getNetwork()).chainId
      ),
      disconnect: () => api.provider.destroy()
    };
  }
  async createViem() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: async () => console.log(`\u{1F44B} Provider ${this.name} is connected to chain ` + await api.getChainId()),
      disconnect: async () => {
      }
    };
  }
  static async populate(name, type, connect) {
    return await new _ProviderInterfaceFactory(name, type, connect).create();
  }
};
var vitestAutoUrl = `ws://127.0.0.1:${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`;

// src/lib/globalContext.ts
var import_node_child_process = require("child_process");
var import_child_process4 = require("child_process");
var debugSetup = (0, import_debug3.default)("global:context");
var MoonwallContext = class _MoonwallContext {
  static instance;
  environment;
  providers;
  nodes;
  foundation;
  zombieNetwork;
  rtUpgradePath;
  ipcServer;
  constructor(config) {
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    this.providers = [];
    this.nodes = [];
    this.foundation = env.foundation.type;
    const foundationHandlers = {
      read_only: this.handleReadOnly,
      chopsticks: this.handleChopsticks,
      dev: this.handleDev,
      zombie: this.handleZombie,
      fork: this.handleReadOnly
      // TODO: Implement fork
    };
    const foundationHandler = foundationHandlers[env.foundation.type];
    this.environment = { providers: [], nodes: [], ...foundationHandler.call(this, env, config) };
  }
  handleZombie(env) {
    if (env.foundation.type !== "zombie") {
      throw new Error(`Foundation type must be 'zombie'`);
    }
    const { cmd: zombieConfig } = parseZombieCmd(env.foundation.zombieSpec);
    this.rtUpgradePath = env.foundation.rtUpgradePath;
    return {
      name: env.name,
      foundationType: "zombie",
      nodes: [
        {
          name: env.foundation.zombieSpec.name,
          cmd: zombieConfig,
          args: [],
          launch: true
        }
      ]
    };
  }
  handleDev(env, config) {
    if (env.foundation.type !== "dev") {
      throw new Error(`Foundation type must be 'dev'`);
    }
    const { cmd, args, launch } = parseRunCmd(
      env.foundation.launchSpec[0],
      config.additionalRepos
    );
    return {
      name: env.name,
      foundationType: "dev",
      nodes: [
        {
          name: env.foundation.launchSpec[0].name,
          cmd,
          args,
          launch
        }
      ],
      providers: env.connections ? ProviderFactory.prepare(env.connections) : isEthereumDevConfig() ? ProviderFactory.prepareDefaultDev() : ProviderFactory.prepare([
        {
          name: "node",
          type: "polkadotJs",
          endpoints: [vitestAutoUrl]
        }
      ])
    };
  }
  handleReadOnly(env) {
    if (env.foundation.type !== "read_only") {
      throw new Error(`Foundation type must be 'read_only'`);
    }
    if (!env.connections) {
      throw new Error(
        `${env.name} env config is missing connections specification, required by foundation READ_ONLY`
      );
    }
    return {
      name: env.name,
      foundationType: "read_only",
      providers: ProviderFactory.prepare(env.connections)
    };
  }
  handleChopsticks(env) {
    if (env.foundation.type !== "chopsticks") {
      throw new Error(`Foundation type must be 'chopsticks'`);
    }
    this.rtUpgradePath = env.foundation.rtUpgradePath;
    return {
      name: env.name,
      foundationType: "chopsticks",
      nodes: [parseChopsticksRunCmd(env.foundation.launchSpec)],
      providers: [...ProviderFactory.prepare(env.connections)]
    };
  }
  async startZombieNetwork() {
    const config = await importAsyncConfig();
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    if (env.foundation.type !== "zombie") {
      throw new Error(`Foundation type must be 'zombie', something has gone very wrong.`);
    }
    console.log("\u{1F9DF} Spawning zombie nodes ...");
    const nodes = this.environment.nodes;
    const zombieConfig = getZombieConfig(nodes[0].cmd);
    await checkZombieBins(zombieConfig);
    const network = await import_orchestrator.default.start("", zombieConfig, { logType: "silent" });
    process.env.MOON_RELAY_WSS = network.relay[0].wsUri;
    process.env.MOON_PARA_WSS = Object.values(network.paras)[0].nodes[0].wsUri;
    const nodeNames = Object.keys(network.nodesByName);
    process.env.MOON_ZOMBIE_DIR = `${network.tmpDir}`;
    process.env.MOON_ZOMBIE_NODES = nodeNames.join("|");
    const onProcessExit = () => {
      try {
        const processIds = Object.values(this.zombieNetwork.client.processMap).filter((item) => item["pid"]).map((process2) => process2["pid"]);
        (0, import_node_child_process.exec)(`kill ${processIds.join(" ")}`, (error) => {
          if (error) {
            console.error(`Error killing process: ${error.message}`);
          }
        });
      } catch (err) {
      }
    };
    const socketPath = `${network.tmpDir}/node-ipc.sock`;
    const server = import_net2.default.createServer((client) => {
      client.on("data", async (data) => {
        const writeToClient = (message) => {
          if (client.writable) {
            client.write(JSON.stringify(message));
          } else {
            console.log("Client disconnected, cannot send response.");
          }
        };
        try {
          const message = JSON.parse(data.toString());
          const zombieClient = network.client;
          switch (message.cmd) {
            case "networkmap": {
              const result = Object.keys(network.nodesByName);
              writeToClient({
                status: "success",
                result: network.nodesByName,
                message: result.join("|")
              });
              break;
            }
            case "restart": {
              await this.disconnect();
              await zombieClient.restartNode(message.nodeName, null);
              await (0, import_promises3.setTimeout)(1e3);
              await this.connectEnvironment(true);
              writeToClient({
                status: "success",
                result: true,
                message: `${message.nodeName} restarted`
              });
              break;
            }
            case "resume": {
              const node = network.getNodeByName(message.nodeName);
              await this.disconnect();
              const result = await node.resume();
              await zombieClient.wait_node_ready(message.nodeName);
              await this.connectEnvironment(true);
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} resumed with result ${result}`
              });
              break;
            }
            case "pause": {
              const node = network.getNodeByName(message.nodeName);
              await this.disconnect();
              const result = await node.pause();
              await (0, import_promises3.setTimeout)(1e3);
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} paused with result ${result}`
              });
              break;
            }
            case "kill": {
              const pid = network.client.processMap[message.nodeName].pid;
              delete network.client.processMap[message.nodeName];
              const result = (0, import_node_child_process.exec)(`kill ${pid}`, { timeout: 1e3 });
              writeToClient({
                status: "success",
                result: result.exitCode === 0,
                message: `${message.nodeName}, pid ${pid} killed with exitCode ${result.exitCode}`
              });
              break;
            }
            case "isup": {
              const node = network.getNodeByName(message.nodeName);
              const result = await node.isUp();
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} isUp result is ${result}`
              });
              break;
            }
            default:
              throw new Error(`Invalid command received: ${message.cmd}`);
          }
        } catch (e) {
          console.log("\u{1F4E8} Error processing message from client:", data.toString());
          console.error(e.message);
          writeToClient({ status: "failure", result: false, message: e.message });
        }
      });
    });
    server.listen(socketPath, () => {
      console.log("\u{1F4E8} IPC Server listening on", socketPath);
    });
    this.ipcServer = server;
    process.env.MOON_IPC_SOCKET = socketPath;
    process.once("exit", onProcessExit);
    process.once("SIGINT", onProcessExit);
    this.zombieNetwork = network;
    return;
  }
  async startNetwork() {
    if (process.env.MOON_RECYCLE == "true") {
      return _MoonwallContext.getContext();
    }
    if (this.nodes.length > 0) {
      return _MoonwallContext.getContext();
    }
    const nodes = _MoonwallContext.getContext().environment.nodes;
    if (this.environment.foundationType === "zombie") {
      return await this.startZombieNetwork();
    }
    const promises = nodes.map(async ({ cmd, args, name, launch }) => {
      if (launch) {
        const result = await launchNode(cmd, args, name);
        this.nodes.push(result);
      } else {
        return Promise.resolve();
      }
    });
    await Promise.allSettled(promises);
    return _MoonwallContext.getContext();
  }
  async connectEnvironment(silent = false) {
    const config = await importAsyncConfig();
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    if (this.environment.foundationType == "zombie") {
      this.environment.providers = env.connections ? ProviderFactory.prepare(env.connections) : isEthereumZombieConfig() ? ProviderFactory.prepareDefaultZombie() : ProviderFactory.prepareNoEthDefaultZombie();
    }
    if (this.providers.length > 0) {
      return _MoonwallContext.getContext();
    }
    const promises = this.environment.providers.map(
      async ({ name, type, connect }) => new Promise(async (resolve) => {
        this.providers.push(await ProviderInterfaceFactory.populate(name, type, connect));
        resolve("");
      })
    );
    await Promise.all(promises);
    if (this.foundation == "zombie") {
      let readStreams;
      if (!isOptionSet("disableLogEavesdropping")) {
        !silent && console.log(`\u{1F9BB} Eavesdropping on node logs at ${process.env.MOON_ZOMBIE_DIR}`);
        const zombieNodeLogs = process.env.MOON_ZOMBIE_NODES.split("|").map((nodeName) => `${process.env.MOON_ZOMBIE_DIR}/${nodeName}.log`);
        readStreams = zombieNodeLogs.map((logPath) => {
          const readStream = import_fs5.default.createReadStream(logPath, { encoding: "utf8" });
          const lineReader = import_readline.default.createInterface({
            input: readStream
          });
          lineReader.on("line", (line) => {
            if (line.includes("WARN") || line.includes("ERROR")) {
              console.log(line);
            }
          });
          return readStream;
        });
      }
      const promises2 = this.providers.filter(({ type }) => type == "polkadotJs").filter(
        ({ name }) => env.foundation.type == "zombie" && (!env.foundation.zombieSpec.skipBlockCheck || !env.foundation.zombieSpec.skipBlockCheck.includes(name))
      ).map(async (provider) => {
        return await new Promise(async (resolve) => {
          !silent && console.log(`\u23F2\uFE0F  Waiting for chain ${provider.name} to produce blocks...`);
          while ((await provider.api.rpc.chain.getBlock()).block.header.number.toNumber() == 0) {
            await (0, import_promises3.setTimeout)(500);
          }
          !silent && console.log(`\u2705 Chain ${provider.name} producing blocks, continuing`);
          resolve("");
        });
      });
      await Promise.all(promises2);
      if (!isOptionSet("disableLogEavesdropping")) {
        readStreams.forEach((readStream) => readStream.close());
      }
    }
    return _MoonwallContext.getContext();
  }
  async disconnect(providerName) {
    if (providerName) {
      this.providers.find(({ name }) => name === providerName).disconnect();
      this.providers.filter(({ name }) => name !== providerName);
    } else {
      await Promise.all(this.providers.map((prov) => prov.disconnect()));
      this.providers = [];
    }
  }
  static printStats() {
    if (_MoonwallContext) {
      console.dir(_MoonwallContext.getContext(), { depth: 1 });
    } else {
      console.log("Global context not created!");
    }
  }
  static getContext(config, force = false) {
    if (!_MoonwallContext.instance || force) {
      if (!config) {
        throw new Error("\u274C Config must be provided on Global Context instantiation");
      }
      _MoonwallContext.instance = new _MoonwallContext(config);
      debugSetup(`\u{1F7E2}  Moonwall context "${config.label}" created`);
    }
    return _MoonwallContext.instance;
  }
  static async destroy() {
    const ctx = this.instance;
    try {
      await ctx.disconnect();
    } catch {
      console.log("\u{1F6D1}  All connections disconnected");
    }
    while (ctx.nodes.length > 0) {
      const node = ctx.nodes.pop();
      const pid = node.pid;
      node.kill();
      for (; ; ) {
        const isRunning = await isPidRunning(pid);
        if (isRunning) {
          await (0, import_promises3.setTimeout)(10);
        } else {
          break;
        }
      }
    }
    if (ctx.zombieNetwork) {
      console.log("\u{1FA93}  Killing zombie nodes");
      await ctx.zombieNetwork.stop();
      const processIds = Object.values(ctx.zombieNetwork.client.processMap).filter((item) => item["pid"]).map((process2) => process2["pid"]);
      try {
        (0, import_child_process4.execSync)(`kill ${processIds.join(" ")}`, {});
      } catch (e) {
        console.log(e.message);
        console.log("continuing...");
      }
      await waitForPidsToDie(processIds);
      ctx.ipcServer?.close();
      ctx.ipcServer?.removeAllListeners();
    }
  }
};
var contextCreator = async () => {
  const config = await importAsyncConfig();
  const ctx = MoonwallContext.getContext(config);
  await runNetworkOnly();
  await ctx.connectEnvironment();
  return ctx;
};
var runNetworkOnly = async () => {
  const config = await importAsyncConfig();
  const ctx = MoonwallContext.getContext(config);
  await ctx.startNetwork();
};
async function isPidRunning(pid) {
  const output = (0, import_node_child_process.exec)(`ps -p ${pid} -o pid=`);
  return output.exitCode === 0;
}
async function waitForPidsToDie(pids) {
  const checkPids = async () => {
    const checks = pids.map(async (pid) => await isPidRunning(pid));
    const results = await Promise.all(checks);
    return results.every((running) => !running);
  };
  while (!await checkPids()) {
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
}

// src/cmds/runTests.ts
async function testCmd(envName, additionalArgs) {
  await cacheConfig();
  const globalConfig = await importAsyncConfig();
  const env = globalConfig.environments.find(({ name }) => name === envName);
  process.env.MOON_TEST_ENV = envName;
  if (!env) {
    const envList = globalConfig.environments.map((env2) => env2.name);
    new Error(
      `No environment found in config for: ${import_chalk5.default.bgWhiteBright.blackBright(
        envName
      )}
 Environments defined in config are: ${envList}
`
    );
  }
  loadEnvVars();
  await commonChecks(env);
  if (env.foundation.type == "dev" && !env.foundation.launchSpec[0].retainAllLogs || env.foundation.type == "chopsticks" && !env.foundation.launchSpec[0].retainAllLogs) {
    clearNodeLogs();
  }
  const vitest = await executeTests(env, additionalArgs);
  const failed = vitest.state.getFiles().filter((file) => file.result.state === "fail");
  if (failed.length === 0) {
    console.log("\u2705 All tests passed");
    return true;
  } else {
    console.log("\u274C Some tests failed");
    return false;
  }
}
async function executeTests(env, additionalArgs) {
  return new Promise(async (resolve, reject) => {
    const globalConfig = await importAsyncConfig();
    if (env.foundation.type === "read_only") {
      try {
        if (!process.env.MOON_TEST_ENV) {
          throw new Error("MOON_TEST_ENV not set");
        }
        const ctx = await contextCreator();
        const chainData = ctx.providers.filter((provider) => provider.type == "polkadotJs" && provider.name.includes("para")).map((provider) => {
          return {
            [provider.name]: {
              rtName: provider.greet().rtName,
              rtVersion: provider.greet().rtVersion
            }
          };
        });
        const { rtVersion, rtName } = Object.values(chainData[0])[0];
        process.env.MOON_RTVERSION = rtVersion;
        process.env.MOON_RTNAME = rtName;
        await MoonwallContext.destroy();
      } catch {
      }
    }
    const baseOptions = {
      watch: false,
      globals: true,
      reporters: env.reporters ? env.reporters : ["default"],
      outputFile: env.reportFile,
      testTimeout: env.timeout || globalConfig.defaultTestTimeout,
      hookTimeout: env.timeout || globalConfig.defaultTestTimeout,
      passWithNoTests: false,
      deps: {
        optimizer: { ssr: { enabled: false }, web: { enabled: false } }
      },
      include: env.include ? env.include : ["**/*{test,spec,test_,test-}*{ts,mts,cts}"],
      onConsoleLog(log) {
        if (filterList.includes(log.trim()))
          return false;
        if (log.includes("has multiple versions, ensure that there is only one installed.")) {
          return false;
        }
      }
    };
    const options = addThreadConfig(baseOptions, env.multiThreads);
    if (globalConfig.environments.find((env2) => env2.name === process.env.MOON_TEST_ENV)?.foundation.type == "zombie") {
      await runNetworkOnly();
      process.env.MOON_RECYCLE = "true";
    }
    try {
      const folders = env.testFileDir.map((folder) => import_path6.default.join(".", folder, "/"));
      resolve(await (0, import_node.startVitest)("test", folders, { ...options, ...additionalArgs }));
    } catch (e) {
      console.error(e);
      reject(e);
    }
  });
}
var filterList = ["<empty line>", "", "stdout | unknown test"];
function addThreadConfig(config, threads = false) {
  const configWithThreads = {
    ...config,
    pool: "threads",
    poolOptions: {
      threads: {
        isolate: true,
        minThreads: 1,
        maxThreads: 1,
        singleThread: false,
        useAtomics: false
      }
    }
  };
  if (threads == true && process.env.MOON_RECYCLE !== "true") {
    configWithThreads.poolOptions.threads = {
      isolate: true,
      minThreads: 1,
      maxThreads: 3,
      singleThread: false,
      useAtomics: false
    };
  }
  if (typeof threads === "number") {
    configWithThreads.poolOptions.threads.maxThreads = threads;
    configWithThreads.poolOptions.threads.singleThread = false;
  }
  if (typeof threads === "object") {
    const key = Object.keys(threads)[0];
    if (["threads", "forks", "vmThreads", "typescript"].includes(key)) {
      configWithThreads.pool = key;
      configWithThreads.poolOptions = Object.values(threads)[0];
    } else {
      throw new Error(`Invalid pool type: ${key}`);
    }
  }
  return configWithThreads;
}

// src/cmds/runNetwork.ts
var import_chalk6 = __toESM(require("chalk"), 1);
var import_clear = __toESM(require("clear"), 1);
var import_fs6 = __toESM(require("fs"), 1);
var import_inquirer2 = __toESM(require("inquirer"), 1);
var import_inquirer_press_to_continue = __toESM(require("inquirer-press-to-continue"), 1);
var import_ws2 = __toESM(require("ws"), 1);
var import_yaml = require("yaml");
import_inquirer2.default.registerPrompt("press-to-continue", import_inquirer_press_to_continue.default);
var lastSelected = 0;
async function runNetworkCmd(args) {
  await cacheConfig();
  process.env.MOON_TEST_ENV = args.envName;
  const globalConfig = await importAsyncConfig();
  const env = globalConfig.environments.find(({ name }) => name === args.envName);
  if (!env) {
    const envList = globalConfig.environments.map((env2) => env2.name);
    throw new Error(
      `No environment found in config for: ${import_chalk6.default.bgWhiteBright.blackBright(
        args.envName
      )}
 Environments defined in config are: ${envList}
`
    );
  }
  loadEnvVars();
  await commonChecks(env);
  const testFileDirs = env.testFileDir;
  const foundation = env.foundation.type;
  const questions2 = [
    {
      type: "confirm",
      name: "Quit",
      message: "\u2139\uFE0F  Are you sure you'd like to close network and quit? \n",
      default: false
    },
    {
      name: "Choice",
      type: "list",
      message: "What would you like todo now",
      choices: ["Chill", "Info", "Test", "Quit"]
    },
    {
      name: "MenuChoice",
      type: "list",
      message: `Environment : ${import_chalk6.default.bgGray.cyanBright(args.envName)}
Please select a choice: `,
      default: () => lastSelected,
      pageSize: 10,
      choices: [
        {
          name: "Tail:      Print the logs of the current running node to this console",
          value: 1,
          short: "tail"
        },
        {
          name: `Info:      Display Information about this environment ${args.envName}`,
          value: 2,
          short: "info"
        },
        {
          name: foundation == "dev" || foundation == "chopsticks" || foundation == "zombie" ? `Command:   Run command on network (${import_chalk6.default.bgGrey.cyanBright(foundation)})` : import_chalk6.default.dim(
            `Not applicable for foundation type (${import_chalk6.default.bgGrey.cyanBright(foundation)})`
          ),
          value: 3,
          short: "cmd",
          disabled: foundation !== "dev" && foundation !== "chopsticks" && foundation !== "zombie"
        },
        {
          name: testFileDirs.length > 0 ? "Test:      Execute tests registered for this environment   (" + import_chalk6.default.bgGrey.cyanBright(testFileDirs) + ")" : import_chalk6.default.dim("Test:    NO TESTS SPECIFIED"),
          value: 4,
          disabled: testFileDirs.length > 0 ? false : true,
          short: "test"
        },
        {
          name: testFileDirs.length > 0 ? "GrepTest:  Execute individual test(s) based on grepping the name / ID (" + import_chalk6.default.bgGrey.cyanBright(testFileDirs) + ")" : import_chalk6.default.dim("Test:    NO TESTS SPECIFIED"),
          value: 5,
          disabled: testFileDirs.length > 0 ? false : true,
          short: "grep"
        },
        new import_inquirer2.default.Separator(),
        {
          name: "Quit:      Close network and quit the application",
          value: 6,
          short: "quit"
        }
      ],
      filter(val) {
        return val;
      }
    },
    {
      name: "NetworkStarted",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: "\u2705  Press any key to continue...\n"
    }
  ];
  if (env.foundation.type == "dev" && !env.foundation.launchSpec[0].retainAllLogs || env.foundation.type == "chopsticks" && !env.foundation.launchSpec[0].retainAllLogs) {
    clearNodeLogs();
  }
  await runNetworkOnly();
  (0, import_clear.default)();
  const portsList = await reportServicePorts();
  reportLogLocation();
  portsList.forEach(
    ({ port }) => console.log(`  \u{1F5A5}\uFE0F   https://polkadot.js.org/apps/?rpc=ws%3A%2F%2F127.0.0.1%3A${port}`)
  );
  if (!args.GrepTest) {
    await import_inquirer2.default.prompt(questions2.find(({ name }) => name == "NetworkStarted"));
  } else {
    process.env.MOON_RECYCLE = "true";
    process.env.MOON_GREP = await args.GrepTest;
    await executeTests(env, { testNamePattern: await args.GrepTest });
  }
  mainloop:
    for (; ; ) {
      const choice = await import_inquirer2.default.prompt(questions2.find(({ name }) => name == "MenuChoice"));
      const env2 = globalConfig.environments.find(({ name }) => name === args.envName);
      switch (choice.MenuChoice) {
        case 1:
          (0, import_clear.default)();
          await resolveTailChoice(env2);
          lastSelected = 0;
          (0, import_clear.default)();
          break;
        case 2:
          await resolveInfoChoice(env2);
          lastSelected = 1;
          break;
        case 3:
          env2.foundation.type !== "zombie" ? await resolveCommandChoice() : await resolveZombieCommandChoice();
          lastSelected = 2;
          break;
        case 4:
          await resolveTestChoice(env2);
          lastSelected = 3;
          break;
        case 5:
          await resolveGrepChoice(env2);
          lastSelected = 4;
          break;
        case 6: {
          const quit = await import_inquirer2.default.prompt(questions2.find(({ name }) => name == "Quit"));
          if (quit.Quit === true) {
            break mainloop;
          }
          break;
        }
        default:
          throw new Error("invalid value");
      }
    }
  await MoonwallContext.destroy();
}
var reportServicePorts = async () => {
  const ctx = MoonwallContext.getContext();
  const portsList = [];
  const globalConfig = await importAsyncConfig();
  const config = globalConfig.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
  if (config.foundation.type == "dev") {
    const port = ctx.environment.nodes[0].args.find((a) => a.includes("ws-port") || a.includes("rpc-port")).split("=")[1] || "9944";
    portsList.push({ port, name: "dev" });
  } else if (config.foundation.type == "chopsticks") {
    portsList.push(
      ...await Promise.all(
        config.foundation.launchSpec.map(async ({ configPath, name }) => {
          const yaml = (0, import_yaml.parse)((await import_fs6.promises.readFile(configPath)).toString());
          return { name, port: yaml.port || "8000" };
        })
      )
    );
  } else if (config.foundation.type == "zombie") {
    ctx.zombieNetwork.relay.forEach(({ wsUri, name }) => {
      portsList.push({ name, port: wsUri.split("ws://127.0.0.1:")[1] });
    });
    Object.keys(ctx.zombieNetwork.paras).forEach((paraId) => {
      ctx.zombieNetwork.paras[paraId].nodes.forEach(({ wsUri, name }) => {
        portsList.push({ name, port: wsUri.split("ws://127.0.0.1:")[1] });
      });
    });
  }
  portsList.forEach(
    ({ name, port }) => console.log(`  \u{1F310}  Node ${name} has started, listening on ports - Websocket: ${port}`)
  );
  return portsList;
};
var resolveZombieCommandChoice = async () => {
  const choice = await import_inquirer2.default.prompt({
    name: "cmd",
    type: "list",
    choices: [
      { name: "\u267B\uFE0F  Restart Node", value: "restart" },
      { name: "\u{1F5E1}\uFE0F  Kill Node", value: "kill" },
      new import_inquirer2.default.Separator(),
      { name: "\u{1F519}  Go Back", value: "back" }
    ],
    message: "What command would you like to run? ",
    default: "back"
  });
  if (choice.cmd == "back") {
    return;
  } else {
    const whichNode = await import_inquirer2.default.prompt({
      name: "nodeName",
      type: "input",
      message: `Which node would you like to ${choice.cmd}? `
    });
    try {
      await sendIpcMessage({
        cmd: choice.cmd,
        nodeName: whichNode.nodeName,
        text: `Running ${choice.cmd} on ${whichNode.nodeName}`
      });
    } catch (e) {
      console.error("Error: ");
      console.error(e.message);
    }
  }
  return;
};
var resolveCommandChoice = async () => {
  const choice = await import_inquirer2.default.prompt({
    name: "cmd",
    type: "list",
    choices: [
      { name: "\u{1F197}  Create Block", value: "createblock" },
      { name: "\u{1F195}  Create Unfinalized Block", value: "createUnfinalizedBlock" },
      { name: "#\uFE0F\u20E3   Create N Blocks", value: "createNBlocks" },
      new import_inquirer2.default.Separator(),
      { name: "\u{1F519}  Go Back", value: "back" }
    ],
    message: `What command would you like to run? `,
    default: "createBlock"
  });
  const ctx = await MoonwallContext.getContext().connectEnvironment();
  const api = ctx.providers.find((a) => a.type == "polkadotJs").api;
  const globalConfig = await importAsyncConfig();
  const config = globalConfig.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
  const sendNewBlockCmd = async (count = 1) => {
    const port = config.foundation.type == "chopsticks" ? await Promise.all(
      config.foundation.launchSpec.map(async ({ configPath }) => {
        const yaml = (0, import_yaml.parse)((await import_fs6.promises.readFile(configPath)).toString());
        return yaml.port || "8000";
      })
    ) : void 0;
    const websocketUrl = `ws://127.0.0.1:${port}`;
    const socket = new import_ws2.default(websocketUrl);
    socket.on("open", () => {
      socket.send(
        JSON.stringify({ jsonrpc: "2.0", id: 1, method: "dev_newBlock", params: [{ count }] })
      );
      socket.close();
    });
  };
  switch (choice.cmd) {
    case "createblock":
      ctx.foundation == "dev" ? await api.rpc.engine.createBlock(true, true) : ctx.foundation == "chopsticks" ? await sendNewBlockCmd() : void 0;
      break;
    case "createUnfinalizedBlock":
      ctx.foundation == "chopsticks" ? console.log("Not supported") : await api.rpc.engine.createBlock(true, false);
      break;
    case "createNBlocks": {
      const result = await new import_inquirer2.default.prompt({
        name: "n",
        type: "number",
        message: `How many blocks? `
      });
      if (ctx.foundation == "dev") {
        const executeSequentially = async (remaining) => {
          if (remaining === 0) {
            return;
          }
          await api.rpc.engine.createBlock(true, true);
          await executeSequentially(remaining - 1);
        };
        await executeSequentially(result.n);
      }
      if (ctx.foundation == "chopsticks") {
        await sendNewBlockCmd(result.n);
      }
      break;
    }
    case "back":
      break;
  }
  return;
};
var resolveInfoChoice = async (env) => {
  console.log(import_chalk6.default.bgWhite.blackBright("Node Launch args:"));
  console.dir(MoonwallContext.getContext().environment, { depth: null });
  console.log(import_chalk6.default.bgWhite.blackBright("Launch Spec in Config File:"));
  console.dir(env, { depth: null });
  const portsList = await reportServicePorts();
  reportLogLocation();
  portsList.forEach(
    ({ port }) => console.log(`  \u{1F5A5}\uFE0F   https://polkadot.js.org/apps/?rpc=ws%3A%2F%2F127.0.0.1%3A${port}`)
  );
};
var resolveGrepChoice = async (env, silent = false) => {
  const choice = await import_inquirer2.default.prompt({
    name: "grep",
    type: "input",
    message: `What pattern would you like to filter for (ID/Title): `,
    default: process.env.MOON_GREP || "D01T01"
  });
  process.env.MOON_RECYCLE = "true";
  process.env.MOON_GREP = await choice.grep;
  const opts = { testNamePattern: await choice.grep, silent };
  if (silent) {
    opts["reporters"] = ["dot"];
  }
  return await executeTests(env, opts);
};
var resolveTestChoice = async (env, silent = false) => {
  process.env.MOON_RECYCLE = "true";
  const opts = { silent };
  if (silent) {
    opts["reporters"] = ["dot"];
  }
  return await executeTests(env, opts);
};
var resolveTailChoice = async (env) => {
  let tailing = true;
  let zombieNodePointer = 0;
  let bottomBarContents = "";
  let switchNode;
  let zombieContent;
  let zombieNodes;
  const resumePauseProse = [
    `, ${import_chalk6.default.bgWhite.black("[p]")} Pause tail`,
    `, ${import_chalk6.default.bgWhite.black("[r]")} Resume tail`
  ];
  const bottomBarBase = `\u{1F4DC} Tailing Logs, commands: ${import_chalk6.default.bgWhite.black(
    "[q]"
  )} Quit, ${import_chalk6.default.bgWhite.black("[t]")} Test, ${import_chalk6.default.bgWhite.black("[g]")} Grep test`;
  bottomBarContents = bottomBarBase + resumePauseProse[0];
  const ui = new import_inquirer2.default.ui.BottomBar({
    bottomBar: bottomBarContents + "\n"
  });
  for (; ; ) {
    (0, import_clear.default)();
    if (process.env.MOON_ZOMBIE_NODES) {
      zombieNodes = process.env.MOON_ZOMBIE_NODES ? process.env.MOON_ZOMBIE_NODES.split("|") : void 0;
      zombieContent = `, ${import_chalk6.default.bgWhite.black("[,]")} Next Log, ${import_chalk6.default.bgWhite.black(
        "[.]"
      )} Previous Log  | CurrentLog: ${import_chalk6.default.bgWhite.black(
        `${zombieNodes[zombieNodePointer]} (${zombieNodePointer + 1}/${zombieNodes.length})`
      )}`;
      bottomBarContents = bottomBarBase + resumePauseProse[tailing ? 0 : 1] + zombieContent;
      ui.updateBottomBar(bottomBarContents, "\n");
    }
    switchNode = false;
    await new Promise(async (resolve) => {
      const onData = (chunk) => ui.log.write(chunk.toString());
      const logFilePath = process.env.MOON_ZOMBIE_NODES ? `${process.env.MOON_ZOMBIE_DIR}/${zombieNodes[zombieNodePointer]}.log` : process.env.MOON_LOG_LOCATION;
      let currentReadPosition = 0;
      const printLogs = (newReadPosition, currentReadPosition2) => {
        const stream = import_fs6.default.createReadStream(logFilePath, {
          start: currentReadPosition2,
          end: newReadPosition
        });
        stream.on("data", onData);
        stream.on("end", () => {
          currentReadPosition2 = newReadPosition;
        });
      };
      const readLog = () => {
        const stats = import_fs6.default.statSync(logFilePath);
        const newReadPosition = stats.size;
        if (newReadPosition > currentReadPosition && tailing) {
          printLogs(newReadPosition, currentReadPosition);
        }
      };
      const incrPtr = () => {
        zombieNodePointer = (zombieNodePointer + 1) % zombieNodes.length;
      };
      const decrPtr = () => {
        zombieNodePointer = (zombieNodePointer - 1 + zombieNodes.length) % zombieNodes.length;
      };
      printLogs(import_fs6.default.statSync(logFilePath).size, 0);
      const renderBottomBar = (...parts) => {
        const content = process.env.MOON_ZOMBIE_NODES ? bottomBarBase + " " + parts?.join(" ") + zombieContent + "\n" : bottomBarBase + " " + parts?.join(" ") + "\n";
        ui.updateBottomBar(content);
      };
      const handleInputData = async (key) => {
        ui.rl.input.pause();
        const char = key.toString().trim();
        if (char === "p") {
          tailing = false;
          renderBottomBar(resumePauseProse[1]);
        }
        if (char === "r") {
          printLogs(import_fs6.default.statSync(logFilePath).size, currentReadPosition);
          tailing = true;
          renderBottomBar(resumePauseProse[0]);
        }
        if (char === "q") {
          ui.rl.input.removeListener("data", handleInputData);
          ui.rl.input.pause();
          import_fs6.default.unwatchFile(logFilePath);
          resolve("");
        }
        if (char === "t") {
          await resolveTestChoice(env, true);
          renderBottomBar(resumePauseProse[tailing ? 0 : 1]);
        }
        if (char === ",") {
          ui.rl.input.removeListener("data", handleInputData);
          ui.rl.input.pause();
          import_fs6.default.unwatchFile(logFilePath);
          switchNode = true;
          incrPtr();
          resolve("");
        }
        if (char === ".") {
          ui.rl.input.removeListener("data", handleInputData);
          ui.rl.input.pause();
          import_fs6.default.unwatchFile(logFilePath);
          switchNode = true;
          decrPtr();
          resolve("");
        }
        if (char === "g") {
          ui.rl.input.pause();
          tailing = false;
          await resolveGrepChoice(env, true);
          renderBottomBar(resumePauseProse[tailing ? 0 : 1]);
          tailing = true;
          ui.rl.input.resume();
        }
        ui.rl.input.resume();
      };
      ui.rl.input.on("data", handleInputData);
      import_fs6.default.watchFile(logFilePath, () => {
        readLog();
      });
    });
    if (!switchNode) {
      break;
    }
  }
  ui.close();
};

// src/internal/cmdFunctions/initialisation.ts
var import_promises4 = __toESM(require("fs/promises"), 1);
var import_inquirer3 = __toESM(require("inquirer"), 1);
var import_inquirer_press_to_continue2 = __toESM(require("inquirer-press-to-continue"), 1);
import_inquirer3.default.registerPrompt("press-to-continue", import_inquirer_press_to_continue2.default);
async function createFolders() {
  await import_promises4.default.mkdir("scripts").catch(() => "scripts folder already exists, skipping");
  await import_promises4.default.mkdir("tests").catch(() => "tests folder already exists, skipping");
  await import_promises4.default.mkdir("tmp").catch(() => "tmp folder already exists, skipping");
}
async function generateConfig() {
  for (; ; ) {
    if (await import_promises4.default.access("moonwall.config.json").catch(() => true)) {
      const answers = await import_inquirer3.default.prompt(generateQuestions);
      const proceed = await import_inquirer3.default.prompt(questions.find(({ name }) => name === "Confirm"));
      if (proceed.Confirm === false) {
        continue;
      }
      const JSONBlob = JSON.stringify(
        createConfig({
          label: answers.Label,
          timeout: answers.Timeout,
          environmentName: answers.EnvironmentName,
          foundation: answers.EnvironmentFoundation,
          testDir: answers.EnvironmentTestDir
        }),
        null,
        3
      );
      await import_promises4.default.writeFile("moonwall.config", textBlob + JSONBlob, "utf-8");
      process.env.MOON_CONFIG_PATH = "./moonwall.config";
      break;
    } else {
      console.log("\u2139\uFE0F  Config file already exists at this location. Quitting.");
      return;
    }
  }
  console.log(`Goodbye! \u{1F44B}`);
}
var generateQuestions = [
  {
    name: "Label",
    type: "input",
    message: "Provide a label for the config file",
    default: "moonwall_config"
  },
  {
    name: "Timeout",
    type: "number",
    message: "Provide a global timeout value",
    default: 3e4,
    validate: (input) => {
      const pass = /^\d+$/.test(input);
      if (pass) {
        return true;
      }
      return "Please enter a valid number \u274C";
    }
  },
  {
    name: "EnvironmentName",
    type: "input",
    message: "Provide a name for this environment",
    default: "default_env"
  },
  {
    name: "EnvironmentTestDir",
    type: "input",
    message: "Provide the path for where tests for this environment are kept",
    default: "tests/"
  },
  {
    name: "EnvironmentFoundation",
    type: "list",
    message: "What type of network foundation is this?",
    choices: ["dev", "chopsticks", "read_only", "fork", "zombie"],
    default: "tests/"
  }
];
var questions = [
  {
    name: "Confirm",
    type: "confirm",
    message: "Would you like to generate this config? (no to restart from beginning)"
  },
  {
    name: "Success",
    type: "press-to-continue",
    anyKey: true,
    pressToContinueMessage: "\u{1F4C4} moonwall.config.ts has been generated. Press any key to exit  \u2705\n"
  },
  {
    name: "Failure",
    type: "press-to-continue",
    anyKey: true,
    pressToContinueMessage: "Config has not been generated due to errors, Press any key to exit  \u274C\n"
  }
];
function createConfig(options) {
  return {
    label: options.label,
    defaultTestTimeout: options.timeout,
    environments: [
      {
        name: options.environmentName,
        testFileDir: [options.testDir],
        foundation: {
          type: options.foundation
        }
      }
    ]
  };
}
var textBlob = `// This Moonwall Config file should be modified to include all types
// of environments you wish to test against.

// For more information on how to configure Moonwall, please visit:
// https://moonsong-labs.github.io/moonwall/config/intro.html
`;

// src/cmds/main.ts
var import_chalk8 = __toESM(require("chalk"), 1);
var import_clear2 = __toESM(require("clear"), 1);
var import_colors = __toESM(require("colors"), 1);
var import_inquirer4 = __toESM(require("inquirer"), 1);
var import_inquirer_press_to_continue3 = __toESM(require("inquirer-press-to-continue"), 1);
var import_node_fetch3 = __toESM(require("node-fetch"), 1);
var import_semver2 = require("semver");

// package.json
var package_default = {
  name: "@moonwall/cli",
  type: "module",
  version: "4.4.4",
  description: "Testing framework for the Moon family of projects",
  author: "timbrinded",
  license: "ISC",
  homepage: "https://github.com/Moonsong-Labs/moonwall#readme",
  repository: {
    type: "git",
    url: "git+https://github.com/Moonsong-Labs/moonwall.git",
    directory: "packages/cli"
  },
  bugs: {
    url: "https://github.com/Moonsong-Labs/moonwall/issues"
  },
  keywords: [
    "moonwall",
    "moonbeam",
    "moondance",
    "polkadot",
    "kusama",
    "substrate"
  ],
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      require: "./dist/index.cjs",
      import: "./dist/index.js",
      bun: "./src/cmds/entrypoint.ts"
    }
  },
  module: "./dist/index.js",
  main: "./dist/index.cjs",
  types: "./dist/index.d.ts",
  bin: {
    moonwall: "./moonwall.mjs"
  },
  engines: {
    node: ">=20.0.0",
    pnpm: ">=7"
  },
  files: [
    "dist",
    "bin",
    "*.d.ts",
    "*.d.cts",
    "*.mjs",
    "*.cjs"
  ],
  scripts: {
    clean: "rm -rf dist && rm -rf node_modules",
    build: "pnpm exec rm -rf dist && tsup src --format cjs,esm  && pnpm generate-types",
    lint: "eslint ./src/**/*.ts",
    "lint:fix": "eslint './src/**/*.ts' --fix",
    fmt: "pnpm prettier --check --ignore-path ../../.prettierignore '**/*.(yml|js|ts|json)'",
    "fmt:fix": "pnpm prettier --write --ignore-path ../../.prettierignore '**/*.(yml|js|ts|json)'",
    "generate-types": "tsup src --format cjs,esm --dts ",
    watch: "tsup src --format cjs,esm --dts --watch",
    typecheck: "pnpm exec tsc --noEmit",
    prepublish: "pnpm run build && pnpm run generate-types"
  },
  dependencies: {
    "@acala-network/chopsticks": "0.9.3",
    "@moonbeam-network/api-augment": "0.2600.0",
    "@moonwall/types": "workspace:*",
    "@moonwall/util": "workspace:*",
    "@polkadot/api": "10.11.1",
    "@polkadot/api-augment": "10.11.1",
    "@polkadot/api-derive": "10.11.1",
    "@polkadot/keyring": "12.6.1",
    "@polkadot/types": "10.11.1",
    "@polkadot/types-codec": "10.11.1",
    "@polkadot/util": "12.6.1",
    "@polkadot/util-crypto": "12.6.1",
    "@vitest/ui": "1.0.1",
    "@zombienet/orchestrator": "0.0.68",
    "@zombienet/utils": "0.0.24",
    bottleneck: "2.19.5",
    chalk: "5.3.0",
    clear: "0.1.0",
    "cli-progress": "3.12.0",
    colors: "1.4.0",
    debug: "4.3.4",
    dotenv: "16.3.1",
    ethers: "6.8.0",
    inquirer: "9.2.12",
    "inquirer-press-to-continue": "1.2.0",
    "jsonc-parser": "3.2.0",
    minimatch: "9.0.3",
    "node-fetch": "3.3.2",
    semver: "7.5.4",
    viem: "1.18.0",
    vitest: "1.0.1",
    web3: "4.2.1",
    "web3-providers-ws": "4.0.7",
    ws: "8.14.2",
    yaml: "2.3.3",
    yargs: "17.7.2"
  },
  devDependencies: {
    "@types/cli-progress": "3.11.5",
    "@types/debug": "4.1.12",
    "@types/node": "20.10.3",
    "@types/yargs": "17.0.32",
    prettier: "2.8.8",
    tsup: "8.0.1",
    tsx: "4.6.2",
    typescript: "5.3.2"
  },
  publishConfig: {
    access: "public"
  }
};

// src/internal/cmdFunctions/fetchArtifact.ts
var import_promises5 = __toESM(require("fs/promises"), 1);
var import_path7 = __toESM(require("path"), 1);
var import_node_fetch2 = __toESM(require("node-fetch"), 1);
var import_semver = __toESM(require("semver"), 1);
var import_chalk7 = __toESM(require("chalk"), 1);

// src/internal/processHelpers.ts
var import_child_process5 = __toESM(require("child_process"), 1);
var import_node_util = require("util");
var import_debug4 = __toESM(require("debug"), 1);
var debug2 = (0, import_debug4.default)("actions:runner");
var execAsync = (0, import_node_util.promisify)(import_child_process5.default.exec);
async function runTask(cmd, { cwd, env } = {
  cwd: process.cwd()
}, title) {
  debug2(`${title ? `Title: ${title}
` : ""}Running task on directory ${cwd}: ${cmd}
`);
  try {
    const result = await execAsync(cmd, { cwd, env });
    return result.stdout;
  } catch (error) {
    const status = error.status ? `[${error.status}]` : "[Unknown Status]";
    const message = error.message ? `${error.message}` : "No Error Message";
    debug2(`Caught exception in command execution. Error[${status}] ${message}`);
    throw error;
  }
}

// src/internal/cmdFunctions/fetchArtifact.ts
var import_minimatch = require("minimatch");

// src/internal/cmdFunctions/downloader.ts
var import_cli_progress = require("cli-progress");
var import_node_fetch = __toESM(require("node-fetch"), 1);
var import_node_fs3 = __toESM(require("fs"), 1);
var progressBar;
var onStart = (length) => {
  progressBar = new import_cli_progress.SingleBar(
    {
      etaAsynchronousUpdate: true,
      etaBuffer: 40,
      format: "Downloading: [{bar}] {percentage}% | ETA: {eta_formatted} | {value}/{total}"
    },
    import_cli_progress.Presets.shades_classic
  );
  progressBar.start(length, 0);
};
var onProgress = (bytes) => {
  progressBar.update(bytes);
};
var onComplete = () => {
  progressBar.stop();
  process.stdout.write(`  \u{1F4BE} Saving binary artefact...`);
};
async function downloader(url, outputPath) {
  const tempPath = outputPath + ".tmp";
  const writeStream = import_node_fs3.default.createWriteStream(tempPath);
  let transferredBytes = 0;
  const response = await (0, import_node_fetch.default)(url);
  if (!response.body) {
    throw new Error("No response body");
  }
  const readStream = response.body;
  readStream.pipe(writeStream);
  await new Promise((resolve, reject) => {
    const contentLength = parseInt(response.headers.get("Content-Length") || "0");
    onStart(contentLength);
    readStream.on("data", (chunk) => {
      transferredBytes += chunk.length;
      onProgress(transferredBytes);
    });
    readStream.on("end", () => {
      writeStream.end();
      onComplete();
      writeStream.close(() => resolve("Finished!"));
    });
    readStream.on("error", () => {
      reject("Error!");
    });
  });
  import_node_fs3.default.writeFileSync(outputPath, import_node_fs3.default.readFileSync(tempPath));
  import_node_fs3.default.rmSync(tempPath);
}

// src/internal/cmdFunctions/fetchArtifact.ts
var import_node_child_process2 = require("child_process");
async function fetchArtifact(args) {
  if (await import_promises5.default.access(args.path).catch(() => true)) {
    console.log("Folder not exists, creating");
    import_promises5.default.mkdir(args.path);
  }
  const binary = args.bin;
  const repo4 = (await allReposAsync()).find(
    (network) => network.binaries.find((bin) => bin.name === binary)
  );
  if (!repo4) {
    throw new Error(`Downloading ${binary} unsupported`);
  }
  const url = `https://api.github.com/repos/${repo4.ghAuthor}/${repo4.ghRepo}/releases`;
  const enteredPath = args.path ? args.path : "tmp/";
  const releases = await (await (0, import_node_fetch2.default)(url)).json();
  const release = binary.includes("-runtime") ? releases.find((release2) => {
    if (args.ver === "latest") {
      return release2.assets.find((asset2) => asset2.name.includes(binary));
    } else {
      return release2.assets.find((asset2) => asset2.name === `${binary}-${args.ver}.wasm`);
    }
  }) : args.ver === "latest" ? releases.find((release2) => release2.assets.find((asset2) => asset2.name === binary)) : releases.filter((release2) => release2.tag_name.includes(args.ver)).find((release2) => release2.assets.find((asset2) => (0, import_minimatch.minimatch)(asset2.name, binary)));
  if (release == null) {
    throw new Error(`Release not found for ${args.ver}`);
  }
  const asset = binary.includes("-runtime") ? release.assets.find((asset2) => asset2.name.includes(binary) && asset2.name.includes("wasm")) : release.assets.find((asset2) => (0, import_minimatch.minimatch)(asset2.name, binary));
  if (!binary.includes("-runtime")) {
    const url2 = asset.browser_download_url;
    const filename = import_path7.default.basename(url2);
    const binPath = import_path7.default.join("./", enteredPath, filename);
    await downloader(url2, binPath);
    await import_promises5.default.chmod(binPath, "755");
    if (filename.endsWith(".tar.gz")) {
      const outputBuffer = (0, import_node_child_process2.execSync)(`tar -xzvf ${binPath}`);
      const cleaned = outputBuffer.toString().split("\n")[0].split("/")[0];
      const version = (await runTask(`./${cleaned} --version`)).trim();
      process.stdout.write(` ${import_chalk7.default.green(version.trim())} \u2713
`);
      return;
    } else {
      const version = (await runTask(`./${binPath} --version`)).trim();
      process.stdout.write(` ${import_chalk7.default.green(version.trim())} \u2713
`);
      return;
    }
  } else {
    const binaryPath = import_path7.default.join("./", args.path, `${args.bin}-${args.ver}.wasm`);
    await downloader(asset.browser_download_url, binaryPath);
    await import_promises5.default.chmod(binaryPath, "755");
    process.stdout.write(` ${import_chalk7.default.green("done")} \u2713
`);
    return;
  }
}
async function getVersions(name, runtime = false) {
  const repo4 = (await allReposAsync()).find(
    (network) => network.binaries.find((bin) => bin.name === name)
  );
  if (!repo4) {
    throw new Error(`Network not found for ${name}`);
  }
  const url = `https://api.github.com/repos/${repo4.ghAuthor}/${repo4.ghRepo}/releases`;
  const releases = await (await (0, import_node_fetch2.default)(url)).json();
  const versions = releases.map((release) => {
    let tag = release.tag_name;
    if (release.tag_name.includes("v")) {
      tag = tag.split("v")[1];
    }
    if (tag.includes("-rc")) {
      tag = tag.split("-rc")[0];
    }
    return tag;
  }).filter(
    (version) => runtime && version.includes("runtime") || !runtime && !version.includes("runtime")
  ).map((version) => version.replace("runtime-", ""));
  const set = new Set(versions);
  return runtime ? [...set] : [...set].sort(
    (a, b) => import_semver.default.valid(a) && import_semver.default.valid(b) ? import_semver.default.rcompare(a, b) : a
  );
}

// src/cmds/main.ts
var import_fs7 = __toESM(require("fs"), 1);
var import_path8 = __toESM(require("path"), 1);
import_inquirer4.default.registerPrompt("press-to-continue", import_inquirer_press_to_continue3.default);
async function main() {
  for (; ; ) {
    let globalConfig;
    try {
      globalConfig = await importAsyncConfig();
    } catch (e) {
      console.log(e);
    }
    (0, import_clear2.default)();
    await printIntro();
    if (await mainMenu(globalConfig)) {
      break;
    } else {
      continue;
    }
  }
  process.stdout.write(`Goodbye! \u{1F44B}
`);
}
async function mainMenu(config) {
  const configPresent = config !== void 0;
  const questionList = {
    name: "MenuChoice",
    type: "list",
    message: `Main Menu - Please select one of the following:`,
    default: 0,
    pageSize: 12,
    choices: !configPresent ? [
      {
        name: !configPresent ? "1) Initialise:                         Generate a new Moonwall Config File" : import_chalk8.default.dim("1) Initialise:                       \u2705  CONFIG ALREADY GENERATED"),
        value: "init"
      },
      {
        name: "2) Artifact Downloader:                Fetch artifacts (x86) from GitHub repos",
        value: "download"
      },
      {
        name: `3) Quit Application`,
        value: "quit"
      }
    ] : [
      {
        name: `1) Execute Script:                     Run scripts placed in your config defined script directory`,
        value: "exec"
      },
      {
        name: `2) Network Launcher & Toolbox:         Launch network, access tools: tail logs, interactive tests etc`,
        value: "run"
      },
      {
        name: "3) Test Suite Execution:               Run automated tests, start network if needed",
        value: "test"
      },
      {
        name: "4) Artifact Downloader:                Fetch artifacts (x86) from GitHub repos",
        value: "download"
      },
      {
        name: `5) Quit Application`,
        value: "quit"
      }
    ],
    filter(val) {
      return val;
    }
  };
  const answers = await import_inquirer4.default.prompt(questionList);
  switch (answers.MenuChoice) {
    case "init":
      await generateConfig();
      await createFolders();
      return false;
    case "run": {
      const chosenRunEnv = await chooseRunEnv(config);
      process.env.MOON_RUN_SCRIPTS = "true";
      if (chosenRunEnv.envName !== "back") {
        await runNetworkCmd(chosenRunEnv);
      }
      return false;
    }
    case "test": {
      const chosenTestEnv = await chooseTestEnv(config);
      if (chosenTestEnv.envName !== "back") {
        process.env.MOON_RUN_SCRIPTS = "true";
        await testCmd(chosenTestEnv.envName);
        await import_inquirer4.default.prompt({
          name: "test complete",
          type: "press-to-continue",
          anyKey: true,
          pressToContinueMessage: `\u2139\uFE0F  Test run for ${import_chalk8.default.bgWhiteBright.black(
            chosenTestEnv.envName
          )} has been completed. Press any key to continue...
`
        });
      }
      return false;
    }
    case "download":
      await resolveDownloadChoice();
      return false;
    case "quit":
      return await resolveQuitChoice();
    case "exec":
      return await resolveExecChoice(config);
    default:
      throw new Error("Invalid choice");
  }
}
async function resolveExecChoice(config) {
  const scriptDir = config.scriptsDir;
  if (!scriptDir) {
    await import_inquirer4.default.prompt({
      name: "test complete",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `\u2139\uFE0F  No scriptDir property defined at ${import_chalk8.default.bgWhiteBright.black(
        "moonwall.config.json"
      )}
 Press any key to continue...
`
    });
    return false;
  }
  if (!import_fs7.default.existsSync(scriptDir)) {
    await import_inquirer4.default.prompt({
      name: "test complete",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `\u2139\uFE0F  No scriptDir found at at ${import_chalk8.default.bgWhiteBright.black(
        import_path8.default.join(process.cwd(), scriptDir)
      )}
 Press any key to continue...
`
    });
    return false;
  }
  const files = await import_fs7.default.promises.readdir(scriptDir);
  if (!files) {
    await import_inquirer4.default.prompt({
      name: "test complete",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `\u2139\uFE0F  No scripts found at ${import_chalk8.default.bgWhiteBright.black(
        import_path8.default.join(process.cwd(), config.scriptsDir)
      )}
 Press any key to continue...
`
    });
  }
  const choices = files.map((file) => {
    const ext = getExtString(file);
    return { name: `${ext}:    ${import_path8.default.basename(file, "")}`, value: file };
  });
  for (; ; ) {
    const result = await import_inquirer4.default.prompt({
      name: "selections",
      message: "Select which scripts you'd like to run (press \u21A9\uFE0F with none selected to go \u{1F519})\n",
      type: "checkbox",
      choices
    });
    if (result.selections.length === 0) {
      const result2 = await import_inquirer4.default.prompt({
        name: "none-selected",
        message: "No scripts have been selected to run, do you wish to exit?",
        type: "confirm",
        default: true
      });
      if (result2["none-selected"]) {
        return false;
      } else {
        continue;
      }
    }
    for (const script of result.selections) {
      const result2 = await import_inquirer4.default.prompt({
        name: "args",
        message: `Enter any arguments for ${import_chalk8.default.bgWhiteBright.black(
          script
        )} (press enter for none)`,
        type: "input"
      });
      await executeScript(script, result2.args);
    }
    await import_inquirer4.default.prompt({
      name: "test complete",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `Press any key to continue...
`
    });
    return false;
  }
}
async function resolveDownloadChoice() {
  const binList = (await allReposAsync()).reduce((acc, curr) => {
    acc.push(...curr.binaries.map((bin) => bin.name).flat());
    acc.push(new import_inquirer4.default.Separator());
    acc.push("Back");
    acc.push(new import_inquirer4.default.Separator());
    return acc;
  }, []);
  for (; ; ) {
    const firstChoice = await import_inquirer4.default.prompt({
      name: "artifact",
      type: "list",
      message: `Download - which artifact?`,
      choices: binList
    });
    if (firstChoice.artifact === "Back") {
      return;
    }
    const versions = await getVersions(
      firstChoice.artifact,
      firstChoice.artifact.includes("runtime")
    );
    const chooseversion = await import_inquirer4.default.prompt({
      name: "binVersion",
      type: "list",
      default: "latest",
      message: `Download - which version?`,
      choices: [...versions, new import_inquirer4.default.Separator(), "Back", new import_inquirer4.default.Separator()]
    });
    if (chooseversion.binVersion === "Back") {
      continue;
    }
    const chooseLocation = await import_inquirer4.default.prompt({
      name: "path",
      type: "input",
      message: `Download - where would you like it placed?`,
      default: "./tmp"
    });
    const result = await import_inquirer4.default.prompt({
      name: "continue",
      type: "confirm",
      message: `You are about to download ${import_chalk8.default.bgWhite.blackBright(
        firstChoice.artifact
      )} v-${import_chalk8.default.bgWhite.blackBright(chooseversion.binVersion)} to: ${import_chalk8.default.bgWhite.blackBright(
        chooseLocation.path
      )}.
 Would you like to continue? `,
      default: true
    });
    if (result.continue === false) {
      continue;
    }
    await fetchArtifact({
      bin: firstChoice.artifact,
      ver: chooseversion.binVersion,
      path: chooseLocation.path
    });
    await import_inquirer4.default.prompt({
      name: "NetworkStarted",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `\u2705 Artifact has been downloaded. Press any key to continue...
`
    });
    return;
  }
}
var chooseTestEnv = async (config) => {
  const envs = config.environments.map((a) => ({
    name: `[${a.foundation.type}] ${a.name}${a.description ? ": 		" + a.description : ""}`,
    value: a.name,
    disabled: false
  })).sort((a, b) => a.name > b.name ? -1 : 1);
  envs.push(
    ...[
      new import_inquirer4.default.Separator(),
      { name: "Back", value: "back" },
      new import_inquirer4.default.Separator()
    ]
  );
  const result = await import_inquirer4.default.prompt({
    name: "envName",
    message: "Select a environment to run",
    type: "list",
    pageSize: 12,
    choices: envs
  });
  return result;
};
var chooseRunEnv = async (config) => {
  const envs = config.environments.map((a) => {
    const result2 = { name: "", value: a.name, disabled: false };
    if (a.foundation.type === "dev" || a.foundation.type === "chopsticks" || a.foundation.type === "zombie") {
      result2.name = `[${a.foundation.type}] ${a.name}${a.description ? ": 		" + a.description : ""}`;
    } else {
      result2.name = import_chalk8.default.dim(`[${a.foundation.type}] ${a.name}     NO NETWORK TO RUN`);
      result2.disabled = true;
    }
    return result2;
  });
  const choices = [
    ...envs.filter(({ disabled }) => disabled === false).sort((a, b) => a.name > b.name ? 1 : -1),
    new import_inquirer4.default.Separator(),
    ...envs.filter(({ disabled }) => disabled === true).sort((a, b) => a.name > b.name ? 1 : -1),
    new import_inquirer4.default.Separator(),
    { name: "Back", value: "back" },
    new import_inquirer4.default.Separator()
  ];
  const result = await import_inquirer4.default.prompt({
    name: "envName",
    message: "Select a environment to run",
    type: "list",
    pageSize: 12,
    choices
  });
  return result;
};
var resolveQuitChoice = async () => {
  const result = await import_inquirer4.default.prompt({
    name: "Quit",
    type: "confirm",
    message: "Are you sure you want to Quit?",
    default: false
  });
  return result.Quit;
};
var printIntro = async () => {
  const currentVersion = new import_semver2.SemVer(package_default.version);
  let remoteVersion = "";
  try {
    const url = "https://api.github.com/repos/moonsong-labs/moonwall/releases";
    const resp = await (0, import_node_fetch3.default)(url);
    const json = await resp.json();
    remoteVersion = json.find((a) => a.tag_name.includes("@moonwall/cli@")).tag_name.split("@")[2];
  } catch (error) {
    remoteVersion = "unknown";
    console.error(`Fetch Error: ${error}`);
  }
  const logo = import_chalk8.default.cyan(`
                                                                                                                  
                                      ####################                      
                                  ############################                  
                               ###################################              
                            ########################################            
                           ###########################################          
                         ##############################################         
                        ################################################        
                       .#################################################       
                       ##################################################       
                       ##################################################       
`) + import_chalk8.default.red(`                                                                                
\u{1F9F1}\u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
              \u{1F9F1}\u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
      \u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
        \u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}    \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
                                       \u{1F9F1}\u{1F9F1}\u{1F9F1}  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
                      \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}      
                                                                                                                                                              

`);
  process.stdout.write(logo);
  process.stdout.write(
    import_colors.default.rainbow(
      "================================================================================\n"
    )
  );
  if (remoteVersion !== "unknown" && (0, import_semver2.lt)(currentVersion, new import_semver2.SemVer(remoteVersion))) {
    process.stdout.write(
      import_chalk8.default.bgCyan.white(
        `                 MOONWALL   V${currentVersion.version}   (New version ${remoteVersion} available!)             
`
      )
    );
  } else {
    process.stdout.write(
      import_chalk8.default.bgCyan.white(
        `                                MOONWALL  V${currentVersion.version}                                
`
      )
    );
  }
  process.stdout.write(
    import_colors.default.rainbow(
      "================================================================================\n"
    )
  );
};
var getExtString = (file) => {
  const ext = import_path8.default.extname(file);
  switch (ext) {
    case ".js":
      return import_chalk8.default.bgYellow.black(ext);
    case ".ts":
      return import_chalk8.default.bgBlue.black(ext);
    case ".sh":
      return import_chalk8.default.bgGreen.black(ext);
    default:
      return import_chalk8.default.bgRed.black(ext);
  }
};

// src/cmds/entrypoint.ts
var import_dotenv = __toESM(require("dotenv"), 1);
import_dotenv.default.config();
var parsed = (0, import_yargs.default)((0, import_helpers.hideBin)(process.argv)).options({
  configFile: {
    type: "string",
    alias: "c",
    description: "path to MoonwallConfig file",
    default: "./moonwall.config.json"
  }
}).parseSync();
process.env.MOON_CONFIG_PATH = parsed.configFile;
(0, import_yargs.default)((0, import_helpers.hideBin)(process.argv)).usage("Usage: $0").version("2.0.0").options({
  configFile: {
    type: "string",
    alias: "c",
    description: "path to MoonwallConfig file",
    default: "./moonwall.config.json"
  }
}).middleware((argv) => {
  process.env.MOON_CONFIG_PATH = argv.configFile;
}).command(`init`, "Run tests for a given Environment", async () => {
  await generateConfig();
}).command(
  `download <bin> [ver] [path]`,
  "Download x86 artifact from GitHub",
  (yargs2) => {
    return yargs2.positional("bin", {
      describe: "Name of artifact to download\n[ moonbeam | polkadot | *-runtime ]"
    }).positional("ver", {
      describe: "Artifact version to download",
      default: "latest"
    }).positional("path", {
      describe: "Path where to save artifacts",
      type: "string",
      default: "./"
    }).option("overwrite", {
      describe: "If file exists, should it be overwritten?",
      type: "boolean",
      alias: "d",
      default: true
    }).option("output-name", {
      describe: "Rename downloaded file to this name",
      alias: "o",
      type: "string"
    });
  },
  async (argv) => {
    await fetchArtifact(argv);
  }
).command(
  `test <envName> [GrepTest]`,
  "Run tests for a given Environment",
  (yargs2) => {
    return yargs2.positional("envName", {
      describe: "Network environment to run tests against",
      array: true,
      string: true
    }).positional("GrepTest", {
      type: "string",
      description: "Pattern to grep test ID/Description to run"
    });
  },
  async (args) => {
    if (args.envName) {
      process.env.MOON_RUN_SCRIPTS = "true";
      await testCmd(args.envName.toString(), { testNamePattern: args.GrepTest }) ? process.exit(0) : process.exit(1);
    } else {
      console.log("\u274C No environment specified");
      console.log(`\u{1F449} Run 'pnpm moonwall --help' for more information`);
      process.exit(1);
    }
  }
).command(
  `run <envName> [GrepTest]`,
  "Start new network found in global config",
  (yargs2) => {
    return yargs2.positional("envName", {
      describe: "Network environment to start"
    }).positional("GrepTest", {
      type: "string",
      description: "Pattern to grep test ID/Description to run"
    });
  },
  async (argv) => {
    process.env.MOON_RUN_SCRIPTS = "true";
    await runNetworkCmd(argv);
    process.exit(0);
  }
).demandCommand(1).fail(async (msg) => {
  console.log(msg);
  await main();
}).help("h").alias("h", "help").parse();
