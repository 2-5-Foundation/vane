import {
  createDevBlock
} from "./chunk-3UGOZS4O.js";
import {
  deployCreateCompiledContract,
  interactWithContract,
  interactWithPrecompileContract
} from "./chunk-3BBWLW2X.js";
import {
  importJsonConfig,
  isEthereumDevConfig
} from "./chunk-3IRCD3RX.js";

// src/lib/handlers/devHandler.ts
import {
  ALITH_PRIVATE_KEY,
  BALTATHAR_PRIVATE_KEY,
  CHARLETH_PRIVATE_KEY,
  DOROTHY_PRIVATE_KEY,
  alith,
  createEthersTransaction,
  createViemTransaction
} from "@moonwall/util";
import { Keyring } from "@polkadot/api";
var devHandler = ({ testCases, context, testCase, logger }) => {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  const ethCompatible = isEthereumDevConfig();
  const accountTypeLookup = () => {
    const metadata = ctx.polkadotJs().runtimeMetadata.asLatest;
    const systemPalletIndex = metadata.pallets.findIndex(
      (pallet) => pallet.name.toString() === "System"
    );
    const systemAccountStorageType = metadata.pallets[systemPalletIndex].storage.unwrap().items.find((storage) => storage.name.toString() === "Account").type;
    return metadata.lookup.getTypeDef(systemAccountStorageType.asMap.key).type;
  };
  const newKeyring = () => {
    const isEth = accountTypeLookup() == "AccountId20";
    const keyring = new Keyring({
      type: isEth ? "ethereum" : "sr25519"
    });
    return {
      alice: keyring.addFromUri(isEth ? ALITH_PRIVATE_KEY : "//Alice", { name: "Alice default" }),
      bob: keyring.addFromUri(isEth ? BALTATHAR_PRIVATE_KEY : "//Bob", { name: "Bob default" }),
      charlie: keyring.addFromUri(isEth ? CHARLETH_PRIVATE_KEY : "//Charlie", {
        name: "Charlie default"
      }),
      dave: keyring.addFromUri(isEth ? DOROTHY_PRIVATE_KEY : "//Dave", { name: "Dave default" })
    };
  };
  const ctx = {
    ...context,
    get isEthereumChain() {
      return accountTypeLookup() === "AccountId20";
    },
    get isSubstrateChain() {
      return accountTypeLookup() === "AccountId32";
    },
    get pjsApi() {
      return context.polkadotJs();
    },
    get keyring() {
      return newKeyring();
    },
    createBlock: async (transactions, options) => {
      const defaults = {
        signer: env.defaultSigner || alith,
        allowFailures: env.defaultAllowFailures === void 0 ? true : env.defaultAllowFailures,
        finalize: env.defaultFinalization === void 0 ? true : env.defaultFinalization
      };
      return await createDevBlock(context, { ...defaults, ...options }, transactions);
    },
    createTxn: !ethCompatible ? void 0 : (options) => {
      const { libraryType = "viem", ...txnOptions } = options;
      return libraryType === "viem" ? createViemTransaction(ctx, txnOptions) : createEthersTransaction(ctx, txnOptions);
    },
    readPrecompile: !ethCompatible ? void 0 : async (options) => {
      const response = await interactWithPrecompileContract(ctx, {
        call: true,
        ...options
      });
      return response;
    },
    writePrecompile: !ethCompatible ? void 0 : async (options) => {
      const response = await interactWithPrecompileContract(ctx, { call: false, ...options });
      return response;
    },
    readContract: !ethCompatible ? void 0 : async (options) => {
      const response = await interactWithContract(ctx, {
        call: true,
        ...options
      });
      return response;
    },
    writeContract: !ethCompatible ? void 0 : async (options) => {
      const response = await interactWithContract(ctx, { call: false, ...options });
      return response;
    },
    deployContract: !ethCompatible ? void 0 : async (contractName, options) => {
      return await deployCreateCompiledContract(ctx, contractName, options);
    }
  };
  testCases({
    context: ctx,
    it: testCase,
    log: logger()
  });
};

export {
  devHandler
};
