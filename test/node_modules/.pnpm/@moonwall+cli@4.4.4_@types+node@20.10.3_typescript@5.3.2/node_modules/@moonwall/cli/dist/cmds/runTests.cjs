var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/cmds/runTests.ts
var runTests_exports = {};
__export(runTests_exports, {
  executeTests: () => executeTests,
  testCmd: () => testCmd
});
module.exports = __toCommonJS(runTests_exports);
var import_chalk5 = __toESM(require("chalk"), 1);
var import_path6 = __toESM(require("path"), 1);
var import_node = require("vitest/node");

// src/internal/cmdFunctions/tempLogs.ts
var import_path = __toESM(require("path"), 1);
var import_fs = __toESM(require("fs"), 1);
function clearNodeLogs(silent = true) {
  const dirPath = import_path.default.join(process.cwd(), "tmp", "node_logs");
  if (!import_fs.default.existsSync(dirPath)) {
    import_fs.default.mkdirSync(dirPath, { recursive: true });
  }
  const files = import_fs.default.readdirSync(dirPath);
  for (const file of files) {
    !silent && console.log(`Deleting log: ${file}`);
    if (file.endsWith(".log")) {
      import_fs.default.unlinkSync(import_path.default.join(dirPath, file));
    }
  }
}

// src/internal/launcherCommon.ts
var import_chalk2 = __toESM(require("chalk"), 1);
var import_child_process2 = require("child_process");
var import_fs3 = __toESM(require("fs"), 1);
var import_path3 = __toESM(require("path"), 1);

// src/lib/configReader.ts
var import_api_augment = require("@moonbeam-network/api-augment");
var import_promises = require("fs/promises");
var import_fs2 = require("fs");
var import_jsonc_parser = __toESM(require("jsonc-parser"), 1);
var import_path2 = __toESM(require("path"), 1);
var cachedConfig;
async function parseConfig(filePath) {
  let result;
  const file = await (0, import_promises.readFile)(filePath, "utf8");
  switch ((0, import_path2.extname)(filePath)) {
    case ".json":
      result = JSON.parse(file);
      break;
    case ".config":
      result = import_jsonc_parser.default.parse(file);
      break;
    default:
      result = void 0;
      break;
  }
  return result;
}
function parseConfigSync(filePath) {
  let result;
  const file = (0, import_fs2.readFileSync)(filePath, "utf8");
  switch ((0, import_path2.extname)(filePath)) {
    case ".json":
      result = JSON.parse(file);
      break;
    case ".config":
      result = import_jsonc_parser.default.parse(file);
      break;
    default:
      result = void 0;
      break;
  }
  return result;
}
function isOptionSet(option) {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  const optionValue = traverseConfig(env, option);
  return optionValue !== void 0;
}
function isEthereumZombieConfig() {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  return env.foundation.type == "zombie" && !env.foundation.zombieSpec.disableDefaultEthProviders;
}
function isEthereumDevConfig() {
  const config = importJsonConfig();
  const env = config.environments.find((env2) => env2.name == process.env.MOON_TEST_ENV);
  return env.foundation.type == "dev" && !env.foundation.launchSpec[0].disableDefaultEthProviders;
}
async function cacheConfig() {
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path2.default.isAbsolute(configPath) ? configPath : import_path2.default.join(process.cwd(), configPath);
  try {
    const config = parseConfigSync(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
function importJsonConfig() {
  if (cachedConfig) {
    return cachedConfig;
  }
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path2.default.isAbsolute(configPath) ? configPath : import_path2.default.join(process.cwd(), configPath);
  try {
    const config = parseConfigSync(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
    return cachedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
async function importAsyncConfig() {
  if (cachedConfig) {
    return cachedConfig;
  }
  const configPath = process.env.MOON_CONFIG_PATH;
  const filePath = import_path2.default.isAbsolute(configPath) ? configPath : import_path2.default.join(process.cwd(), configPath);
  try {
    const config = await parseConfig(filePath);
    const replacedConfig = replaceEnvVars(config);
    cachedConfig = replacedConfig;
    return cachedConfig;
  } catch (e) {
    console.error(e);
    throw new Error(`Error import config at ${filePath}`);
  }
}
function loadEnvVars() {
  const globalConfig = importJsonConfig();
  const env = globalConfig.environments.find(({ name }) => name === process.env.MOON_TEST_ENV);
  env.envVars && env.envVars.forEach((envVar) => {
    const [key, value] = envVar.split("=");
    process.env[key] = value;
  });
}
function replaceEnvVars(value) {
  if (typeof value === "string") {
    return value.replace(/\$\{([^}]+)\}/g, (match, group) => {
      const envVarValue = process.env[group];
      return envVarValue || match;
    });
  } else if (Array.isArray(value)) {
    return value.map(replaceEnvVars);
  } else if (typeof value === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, replaceEnvVars(v)]));
  } else {
    return value;
  }
}
function traverseConfig(configObj, option) {
  if (typeof configObj !== "object" || configObj === null)
    return void 0;
  if (Object.prototype.hasOwnProperty.call(configObj, option)) {
    return configObj[option];
  }
  for (const key in configObj) {
    const result = traverseConfig(configObj[key], option);
    if (result !== void 0) {
      return result;
    }
  }
  return void 0;
}
function parseZombieConfigForBins(zombieConfigPath) {
  const config = JSON.parse((0, import_fs2.readFileSync)(zombieConfigPath, "utf8"));
  const commands = [];
  if (config.relaychain && config.relaychain.default_command) {
    commands.push(import_path2.default.basename(config.relaychain.default_command));
  }
  if (config.parachains) {
    for (const parachain of config.parachains) {
      if (parachain.collator && parachain.collator.command) {
        commands.push(import_path2.default.basename(parachain.collator.command));
      }
    }
  }
  return [...new Set(commands)].sort();
}

// src/internal/fileCheckers.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_child_process = require("child_process");
var import_chalk = __toESM(require("chalk"), 1);
var import_node_os = __toESM(require("os"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_node_path = __toESM(require("path"), 1);
async function checkExists(path8) {
  const binPath = path8.split(" ")[0];
  const fsResult = import_node_fs.default.existsSync(binPath);
  if (!fsResult) {
    throw new Error(
      `No binary file found at location: ${binPath} 
 Are you sure your ${import_chalk.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "binPath" in launchSpec?`
    );
  }
  const binArch = await getBinaryArchitecture(binPath);
  const currentArch = import_node_os.default.arch();
  if (binArch !== currentArch && binArch !== "unknown") {
    throw new Error(
      `The binary architecture ${import_chalk.default.bgWhiteBright.blackBright(
        binArch
      )} does not match this system's architecture ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )}
Download or compile a new binary executable for ${import_chalk.default.bgWhiteBright.blackBright(
        currentArch
      )} `
    );
  }
  return true;
}
async function downloadBinsIfMissing(binPath) {
  const binName = import_node_path.default.basename(binPath);
  const binDir = import_node_path.default.dirname(binPath);
  const binPathExists = import_node_fs.default.existsSync(binPath);
  if (!binPathExists && process.arch === "x64") {
    const choices = await import_inquirer.default.prompt({
      name: "download",
      type: "list",
      message: `The binary ${import_chalk.default.bgBlack.greenBright(
        binName
      )} is missing from ${import_chalk.default.bgBlack.greenBright(
        import_node_path.default.join(process.cwd(), binDir)
      )}.
Would you like to download it now?`,
      default: 0,
      choices: [
        { name: `Yes, download ${binName}`, value: true },
        { name: "No, quit program", value: false }
      ]
    });
    if (!choices.download) {
      process.exit(0);
    } else {
      (0, import_child_process.execSync)(`mkdir -p ${binDir}`);
      (0, import_child_process.execSync)(`pnpm moonwall download ${binName} latest ${binDir}`, {
        stdio: "inherit"
      });
    }
  } else if (!binPathExists) {
    console.log(
      `The binary: ${import_chalk.default.bgBlack.greenBright(
        binName
      )} is missing from: ${import_chalk.default.bgBlack.greenBright(import_node_path.default.join(process.cwd(), binDir))}`
    );
    console.log(
      `Given you are running ${import_chalk.default.bgBlack.yellowBright(
        process.arch
      )} architecture, you will need to build it manually from source \u{1F6E0}\uFE0F`
    );
    throw new Error("Executable binary not available");
  }
}
function checkListeningPorts(processId) {
  try {
    const stdOut = (0, import_child_process.execSync)(`lsof -p  ${processId} | grep LISTEN`, { encoding: "utf-8" });
    const binName = stdOut.split("\n")[0].split(" ")[0];
    const ports = stdOut.split("\n").filter(Boolean).map((line) => {
      const port = line.split(":")[1];
      return port.split(" ")[0];
    });
    const filtered = new Set(ports);
    return { binName, processId, ports: [...filtered].sort() };
  } catch (e) {
    console.log(e);
    const binName = (0, import_child_process.execSync)(`ps -p ${processId} -o comm=`).toString().trim();
    console.log(
      `Process ${processId} is running which for binary ${binName}, however it is unresponsive.`
    );
    console.log(
      "Running Moonwall with this in the background may cause unexpected behaviour. Please manually kill the process and try running Moonwall again."
    );
    console.log(`N.B. You can kill it with: sudo kill -9 ${processId}`);
    throw new Error(e);
  }
}
function checkAlreadyRunning(binaryName) {
  try {
    console.log(`Checking if ${import_chalk.default.bgWhiteBright.blackBright(binaryName)} is already running...`);
    const stdout = (0, import_child_process.execSync)(`pgrep ${[binaryName.slice(0, 14)]}`, {
      encoding: "utf8",
      timeout: 2e3
    });
    const pIdStrings = stdout.split("\n").filter(Boolean);
    return pIdStrings.map((pId) => parseInt(pId, 10));
  } catch (error) {
    if (error.status === 1) {
      return [];
    }
    throw error;
  }
}
async function promptAlreadyRunning(pids) {
  const choice = await import_inquirer.default.prompt({
    name: "AlreadyRunning",
    type: "list",
    message: `The following processes are already running: 
${pids.map((pid) => {
      const { binName, ports } = checkListeningPorts(pid);
      return `${binName} - pid: ${pid}, listenPorts: [${ports.join(", ")}]`;
    }).join("\n")}`,
    default: 1,
    choices: [
      { name: "\u{1FA93}  Kill processes and continue", value: "kill" },
      { name: "\u27A1\uFE0F   Continue (and let processes live)", value: "continue" },
      { name: "\u{1F6D1}  Abort (and let processes live)", value: "abort" }
    ]
  });
  switch (choice.AlreadyRunning) {
    case "kill":
      pids.forEach((pid) => {
        (0, import_child_process.execSync)(`kill ${pid}`);
      });
      break;
    case "continue":
      break;
    case "abort":
      throw new Error("Abort Signal Picked");
  }
}
function checkAccess(path8) {
  const binPath = path8.split(" ")[0];
  try {
    import_node_fs.default.accessSync(binPath, import_node_fs.default.constants.X_OK);
  } catch (err) {
    console.error(`The file ${binPath} is not executable`);
    throw new Error(`The file at ${binPath} , lacks execute permissions.`);
  }
}
async function getBinaryArchitecture(filePath) {
  return new Promise((resolve, reject) => {
    const architectureMap = {
      0: "unknown",
      3: "x86",
      62: "x64",
      183: "arm64"
    };
    import_node_fs.default.open(filePath, "r", (err, fd) => {
      if (err) {
        reject(err);
        return;
      }
      const buffer = Buffer.alloc(20);
      import_node_fs.default.read(fd, buffer, 0, 20, 0, (err2, bytesRead, buffer2) => {
        if (err2) {
          reject(err2);
          return;
        }
        const e_machine = buffer2.readUInt16LE(18);
        const architecture = architectureMap[e_machine] || "unknown";
        resolve(architecture);
      });
    });
  });
}

// src/internal/launcherCommon.ts
async function commonChecks(env) {
  const globalConfig = await importAsyncConfig();
  if (env.foundation.type == "dev") {
    await devBinCheck(env);
  }
  if (env.foundation.type == "zombie") {
    await zombieBinCheck(env);
  }
  if (process.env.MOON_RUN_SCRIPTS == "true" && globalConfig.scriptsDir && env.runScripts && env.runScripts.length > 0) {
    for (const scriptCommand of env.runScripts) {
      await executeScript(scriptCommand);
    }
  }
}
async function zombieBinCheck(env) {
  if (env.foundation.type !== "zombie") {
    throw new Error("This function is only for zombie environments");
  }
  const bins = parseZombieConfigForBins(env.foundation.zombieSpec.configPath);
  const pids = bins.flatMap((bin) => checkAlreadyRunning(bin));
  pids.length == 0 || process.env.CI || await promptAlreadyRunning(pids);
}
async function devBinCheck(env) {
  if (env.foundation.type !== "dev") {
    throw new Error("This function is only for dev environments");
  }
  const binName = import_path3.default.basename(env.foundation.launchSpec[0].binPath);
  const pids = checkAlreadyRunning(binName);
  pids.length == 0 || process.env.CI || await promptAlreadyRunning(pids);
  await downloadBinsIfMissing(env.foundation.launchSpec[0].binPath);
}
async function executeScript(scriptCommand, args) {
  const scriptsDir = (await importAsyncConfig()).scriptsDir;
  const files = await import_fs3.default.promises.readdir(scriptsDir);
  try {
    const script = scriptCommand.split(" ")[0];
    const ext = import_path3.default.extname(script);
    const scriptPath = import_path3.default.join(process.cwd(), scriptsDir, scriptCommand);
    if (!files.includes(script)) {
      throw new Error(`Script ${script} not found in ${scriptsDir}`);
    }
    console.log(`========== Executing script: ${import_chalk2.default.bgGrey.greenBright(script)} ==========`);
    switch (ext) {
      case ".js":
        (0, import_child_process2.execSync)("node " + scriptPath + ` ${args}`, { stdio: "inherit" });
        break;
      case ".ts":
        (0, import_child_process2.execSync)("pnpm tsx " + scriptPath + ` ${args}`, { stdio: "inherit" });
        break;
      case ".sh":
        (0, import_child_process2.execSync)(scriptPath + ` ${args}`, { stdio: "inherit" });
        break;
      default:
        console.log(`${ext} not supported, skipping ${script}`);
    }
  } catch (err) {
    console.error(`Error executing script: ${import_chalk2.default.bgGrey.redBright(err)}`);
  }
}

// src/lib/globalContext.ts
var import_api_augment3 = require("@moonbeam-network/api-augment");
var import_orchestrator = __toESM(require("@zombienet/orchestrator"), 1);
var import_debug3 = __toESM(require("debug"), 1);
var import_fs5 = __toESM(require("fs"), 1);
var import_net = __toESM(require("net"), 1);
var import_readline = __toESM(require("readline"), 1);
var import_promises2 = require("timers/promises");

// src/internal/commandParsers.ts
var import_chalk3 = __toESM(require("chalk"), 1);
var import_path4 = __toESM(require("path"), 1);

// src/lib/repoDefinitions/moonbeam.ts
var repo = {
  name: "moonbeam",
  binaries: [
    {
      name: "moonbeam",
      defaultArgs: [
        "--no-hardware-benchmarks",
        "--no-telemetry",
        "--reserved-only",
        "--rpc-cors=all",
        "--no-grandpa",
        "--sealing=manual",
        "--force-authoring",
        "--no-prometheus",
        "--alice",
        "--chain=moonbase-dev",
        "--tmp"
      ]
    },
    { name: "moonbase-runtime" },
    { name: "moonbeam-runtime" },
    { name: "moonriver-runtime" }
  ],
  ghAuthor: "moonbeam-foundation",
  ghRepo: "moonbeam"
};
var moonbeam_default = repo;

// src/lib/repoDefinitions/polkadot.ts
var repo2 = {
  name: "polkadot",
  binaries: [
    { name: "polkadot" },
    { name: "polkadot-prepare-worker" },
    { name: "polkadot-execute-worker" }
  ],
  ghAuthor: "paritytech",
  ghRepo: "polkadot-sdk"
};
var polkadot_default = repo2;

// src/lib/repoDefinitions/tanssi.ts
var repo3 = {
  name: "tanssi",
  binaries: [
    { name: "tanssi-node", defaultArgs: ["--dev", "--sealing=manual", "--no-hardware-benchmarks"] },
    { name: "container-chain-template-simple-node" },
    { name: "container-chain-template-frontier-node" }
  ],
  ghAuthor: "moondance-labs",
  ghRepo: "tanssi"
};
var tanssi_default = repo3;

// src/lib/repoDefinitions/index.ts
function standardRepos() {
  const defaultRepos = [moonbeam_default, polkadot_default, tanssi_default];
  return [...defaultRepos];
}

// src/internal/commandParsers.ts
function parseZombieCmd(launchSpec) {
  if (launchSpec) {
    return { cmd: launchSpec.configPath };
  } else {
    throw new Error(
      `No ZombieSpec found in config. 
 Are you sure your ${import_chalk3.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "configPath" in zombieSpec?`
    );
  }
}
function fetchDefaultArgs(binName, additionalRepos = []) {
  let defaultArgs;
  const repos = [...standardRepos(), ...additionalRepos];
  for (const repo4 of repos) {
    const foundBin = repo4.binaries.find((bin) => bin.name === binName);
    if (foundBin) {
      defaultArgs = foundBin.defaultArgs;
      break;
    }
  }
  if (!defaultArgs) {
    defaultArgs = ["--dev"];
  }
  return defaultArgs;
}
function parseRunCmd(launchSpec, additionalRepos) {
  const launch = !launchSpec.running ? true : launchSpec.running;
  const cmd = launchSpec.binPath;
  const args = launchSpec.options ? [...launchSpec.options] : fetchDefaultArgs(import_path4.default.basename(launchSpec.binPath), additionalRepos);
  if (launchSpec.ports) {
    const ports = launchSpec.ports;
    if (ports.p2pPort) {
      args.push(`--port=${ports.p2pPort}`);
    }
    if (ports.wsPort) {
      args.push(`--ws-port=${ports.wsPort}`);
    }
    if (ports.rpcPort) {
      args.push(`--rpc-port=${ports.rpcPort}`);
    }
  } else {
    if (launchSpec.newRpcBehaviour) {
      args.push(`--rpc-port=${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`);
    } else {
      args.push(`--ws-port=${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`);
    }
  }
  return { cmd, args, launch };
}
function parseChopsticksRunCmd(launchSpecs) {
  const launch = !launchSpecs[0].running ? true : launchSpecs[0].running;
  if (launchSpecs.length === 1) {
    const chopsticksCmd2 = "node";
    const chopsticksArgs2 = [
      "node_modules/@acala-network/chopsticks/chopsticks.cjs",
      `--config=${launchSpecs[0].configPath}`
    ];
    const mode = launchSpecs[0].buildBlockMode ? launchSpecs[0].buildBlockMode : "manual";
    const num = mode == "batch" ? 0 : mode == "instant" ? 1 : 2;
    chopsticksArgs2.push(`--build-block-mode=${num}`);
    if (launchSpecs[0].wsPort) {
      chopsticksArgs2.push(`--port=${launchSpecs[0].wsPort}`);
    }
    if (launchSpecs[0].wasmOverride) {
      chopsticksArgs2.push(`--wasm-override=${launchSpecs[0].wasmOverride}`);
    }
    if (launchSpecs[0].allowUnresolvedImports) {
      chopsticksArgs2.push("--allow-unresolved-imports");
    }
    return {
      cmd: chopsticksCmd2,
      args: chopsticksArgs2,
      launch
    };
  }
  const chopsticksCmd = "node";
  const chopsticksArgs = ["node_modules/@acala-network/chopsticks/chopsticks.cjs", "xcm"];
  launchSpecs.forEach((spec) => {
    const type = spec.type ? spec.type : "parachain";
    switch (type) {
      case "parachain":
        chopsticksArgs.push(`--parachain=${spec.configPath}`);
        break;
      case "relaychain":
        chopsticksArgs.push(`--relaychain=${spec.configPath}`);
    }
  });
  return {
    cmd: chopsticksCmd,
    args: chopsticksArgs,
    launch
  };
}

// src/internal/foundations/zombieHelpers.ts
var import_chalk4 = __toESM(require("chalk"), 1);
var import_node_fs2 = __toESM(require("fs"), 1);
async function checkZombieBins(config) {
  const relayBinPath = config.relaychain.default_command;
  await checkExists(relayBinPath);
  checkAccess(relayBinPath);
  const promises = config.parachains.map((para) => {
    if (para.collator) {
      if (!para.collator.command) {
        throw new Error(
          "No command found for collator, please check your zombienet config file for collator command"
        );
      }
      checkExists(para.collator.command);
      checkAccess(para.collator.command);
    }
    if (para.collators) {
      para.collators.forEach((coll) => {
        if (!coll.command) {
          throw new Error(
            "No command found for collators, please check your zombienet config file for para collators command"
          );
        }
        checkExists(coll.command);
        checkAccess(coll.command);
      });
    }
  });
  await Promise.all(promises);
}
function getZombieConfig(path8) {
  const fsResult = import_node_fs2.default.existsSync(path8);
  if (!fsResult) {
    throw new Error(
      `No ZombieConfig file found at location: ${path8} 
 Are you sure your ${import_chalk4.default.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "configPath" in zombieSpec?`
    );
  }
  const buffer = import_node_fs2.default.readFileSync(path8, "utf-8");
  return JSON.parse(buffer);
}

// src/internal/localNode.ts
var import_child_process3 = require("child_process");
var import_debug = __toESM(require("debug"), 1);
var import_fs4 = __toESM(require("fs"), 1);
var import_path5 = __toESM(require("path"), 1);
var import_ws = __toESM(require("ws"), 1);
var debugNode = (0, import_debug.default)("global:node");
async function launchNode(cmd, args, name) {
  if (cmd.includes("moonbeam")) {
    await checkExists(cmd);
    checkAccess(cmd);
  }
  const dirPath = import_path5.default.join(process.cwd(), "tmp", "node_logs");
  const onProcessExit = () => {
    runningNode && runningNode.kill();
  };
  const onProcessInterrupt = () => {
    runningNode && runningNode.kill();
  };
  process.once("exit", onProcessExit);
  process.once("SIGINT", onProcessInterrupt);
  const runningNode = (0, import_child_process3.spawn)(cmd, args);
  const logLocation = import_path5.default.join(
    dirPath,
    `${import_path5.default.basename(cmd)}_node_${args.find((a) => a.includes("port"))?.split("=")[1]}_${runningNode.pid}.log`
  ).replaceAll("node_node_undefined", "chopsticks");
  process.env.MOON_LOG_LOCATION = logLocation;
  const fsStream = import_fs4.default.createWriteStream(logLocation);
  runningNode.once("exit", () => {
    process.removeListener("exit", onProcessExit);
    process.removeListener("SIGINT", onProcessInterrupt);
    runningNode.stderr?.off("data", writeLogToFile);
    runningNode.stdout?.off("data", writeLogToFile);
    fsStream.end();
    debugNode(`Exiting dev node: ${name}`);
  });
  runningNode.on("error", (err) => {
    if (err.errno == "ENOENT") {
      console.error(
        `\x1B[31mMissing Local binary at(${cmd}).
Please compile the project\x1B[0m`
      );
    } else {
      console.error(err);
    }
    process.exit(1);
  });
  const writeLogToFile = (chunk) => {
    if (fsStream.writable) {
      fsStream.write(chunk, (err) => {
        if (err)
          console.error(err);
        else
          fsStream.emit("drain");
      });
    }
  };
  runningNode.stderr?.on("data", writeLogToFile);
  runningNode.stdout?.on("data", writeLogToFile);
  probe:
    for (; ; ) {
      try {
        const ports = await findPortsByPid(runningNode.pid);
        if (ports) {
          for (const port of ports) {
            try {
              await checkWebSocketJSONRPC(port);
              break probe;
            } catch {
              continue;
            }
          }
        }
      } catch {
        continue;
      }
    }
  return runningNode;
}
async function checkWebSocketJSONRPC(port) {
  return new Promise((resolve, reject) => {
    const ws = new import_ws.default(`ws://localhost:${port}`);
    ws.on("open", () => {
      ws.send(
        JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "system_chain",
          params: []
        })
      );
    });
    ws.on("message", (data) => {
      try {
        const response = JSON.parse(data.toString());
        if (response.jsonrpc === "2.0" && response.id === 1) {
          resolve(true);
        } else {
          reject(false);
        }
      } catch (e) {
        reject(false);
      }
      ws.close();
    });
    ws.on("error", () => {
      reject(false);
    });
  });
}
async function findPortsByPid(pid, retryCount = 600, retryDelay = 100) {
  for (let i = 0; i < retryCount; i++) {
    try {
      const stdout = (0, import_child_process3.execSync)(`lsof -i -n -P | grep LISTEN | grep ${pid}`).toString();
      const ports = [];
      const lines = stdout.split("\n");
      for (const line of lines) {
        const regex = /(?:\*|127\.0\.0\.1):(\d+)/;
        const match = line.match(regex);
        if (match) {
          ports.push(Number(match[1]));
        }
      }
      if (ports.length) {
        return ports;
      }
    } catch (error) {
      if (i === retryCount - 1) {
        throw error;
      }
    }
    await new Promise((resolve) => setTimeout(resolve, retryDelay));
  }
  return [];
}

// src/internal/providerFactories.ts
var import_api_augment2 = require("@moonbeam-network/api-augment");
var import_util = require("@moonwall/util");
var import_api = require("@polkadot/api");
var import_debug2 = __toESM(require("debug"), 1);
var import_ethers = require("ethers");
var import_viem = require("viem");
var import_accounts = require("viem/accounts");
var import_web3 = require("web3");
var import_web3_providers_ws = require("web3-providers-ws");
var debug = (0, import_debug2.default)("global:providers");
var ProviderFactory = class _ProviderFactory {
  constructor(providerConfig) {
    this.providerConfig = providerConfig;
    this.url = providerConfig.endpoints.includes("ENV_VAR") ? process.env.WSS_URL : providerConfig.endpoints[0];
    this.privateKey = process.env.MOON_PRIV_KEY || import_util.ALITH_PRIVATE_KEY;
  }
  url;
  privateKey;
  create() {
    switch (this.providerConfig.type) {
      case "polkadotJs":
        return this.createPolkadotJs();
      case "web3":
        return this.createWeb3();
      case "ethers":
        return this.createEthers();
      case "viem":
        return this.createViem();
      default:
        return this.createDefault();
    }
  }
  createPolkadotJs() {
    debug(`\u{1F7E2}  PolkadotJs provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: async () => {
        const options = {
          provider: new import_api.WsProvider(this.url),
          initWasm: false,
          noInitWarn: true,
          isPedantic: false,
          rpc: this.providerConfig.rpc ? this.providerConfig.rpc : void 0,
          typesBundle: this.providerConfig.additionalTypes ? this.providerConfig.additionalTypes : void 0
        };
        const api = await import_api.ApiPromise.create(options);
        await api.isReady;
        return api;
      },
      ws: () => new import_api.WsProvider(this.url)
    };
  }
  createWeb3() {
    debug(`\u{1F7E2}  Web3 provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: () => {
        const provider = new import_web3_providers_ws.WebSocketProvider(
          this.url,
          {},
          { delay: 50, autoReconnect: false, maxAttempts: 10 }
        );
        return new import_web3.Web3(provider);
      }
    };
  }
  createEthers() {
    debug(`\u{1F7E2}  Ethers provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: () => {
        const provider = new import_ethers.ethers.WebSocketProvider(this.url);
        return new import_ethers.Wallet(this.privateKey, provider);
      }
    };
  }
  createViem() {
    debug(`\u{1F7E2}  Viem omni provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: async () => (0, import_viem.createWalletClient)({
        chain: await (0, import_util.deriveViemChain)(this.url),
        account: (0, import_accounts.privateKeyToAccount)(this.privateKey),
        transport: (0, import_viem.http)(this.url.replace("ws", "http"))
      }).extend(import_viem.publicActions)
    };
  }
  createDefault() {
    debug(`\u{1F7E2}  Default provider ${this.providerConfig.name} details prepared`);
    return {
      name: this.providerConfig.name,
      type: this.providerConfig.type,
      connect: () => console.log(`\u{1F6A7}  provider ${this.providerConfig.name} not yet implemented`)
    };
  }
  static prepare(providerConfigs) {
    return providerConfigs.map((providerConfig) => new _ProviderFactory(providerConfig).create());
  }
  static prepareDefaultDev() {
    return this.prepare([
      {
        name: "dev",
        type: "polkadotJs",
        endpoints: [vitestAutoUrl]
      },
      {
        name: "w3",
        type: "web3",
        endpoints: [vitestAutoUrl]
      },
      {
        name: "eth",
        type: "ethers",
        endpoints: [vitestAutoUrl]
      },
      {
        name: "public",
        type: "viem",
        endpoints: [vitestAutoUrl]
      }
    ]);
  }
  static prepareDefaultZombie() {
    const MOON_PARA_WSS = process.env.MOON_PARA_WSS || "error";
    const MOON_RELAY_WSS = process.env.MOON_RELAY_WSS || "error";
    return this.prepare([
      {
        name: "w3",
        type: "web3",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "eth",
        type: "ethers",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "viem",
        type: "viem",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "parachain",
        type: "polkadotJs",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "relaychain",
        type: "polkadotJs",
        endpoints: [MOON_RELAY_WSS]
      }
    ]);
  }
  static prepareNoEthDefaultZombie() {
    const MOON_PARA_WSS = process.env.MOON_PARA_WSS || "error";
    const MOON_RELAY_WSS = process.env.MOON_RELAY_WSS || "error";
    return this.prepare([
      {
        name: "parachain",
        type: "polkadotJs",
        endpoints: [MOON_PARA_WSS]
      },
      {
        name: "relaychain",
        type: "polkadotJs",
        endpoints: [MOON_RELAY_WSS]
      }
    ]);
  }
};
var ProviderInterfaceFactory = class _ProviderInterfaceFactory {
  constructor(name, type, connect) {
    this.name = name;
    this.type = type;
    this.connect = connect;
  }
  async create() {
    switch (this.type) {
      case "polkadotJs":
        return this.createPolkadotJs();
      case "web3":
        return this.createWeb3();
      case "ethers":
        return this.createEthers();
      case "viem":
        return this.createViem();
      default:
        throw new Error("UNKNOWN TYPE");
    }
  }
  async createPolkadotJs() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: () => {
        debug(
          `\u{1F44B}  Provider ${this.name} is connected to chain ${api.consts.system.version.specName.toString()} RT${api.consts.system.version.specVersion.toNumber()}`
        );
        return {
          rtVersion: api.consts.system.version.specVersion.toNumber(),
          rtName: api.consts.system.version.specName.toString()
        };
      },
      disconnect: async () => api.disconnect()
    };
  }
  async createWeb3() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: async () => console.log(
        `\u{1F44B} Provider ${this.name} is connected to chain ` + await api.eth.getChainId()
      ),
      disconnect: async () => {
        api.currentProvider.disconnect();
      }
    };
  }
  async createEthers() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: async () => debug(
        `\u{1F44B}  Provider ${this.name} is connected to chain ` + (await api.provider.getNetwork()).chainId
      ),
      disconnect: () => api.provider.destroy()
    };
  }
  async createViem() {
    const api = await this.connect();
    return {
      name: this.name,
      api,
      type: this.type,
      greet: async () => console.log(`\u{1F44B} Provider ${this.name} is connected to chain ` + await api.getChainId()),
      disconnect: async () => {
      }
    };
  }
  static async populate(name, type, connect) {
    return await new _ProviderInterfaceFactory(name, type, connect).create();
  }
};
var vitestAutoUrl = `ws://127.0.0.1:${1e4 + Number(process.env.VITEST_POOL_ID || 1) * 100}`;

// src/lib/globalContext.ts
var import_node_child_process = require("child_process");
var import_child_process4 = require("child_process");
var debugSetup = (0, import_debug3.default)("global:context");
var MoonwallContext = class _MoonwallContext {
  static instance;
  environment;
  providers;
  nodes;
  foundation;
  zombieNetwork;
  rtUpgradePath;
  ipcServer;
  constructor(config) {
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    this.providers = [];
    this.nodes = [];
    this.foundation = env.foundation.type;
    const foundationHandlers = {
      read_only: this.handleReadOnly,
      chopsticks: this.handleChopsticks,
      dev: this.handleDev,
      zombie: this.handleZombie,
      fork: this.handleReadOnly
      // TODO: Implement fork
    };
    const foundationHandler = foundationHandlers[env.foundation.type];
    this.environment = { providers: [], nodes: [], ...foundationHandler.call(this, env, config) };
  }
  handleZombie(env) {
    if (env.foundation.type !== "zombie") {
      throw new Error(`Foundation type must be 'zombie'`);
    }
    const { cmd: zombieConfig } = parseZombieCmd(env.foundation.zombieSpec);
    this.rtUpgradePath = env.foundation.rtUpgradePath;
    return {
      name: env.name,
      foundationType: "zombie",
      nodes: [
        {
          name: env.foundation.zombieSpec.name,
          cmd: zombieConfig,
          args: [],
          launch: true
        }
      ]
    };
  }
  handleDev(env, config) {
    if (env.foundation.type !== "dev") {
      throw new Error(`Foundation type must be 'dev'`);
    }
    const { cmd, args, launch } = parseRunCmd(
      env.foundation.launchSpec[0],
      config.additionalRepos
    );
    return {
      name: env.name,
      foundationType: "dev",
      nodes: [
        {
          name: env.foundation.launchSpec[0].name,
          cmd,
          args,
          launch
        }
      ],
      providers: env.connections ? ProviderFactory.prepare(env.connections) : isEthereumDevConfig() ? ProviderFactory.prepareDefaultDev() : ProviderFactory.prepare([
        {
          name: "node",
          type: "polkadotJs",
          endpoints: [vitestAutoUrl]
        }
      ])
    };
  }
  handleReadOnly(env) {
    if (env.foundation.type !== "read_only") {
      throw new Error(`Foundation type must be 'read_only'`);
    }
    if (!env.connections) {
      throw new Error(
        `${env.name} env config is missing connections specification, required by foundation READ_ONLY`
      );
    }
    return {
      name: env.name,
      foundationType: "read_only",
      providers: ProviderFactory.prepare(env.connections)
    };
  }
  handleChopsticks(env) {
    if (env.foundation.type !== "chopsticks") {
      throw new Error(`Foundation type must be 'chopsticks'`);
    }
    this.rtUpgradePath = env.foundation.rtUpgradePath;
    return {
      name: env.name,
      foundationType: "chopsticks",
      nodes: [parseChopsticksRunCmd(env.foundation.launchSpec)],
      providers: [...ProviderFactory.prepare(env.connections)]
    };
  }
  async startZombieNetwork() {
    const config = await importAsyncConfig();
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    if (env.foundation.type !== "zombie") {
      throw new Error(`Foundation type must be 'zombie', something has gone very wrong.`);
    }
    console.log("\u{1F9DF} Spawning zombie nodes ...");
    const nodes = this.environment.nodes;
    const zombieConfig = getZombieConfig(nodes[0].cmd);
    await checkZombieBins(zombieConfig);
    const network = await import_orchestrator.default.start("", zombieConfig, { logType: "silent" });
    process.env.MOON_RELAY_WSS = network.relay[0].wsUri;
    process.env.MOON_PARA_WSS = Object.values(network.paras)[0].nodes[0].wsUri;
    const nodeNames = Object.keys(network.nodesByName);
    process.env.MOON_ZOMBIE_DIR = `${network.tmpDir}`;
    process.env.MOON_ZOMBIE_NODES = nodeNames.join("|");
    const onProcessExit = () => {
      try {
        const processIds = Object.values(this.zombieNetwork.client.processMap).filter((item) => item["pid"]).map((process2) => process2["pid"]);
        (0, import_node_child_process.exec)(`kill ${processIds.join(" ")}`, (error) => {
          if (error) {
            console.error(`Error killing process: ${error.message}`);
          }
        });
      } catch (err) {
      }
    };
    const socketPath = `${network.tmpDir}/node-ipc.sock`;
    const server = import_net.default.createServer((client) => {
      client.on("data", async (data) => {
        const writeToClient = (message) => {
          if (client.writable) {
            client.write(JSON.stringify(message));
          } else {
            console.log("Client disconnected, cannot send response.");
          }
        };
        try {
          const message = JSON.parse(data.toString());
          const zombieClient = network.client;
          switch (message.cmd) {
            case "networkmap": {
              const result = Object.keys(network.nodesByName);
              writeToClient({
                status: "success",
                result: network.nodesByName,
                message: result.join("|")
              });
              break;
            }
            case "restart": {
              await this.disconnect();
              await zombieClient.restartNode(message.nodeName, null);
              await (0, import_promises2.setTimeout)(1e3);
              await this.connectEnvironment(true);
              writeToClient({
                status: "success",
                result: true,
                message: `${message.nodeName} restarted`
              });
              break;
            }
            case "resume": {
              const node = network.getNodeByName(message.nodeName);
              await this.disconnect();
              const result = await node.resume();
              await zombieClient.wait_node_ready(message.nodeName);
              await this.connectEnvironment(true);
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} resumed with result ${result}`
              });
              break;
            }
            case "pause": {
              const node = network.getNodeByName(message.nodeName);
              await this.disconnect();
              const result = await node.pause();
              await (0, import_promises2.setTimeout)(1e3);
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} paused with result ${result}`
              });
              break;
            }
            case "kill": {
              const pid = network.client.processMap[message.nodeName].pid;
              delete network.client.processMap[message.nodeName];
              const result = (0, import_node_child_process.exec)(`kill ${pid}`, { timeout: 1e3 });
              writeToClient({
                status: "success",
                result: result.exitCode === 0,
                message: `${message.nodeName}, pid ${pid} killed with exitCode ${result.exitCode}`
              });
              break;
            }
            case "isup": {
              const node = network.getNodeByName(message.nodeName);
              const result = await node.isUp();
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} isUp result is ${result}`
              });
              break;
            }
            default:
              throw new Error(`Invalid command received: ${message.cmd}`);
          }
        } catch (e) {
          console.log("\u{1F4E8} Error processing message from client:", data.toString());
          console.error(e.message);
          writeToClient({ status: "failure", result: false, message: e.message });
        }
      });
    });
    server.listen(socketPath, () => {
      console.log("\u{1F4E8} IPC Server listening on", socketPath);
    });
    this.ipcServer = server;
    process.env.MOON_IPC_SOCKET = socketPath;
    process.once("exit", onProcessExit);
    process.once("SIGINT", onProcessExit);
    this.zombieNetwork = network;
    return;
  }
  async startNetwork() {
    if (process.env.MOON_RECYCLE == "true") {
      return _MoonwallContext.getContext();
    }
    if (this.nodes.length > 0) {
      return _MoonwallContext.getContext();
    }
    const nodes = _MoonwallContext.getContext().environment.nodes;
    if (this.environment.foundationType === "zombie") {
      return await this.startZombieNetwork();
    }
    const promises = nodes.map(async ({ cmd, args, name, launch }) => {
      if (launch) {
        const result = await launchNode(cmd, args, name);
        this.nodes.push(result);
      } else {
        return Promise.resolve();
      }
    });
    await Promise.allSettled(promises);
    return _MoonwallContext.getContext();
  }
  async connectEnvironment(silent = false) {
    const config = await importAsyncConfig();
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    if (this.environment.foundationType == "zombie") {
      this.environment.providers = env.connections ? ProviderFactory.prepare(env.connections) : isEthereumZombieConfig() ? ProviderFactory.prepareDefaultZombie() : ProviderFactory.prepareNoEthDefaultZombie();
    }
    if (this.providers.length > 0) {
      return _MoonwallContext.getContext();
    }
    const promises = this.environment.providers.map(
      async ({ name, type, connect }) => new Promise(async (resolve) => {
        this.providers.push(await ProviderInterfaceFactory.populate(name, type, connect));
        resolve("");
      })
    );
    await Promise.all(promises);
    if (this.foundation == "zombie") {
      let readStreams;
      if (!isOptionSet("disableLogEavesdropping")) {
        !silent && console.log(`\u{1F9BB} Eavesdropping on node logs at ${process.env.MOON_ZOMBIE_DIR}`);
        const zombieNodeLogs = process.env.MOON_ZOMBIE_NODES.split("|").map((nodeName) => `${process.env.MOON_ZOMBIE_DIR}/${nodeName}.log`);
        readStreams = zombieNodeLogs.map((logPath) => {
          const readStream = import_fs5.default.createReadStream(logPath, { encoding: "utf8" });
          const lineReader = import_readline.default.createInterface({
            input: readStream
          });
          lineReader.on("line", (line) => {
            if (line.includes("WARN") || line.includes("ERROR")) {
              console.log(line);
            }
          });
          return readStream;
        });
      }
      const promises2 = this.providers.filter(({ type }) => type == "polkadotJs").filter(
        ({ name }) => env.foundation.type == "zombie" && (!env.foundation.zombieSpec.skipBlockCheck || !env.foundation.zombieSpec.skipBlockCheck.includes(name))
      ).map(async (provider) => {
        return await new Promise(async (resolve) => {
          !silent && console.log(`\u23F2\uFE0F  Waiting for chain ${provider.name} to produce blocks...`);
          while ((await provider.api.rpc.chain.getBlock()).block.header.number.toNumber() == 0) {
            await (0, import_promises2.setTimeout)(500);
          }
          !silent && console.log(`\u2705 Chain ${provider.name} producing blocks, continuing`);
          resolve("");
        });
      });
      await Promise.all(promises2);
      if (!isOptionSet("disableLogEavesdropping")) {
        readStreams.forEach((readStream) => readStream.close());
      }
    }
    return _MoonwallContext.getContext();
  }
  async disconnect(providerName) {
    if (providerName) {
      this.providers.find(({ name }) => name === providerName).disconnect();
      this.providers.filter(({ name }) => name !== providerName);
    } else {
      await Promise.all(this.providers.map((prov) => prov.disconnect()));
      this.providers = [];
    }
  }
  static printStats() {
    if (_MoonwallContext) {
      console.dir(_MoonwallContext.getContext(), { depth: 1 });
    } else {
      console.log("Global context not created!");
    }
  }
  static getContext(config, force = false) {
    if (!_MoonwallContext.instance || force) {
      if (!config) {
        throw new Error("\u274C Config must be provided on Global Context instantiation");
      }
      _MoonwallContext.instance = new _MoonwallContext(config);
      debugSetup(`\u{1F7E2}  Moonwall context "${config.label}" created`);
    }
    return _MoonwallContext.instance;
  }
  static async destroy() {
    const ctx = this.instance;
    try {
      await ctx.disconnect();
    } catch {
      console.log("\u{1F6D1}  All connections disconnected");
    }
    while (ctx.nodes.length > 0) {
      const node = ctx.nodes.pop();
      const pid = node.pid;
      node.kill();
      for (; ; ) {
        const isRunning = await isPidRunning(pid);
        if (isRunning) {
          await (0, import_promises2.setTimeout)(10);
        } else {
          break;
        }
      }
    }
    if (ctx.zombieNetwork) {
      console.log("\u{1FA93}  Killing zombie nodes");
      await ctx.zombieNetwork.stop();
      const processIds = Object.values(ctx.zombieNetwork.client.processMap).filter((item) => item["pid"]).map((process2) => process2["pid"]);
      try {
        (0, import_child_process4.execSync)(`kill ${processIds.join(" ")}`, {});
      } catch (e) {
        console.log(e.message);
        console.log("continuing...");
      }
      await waitForPidsToDie(processIds);
      ctx.ipcServer?.close();
      ctx.ipcServer?.removeAllListeners();
    }
  }
};
var contextCreator = async () => {
  const config = await importAsyncConfig();
  const ctx = MoonwallContext.getContext(config);
  await runNetworkOnly();
  await ctx.connectEnvironment();
  return ctx;
};
var runNetworkOnly = async () => {
  const config = await importAsyncConfig();
  const ctx = MoonwallContext.getContext(config);
  await ctx.startNetwork();
};
async function isPidRunning(pid) {
  const output = (0, import_node_child_process.exec)(`ps -p ${pid} -o pid=`);
  return output.exitCode === 0;
}
async function waitForPidsToDie(pids) {
  const checkPids = async () => {
    const checks = pids.map(async (pid) => await isPidRunning(pid));
    const results = await Promise.all(checks);
    return results.every((running) => !running);
  };
  while (!await checkPids()) {
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
}

// src/cmds/runTests.ts
async function testCmd(envName, additionalArgs) {
  await cacheConfig();
  const globalConfig = await importAsyncConfig();
  const env = globalConfig.environments.find(({ name }) => name === envName);
  process.env.MOON_TEST_ENV = envName;
  if (!env) {
    const envList = globalConfig.environments.map((env2) => env2.name);
    new Error(
      `No environment found in config for: ${import_chalk5.default.bgWhiteBright.blackBright(
        envName
      )}
 Environments defined in config are: ${envList}
`
    );
  }
  loadEnvVars();
  await commonChecks(env);
  if (env.foundation.type == "dev" && !env.foundation.launchSpec[0].retainAllLogs || env.foundation.type == "chopsticks" && !env.foundation.launchSpec[0].retainAllLogs) {
    clearNodeLogs();
  }
  const vitest = await executeTests(env, additionalArgs);
  const failed = vitest.state.getFiles().filter((file) => file.result.state === "fail");
  if (failed.length === 0) {
    console.log("\u2705 All tests passed");
    return true;
  } else {
    console.log("\u274C Some tests failed");
    return false;
  }
}
async function executeTests(env, additionalArgs) {
  return new Promise(async (resolve, reject) => {
    const globalConfig = await importAsyncConfig();
    if (env.foundation.type === "read_only") {
      try {
        if (!process.env.MOON_TEST_ENV) {
          throw new Error("MOON_TEST_ENV not set");
        }
        const ctx = await contextCreator();
        const chainData = ctx.providers.filter((provider) => provider.type == "polkadotJs" && provider.name.includes("para")).map((provider) => {
          return {
            [provider.name]: {
              rtName: provider.greet().rtName,
              rtVersion: provider.greet().rtVersion
            }
          };
        });
        const { rtVersion, rtName } = Object.values(chainData[0])[0];
        process.env.MOON_RTVERSION = rtVersion;
        process.env.MOON_RTNAME = rtName;
        await MoonwallContext.destroy();
      } catch {
      }
    }
    const baseOptions = {
      watch: false,
      globals: true,
      reporters: env.reporters ? env.reporters : ["default"],
      outputFile: env.reportFile,
      testTimeout: env.timeout || globalConfig.defaultTestTimeout,
      hookTimeout: env.timeout || globalConfig.defaultTestTimeout,
      passWithNoTests: false,
      deps: {
        optimizer: { ssr: { enabled: false }, web: { enabled: false } }
      },
      include: env.include ? env.include : ["**/*{test,spec,test_,test-}*{ts,mts,cts}"],
      onConsoleLog(log) {
        if (filterList.includes(log.trim()))
          return false;
        if (log.includes("has multiple versions, ensure that there is only one installed.")) {
          return false;
        }
      }
    };
    const options = addThreadConfig(baseOptions, env.multiThreads);
    if (globalConfig.environments.find((env2) => env2.name === process.env.MOON_TEST_ENV)?.foundation.type == "zombie") {
      await runNetworkOnly();
      process.env.MOON_RECYCLE = "true";
    }
    try {
      const folders = env.testFileDir.map((folder) => import_path6.default.join(".", folder, "/"));
      resolve(await (0, import_node.startVitest)("test", folders, { ...options, ...additionalArgs }));
    } catch (e) {
      console.error(e);
      reject(e);
    }
  });
}
var filterList = ["<empty line>", "", "stdout | unknown test"];
function addThreadConfig(config, threads = false) {
  const configWithThreads = {
    ...config,
    pool: "threads",
    poolOptions: {
      threads: {
        isolate: true,
        minThreads: 1,
        maxThreads: 1,
        singleThread: false,
        useAtomics: false
      }
    }
  };
  if (threads == true && process.env.MOON_RECYCLE !== "true") {
    configWithThreads.poolOptions.threads = {
      isolate: true,
      minThreads: 1,
      maxThreads: 3,
      singleThread: false,
      useAtomics: false
    };
  }
  if (typeof threads === "number") {
    configWithThreads.poolOptions.threads.maxThreads = threads;
    configWithThreads.poolOptions.threads.singleThread = false;
  }
  if (typeof threads === "object") {
    const key = Object.keys(threads)[0];
    if (["threads", "forks", "vmThreads", "typescript"].includes(key)) {
      configWithThreads.pool = key;
      configWithThreads.poolOptions = Object.values(threads)[0];
    } else {
      throw new Error(`Invalid pool type: ${key}`);
    }
  }
  return configWithThreads;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  executeTests,
  testCmd
});
