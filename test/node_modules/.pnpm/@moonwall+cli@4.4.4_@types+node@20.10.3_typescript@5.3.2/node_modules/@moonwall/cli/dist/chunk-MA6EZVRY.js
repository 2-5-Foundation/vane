import {
  checkAccess,
  checkExists
} from "./chunk-K44KZJFV.js";

// src/internal/foundations/zombieHelpers.ts
import chalk from "chalk";
import fs from "node:fs";
import { setTimeout as timer } from "timers/promises";
import net from "net";
async function checkZombieBins(config) {
  const relayBinPath = config.relaychain.default_command;
  await checkExists(relayBinPath);
  checkAccess(relayBinPath);
  const promises = config.parachains.map((para) => {
    if (para.collator) {
      if (!para.collator.command) {
        throw new Error(
          "No command found for collator, please check your zombienet config file for collator command"
        );
      }
      checkExists(para.collator.command);
      checkAccess(para.collator.command);
    }
    if (para.collators) {
      para.collators.forEach((coll) => {
        if (!coll.command) {
          throw new Error(
            "No command found for collators, please check your zombienet config file for para collators command"
          );
        }
        checkExists(coll.command);
        checkAccess(coll.command);
      });
    }
  });
  await Promise.all(promises);
}
function getZombieConfig(path) {
  const fsResult = fs.existsSync(path);
  if (!fsResult) {
    throw new Error(
      `No ZombieConfig file found at location: ${path} 
 Are you sure your ${chalk.bgWhiteBright.blackBright(
        "moonwall.config.json"
      )} file has the correct "configPath" in zombieSpec?`
    );
  }
  const buffer = fs.readFileSync(path, "utf-8");
  return JSON.parse(buffer);
}
async function sendIpcMessage(message) {
  return new Promise(async (resolve, reject) => {
    let response;
    const ipcPath = process.env.MOON_IPC_SOCKET;
    const client = net.createConnection({ path: ipcPath });
    client.on("data", async (data) => {
      response = JSON.parse(data.toString());
      if (response.status === "success") {
        client.end();
        for (let i = 0; ; i++) {
          if (client.closed) {
            break;
          }
          if (i > 100) {
            reject(new Error(`Closing IPC connection failed`));
          }
          await timer(200);
        }
        resolve(response);
      }
      if (response.status === "failure") {
        reject(new Error(JSON.stringify(response)));
      }
    });
    for (let i = 0; ; i++) {
      if (!client.connecting) {
        break;
      }
      if (i > 100) {
        reject(new Error(`Connection to ${ipcPath} failed`));
      }
      await timer(200);
    }
    await new Promise((resolve2) => {
      client.write(JSON.stringify(message), () => resolve2("Sent!"));
    });
  });
}

export {
  checkZombieBins,
  getZombieConfig,
  sendIpcMessage
};
