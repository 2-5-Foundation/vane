import {
  checkZombieBins,
  getZombieConfig
} from "./chunk-MA6EZVRY.js";
import {
  launchNode
} from "./chunk-47TGWJ6Q.js";
import {
  ProviderFactory,
  ProviderInterfaceFactory,
  vitestAutoUrl
} from "./chunk-WE3KBB4L.js";
import {
  parseChopsticksRunCmd,
  parseRunCmd,
  parseZombieCmd
} from "./chunk-5FSDTNPM.js";
import {
  importAsyncConfig,
  isEthereumDevConfig,
  isEthereumZombieConfig,
  isOptionSet
} from "./chunk-3IRCD3RX.js";

// src/lib/globalContext.ts
import "@moonbeam-network/api-augment";
import zombie from "@zombienet/orchestrator";
import Debug from "debug";
import fs from "fs";
import net from "net";
import readline from "readline";
import { setTimeout as timer } from "timers/promises";
import { exec } from "node:child_process";
import { execSync } from "child_process";
var debugSetup = Debug("global:context");
var MoonwallContext = class _MoonwallContext {
  static instance;
  environment;
  providers;
  nodes;
  foundation;
  zombieNetwork;
  rtUpgradePath;
  ipcServer;
  constructor(config) {
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    this.providers = [];
    this.nodes = [];
    this.foundation = env.foundation.type;
    const foundationHandlers = {
      read_only: this.handleReadOnly,
      chopsticks: this.handleChopsticks,
      dev: this.handleDev,
      zombie: this.handleZombie,
      fork: this.handleReadOnly
      // TODO: Implement fork
    };
    const foundationHandler = foundationHandlers[env.foundation.type];
    this.environment = { providers: [], nodes: [], ...foundationHandler.call(this, env, config) };
  }
  handleZombie(env) {
    if (env.foundation.type !== "zombie") {
      throw new Error(`Foundation type must be 'zombie'`);
    }
    const { cmd: zombieConfig } = parseZombieCmd(env.foundation.zombieSpec);
    this.rtUpgradePath = env.foundation.rtUpgradePath;
    return {
      name: env.name,
      foundationType: "zombie",
      nodes: [
        {
          name: env.foundation.zombieSpec.name,
          cmd: zombieConfig,
          args: [],
          launch: true
        }
      ]
    };
  }
  handleDev(env, config) {
    if (env.foundation.type !== "dev") {
      throw new Error(`Foundation type must be 'dev'`);
    }
    const { cmd, args, launch } = parseRunCmd(
      env.foundation.launchSpec[0],
      config.additionalRepos
    );
    return {
      name: env.name,
      foundationType: "dev",
      nodes: [
        {
          name: env.foundation.launchSpec[0].name,
          cmd,
          args,
          launch
        }
      ],
      providers: env.connections ? ProviderFactory.prepare(env.connections) : isEthereumDevConfig() ? ProviderFactory.prepareDefaultDev() : ProviderFactory.prepare([
        {
          name: "node",
          type: "polkadotJs",
          endpoints: [vitestAutoUrl]
        }
      ])
    };
  }
  handleReadOnly(env) {
    if (env.foundation.type !== "read_only") {
      throw new Error(`Foundation type must be 'read_only'`);
    }
    if (!env.connections) {
      throw new Error(
        `${env.name} env config is missing connections specification, required by foundation READ_ONLY`
      );
    }
    return {
      name: env.name,
      foundationType: "read_only",
      providers: ProviderFactory.prepare(env.connections)
    };
  }
  handleChopsticks(env) {
    if (env.foundation.type !== "chopsticks") {
      throw new Error(`Foundation type must be 'chopsticks'`);
    }
    this.rtUpgradePath = env.foundation.rtUpgradePath;
    return {
      name: env.name,
      foundationType: "chopsticks",
      nodes: [parseChopsticksRunCmd(env.foundation.launchSpec)],
      providers: [...ProviderFactory.prepare(env.connections)]
    };
  }
  async startZombieNetwork() {
    const config = await importAsyncConfig();
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    if (env.foundation.type !== "zombie") {
      throw new Error(`Foundation type must be 'zombie', something has gone very wrong.`);
    }
    console.log("\u{1F9DF} Spawning zombie nodes ...");
    const nodes = this.environment.nodes;
    const zombieConfig = getZombieConfig(nodes[0].cmd);
    await checkZombieBins(zombieConfig);
    const network = await zombie.start("", zombieConfig, { logType: "silent" });
    process.env.MOON_RELAY_WSS = network.relay[0].wsUri;
    process.env.MOON_PARA_WSS = Object.values(network.paras)[0].nodes[0].wsUri;
    const nodeNames = Object.keys(network.nodesByName);
    process.env.MOON_ZOMBIE_DIR = `${network.tmpDir}`;
    process.env.MOON_ZOMBIE_NODES = nodeNames.join("|");
    const onProcessExit = () => {
      try {
        const processIds = Object.values(this.zombieNetwork.client.processMap).filter((item) => item["pid"]).map((process2) => process2["pid"]);
        exec(`kill ${processIds.join(" ")}`, (error) => {
          if (error) {
            console.error(`Error killing process: ${error.message}`);
          }
        });
      } catch (err) {
      }
    };
    const socketPath = `${network.tmpDir}/node-ipc.sock`;
    const server = net.createServer((client) => {
      client.on("data", async (data) => {
        const writeToClient = (message) => {
          if (client.writable) {
            client.write(JSON.stringify(message));
          } else {
            console.log("Client disconnected, cannot send response.");
          }
        };
        try {
          const message = JSON.parse(data.toString());
          const zombieClient = network.client;
          switch (message.cmd) {
            case "networkmap": {
              const result = Object.keys(network.nodesByName);
              writeToClient({
                status: "success",
                result: network.nodesByName,
                message: result.join("|")
              });
              break;
            }
            case "restart": {
              await this.disconnect();
              await zombieClient.restartNode(message.nodeName, null);
              await timer(1e3);
              await this.connectEnvironment(true);
              writeToClient({
                status: "success",
                result: true,
                message: `${message.nodeName} restarted`
              });
              break;
            }
            case "resume": {
              const node = network.getNodeByName(message.nodeName);
              await this.disconnect();
              const result = await node.resume();
              await zombieClient.wait_node_ready(message.nodeName);
              await this.connectEnvironment(true);
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} resumed with result ${result}`
              });
              break;
            }
            case "pause": {
              const node = network.getNodeByName(message.nodeName);
              await this.disconnect();
              const result = await node.pause();
              await timer(1e3);
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} paused with result ${result}`
              });
              break;
            }
            case "kill": {
              const pid = network.client.processMap[message.nodeName].pid;
              delete network.client.processMap[message.nodeName];
              const result = exec(`kill ${pid}`, { timeout: 1e3 });
              writeToClient({
                status: "success",
                result: result.exitCode === 0,
                message: `${message.nodeName}, pid ${pid} killed with exitCode ${result.exitCode}`
              });
              break;
            }
            case "isup": {
              const node = network.getNodeByName(message.nodeName);
              const result = await node.isUp();
              writeToClient({
                status: "success",
                result,
                message: `${message.nodeName} isUp result is ${result}`
              });
              break;
            }
            default:
              throw new Error(`Invalid command received: ${message.cmd}`);
          }
        } catch (e) {
          console.log("\u{1F4E8} Error processing message from client:", data.toString());
          console.error(e.message);
          writeToClient({ status: "failure", result: false, message: e.message });
        }
      });
    });
    server.listen(socketPath, () => {
      console.log("\u{1F4E8} IPC Server listening on", socketPath);
    });
    this.ipcServer = server;
    process.env.MOON_IPC_SOCKET = socketPath;
    process.once("exit", onProcessExit);
    process.once("SIGINT", onProcessExit);
    this.zombieNetwork = network;
    return;
  }
  async startNetwork() {
    if (process.env.MOON_RECYCLE == "true") {
      return _MoonwallContext.getContext();
    }
    if (this.nodes.length > 0) {
      return _MoonwallContext.getContext();
    }
    const nodes = _MoonwallContext.getContext().environment.nodes;
    if (this.environment.foundationType === "zombie") {
      return await this.startZombieNetwork();
    }
    const promises = nodes.map(async ({ cmd, args, name, launch }) => {
      if (launch) {
        const result = await launchNode(cmd, args, name);
        this.nodes.push(result);
      } else {
        return Promise.resolve();
      }
    });
    await Promise.allSettled(promises);
    return _MoonwallContext.getContext();
  }
  async connectEnvironment(silent = false) {
    const config = await importAsyncConfig();
    const env = config.environments.find(({ name }) => name == process.env.MOON_TEST_ENV);
    if (this.environment.foundationType == "zombie") {
      this.environment.providers = env.connections ? ProviderFactory.prepare(env.connections) : isEthereumZombieConfig() ? ProviderFactory.prepareDefaultZombie() : ProviderFactory.prepareNoEthDefaultZombie();
    }
    if (this.providers.length > 0) {
      return _MoonwallContext.getContext();
    }
    const promises = this.environment.providers.map(
      async ({ name, type, connect }) => new Promise(async (resolve) => {
        this.providers.push(await ProviderInterfaceFactory.populate(name, type, connect));
        resolve("");
      })
    );
    await Promise.all(promises);
    if (this.foundation == "zombie") {
      let readStreams;
      if (!isOptionSet("disableLogEavesdropping")) {
        !silent && console.log(`\u{1F9BB} Eavesdropping on node logs at ${process.env.MOON_ZOMBIE_DIR}`);
        const zombieNodeLogs = process.env.MOON_ZOMBIE_NODES.split("|").map((nodeName) => `${process.env.MOON_ZOMBIE_DIR}/${nodeName}.log`);
        readStreams = zombieNodeLogs.map((logPath) => {
          const readStream = fs.createReadStream(logPath, { encoding: "utf8" });
          const lineReader = readline.createInterface({
            input: readStream
          });
          lineReader.on("line", (line) => {
            if (line.includes("WARN") || line.includes("ERROR")) {
              console.log(line);
            }
          });
          return readStream;
        });
      }
      const promises2 = this.providers.filter(({ type }) => type == "polkadotJs").filter(
        ({ name }) => env.foundation.type == "zombie" && (!env.foundation.zombieSpec.skipBlockCheck || !env.foundation.zombieSpec.skipBlockCheck.includes(name))
      ).map(async (provider) => {
        return await new Promise(async (resolve) => {
          !silent && console.log(`\u23F2\uFE0F  Waiting for chain ${provider.name} to produce blocks...`);
          while ((await provider.api.rpc.chain.getBlock()).block.header.number.toNumber() == 0) {
            await timer(500);
          }
          !silent && console.log(`\u2705 Chain ${provider.name} producing blocks, continuing`);
          resolve("");
        });
      });
      await Promise.all(promises2);
      if (!isOptionSet("disableLogEavesdropping")) {
        readStreams.forEach((readStream) => readStream.close());
      }
    }
    return _MoonwallContext.getContext();
  }
  async disconnect(providerName) {
    if (providerName) {
      this.providers.find(({ name }) => name === providerName).disconnect();
      this.providers.filter(({ name }) => name !== providerName);
    } else {
      await Promise.all(this.providers.map((prov) => prov.disconnect()));
      this.providers = [];
    }
  }
  static printStats() {
    if (_MoonwallContext) {
      console.dir(_MoonwallContext.getContext(), { depth: 1 });
    } else {
      console.log("Global context not created!");
    }
  }
  static getContext(config, force = false) {
    if (!_MoonwallContext.instance || force) {
      if (!config) {
        throw new Error("\u274C Config must be provided on Global Context instantiation");
      }
      _MoonwallContext.instance = new _MoonwallContext(config);
      debugSetup(`\u{1F7E2}  Moonwall context "${config.label}" created`);
    }
    return _MoonwallContext.instance;
  }
  static async destroy() {
    const ctx = this.instance;
    try {
      await ctx.disconnect();
    } catch {
      console.log("\u{1F6D1}  All connections disconnected");
    }
    while (ctx.nodes.length > 0) {
      const node = ctx.nodes.pop();
      const pid = node.pid;
      node.kill();
      for (; ; ) {
        const isRunning = await isPidRunning(pid);
        if (isRunning) {
          await timer(10);
        } else {
          break;
        }
      }
    }
    if (ctx.zombieNetwork) {
      console.log("\u{1FA93}  Killing zombie nodes");
      await ctx.zombieNetwork.stop();
      const processIds = Object.values(ctx.zombieNetwork.client.processMap).filter((item) => item["pid"]).map((process2) => process2["pid"]);
      try {
        execSync(`kill ${processIds.join(" ")}`, {});
      } catch (e) {
        console.log(e.message);
        console.log("continuing...");
      }
      await waitForPidsToDie(processIds);
      ctx.ipcServer?.close();
      ctx.ipcServer?.removeAllListeners();
    }
  }
};
var contextCreator = async () => {
  const config = await importAsyncConfig();
  const ctx = MoonwallContext.getContext(config);
  await runNetworkOnly();
  await ctx.connectEnvironment();
  return ctx;
};
var runNetworkOnly = async () => {
  const config = await importAsyncConfig();
  const ctx = MoonwallContext.getContext(config);
  await ctx.startNetwork();
};
async function isPidRunning(pid) {
  const output = exec(`ps -p ${pid} -o pid=`);
  return output.exitCode === 0;
}
async function waitForPidsToDie(pids) {
  const checkPids = async () => {
    const checks = pids.map(async (pid) => await isPidRunning(pid));
    const results = await Promise.all(checks);
    return results.every((running) => !running);
  };
  while (!await checkPids()) {
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
}

export {
  MoonwallContext,
  contextCreator,
  runNetworkOnly
};
