import {
  createFolders,
  generateConfig
} from "./chunk-K2KVKH3X.js";
import {
  fetchArtifact,
  getVersions
} from "./chunk-OFLP6IXX.js";
import {
  runNetworkCmd
} from "./chunk-DWALI2JA.js";
import {
  testCmd
} from "./chunk-NJDJMSQ4.js";
import {
  allReposAsync
} from "./chunk-3ZFRI75O.js";
import {
  executeScript
} from "./chunk-WRSD6W42.js";
import {
  importAsyncConfig
} from "./chunk-3IRCD3RX.js";

// src/cmds/main.ts
import chalk from "chalk";
import clear from "clear";
import colors from "colors";
import inquirer from "inquirer";
import PressToContinuePrompt from "inquirer-press-to-continue";
import fetch from "node-fetch";
import { SemVer, lt } from "semver";

// package.json
var package_default = {
  name: "@moonwall/cli",
  type: "module",
  version: "4.4.4",
  description: "Testing framework for the Moon family of projects",
  author: "timbrinded",
  license: "ISC",
  homepage: "https://github.com/Moonsong-Labs/moonwall#readme",
  repository: {
    type: "git",
    url: "git+https://github.com/Moonsong-Labs/moonwall.git",
    directory: "packages/cli"
  },
  bugs: {
    url: "https://github.com/Moonsong-Labs/moonwall/issues"
  },
  keywords: [
    "moonwall",
    "moonbeam",
    "moondance",
    "polkadot",
    "kusama",
    "substrate"
  ],
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      require: "./dist/index.cjs",
      import: "./dist/index.js",
      bun: "./src/cmds/entrypoint.ts"
    }
  },
  module: "./dist/index.js",
  main: "./dist/index.cjs",
  types: "./dist/index.d.ts",
  bin: {
    moonwall: "./moonwall.mjs"
  },
  engines: {
    node: ">=20.0.0",
    pnpm: ">=7"
  },
  files: [
    "dist",
    "bin",
    "*.d.ts",
    "*.d.cts",
    "*.mjs",
    "*.cjs"
  ],
  scripts: {
    clean: "rm -rf dist && rm -rf node_modules",
    build: "pnpm exec rm -rf dist && tsup src --format cjs,esm  && pnpm generate-types",
    lint: "eslint ./src/**/*.ts",
    "lint:fix": "eslint './src/**/*.ts' --fix",
    fmt: "pnpm prettier --check --ignore-path ../../.prettierignore '**/*.(yml|js|ts|json)'",
    "fmt:fix": "pnpm prettier --write --ignore-path ../../.prettierignore '**/*.(yml|js|ts|json)'",
    "generate-types": "tsup src --format cjs,esm --dts ",
    watch: "tsup src --format cjs,esm --dts --watch",
    typecheck: "pnpm exec tsc --noEmit",
    prepublish: "pnpm run build && pnpm run generate-types"
  },
  dependencies: {
    "@acala-network/chopsticks": "0.9.3",
    "@moonbeam-network/api-augment": "0.2600.0",
    "@moonwall/types": "workspace:*",
    "@moonwall/util": "workspace:*",
    "@polkadot/api": "10.11.1",
    "@polkadot/api-augment": "10.11.1",
    "@polkadot/api-derive": "10.11.1",
    "@polkadot/keyring": "12.6.1",
    "@polkadot/types": "10.11.1",
    "@polkadot/types-codec": "10.11.1",
    "@polkadot/util": "12.6.1",
    "@polkadot/util-crypto": "12.6.1",
    "@vitest/ui": "1.0.1",
    "@zombienet/orchestrator": "0.0.68",
    "@zombienet/utils": "0.0.24",
    bottleneck: "2.19.5",
    chalk: "5.3.0",
    clear: "0.1.0",
    "cli-progress": "3.12.0",
    colors: "1.4.0",
    debug: "4.3.4",
    dotenv: "16.3.1",
    ethers: "6.8.0",
    inquirer: "9.2.12",
    "inquirer-press-to-continue": "1.2.0",
    "jsonc-parser": "3.2.0",
    minimatch: "9.0.3",
    "node-fetch": "3.3.2",
    semver: "7.5.4",
    viem: "1.18.0",
    vitest: "1.0.1",
    web3: "4.2.1",
    "web3-providers-ws": "4.0.7",
    ws: "8.14.2",
    yaml: "2.3.3",
    yargs: "17.7.2"
  },
  devDependencies: {
    "@types/cli-progress": "3.11.5",
    "@types/debug": "4.1.12",
    "@types/node": "20.10.3",
    "@types/yargs": "17.0.32",
    prettier: "2.8.8",
    tsup: "8.0.1",
    tsx: "4.6.2",
    typescript: "5.3.2"
  },
  publishConfig: {
    access: "public"
  }
};

// src/cmds/main.ts
import fs from "fs";
import path from "path";
inquirer.registerPrompt("press-to-continue", PressToContinuePrompt);
async function main() {
  for (; ; ) {
    let globalConfig;
    try {
      globalConfig = await importAsyncConfig();
    } catch (e) {
      console.log(e);
    }
    clear();
    await printIntro();
    if (await mainMenu(globalConfig)) {
      break;
    } else {
      continue;
    }
  }
  process.stdout.write(`Goodbye! \u{1F44B}
`);
}
async function mainMenu(config) {
  const configPresent = config !== void 0;
  const questionList = {
    name: "MenuChoice",
    type: "list",
    message: `Main Menu - Please select one of the following:`,
    default: 0,
    pageSize: 12,
    choices: !configPresent ? [
      {
        name: !configPresent ? "1) Initialise:                         Generate a new Moonwall Config File" : chalk.dim("1) Initialise:                       \u2705  CONFIG ALREADY GENERATED"),
        value: "init"
      },
      {
        name: "2) Artifact Downloader:                Fetch artifacts (x86) from GitHub repos",
        value: "download"
      },
      {
        name: `3) Quit Application`,
        value: "quit"
      }
    ] : [
      {
        name: `1) Execute Script:                     Run scripts placed in your config defined script directory`,
        value: "exec"
      },
      {
        name: `2) Network Launcher & Toolbox:         Launch network, access tools: tail logs, interactive tests etc`,
        value: "run"
      },
      {
        name: "3) Test Suite Execution:               Run automated tests, start network if needed",
        value: "test"
      },
      {
        name: "4) Artifact Downloader:                Fetch artifacts (x86) from GitHub repos",
        value: "download"
      },
      {
        name: `5) Quit Application`,
        value: "quit"
      }
    ],
    filter(val) {
      return val;
    }
  };
  const answers = await inquirer.prompt(questionList);
  switch (answers.MenuChoice) {
    case "init":
      await generateConfig();
      await createFolders();
      return false;
    case "run": {
      const chosenRunEnv = await chooseRunEnv(config);
      process.env.MOON_RUN_SCRIPTS = "true";
      if (chosenRunEnv.envName !== "back") {
        await runNetworkCmd(chosenRunEnv);
      }
      return false;
    }
    case "test": {
      const chosenTestEnv = await chooseTestEnv(config);
      if (chosenTestEnv.envName !== "back") {
        process.env.MOON_RUN_SCRIPTS = "true";
        await testCmd(chosenTestEnv.envName);
        await inquirer.prompt({
          name: "test complete",
          type: "press-to-continue",
          anyKey: true,
          pressToContinueMessage: `\u2139\uFE0F  Test run for ${chalk.bgWhiteBright.black(
            chosenTestEnv.envName
          )} has been completed. Press any key to continue...
`
        });
      }
      return false;
    }
    case "download":
      await resolveDownloadChoice();
      return false;
    case "quit":
      return await resolveQuitChoice();
    case "exec":
      return await resolveExecChoice(config);
    default:
      throw new Error("Invalid choice");
  }
}
async function resolveExecChoice(config) {
  const scriptDir = config.scriptsDir;
  if (!scriptDir) {
    await inquirer.prompt({
      name: "test complete",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `\u2139\uFE0F  No scriptDir property defined at ${chalk.bgWhiteBright.black(
        "moonwall.config.json"
      )}
 Press any key to continue...
`
    });
    return false;
  }
  if (!fs.existsSync(scriptDir)) {
    await inquirer.prompt({
      name: "test complete",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `\u2139\uFE0F  No scriptDir found at at ${chalk.bgWhiteBright.black(
        path.join(process.cwd(), scriptDir)
      )}
 Press any key to continue...
`
    });
    return false;
  }
  const files = await fs.promises.readdir(scriptDir);
  if (!files) {
    await inquirer.prompt({
      name: "test complete",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `\u2139\uFE0F  No scripts found at ${chalk.bgWhiteBright.black(
        path.join(process.cwd(), config.scriptsDir)
      )}
 Press any key to continue...
`
    });
  }
  const choices = files.map((file) => {
    const ext = getExtString(file);
    return { name: `${ext}:    ${path.basename(file, "")}`, value: file };
  });
  for (; ; ) {
    const result = await inquirer.prompt({
      name: "selections",
      message: "Select which scripts you'd like to run (press \u21A9\uFE0F with none selected to go \u{1F519})\n",
      type: "checkbox",
      choices
    });
    if (result.selections.length === 0) {
      const result2 = await inquirer.prompt({
        name: "none-selected",
        message: "No scripts have been selected to run, do you wish to exit?",
        type: "confirm",
        default: true
      });
      if (result2["none-selected"]) {
        return false;
      } else {
        continue;
      }
    }
    for (const script of result.selections) {
      const result2 = await inquirer.prompt({
        name: "args",
        message: `Enter any arguments for ${chalk.bgWhiteBright.black(
          script
        )} (press enter for none)`,
        type: "input"
      });
      await executeScript(script, result2.args);
    }
    await inquirer.prompt({
      name: "test complete",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `Press any key to continue...
`
    });
    return false;
  }
}
async function resolveDownloadChoice() {
  const binList = (await allReposAsync()).reduce((acc, curr) => {
    acc.push(...curr.binaries.map((bin) => bin.name).flat());
    acc.push(new inquirer.Separator());
    acc.push("Back");
    acc.push(new inquirer.Separator());
    return acc;
  }, []);
  for (; ; ) {
    const firstChoice = await inquirer.prompt({
      name: "artifact",
      type: "list",
      message: `Download - which artifact?`,
      choices: binList
    });
    if (firstChoice.artifact === "Back") {
      return;
    }
    const versions = await getVersions(
      firstChoice.artifact,
      firstChoice.artifact.includes("runtime")
    );
    const chooseversion = await inquirer.prompt({
      name: "binVersion",
      type: "list",
      default: "latest",
      message: `Download - which version?`,
      choices: [...versions, new inquirer.Separator(), "Back", new inquirer.Separator()]
    });
    if (chooseversion.binVersion === "Back") {
      continue;
    }
    const chooseLocation = await inquirer.prompt({
      name: "path",
      type: "input",
      message: `Download - where would you like it placed?`,
      default: "./tmp"
    });
    const result = await inquirer.prompt({
      name: "continue",
      type: "confirm",
      message: `You are about to download ${chalk.bgWhite.blackBright(
        firstChoice.artifact
      )} v-${chalk.bgWhite.blackBright(chooseversion.binVersion)} to: ${chalk.bgWhite.blackBright(
        chooseLocation.path
      )}.
 Would you like to continue? `,
      default: true
    });
    if (result.continue === false) {
      continue;
    }
    await fetchArtifact({
      bin: firstChoice.artifact,
      ver: chooseversion.binVersion,
      path: chooseLocation.path
    });
    await inquirer.prompt({
      name: "NetworkStarted",
      type: "press-to-continue",
      anyKey: true,
      pressToContinueMessage: `\u2705 Artifact has been downloaded. Press any key to continue...
`
    });
    return;
  }
}
var chooseTestEnv = async (config) => {
  const envs = config.environments.map((a) => ({
    name: `[${a.foundation.type}] ${a.name}${a.description ? ": 		" + a.description : ""}`,
    value: a.name,
    disabled: false
  })).sort((a, b) => a.name > b.name ? -1 : 1);
  envs.push(
    ...[
      new inquirer.Separator(),
      { name: "Back", value: "back" },
      new inquirer.Separator()
    ]
  );
  const result = await inquirer.prompt({
    name: "envName",
    message: "Select a environment to run",
    type: "list",
    pageSize: 12,
    choices: envs
  });
  return result;
};
var chooseRunEnv = async (config) => {
  const envs = config.environments.map((a) => {
    const result2 = { name: "", value: a.name, disabled: false };
    if (a.foundation.type === "dev" || a.foundation.type === "chopsticks" || a.foundation.type === "zombie") {
      result2.name = `[${a.foundation.type}] ${a.name}${a.description ? ": 		" + a.description : ""}`;
    } else {
      result2.name = chalk.dim(`[${a.foundation.type}] ${a.name}     NO NETWORK TO RUN`);
      result2.disabled = true;
    }
    return result2;
  });
  const choices = [
    ...envs.filter(({ disabled }) => disabled === false).sort((a, b) => a.name > b.name ? 1 : -1),
    new inquirer.Separator(),
    ...envs.filter(({ disabled }) => disabled === true).sort((a, b) => a.name > b.name ? 1 : -1),
    new inquirer.Separator(),
    { name: "Back", value: "back" },
    new inquirer.Separator()
  ];
  const result = await inquirer.prompt({
    name: "envName",
    message: "Select a environment to run",
    type: "list",
    pageSize: 12,
    choices
  });
  return result;
};
var resolveQuitChoice = async () => {
  const result = await inquirer.prompt({
    name: "Quit",
    type: "confirm",
    message: "Are you sure you want to Quit?",
    default: false
  });
  return result.Quit;
};
var printIntro = async () => {
  const currentVersion = new SemVer(package_default.version);
  let remoteVersion = "";
  try {
    const url = "https://api.github.com/repos/moonsong-labs/moonwall/releases";
    const resp = await fetch(url);
    const json = await resp.json();
    remoteVersion = json.find((a) => a.tag_name.includes("@moonwall/cli@")).tag_name.split("@")[2];
  } catch (error) {
    remoteVersion = "unknown";
    console.error(`Fetch Error: ${error}`);
  }
  const logo = chalk.cyan(`
                                                                                                                  
                                      ####################                      
                                  ############################                  
                               ###################################              
                            ########################################            
                           ###########################################          
                         ##############################################         
                        ################################################        
                       .#################################################       
                       ##################################################       
                       ##################################################       
`) + chalk.red(`                                                                                
\u{1F9F1}\u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
              \u{1F9F1}\u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
      \u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
        \u{1F9F1}\u{1F9F1}   \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}    \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
                                       \u{1F9F1}\u{1F9F1}\u{1F9F1}  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}
                      \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}  \u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}\u{1F9F1}      
                                                                                                                                                              

`);
  process.stdout.write(logo);
  process.stdout.write(
    colors.rainbow(
      "================================================================================\n"
    )
  );
  if (remoteVersion !== "unknown" && lt(currentVersion, new SemVer(remoteVersion))) {
    process.stdout.write(
      chalk.bgCyan.white(
        `                 MOONWALL   V${currentVersion.version}   (New version ${remoteVersion} available!)             
`
      )
    );
  } else {
    process.stdout.write(
      chalk.bgCyan.white(
        `                                MOONWALL  V${currentVersion.version}                                
`
      )
    );
  }
  process.stdout.write(
    colors.rainbow(
      "================================================================================\n"
    )
  );
};
var getExtString = (file) => {
  const ext = path.extname(file);
  switch (ext) {
    case ".js":
      return chalk.bgYellow.black(ext);
    case ".ts":
      return chalk.bgBlue.black(ext);
    case ".sh":
      return chalk.bgGreen.black(ext);
    default:
      return chalk.bgRed.black(ext);
  }
};

export {
  main
};
