var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/internal/cmdFunctions/initialisation.ts
var initialisation_exports = {};
__export(initialisation_exports, {
  createConfig: () => createConfig,
  createFolders: () => createFolders,
  generateConfig: () => generateConfig
});
module.exports = __toCommonJS(initialisation_exports);
var import_promises = __toESM(require("fs/promises"), 1);
var import_inquirer = __toESM(require("inquirer"), 1);
var import_inquirer_press_to_continue = __toESM(require("inquirer-press-to-continue"), 1);
import_inquirer.default.registerPrompt("press-to-continue", import_inquirer_press_to_continue.default);
async function createFolders() {
  await import_promises.default.mkdir("scripts").catch(() => "scripts folder already exists, skipping");
  await import_promises.default.mkdir("tests").catch(() => "tests folder already exists, skipping");
  await import_promises.default.mkdir("tmp").catch(() => "tmp folder already exists, skipping");
}
async function generateConfig() {
  for (; ; ) {
    if (await import_promises.default.access("moonwall.config.json").catch(() => true)) {
      const answers = await import_inquirer.default.prompt(generateQuestions);
      const proceed = await import_inquirer.default.prompt(questions.find(({ name }) => name === "Confirm"));
      if (proceed.Confirm === false) {
        continue;
      }
      const JSONBlob = JSON.stringify(
        createConfig({
          label: answers.Label,
          timeout: answers.Timeout,
          environmentName: answers.EnvironmentName,
          foundation: answers.EnvironmentFoundation,
          testDir: answers.EnvironmentTestDir
        }),
        null,
        3
      );
      await import_promises.default.writeFile("moonwall.config", textBlob + JSONBlob, "utf-8");
      process.env.MOON_CONFIG_PATH = "./moonwall.config";
      break;
    } else {
      console.log("\u2139\uFE0F  Config file already exists at this location. Quitting.");
      return;
    }
  }
  console.log(`Goodbye! \u{1F44B}`);
}
var generateQuestions = [
  {
    name: "Label",
    type: "input",
    message: "Provide a label for the config file",
    default: "moonwall_config"
  },
  {
    name: "Timeout",
    type: "number",
    message: "Provide a global timeout value",
    default: 3e4,
    validate: (input) => {
      const pass = /^\d+$/.test(input);
      if (pass) {
        return true;
      }
      return "Please enter a valid number \u274C";
    }
  },
  {
    name: "EnvironmentName",
    type: "input",
    message: "Provide a name for this environment",
    default: "default_env"
  },
  {
    name: "EnvironmentTestDir",
    type: "input",
    message: "Provide the path for where tests for this environment are kept",
    default: "tests/"
  },
  {
    name: "EnvironmentFoundation",
    type: "list",
    message: "What type of network foundation is this?",
    choices: ["dev", "chopsticks", "read_only", "fork", "zombie"],
    default: "tests/"
  }
];
var questions = [
  {
    name: "Confirm",
    type: "confirm",
    message: "Would you like to generate this config? (no to restart from beginning)"
  },
  {
    name: "Success",
    type: "press-to-continue",
    anyKey: true,
    pressToContinueMessage: "\u{1F4C4} moonwall.config.ts has been generated. Press any key to exit  \u2705\n"
  },
  {
    name: "Failure",
    type: "press-to-continue",
    anyKey: true,
    pressToContinueMessage: "Config has not been generated due to errors, Press any key to exit  \u274C\n"
  }
];
function createConfig(options) {
  return {
    label: options.label,
    defaultTestTimeout: options.timeout,
    environments: [
      {
        name: options.environmentName,
        testFileDir: [options.testDir],
        foundation: {
          type: options.foundation
        }
      }
    ]
  };
}
var textBlob = `// This Moonwall Config file should be modified to include all types
// of environments you wish to test against.

// For more information on how to configure Moonwall, please visit:
// https://moonsong-labs.github.io/moonwall/config/intro.html
`;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createConfig,
  createFolders,
  generateConfig
});
