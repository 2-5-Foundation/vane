import { prefixedChildKey, splitChildKey, stripChildPrefix } from './utils/index.js';
/**
 * API class. Calls provider to get on-chain data.
 * Either `endpoint` or `genesis` porvider must be provided.
 *
 * @example Instantiate an API
 *
 * ```ts
 * const provider = new WsProvider(options.endpoint)
 * const api = new Api(provider)
 * await api.isReady
 * ```
 */ export class Api {
    #provider;
    #ready;
    #chain;
    #chainProperties;
    signedExtensions;
    constructor(provider, signedExtensions){
        this.#provider = provider;
        this.signedExtensions = signedExtensions || {};
    }
    async disconnect() {
        return this.#provider.disconnect();
    }
    get isReady() {
        if (!this.#ready) {
            if (this.#provider['isReady']) {
                this.#ready = this.#provider['isReady'];
            } else {
                this.#ready = new Promise((resolve)=>{
                    if (this.#provider.hasSubscriptions) {
                        this.#provider.on('connected', resolve);
                        this.#provider.connect();
                    } else {
                        resolve();
                    }
                });
            }
        }
        return this.#ready;
    }
    get chain() {
        if (!this.#chain) {
            this.#chain = this.getSystemChain();
        }
        return this.#chain;
    }
    get chainProperties() {
        if (!this.#chainProperties) {
            this.#chainProperties = this.getSystemProperties();
        }
        return this.#chainProperties;
    }
    async getSystemName() {
        return this.#provider.send('system_name', []);
    }
    async getSystemProperties() {
        return this.#provider.send('system_properties', []);
    }
    async getSystemChain() {
        return this.#provider.send('system_chain', []);
    }
    async getBlockHash(blockNumber) {
        return this.#provider.send('chain_getBlockHash', Number.isInteger(blockNumber) ? [
            blockNumber
        ] : [], !!blockNumber);
    }
    async getHeader(hash) {
        return this.#provider.send('chain_getHeader', hash ? [
            hash
        ] : [], !!hash);
    }
    async getBlock(hash) {
        return this.#provider.send('chain_getBlock', hash ? [
            hash
        ] : [], !!hash);
    }
    async getStorage(key, hash) {
        const [child, storageKey] = splitChildKey(key);
        if (child) {
            // child storage key, use childstate_getStorage
            const params = [
                child,
                storageKey
            ];
            if (hash) params.push(hash);
            return this.#provider.send('childstate_getStorage', params, !!hash);
        } else {
            // main storage key, use state_getStorage
            const params = [
                key
            ];
            if (hash) params.push(hash);
            return this.#provider.send('state_getStorage', params, !!hash);
        }
    }
    async getKeysPaged(prefix, pageSize, startKey, hash) {
        const [child, storageKey] = splitChildKey(prefix);
        if (child) {
            // child storage key, use childstate_getKeysPaged
            // strip child prefix from startKey
            const params = [
                child,
                storageKey,
                pageSize,
                stripChildPrefix(startKey)
            ];
            if (hash) params.push(hash);
            return this.#provider.send('childstate_getKeysPaged', params, !!hash).then((keys)=>keys.map((key)=>prefixedChildKey(child, key)));
        } else {
            // main storage key, use state_getKeysPaged
            const params = [
                prefix,
                pageSize,
                startKey
            ];
            if (hash) params.push(hash);
            return this.#provider.send('state_getKeysPaged', params, !!hash);
        }
    }
    async subscribeRemoteNewHeads(cb) {
        if (!this.#provider.hasSubscriptions) {
            throw new Error('subscribeRemoteNewHeads only works with subscriptions');
        }
        return this.#provider.subscribe('chain_newHead', 'chain_subscribeNewHeads', [], cb);
    }
    async subscribeRemoteFinalizedHeads(cb) {
        if (!this.#provider.hasSubscriptions) {
            throw new Error('subscribeRemoteFinalizedHeads only works with subscriptions');
        }
        return this.#provider.subscribe('chain_finalizedHead', 'chain_subscribeFinalizedHeads', [], cb);
    }
}
