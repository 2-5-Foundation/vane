"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getCurrentSlot: function() {
        return getCurrentSlot;
    },
    getCurrentTimestamp: function() {
        return getCurrentTimestamp;
    },
    getSlotDuration: function() {
        return getSlotDuration;
    },
    timeTravel: function() {
        return timeTravel;
    }
});
const _util = require("@polkadot/util");
const _index = require("./index.js");
const _index1 = require("../wasm-executor/index.js");
const _setstorage = require("./set-storage.js");
const getCurrentSlot = async (chain)=>{
    const meta = await chain.head.meta;
    // use raw key here because some chain did not expose those storage to metadata
    const slotRaw = meta.consts.babe ? await chain.head.get('0x1cb6f36e027abb2091cfb5110ab5087f06155b3cd9a8c9e5e9a23fd5dc13a5ed') // babe.currentSlot
     : await chain.head.get('0x57f8dc2f5ab09467896f47300f04243806155b3cd9a8c9e5e9a23fd5dc13a5ed') // aura.currentSlot
    ;
    if (!slotRaw) throw new Error('Cannot find current slot');
    return meta.registry.createType('Slot', (0, _util.hexToU8a)(slotRaw)).toNumber();
};
const getCurrentTimestamp = async (chain)=>{
    const meta = await chain.head.meta;
    const timestamp = await chain.head.read('u64', meta.query.timestamp.now);
    return timestamp?.toBigInt() ?? 0n;
};
const getSlotDuration = async (chain)=>{
    const meta = await chain.head.meta;
    return meta.consts.babe ? meta.consts.babe.expectedBlockTime.toNumber() : meta.query.aura ? (0, _index1.getAuraSlotDuration)(await chain.head.wasm) : 12_000;
};
const timeTravel = async (chain, timestamp)=>{
    const meta = await chain.head.meta;
    const slotDuration = await getSlotDuration(chain);
    const newSlot = Math.floor(timestamp / slotDuration);
    // new timestamp
    const storage = [
        [
            (0, _index.compactHex)(meta.query.timestamp.now()),
            (0, _util.u8aToHex)(meta.registry.createType('u64', timestamp).toU8a())
        ]
    ];
    if (meta.consts.babe) {
        // new slot
        storage.push([
            (0, _index.compactHex)(meta.query.babe.currentSlot()),
            (0, _util.u8aToHex)(meta.registry.createType('Slot', newSlot).toU8a())
        ]);
        // new epoch
        const epochDuration = meta.consts.babe.epochDuration.toNumber();
        const newEpoch = Math.floor(timestamp / epochDuration);
        storage.push([
            (0, _index.compactHex)(meta.query.babe.epochIndex()),
            (0, _util.u8aToHex)(meta.registry.createType('u64', newEpoch).toU8a())
        ]);
    } else if (meta.query.aura) {
        // new slot
        storage.push([
            (0, _index.compactHex)(meta.query.aura.currentSlot()),
            (0, _util.u8aToHex)(meta.registry.createType('Slot', newSlot).toU8a())
        ]);
    }
    await (0, _setstorage.setStorage)(chain, storage);
};
