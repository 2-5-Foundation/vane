import { EventEmitter } from 'eventemitter3';
import _ from 'lodash';
import { defer } from '../utils/index.js';
import { buildBlock } from './block-builder.js';
import { defaultLogger, truncate } from '../logger.js';
const logger = defaultLogger.child({
    name: 'txpool'
});
export const APPLY_EXTRINSIC_ERROR = 'TxPool::ApplyExtrinsicError';
export var BuildBlockMode;
(function(BuildBlockMode) {
    /** One block per batch (default) */ BuildBlockMode[BuildBlockMode["Batch"] = 0] = "Batch";
    /** One block per tx */ BuildBlockMode[BuildBlockMode["Instant"] = 1] = "Instant";
    /** Only build when triggered */ BuildBlockMode[BuildBlockMode["Manual"] = 2] = "Manual";
})(BuildBlockMode || (BuildBlockMode = {}));
export class TxPool {
    #chain;
    #pool = [];
    #ump = {};
    #dmp = [];
    #hrmp = {};
    #mode;
    #inherentProvider;
    #pendingBlocks = [];
    event = new EventEmitter();
    #isBuilding = false;
    constructor(chain, inherentProvider, mode = 0){
        this.#chain = chain;
        this.#mode = mode;
        this.#inherentProvider = inherentProvider;
    }
    get pendingExtrinsics() {
        return this.#pool.map(({ extrinsic })=>extrinsic);
    }
    get ump() {
        return this.#ump;
    }
    get dmp() {
        return this.#dmp;
    }
    get hrmp() {
        return this.#hrmp;
    }
    get mode() {
        return this.#mode;
    }
    set mode(mode) {
        this.#mode = mode;
    }
    clear() {
        this.#pool.length = 0;
        for (const id of Object.keys(this.#ump)){
            delete this.#ump[id];
        }
        this.#dmp.length = 0;
        for (const id of Object.keys(this.#hrmp)){
            delete this.#hrmp[id];
        }
    }
    pendingExtrinsicsBy(address) {
        return this.#pool.filter(({ signer })=>signer === address).map(({ extrinsic })=>extrinsic);
    }
    async submitExtrinsic(extrinsic) {
        logger.debug({
            extrinsic: truncate(extrinsic)
        }, 'submit extrinsic');
        this.#pool.push({
            extrinsic,
            signer: await this.#getSigner(extrinsic)
        });
        this.#maybeBuildBlock();
    }
    async #getSigner(extrinsic) {
        const registry = await this.#chain.head.registry;
        const tx = registry.createType('GenericExtrinsic', extrinsic);
        return tx.signer.toString();
    }
    submitUpwardMessages(id, ump) {
        logger.debug({
            id,
            ump: truncate(ump)
        }, 'submit upward messages');
        if (!this.#ump[id]) {
            this.#ump[id] = [];
        }
        this.#ump[id].push(...ump);
        this.#maybeBuildBlock();
    }
    submitDownwardMessages(dmp) {
        logger.debug({
            dmp: truncate(dmp)
        }, 'submit downward messages');
        this.#dmp.push(...dmp);
        this.#maybeBuildBlock();
    }
    submitHorizontalMessages(id, hrmp) {
        logger.debug({
            id,
            hrmp: truncate(hrmp)
        }, 'submit horizontal messages');
        if (!this.#hrmp[id]) {
            this.#hrmp[id] = [];
        }
        this.#hrmp[id].push(...hrmp);
        this.#maybeBuildBlock();
    }
    #maybeBuildBlock() {
        switch(this.#mode){
            case 0:
                this.#batchBuildBlock();
                break;
            case 1:
                this.buildBlock();
                break;
            case 2:
                break;
        }
    }
    #batchBuildBlock = _.debounce(this.buildBlock, 100, {
        maxWait: 1000
    });
    async buildBlockWithParams(params) {
        this.#pendingBlocks.push({
            params,
            deferred: defer()
        });
        this.#buildBlockIfNeeded();
        await this.upcomingBlocks();
    }
    async buildBlock(params) {
        const transactions = params?.transactions || this.#pool.splice(0).map(({ extrinsic })=>extrinsic);
        const upwardMessages = params?.upwardMessages || {
            ...this.#ump
        };
        const downwardMessages = params?.downwardMessages || this.#dmp.splice(0);
        const horizontalMessages = params?.horizontalMessages || {
            ...this.#hrmp
        };
        const unsafeBlockHeight = params?.unsafeBlockHeight;
        if (!params?.upwardMessages) {
            for (const id of Object.keys(this.#ump)){
                delete this.#ump[id];
            }
        }
        if (!params?.horizontalMessages) {
            for (const id of Object.keys(this.#hrmp)){
                delete this.#hrmp[id];
            }
        }
        await this.buildBlockWithParams({
            transactions,
            upwardMessages,
            downwardMessages,
            horizontalMessages,
            unsafeBlockHeight
        });
    }
    async upcomingBlocks() {
        const count = this.#pendingBlocks.length;
        if (count > 0) {
            await this.#pendingBlocks[count - 1].deferred.promise;
        }
        return count;
    }
    async #buildBlockIfNeeded() {
        if (this.#isBuilding) return;
        if (this.#pendingBlocks.length === 0) return;
        this.#isBuilding = true;
        try {
            await this.#buildBlock();
        } finally{
            this.#isBuilding = false;
        }
        this.#buildBlockIfNeeded();
    }
    async #buildBlock() {
        await this.#chain.api.isReady;
        const pending = this.#pendingBlocks[0];
        if (!pending) {
            throw new Error('Unreachable');
        }
        const { params, deferred } = pending;
        logger.trace({
            params
        }, 'build block');
        const head = this.#chain.head;
        const inherents = await this.#inherentProvider.createInherents(head, params);
        const [newBlock, pendingExtrinsics] = await buildBlock(head, inherents, params.transactions, params.upwardMessages, {
            onApplyExtrinsicError: (extrinsic, error)=>{
                this.event.emit(APPLY_EXTRINSIC_ERROR, [
                    extrinsic,
                    error
                ]);
            },
            onPhaseApplied: logger.level.toLowerCase() === 'trace' ? (phase, resp)=>{
                switch(phase){
                    case 'initialize':
                        logger.trace(truncate(resp.storageDiff), 'Initialize block');
                        break;
                    case 'finalize':
                        logger.trace(truncate(resp.storageDiff), 'Finalize block');
                        break;
                    default:
                        logger.trace(truncate(resp.storageDiff), `Apply extrinsic ${phase}`);
                }
            } : undefined
        }, params.unsafeBlockHeight);
        for (const extrinsic of pendingExtrinsics){
            this.#pool.push({
                extrinsic,
                signer: await this.#getSigner(extrinsic)
            });
        }
        await this.#chain.onNewBlock(newBlock);
        this.#pendingBlocks.shift();
        deferred.resolve();
    }
}
