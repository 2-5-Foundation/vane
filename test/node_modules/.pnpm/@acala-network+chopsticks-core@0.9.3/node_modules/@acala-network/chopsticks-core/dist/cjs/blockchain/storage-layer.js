"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RemoteStorageLayer: function() {
        return RemoteStorageLayer;
    },
    StorageLayer: function() {
        return StorageLayer;
    },
    StorageValueKind: function() {
        return StorageValueKind;
    }
});
const _lodash = /*#__PURE__*/ _interop_require_default(require("lodash"));
const _logger = require("../logger.js");
const _keycache = /*#__PURE__*/ _interop_require_wildcard(require("../utils/key-cache.js"));
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init(obj, privateSet) {
    _check_private_redeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const logger = _logger.defaultLogger.child({
    name: 'layer'
});
const BATCH_SIZE = 1000;
var StorageValueKind;
(function(StorageValueKind) {
    StorageValueKind["Deleted"] = "Deleted";
    StorageValueKind["DeletedPrefix"] = "DeletedPrefix";
})(StorageValueKind || (StorageValueKind = {}));
var _api = /*#__PURE__*/ new WeakMap(), _at = /*#__PURE__*/ new WeakMap(), _db = /*#__PURE__*/ new WeakMap(), _keyCache = /*#__PURE__*/ new WeakMap();
class RemoteStorageLayer {
    async get(key, _cache) {
        if (_class_private_field_get(this, _db)) {
            const res = await _class_private_field_get(this, _db).queryStorage(_class_private_field_get(this, _at), key);
            if (res) {
                return res.value ?? undefined;
            }
        }
        logger.trace({
            at: _class_private_field_get(this, _at),
            key
        }, 'RemoteStorageLayer get');
        const data = await _class_private_field_get(this, _api).getStorage(key, _class_private_field_get(this, _at));
        _class_private_field_get(this, _db)?.saveStorage(_class_private_field_get(this, _at), key, data);
        return data ?? undefined;
    }
    async foldInto(_into) {
        return this;
    }
    async fold() {}
    async getKeysPaged(prefix, pageSize, startKey) {
        if (pageSize > BATCH_SIZE) throw new Error(`pageSize must be less or equal to ${BATCH_SIZE}`);
        logger.trace({
            at: _class_private_field_get(this, _at),
            prefix,
            pageSize,
            startKey
        }, 'RemoteStorageLayer getKeysPaged');
        // can't handle keyCache without prefix
        if (prefix.length < _keycache.PREFIX_LENGTH || startKey.length < _keycache.PREFIX_LENGTH) {
            return _class_private_field_get(this, _api).getKeysPaged(prefix, pageSize, startKey, _class_private_field_get(this, _at));
        }
        let batchComplete = false;
        const keysPaged = [];
        while(keysPaged.length < pageSize){
            const nextKey = await _class_private_field_get(this, _keyCache).next(startKey);
            if (nextKey) {
                keysPaged.push(nextKey);
                startKey = nextKey;
                continue;
            }
            // batch fetch was completed
            if (batchComplete) {
                break;
            }
            // fetch a batch of keys
            const batch = await _class_private_field_get(this, _api).getKeysPaged(prefix, BATCH_SIZE, startKey, _class_private_field_get(this, _at));
            batchComplete = batch.length < BATCH_SIZE;
            // feed the key cache
            if (batch.length > 0) {
                _class_private_field_get(this, _keyCache).feed([
                    startKey,
                    ...batch
                ]);
            }
            if (batch.length === 0) {
                break;
            }
        }
        return keysPaged;
    }
    constructor(api, at, db){
        _class_private_field_init(this, _api, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _at, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _db, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _keyCache, {
            writable: true,
            value: new _keycache.default()
        });
        _class_private_field_set(this, _api, api);
        _class_private_field_set(this, _at, at);
        _class_private_field_set(this, _db, db);
    }
}
var _store = /*#__PURE__*/ new WeakMap(), _keys = /*#__PURE__*/ new WeakMap(), _deletedPrefix = /*#__PURE__*/ new WeakMap(), _parent = /*#__PURE__*/ new WeakMap(), _addKey = /*#__PURE__*/ new WeakSet(), _removeKey = /*#__PURE__*/ new WeakSet();
class StorageLayer {
    async get(key, cache) {
        if (_class_private_field_get(this, _store).has(key)) {
            return _class_private_field_get(this, _store).get(key);
        }
        if (_class_private_field_get(this, _deletedPrefix).some((dp)=>key.startsWith(dp))) {
            return "Deleted";
        }
        if (_class_private_field_get(this, _parent)) {
            const val = _class_private_field_get(this, _parent).get(key, false);
            if (cache) {
                _class_private_field_get(this, _store).set(key, val);
            }
            return val;
        }
        return undefined;
    }
    set(key, value) {
        switch(value){
            case "Deleted":
                _class_private_field_get(this, _store).set(key, "Deleted");
                _class_private_method_get(this, _removeKey, removeKey).call(this, key);
                break;
            case "DeletedPrefix":
                _class_private_field_get(this, _deletedPrefix).push(key);
                for (const k of _class_private_field_get(this, _keys)){
                    if (k.startsWith(key)) {
                        _class_private_field_get(this, _store).set(k, "Deleted");
                        _class_private_method_get(this, _removeKey, removeKey).call(this, k);
                    }
                }
                break;
            case undefined:
                _class_private_field_get(this, _store).delete(key);
                _class_private_method_get(this, _removeKey, removeKey).call(this, key);
                break;
            default:
                _class_private_field_get(this, _store).set(key, value);
                _class_private_method_get(this, _addKey, addKey).call(this, key);
                break;
        }
    }
    setAll(values) {
        if (!Array.isArray(values)) {
            values = Object.entries(values);
        }
        for (const [key, value] of values){
            this.set(key, value || "Deleted");
        }
    }
    async foldInto(into) {
        const newParent = await _class_private_field_get(this, _parent)?.foldInto(into);
        for (const deletedPrefix of _class_private_field_get(this, _deletedPrefix)){
            into.set(deletedPrefix, "DeletedPrefix");
        }
        for (const [key, value] of _class_private_field_get(this, _store)){
            into.set(key, await value);
        }
        return newParent;
    }
    async fold() {
        if (_class_private_field_get(this, _parent)) {
            _class_private_field_set(this, _parent, await _class_private_field_get(this, _parent).foldInto(this));
        }
    }
    async getKeysPaged(prefix, pageSize, startKey) {
        if (!_class_private_field_get(this, _deletedPrefix).some((dp)=>startKey.startsWith(dp))) {
            const remote = await _class_private_field_get(this, _parent)?.getKeysPaged(prefix, pageSize, startKey) ?? [];
            for (const key of remote){
                if (_class_private_field_get(this, _store).get(key) === "Deleted") {
                    continue;
                }
                if (_class_private_field_get(this, _deletedPrefix).some((dp)=>key.startsWith(dp))) {
                    continue;
                }
                _class_private_method_get(this, _addKey, addKey).call(this, key);
            }
        }
        let idx = _lodash.default.sortedIndex(_class_private_field_get(this, _keys), startKey);
        if (_class_private_field_get(this, _keys)[idx] === startKey) {
            ++idx;
        }
        const res = [];
        while(res.length < pageSize){
            const key = _class_private_field_get(this, _keys)[idx];
            if (!key || !key.startsWith(prefix)) {
                break;
            }
            res.push(key);
            ++idx;
        }
        return res;
    }
    /**
   * Merge the storage layer into the given object, can be used to get sotrage diff.
   */ async mergeInto(into) {
        for (const [key, maybeValue] of _class_private_field_get(this, _store)){
            const value = await maybeValue;
            if (value === "Deleted") {
                into[key] = null;
            } else {
                into[key] = value;
            }
        }
    }
    constructor(parent){
        _class_private_method_init(this, _addKey);
        _class_private_method_init(this, _removeKey);
        _class_private_field_init(this, _store, {
            writable: true,
            value: new Map()
        });
        _class_private_field_init(this, _keys, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _deletedPrefix, {
            writable: true,
            value: []
        });
        _class_private_field_init(this, _parent, {
            writable: true,
            value: void 0
        });
        _class_private_field_set(this, _parent, parent);
    }
}
function addKey(key) {
    const idx = _lodash.default.sortedIndex(_class_private_field_get(this, _keys), key);
    const key2 = _class_private_field_get(this, _keys)[idx];
    if (key === key2) {
        return;
    }
    _class_private_field_get(this, _keys).splice(idx, 0, key);
}
function removeKey(key) {
    const idx = _lodash.default.sortedIndex(_class_private_field_get(this, _keys), key);
    const key2 = _class_private_field_get(this, _keys)[idx];
    if (key === key2) {
        _class_private_field_get(this, _keys).splice(idx, 1);
    }
}
