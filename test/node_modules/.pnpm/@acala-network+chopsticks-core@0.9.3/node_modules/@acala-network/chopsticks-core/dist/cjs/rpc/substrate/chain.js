"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    chain_getBlock: function() {
        return chain_getBlock;
    },
    chain_getBlockHash: function() {
        return chain_getBlockHash;
    },
    chain_getFinalizedHead: function() {
        return chain_getFinalizedHead;
    },
    chain_getHead: function() {
        return chain_getHead;
    },
    chain_getHeader: function() {
        return chain_getHeader;
    },
    chain_subscribeFinalizedHeads: function() {
        return chain_subscribeFinalizedHeads;
    },
    chain_subscribeNewHead: function() {
        return chain_subscribeNewHead;
    },
    chain_subscribeNewHeads: function() {
        return chain_subscribeNewHeads;
    },
    chain_unsubscribeFinalizedHeads: function() {
        return chain_unsubscribeFinalizedHeads;
    },
    chain_unsubscribeNewHead: function() {
        return chain_unsubscribeNewHead;
    },
    chain_unsubscribeNewHeads: function() {
        return chain_unsubscribeNewHeads;
    }
});
const _shared = require("../shared.js");
const processHeader = (header)=>{
    const res = header.toJSON();
    res.number = '0x' + res.number.toString(16) // number is hex format
    ;
    return res;
};
const chain_getBlockHash = async (context, [blockNumber])=>{
    const numbers = Array.isArray(blockNumber) ? blockNumber : [
        blockNumber
    ];
    const hashes = await Promise.all(numbers.map((n)=>context.chain.getBlockAt(n))).then((blocks)=>blocks.map((b)=>b?.hash || null));
    return Array.isArray(blockNumber) ? hashes : hashes[0];
};
const chain_getHeader = async (context, [hash])=>{
    const block = await context.chain.getBlock(hash);
    if (!block) {
        throw new _shared.ResponseError(1, `Block ${hash} not found`);
    }
    return processHeader(await block.header);
};
const chain_getBlock = async (context, [hash])=>{
    const block = await context.chain.getBlock(hash);
    if (!block) {
        throw new _shared.ResponseError(1, `Block ${hash} not found`);
    }
    return {
        block: {
            header: processHeader(await block.header),
            extrinsics: await block.extrinsics
        },
        justifications: null
    };
};
const chain_getFinalizedHead = async (context)=>{
    return context.chain.head.hash;
};
const chain_subscribeNewHead = async (context, _params, { subscribe })=>{
    let update = ()=>{};
    const id = context.chain.headState.subscribeHead(()=>update());
    const callback = subscribe('chain_newHead', id, ()=>context.chain.headState.unsubscribeHead(id));
    update = async ()=>{
        callback(processHeader(await context.chain.head.header));
    };
    setTimeout(update, 50);
    return id;
};
const chain_subscribeFinalizedHeads = async (context, _params, { subscribe })=>{
    let update = ()=>{};
    const id = context.chain.headState.subscribeHead(()=>update());
    const callback = subscribe('chain_finalizedHead', id, ()=>context.chain.headState.unsubscribeHead(id));
    update = async ()=>{
        callback(processHeader(await context.chain.head.header));
    };
    setTimeout(update, 50);
    return id;
};
const chain_unsubscribeNewHead = async (_context, [subid], { unsubscribe })=>{
    unsubscribe(subid);
};
const chain_getHead = chain_getBlockHash;
const chain_subscribeNewHeads = chain_subscribeNewHead;
const chain_unsubscribeNewHeads = chain_unsubscribeNewHead;
const chain_unsubscribeFinalizedHeads = chain_unsubscribeNewHead;
