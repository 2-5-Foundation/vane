import { EventEmitter } from 'eventemitter3';
import { genesisSchema } from './schema/index.js';
import { calculateStateRoot, emptyTaskHandler } from './wasm-executor/index.js';
/**
 * Provider to start a chain from genesis
 */ export class GenesisProvider {
    #isConnected = false;
    #eventemitter = new EventEmitter();
    #isReadyPromise;
    #genesis;
    #stateRoot;
    /**
   * @ignore
   * Create a genesis provider
   *
   * @param genesis - genesis file
   * @requires genesis provider
   */ constructor(genesis){
        this.#genesis = genesisSchema.parse(genesis);
        this.#stateRoot = calculateStateRoot(Object.entries(this.#genesis.genesis.raw.top).reduce((accu, item)=>{
            accu.push(item);
            return accu;
        }, []), 1);
        this.#isReadyPromise = new Promise((resolve, reject)=>{
            this.#eventemitter.once('connected', ()=>{
                resolve();
            });
            this.#eventemitter.once('error', reject);
            this.connect();
        });
    }
    get isClonable() {
        return true;
    }
    clone = ()=>{
        return new GenesisProvider(this.#genesis);
    };
    get hasSubscriptions() {
        return false;
    }
    get isConnected() {
        return this.#isConnected;
    }
    get isReady() {
        return this.#isReadyPromise;
    }
    connect = async ()=>{
        this.#isConnected = true;
        this.#eventemitter.emit('connected');
    };
    disconnect = async ()=>{
        this.#isConnected = false;
        this.#eventemitter.emit('disconnected');
    };
    on = (type, sub)=>{
        this.#eventemitter.on(type, sub);
        return ()=>{
            this.#eventemitter.removeListener(type, sub);
        };
    };
    get blockHash() {
        return '0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3';
    }
    getHeader = async ()=>{
        return {
            blockHash: this.blockHash,
            number: '0x0',
            stateRoot: await this.#stateRoot,
            digest: {
                logs: []
            }
        };
    };
    getBlock = async ()=>{
        return {
            block: {
                header: await this.getHeader(),
                extrinsics: []
            }
        };
    };
    get _jsCallback() {
        const storage = this.#genesis.genesis.raw.top;
        return {
            ...emptyTaskHandler,
            getStorage: async function(key) {
                return storage[key];
            },
            getStateRoot: async function() {
                return '0x49416764844ff0d8bad851e8abe686dff9dd2de78621180ef8e9f99bb7a480f1';
            },
            getNextKey: async function(_prefix, _key) {
                return undefined;
            }
        };
    }
    send = async (method, params, _isCacheable)=>{
        await this.isReady;
        switch(method){
            case 'system_properties':
                return this.#genesis.properties;
            case 'system_chain':
                return this.#genesis.id;
            case 'system_name':
                return this.#genesis.name;
            case 'chain_getHeader':
                return this.getHeader();
            case 'chain_getBlock':
                return this.getBlock();
            case 'chain_getBlockHash':
                return this.blockHash;
            case 'state_getKeysPaged':
            case 'state_getKeysPagedAt':
                return [];
            case 'state_getStorage':
            case 'state_getStorageAt':
                return this.#genesis.genesis.raw.top[params[0]];
            default:
                throw Error(`${method} not implemented`);
        }
    };
    subscribe = async (_type, _method, _params, _cb)=>{
        throw Error('unimplemented');
    };
    unsubscribe = async (_type, _method, _id)=>{
        throw Error('unimplemented');
    };
}
