import '@polkadot/types-codec';
import { HttpProvider, WsProvider } from '@polkadot/rpc-provider';
import { Api } from './api.js';
import { Blockchain } from './blockchain/index.js';
import { InherentProviders, ParaInherentEnter, SetBabeRandomness, SetNimbusAuthorInherent, SetTimestamp, SetValidationData } from './blockchain/inherent/index.js';
import { defaultLogger } from './logger.js';
export const setup = async (options)=>{
    let provider;
    if (options.genesis) {
        provider = options.genesis;
    } else if (typeof options.endpoint === 'string' && /^(https|http):\/\//.test(options.endpoint || '')) {
        provider = new HttpProvider(options.endpoint);
    } else {
        provider = new WsProvider(options.endpoint, 3_000);
    }
    const api = new Api(provider);
    await api.isReady;
    let blockHash;
    if (options.block == null) {
        blockHash = await api.getBlockHash().then((hash)=>{
            if (!hash) {
                // should not happen, but just in case
                throw new Error('Cannot find block hash');
            }
            return hash;
        });
    } else if (typeof options.block === 'string' && options.block.startsWith('0x')) {
        blockHash = options.block;
    } else if (Number.isInteger(+options.block)) {
        blockHash = await api.getBlockHash(Number(options.block)).then((hash)=>{
            if (!hash) {
                throw new Error(`Cannot find block hash for ${options.block}`);
            }
            return hash;
        });
    } else {
        throw new Error(`Invalid block number or hash: ${options.block}`);
    }
    defaultLogger.debug({
        ...options,
        blockHash
    }, 'Args');
    const header = await api.getHeader(blockHash);
    if (!header) {
        throw new Error(`Cannot find header for ${blockHash}`);
    }
    const inherents = new InherentProviders(new SetTimestamp(), [
        new SetValidationData(),
        new ParaInherentEnter(),
        new SetNimbusAuthorInherent(),
        new SetBabeRandomness()
    ]);
    return new Blockchain({
        api,
        buildBlockMode: options.buildBlockMode,
        inherentProvider: inherents,
        db: options.db,
        header: {
            hash: blockHash,
            number: Number(header.number)
        },
        mockSignatureHost: options.mockSignatureHost,
        allowUnresolvedImports: options.allowUnresolvedImports,
        runtimeLogLevel: options.runtimeLogLevel,
        registeredTypes: options.registeredTypes || {},
        offchainWorker: options.offchainWorker,
        maxMemoryBlockCount: options.maxMemoryBlockCount
    });
};
