"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "setup", {
    enumerable: true,
    get: function() {
        return setup;
    }
});
require("@polkadot/types-codec");
const _rpcprovider = require("@polkadot/rpc-provider");
const _api = require("./api.js");
const _index = require("./blockchain/index.js");
const _index1 = require("./blockchain/inherent/index.js");
const _logger = require("./logger.js");
const setup = async (options)=>{
    let provider;
    if (options.genesis) {
        provider = options.genesis;
    } else if (typeof options.endpoint === 'string' && /^(https|http):\/\//.test(options.endpoint || '')) {
        provider = new _rpcprovider.HttpProvider(options.endpoint);
    } else {
        provider = new _rpcprovider.WsProvider(options.endpoint, 3_000);
    }
    const api = new _api.Api(provider);
    await api.isReady;
    let blockHash;
    if (options.block == null) {
        blockHash = await api.getBlockHash().then((hash)=>{
            if (!hash) {
                // should not happen, but just in case
                throw new Error('Cannot find block hash');
            }
            return hash;
        });
    } else if (typeof options.block === 'string' && options.block.startsWith('0x')) {
        blockHash = options.block;
    } else if (Number.isInteger(+options.block)) {
        blockHash = await api.getBlockHash(Number(options.block)).then((hash)=>{
            if (!hash) {
                throw new Error(`Cannot find block hash for ${options.block}`);
            }
            return hash;
        });
    } else {
        throw new Error(`Invalid block number or hash: ${options.block}`);
    }
    _logger.defaultLogger.debug({
        ...options,
        blockHash
    }, 'Args');
    const header = await api.getHeader(blockHash);
    if (!header) {
        throw new Error(`Cannot find header for ${blockHash}`);
    }
    const inherents = new _index1.InherentProviders(new _index1.SetTimestamp(), [
        new _index1.SetValidationData(),
        new _index1.ParaInherentEnter(),
        new _index1.SetNimbusAuthorInherent(),
        new _index1.SetBabeRandomness()
    ]);
    return new _index.Blockchain({
        api,
        buildBlockMode: options.buildBlockMode,
        inherentProvider: inherents,
        db: options.db,
        header: {
            hash: blockHash,
            number: Number(header.number)
        },
        mockSignatureHost: options.mockSignatureHost,
        allowUnresolvedImports: options.allowUnresolvedImports,
        runtimeLogLevel: options.runtimeLogLevel,
        registeredTypes: options.registeredTypes || {},
        offchainWorker: options.offchainWorker,
        maxMemoryBlockCount: options.maxMemoryBlockCount
    });
};
