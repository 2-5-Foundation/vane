import * as Comlink from 'comlink';
import { hexToString, hexToU8a, u8aToBn } from '@polkadot/util';
import { randomAsHex } from '@polkadot/util-crypto';
import _ from 'lodash';
import { PREFIX_LENGTH } from '../utils/key-cache.js';
import { defaultLogger, truncate } from '../logger.js';
import { stripChildPrefix } from '../utils/index.js';
const logger = defaultLogger.child({
    name: 'executor'
});
let __executor_worker;
const getWorker = async ()=>{
    if (__executor_worker) return __executor_worker;
    const isNode = typeof process !== 'undefined' && process?.versions?.node // true for node or bun
    ;
    if (isNode) {
        __executor_worker = import('./node-worker.js').then(({ startWorker })=>startWorker());
    } else {
        __executor_worker = import('./browser-worker.js').then(({ startWorker })=>startWorker());
    }
    return __executor_worker;
};
export const getRuntimeVersion = _.memoize(async (code)=>{
    const worker = await getWorker();
    return worker.remote.getRuntimeVersion(code).then((version)=>{
        version.specName = hexToString(version.specName);
        version.implName = hexToString(version.implName);
        return version;
    });
});
// trie_version: 0 for old trie, 1 for new trie
export const calculateStateRoot = async (entries, trie_version)=>{
    const worker = await getWorker();
    return worker.remote.calculateStateRoot(entries, trie_version);
};
export const decodeProof = async (trieRootHash, keys, nodes)=>{
    const worker = await getWorker();
    const result = await worker.remote.decodeProof(trieRootHash, keys, nodes);
    return result.reduce((accum, [key, value])=>{
        accum[key] = value;
        return accum;
    }, {});
};
export const createProof = async (nodes, entries)=>{
    const worker = await getWorker();
    const [trieRootHash, newNodes] = await worker.remote.createProof(nodes, entries);
    return {
        trieRootHash,
        nodes: newNodes
    };
};
export const runTask = async (task, callback = emptyTaskHandler)=>{
    const worker = await getWorker();
    logger.trace(truncate(task), 'taskRun');
    const response = await worker.remote.runTask(task, Comlink.proxy(callback));
    if ('Call' in response) {
        logger.trace(truncate(response.Call), 'taskResponse');
    } else {
        logger.trace({
            response
        }, 'taskResponse');
    }
    return response;
};
export const taskHandler = (block)=>{
    return {
        getStorage: async function(key) {
            return block.get(key);
        },
        getStateRoot: async function() {
            const header = await block.header;
            return header.stateRoot.toHex();
        },
        getNextKey: async function(prefix, key) {
            const [nextKey] = await block.getKeysPaged({
                prefix: prefix.length === 2 /** 0x */  ? key.slice(0, PREFIX_LENGTH) : prefix,
                pageSize: 1,
                startKey: key
            });
            return nextKey && stripChildPrefix(nextKey);
        },
        offchainGetStorage: async function(key) {
            if (!block.chain.offchainWorker) throw new Error('offchain worker not found');
            return block.chain.offchainWorker.get(key);
        },
        offchainTimestamp: async function() {
            return Date.now();
        },
        offchainRandomSeed: async function() {
            return randomAsHex(32);
        },
        offchainSubmitTransaction: async function(tx) {
            if (!block.chain.offchainWorker) throw new Error('offchain worker not found');
            try {
                const hash = await block.chain.offchainWorker.pushExtrinsic(block, tx);
                logger.trace({
                    hash
                }, 'offchainSubmitTransaction');
                return true;
            } catch (error) {
                logger.trace({
                    error
                }, 'offchainSubmitTransaction');
                return false;
            }
        }
    };
};
export const emptyTaskHandler = {
    getStorage: async function(_key) {
        throw new Error('Method not implemented');
    },
    getStateRoot: async function() {
        throw new Error('Method not implemented');
    },
    getNextKey: async function(_prefix, _key) {
        throw new Error('Method not implemented');
    },
    offchainGetStorage: async function(_key) {
        throw new Error('Method not implemented');
    },
    offchainTimestamp: async function() {
        throw new Error('Method not implemented');
    },
    offchainRandomSeed: async function() {
        throw new Error('Method not implemented');
    },
    offchainSubmitTransaction: async function(_tx) {
        throw new Error('Method not implemented');
    }
};
export const getAuraSlotDuration = _.memoize(async (wasm)=>{
    const result = await runTask({
        wasm,
        calls: [
            [
                'AuraApi_slot_duration',
                []
            ]
        ],
        mockSignatureHost: false,
        allowUnresolvedImports: false,
        runtimeLogLevel: 0
    });
    if ('Error' in result) throw new Error(result.Error);
    return u8aToBn(hexToU8a(result.Call.result).subarray(0, 8 /* u64: 8 bytes */ )).toNumber();
});
export const destroyWorker = async ()=>{
    if (!__executor_worker) return;
    const executor = await __executor_worker;
    executor.remote[Comlink.releaseProxy]();
    await new Promise((resolve)=>setTimeout(resolve, 50));
    await executor.terminate();
    __executor_worker = undefined;
};
