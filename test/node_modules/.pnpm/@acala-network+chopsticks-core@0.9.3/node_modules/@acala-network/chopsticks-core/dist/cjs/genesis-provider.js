"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "GenesisProvider", {
    enumerable: true,
    get: function() {
        return GenesisProvider;
    }
});
const _eventemitter3 = require("eventemitter3");
const _index = require("./schema/index.js");
const _index1 = require("./wasm-executor/index.js");
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var _isConnected = /*#__PURE__*/ new WeakMap(), _eventemitter = /*#__PURE__*/ new WeakMap(), _isReadyPromise = /*#__PURE__*/ new WeakMap(), _genesis = /*#__PURE__*/ new WeakMap(), _stateRoot = /*#__PURE__*/ new WeakMap();
class GenesisProvider {
    get isClonable() {
        return true;
    }
    get hasSubscriptions() {
        return false;
    }
    get isConnected() {
        return _class_private_field_get(this, _isConnected);
    }
    get isReady() {
        return _class_private_field_get(this, _isReadyPromise);
    }
    get blockHash() {
        return '0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3';
    }
    get _jsCallback() {
        const storage = _class_private_field_get(this, _genesis).genesis.raw.top;
        return {
            ..._index1.emptyTaskHandler,
            getStorage: async function(key) {
                return storage[key];
            },
            getStateRoot: async function() {
                return '0x49416764844ff0d8bad851e8abe686dff9dd2de78621180ef8e9f99bb7a480f1';
            },
            getNextKey: async function(_prefix, _key) {
                return undefined;
            }
        };
    }
    /**
   * @ignore
   * Create a genesis provider
   *
   * @param genesis - genesis file
   * @requires genesis provider
   */ constructor(genesis){
        _class_private_field_init(this, _isConnected, {
            writable: true,
            value: false
        });
        _class_private_field_init(this, _eventemitter, {
            writable: true,
            value: new _eventemitter3.EventEmitter()
        });
        _class_private_field_init(this, _isReadyPromise, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _genesis, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _stateRoot, {
            writable: true,
            value: void 0
        });
        _define_property(this, "clone", ()=>{
            return new GenesisProvider(_class_private_field_get(this, _genesis));
        });
        _define_property(this, "connect", async ()=>{
            _class_private_field_set(this, _isConnected, true);
            _class_private_field_get(this, _eventemitter).emit('connected');
        });
        _define_property(this, "disconnect", async ()=>{
            _class_private_field_set(this, _isConnected, false);
            _class_private_field_get(this, _eventemitter).emit('disconnected');
        });
        _define_property(this, "on", (type, sub)=>{
            _class_private_field_get(this, _eventemitter).on(type, sub);
            return ()=>{
                _class_private_field_get(this, _eventemitter).removeListener(type, sub);
            };
        });
        _define_property(this, "getHeader", async ()=>{
            return {
                blockHash: this.blockHash,
                number: '0x0',
                stateRoot: await _class_private_field_get(this, _stateRoot),
                digest: {
                    logs: []
                }
            };
        });
        _define_property(this, "getBlock", async ()=>{
            return {
                block: {
                    header: await this.getHeader(),
                    extrinsics: []
                }
            };
        });
        _define_property(this, "send", async (method, params, _isCacheable)=>{
            await this.isReady;
            switch(method){
                case 'system_properties':
                    return _class_private_field_get(this, _genesis).properties;
                case 'system_chain':
                    return _class_private_field_get(this, _genesis).id;
                case 'system_name':
                    return _class_private_field_get(this, _genesis).name;
                case 'chain_getHeader':
                    return this.getHeader();
                case 'chain_getBlock':
                    return this.getBlock();
                case 'chain_getBlockHash':
                    return this.blockHash;
                case 'state_getKeysPaged':
                case 'state_getKeysPagedAt':
                    return [];
                case 'state_getStorage':
                case 'state_getStorageAt':
                    return _class_private_field_get(this, _genesis).genesis.raw.top[params[0]];
                default:
                    throw Error(`${method} not implemented`);
            }
        });
        _define_property(this, "subscribe", async (_type, _method, _params, _cb)=>{
            throw Error('unimplemented');
        });
        _define_property(this, "unsubscribe", async (_type, _method, _id)=>{
            throw Error('unimplemented');
        });
        _class_private_field_set(this, _genesis, _index.genesisSchema.parse(genesis));
        _class_private_field_set(this, _stateRoot, (0, _index1.calculateStateRoot)(Object.entries(_class_private_field_get(this, _genesis).genesis.raw.top).reduce((accu, item)=>{
            accu.push(item);
            return accu;
        }, []), 1));
        _class_private_field_set(this, _isReadyPromise, new Promise((resolve, reject)=>{
            _class_private_field_get(this, _eventemitter).once('connected', ()=>{
                resolve();
            });
            _class_private_field_get(this, _eventemitter).once('error', reject);
            this.connect();
        }));
    }
}
